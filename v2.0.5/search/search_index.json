{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to iceoryx.io \ud83d\udd17 Eclipse iceoryx\u2122 is an inter-process-communication middleware that enables virtually limitless data transmissions at constant time. Fast Flexible Dependable True zero-copy shared memory communication Message transfers with a latency of less than 1 \u00b5s Made to handle GBytes/sec data transfers Support of various operating systems, communication patterns and APIs Service discovery enables the design of dynamic systems Easy to integrate into frameworks like ROS 2 or AUTOSAR Adaptive Developed according to automotive requirements Implementation based on static memory and lock-free algorithms Huge C++ library with safe STL implementations Learn more Learn more Learn more","title":"Home"},{"location":"#welcome-to-iceoryxio","text":"Eclipse iceoryx\u2122 is an inter-process-communication middleware that enables virtually limitless data transmissions at constant time.","title":"Welcome to iceoryx.io"},{"location":"API-cheatsheet/","text":"","title":"API cheatsheet"},{"location":"FAQ/","text":"FAQ \ud83d\udd17 In this document are tips and hints documented which can help for troubleshooting on RouDi. Does iceoryx run in a docker environment \ud83d\udd17 Yes. Take a look at the icedocker example iox-roudi fails on startup \ud83d\udd17 An error message like user@iceoryx-host:/# iox-roudi Log level set to: [Warning] SharedMemory still there, doing an unlink of /iceoryx_mgmt Reserving 59736448 bytes in the shared memory [/iceoryx_mgmt] [ Reserving shared memory successful ] SharedMemory still there, doing an unlink of /root Reserving 27902400 bytes in the shared memory [/root] While setting the acquired shared memory to zero a fatal SIGBUS signal appeared caused by memset. The shared memory object with the following properties [ name = /root, sizeInBytes = 27902400, access mode = AccessMode::READ_WRITE, ownership = OwnerShip::MINE, baseAddressHint = (nil), permissions = 0 ] maybe requires more memory than it is currently available in the system. indicates that there is not enough shared memory available. Check with df -H /dev/shm if you have enough memory available. In this exemplary error message we require 59736448 (iceoryx management data) + 27902400 (user samples) ~ 83.57mb of shared memory. Stack size handling \ud83d\udd17 The iceoryx middleware utilize stack memory from the system for book-keeping of internal structures. Most Linux distributions offers 8 Megabyte of stack memory for a process which is enough for iceoryx. You can check this with the output from ulimit -a . On other platforms like windows other rules apply for the stack memory. On windows there is only 1 Megabyte of stack available. Increasing the stack size generally on iceoryx is not recommended since Roudi could consume lots of memory without using it. Especially using RouDi in a multi-threaded context can run out the stack memory and lead to memory errors. The Single process example shows that when compiling and executing it on windows. Without setting the stack size the application will throw a Stack overflow exception when entering the main() method. This can be solved in CMake by adding a linker flag: target_link_options ( single_process BEFORE PRIVATE /STACK:3500000 ) For other platforms apply other flags or solutions. CI fails but error is locally not reproducable \ud83d\udd17 One can use tools/scripts/ice_env.sh to create an iceoryx development environment with a configuration very similar to the CI target. When for instance the target ubuntu 18.04 fails one can create a docker container with cd tools/scripts ./ice-env.sh enter ubuntu:18.04 This starts the container, installs all dependencies which iceoryx requires and enters the environment. docker \ud83d\udd17 When you are in a docker environment check if there is enough memory available in your docker. # docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 367b9fae6c2f nifty_galileo 0.00% 4.48MiB / 1GiB 0.44% 11.6kB / 0B 17.6MB / 0B 1 If not you can restart the docker container with --shm-size=\"2g\" to increase the total amount of available shared memory. docker run -it --shm-size=\"2g\" ubuntu Termination of RouDi and processes \ud83d\udd17 To avoid undefined behavior of iceoryx posh it is recommended to terminate RouDi and the corresponding middleware processes with SIGINT or SIGTERM. In RouDi, we have integrated a sighandler that catches the signals and gives RouDi the chance to exit and clean-up everything. This also applies for processes. Therefore, we recommend adding a signalhandler to your process (see this example ).","title":"FAQ"},{"location":"FAQ/#faq","text":"In this document are tips and hints documented which can help for troubleshooting on RouDi.","title":"FAQ"},{"location":"FAQ/#does-iceoryx-run-in-a-docker-environment","text":"Yes. Take a look at the icedocker example","title":"Does iceoryx run in a docker environment"},{"location":"FAQ/#iox-roudi-fails-on-startup","text":"An error message like user@iceoryx-host:/# iox-roudi Log level set to: [Warning] SharedMemory still there, doing an unlink of /iceoryx_mgmt Reserving 59736448 bytes in the shared memory [/iceoryx_mgmt] [ Reserving shared memory successful ] SharedMemory still there, doing an unlink of /root Reserving 27902400 bytes in the shared memory [/root] While setting the acquired shared memory to zero a fatal SIGBUS signal appeared caused by memset. The shared memory object with the following properties [ name = /root, sizeInBytes = 27902400, access mode = AccessMode::READ_WRITE, ownership = OwnerShip::MINE, baseAddressHint = (nil), permissions = 0 ] maybe requires more memory than it is currently available in the system. indicates that there is not enough shared memory available. Check with df -H /dev/shm if you have enough memory available. In this exemplary error message we require 59736448 (iceoryx management data) + 27902400 (user samples) ~ 83.57mb of shared memory.","title":"iox-roudi fails on startup"},{"location":"FAQ/#stack-size-handling","text":"The iceoryx middleware utilize stack memory from the system for book-keeping of internal structures. Most Linux distributions offers 8 Megabyte of stack memory for a process which is enough for iceoryx. You can check this with the output from ulimit -a . On other platforms like windows other rules apply for the stack memory. On windows there is only 1 Megabyte of stack available. Increasing the stack size generally on iceoryx is not recommended since Roudi could consume lots of memory without using it. Especially using RouDi in a multi-threaded context can run out the stack memory and lead to memory errors. The Single process example shows that when compiling and executing it on windows. Without setting the stack size the application will throw a Stack overflow exception when entering the main() method. This can be solved in CMake by adding a linker flag: target_link_options ( single_process BEFORE PRIVATE /STACK:3500000 ) For other platforms apply other flags or solutions.","title":"Stack size handling"},{"location":"FAQ/#ci-fails-but-error-is-locally-not-reproducable","text":"One can use tools/scripts/ice_env.sh to create an iceoryx development environment with a configuration very similar to the CI target. When for instance the target ubuntu 18.04 fails one can create a docker container with cd tools/scripts ./ice-env.sh enter ubuntu:18.04 This starts the container, installs all dependencies which iceoryx requires and enters the environment.","title":"CI fails but error is locally not reproducable"},{"location":"FAQ/#docker","text":"When you are in a docker environment check if there is enough memory available in your docker. # docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 367b9fae6c2f nifty_galileo 0.00% 4.48MiB / 1GiB 0.44% 11.6kB / 0B 17.6MB / 0B 1 If not you can restart the docker container with --shm-size=\"2g\" to increase the total amount of available shared memory. docker run -it --shm-size=\"2g\" ubuntu","title":"docker"},{"location":"FAQ/#termination-of-roudi-and-processes","text":"To avoid undefined behavior of iceoryx posh it is recommended to terminate RouDi and the corresponding middleware processes with SIGINT or SIGTERM. In RouDi, we have integrated a sighandler that catches the signals and gives RouDi the chance to exit and clean-up everything. This also applies for processes. Therefore, we recommend adding a signalhandler to your process (see this example ).","title":"Termination of RouDi and processes"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/","text":"iox::dds::CycloneContext \ud83d\udd17 The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application. #include <iceoryx_dds/dds/cyclone_context.hpp> Public Functions \ud83d\udd17 Name ::dds::domain::DomainParticipant & getParticipant () getParticipant Get the DDS Domain Participant for the current runtime. Public Functions Documentation \ud83d\udd17 function getParticipant \ud83d\udd17 static :: dds :: domain :: DomainParticipant & getParticipant () getParticipant Get the DDS Domain Participant for the current runtime. Return : The DDS Domain Participant. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::CycloneContext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#ioxddscyclonecontext","text":"The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application. #include <iceoryx_dds/dds/cyclone_context.hpp>","title":"iox::dds::CycloneContext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#public-functions","text":"Name ::dds::domain::DomainParticipant & getParticipant () getParticipant Get the DDS Domain Participant for the current runtime.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneContext/#function-getparticipant","text":"static :: dds :: domain :: DomainParticipant & getParticipant () getParticipant Get the DDS Domain Participant for the current runtime. Return : The DDS Domain Participant. Updated on 18 December 2023 at 13:11:43 CET","title":"function getParticipant"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/","text":"iox::dds::CycloneDataReader \ud83d\udd17 Implementation of the DataReader abstraction using the cyclonedds implementation. #include <iceoryx_dds/dds/cyclone_data_reader.hpp> Inherits from iox::dds::DataReader Public Functions \ud83d\udd17 Name CycloneDataReader () CycloneDataReader (const capro::IdString_t serviceId, const capro::IdString_t instanceId, const capro::IdString_t eventId) Constructor to set cyclone data reader object from given IDs. virtual ~CycloneDataReader () CycloneDataReader (const CycloneDataReader & ) CycloneDataReader & operator= (const CycloneDataReader & ) CycloneDataReader ( CycloneDataReader && ) CycloneDataReader & operator= ( CycloneDataReader && ) virtual void connect () override Connect cylcone data reader to the underlying DDS network. virtual iox::cxx::optional< IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () override peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. virtual bool hasSamples () override Checks if new samples are ready to take. virtual iox::cxx::expected< DataReaderError > takeNext (const IoxChunkDatagramHeader datagramHeader, uint8_t const userHeaderBuffer, uint8_t const userPayloadBuffer) override take Take the next available sample from the DDS data space. virtual capro::IdString_t getServiceId () const override get ID of the service virtual capro::IdString_t getInstanceId () const override get ID of the instance virtual capro::IdString_t getEventId () const override get ID of the event Additional inherited members \ud83d\udd17 Protected Functions inherited from iox::dds::DataReader Name DataReader () =default Public Functions Documentation \ud83d\udd17 function CycloneDataReader \ud83d\udd17 CycloneDataReader () function CycloneDataReader \ud83d\udd17 CycloneDataReader ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) Constructor to set cyclone data reader object from given IDs. Parameters : serviceId ID of the service instanceId ID of the instance of the service eventId ID of the event function ~CycloneDataReader \ud83d\udd17 virtual ~ CycloneDataReader () function CycloneDataReader \ud83d\udd17 CycloneDataReader ( const CycloneDataReader & ) function operator= \ud83d\udd17 CycloneDataReader & operator = ( const CycloneDataReader & ) function CycloneDataReader \ud83d\udd17 CycloneDataReader ( CycloneDataReader && ) function operator= \ud83d\udd17 CycloneDataReader & operator = ( CycloneDataReader && ) function connect \ud83d\udd17 virtual void connect () override Connect cylcone data reader to the underlying DDS network. Reimplements : iox::dds::DataReader::connect function peekNextIoxChunkDatagramHeader \ud83d\udd17 virtual iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () override peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. Return : The IoxChunkDatagramHeader of the next sample if one is available. Reimplements : iox::dds::DataReader::peekNextIoxChunkDatagramHeader function hasSamples \ud83d\udd17 virtual bool hasSamples () override Checks if new samples are ready to take. Return : True if new samples are available. Reimplements : iox::dds::DataReader::hasSamples function takeNext \ud83d\udd17 virtual iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) override take Take the next available sample from the DDS data space. Parameters : datagramHeader with size information userHeaderBuffer buffer for the user-header userPayloadBuffer buffer for the user-payload Return : Error if unsuccessful. Reimplements : iox::dds::DataReader::takeNext function getServiceId \ud83d\udd17 virtual capro :: IdString_t getServiceId () const override get ID of the service Reimplements : iox::dds::DataReader::getServiceId function getInstanceId \ud83d\udd17 virtual capro :: IdString_t getInstanceId () const override get ID of the instance Reimplements : iox::dds::DataReader::getInstanceId function getEventId \ud83d\udd17 virtual capro :: IdString_t getEventId () const override get ID of the event Reimplements : iox::dds::DataReader::getEventId Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#ioxddscyclonedatareader","text":"Implementation of the DataReader abstraction using the cyclonedds implementation. #include <iceoryx_dds/dds/cyclone_data_reader.hpp> Inherits from iox::dds::DataReader","title":"iox::dds::CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#public-functions","text":"Name CycloneDataReader () CycloneDataReader (const capro::IdString_t serviceId, const capro::IdString_t instanceId, const capro::IdString_t eventId) Constructor to set cyclone data reader object from given IDs. virtual ~CycloneDataReader () CycloneDataReader (const CycloneDataReader & ) CycloneDataReader & operator= (const CycloneDataReader & ) CycloneDataReader ( CycloneDataReader && ) CycloneDataReader & operator= ( CycloneDataReader && ) virtual void connect () override Connect cylcone data reader to the underlying DDS network. virtual iox::cxx::optional< IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () override peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. virtual bool hasSamples () override Checks if new samples are ready to take. virtual iox::cxx::expected< DataReaderError > takeNext (const IoxChunkDatagramHeader datagramHeader, uint8_t const userHeaderBuffer, uint8_t const userPayloadBuffer) override take Take the next available sample from the DDS data space. virtual capro::IdString_t getServiceId () const override get ID of the service virtual capro::IdString_t getInstanceId () const override get ID of the instance virtual capro::IdString_t getEventId () const override get ID of the event","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#additional-inherited-members","text":"Protected Functions inherited from iox::dds::DataReader Name DataReader () =default","title":"Additional inherited members"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader","text":"CycloneDataReader ()","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_1","text":"CycloneDataReader ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) Constructor to set cyclone data reader object from given IDs. Parameters : serviceId ID of the service instanceId ID of the instance of the service eventId ID of the event","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_2","text":"virtual ~ CycloneDataReader ()","title":"function ~CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_3","text":"CycloneDataReader ( const CycloneDataReader & )","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-operator","text":"CycloneDataReader & operator = ( const CycloneDataReader & )","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-cyclonedatareader_4","text":"CycloneDataReader ( CycloneDataReader && )","title":"function CycloneDataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-operator_1","text":"CycloneDataReader & operator = ( CycloneDataReader && )","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-connect","text":"virtual void connect () override Connect cylcone data reader to the underlying DDS network. Reimplements : iox::dds::DataReader::connect","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-peeknextioxchunkdatagramheader","text":"virtual iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () override peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. Return : The IoxChunkDatagramHeader of the next sample if one is available. Reimplements : iox::dds::DataReader::peekNextIoxChunkDatagramHeader","title":"function peekNextIoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-hassamples","text":"virtual bool hasSamples () override Checks if new samples are ready to take. Return : True if new samples are available. Reimplements : iox::dds::DataReader::hasSamples","title":"function hasSamples"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-takenext","text":"virtual iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) override take Take the next available sample from the DDS data space. Parameters : datagramHeader with size information userHeaderBuffer buffer for the user-header userPayloadBuffer buffer for the user-payload Return : Error if unsuccessful. Reimplements : iox::dds::DataReader::takeNext","title":"function takeNext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-getserviceid","text":"virtual capro :: IdString_t getServiceId () const override get ID of the service Reimplements : iox::dds::DataReader::getServiceId","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-getinstanceid","text":"virtual capro :: IdString_t getInstanceId () const override get ID of the instance Reimplements : iox::dds::DataReader::getInstanceId","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataReader/#function-geteventid","text":"virtual capro :: IdString_t getEventId () const override get ID of the event Reimplements : iox::dds::DataReader::getEventId Updated on 18 December 2023 at 13:11:43 CET","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/","text":"iox::dds::CycloneDataWriter \ud83d\udd17 Implementation of the DataWriter abstraction using the cyclonedds implementation. #include <iceoryx_dds/dds/cyclone_data_writer.hpp> Inherits from iox::dds::DataWriter Public Functions \ud83d\udd17 Name CycloneDataWriter () CycloneDataWriter (const capro::IdString_t serviceId, const capro::IdString_t instanceId, const capro::IdString_t eventId) Constructor to set cyclone data writer object from given IDs. virtual ~CycloneDataWriter () CycloneDataWriter (const CycloneDataWriter & ) CycloneDataWriter & operator= (const CycloneDataWriter & ) CycloneDataWriter ( CycloneDataWriter && rhs) =default CycloneDataWriter & operator= ( CycloneDataWriter && rhs) =default virtual void connect () override connect cyclone data writer to the underlying DDS network virtual void write ( iox::dds::IoxChunkDatagramHeader datagramHeader, const uint8_t const userHeaderBytes, const uint8_t const userPayloadBytes) override write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId virtual capro::IdString_t getServiceId () const override Get ID of the service. virtual capro::IdString_t getInstanceId () const override Get ID of the instance. virtual capro::IdString_t getEventId () const override Get ID of the event. Additional inherited members \ud83d\udd17 Public Functions inherited from iox::dds::DataWriter Name virtual ~DataWriter () =default Protected Functions inherited from iox::dds::DataWriter Name DataWriter () =default Public Functions Documentation \ud83d\udd17 function CycloneDataWriter \ud83d\udd17 CycloneDataWriter () function CycloneDataWriter \ud83d\udd17 CycloneDataWriter ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) Constructor to set cyclone data writer object from given IDs. Parameters : serviceId ID of the service instanceId ID of the instance of the service eventId ID of the event function ~CycloneDataWriter \ud83d\udd17 virtual ~ CycloneDataWriter () function CycloneDataWriter \ud83d\udd17 CycloneDataWriter ( const CycloneDataWriter & ) function operator= \ud83d\udd17 CycloneDataWriter & operator = ( const CycloneDataWriter & ) function CycloneDataWriter \ud83d\udd17 CycloneDataWriter ( CycloneDataWriter && rhs ) = default function operator= \ud83d\udd17 CycloneDataWriter & operator = ( CycloneDataWriter && rhs ) = default function connect \ud83d\udd17 virtual void connect () override connect cyclone data writer to the underlying DDS network Reimplements : iox::dds::DataWriter::connect function write \ud83d\udd17 virtual void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) override write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId Parameters : datagramHeader with size information userHeaderBytes buffer with the user-header userPayloadBytes buffer with the user-payload Reimplements : iox::dds::DataWriter::write function getServiceId \ud83d\udd17 virtual capro :: IdString_t getServiceId () const override Get ID of the service. Reimplements : iox::dds::DataWriter::getServiceId function getInstanceId \ud83d\udd17 virtual capro :: IdString_t getInstanceId () const override Get ID of the instance. Reimplements : iox::dds::DataWriter::getInstanceId function getEventId \ud83d\udd17 virtual capro :: IdString_t getEventId () const override Get ID of the event. Reimplements : iox::dds::DataWriter::getEventId Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#ioxddscyclonedatawriter","text":"Implementation of the DataWriter abstraction using the cyclonedds implementation. #include <iceoryx_dds/dds/cyclone_data_writer.hpp> Inherits from iox::dds::DataWriter","title":"iox::dds::CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#public-functions","text":"Name CycloneDataWriter () CycloneDataWriter (const capro::IdString_t serviceId, const capro::IdString_t instanceId, const capro::IdString_t eventId) Constructor to set cyclone data writer object from given IDs. virtual ~CycloneDataWriter () CycloneDataWriter (const CycloneDataWriter & ) CycloneDataWriter & operator= (const CycloneDataWriter & ) CycloneDataWriter ( CycloneDataWriter && rhs) =default CycloneDataWriter & operator= ( CycloneDataWriter && rhs) =default virtual void connect () override connect cyclone data writer to the underlying DDS network virtual void write ( iox::dds::IoxChunkDatagramHeader datagramHeader, const uint8_t const userHeaderBytes, const uint8_t const userPayloadBytes) override write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId virtual capro::IdString_t getServiceId () const override Get ID of the service. virtual capro::IdString_t getInstanceId () const override Get ID of the instance. virtual capro::IdString_t getEventId () const override Get ID of the event.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#additional-inherited-members","text":"Public Functions inherited from iox::dds::DataWriter Name virtual ~DataWriter () =default Protected Functions inherited from iox::dds::DataWriter Name DataWriter () =default","title":"Additional inherited members"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter","text":"CycloneDataWriter ()","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_1","text":"CycloneDataWriter ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) Constructor to set cyclone data writer object from given IDs. Parameters : serviceId ID of the service instanceId ID of the instance of the service eventId ID of the event","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_2","text":"virtual ~ CycloneDataWriter ()","title":"function ~CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_3","text":"CycloneDataWriter ( const CycloneDataWriter & )","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-operator","text":"CycloneDataWriter & operator = ( const CycloneDataWriter & )","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-cyclonedatawriter_4","text":"CycloneDataWriter ( CycloneDataWriter && rhs ) = default","title":"function CycloneDataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-operator_1","text":"CycloneDataWriter & operator = ( CycloneDataWriter && rhs ) = default","title":"function operator="},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-connect","text":"virtual void connect () override connect cyclone data writer to the underlying DDS network Reimplements : iox::dds::DataWriter::connect","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-write","text":"virtual void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) override write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId Parameters : datagramHeader with size information userHeaderBytes buffer with the user-header userPayloadBytes buffer with the user-payload Reimplements : iox::dds::DataWriter::write","title":"function write"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-getserviceid","text":"virtual capro :: IdString_t getServiceId () const override Get ID of the service. Reimplements : iox::dds::DataWriter::getServiceId","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-getinstanceid","text":"virtual capro :: IdString_t getInstanceId () const override Get ID of the instance. Reimplements : iox::dds::DataWriter::getInstanceId","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1CycloneDataWriter/#function-geteventid","text":"virtual capro :: IdString_t getEventId () const override Get ID of the event. Reimplements : iox::dds::DataWriter::getEventId Updated on 18 December 2023 at 13:11:43 CET","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/","text":"iox::dds::DDS2IceoryxGateway \ud83d\udd17 DDS Gateway implementation for the DDS to iceoryx direction. More... #include <iceoryx_dds/gateway/dds_to_iox.hpp> Inherits from gw::GatewayGeneric< gw::Channel< popo::UntypedPublisher, dds::data_reader_t > > Public Functions \ud83d\udd17 Name DDS2IceoryxGateway () Creates a gateway with DDS set as interface. void loadConfiguration (const config::GatewayConfig & config) void discover (const capro::CaproMessage & msg) void forward (const channel_t & channel) Detailed Description \ud83d\udd17 template < typename channel_t = gw :: Channel < popo :: UntypedPublisher , dds :: data_reader_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class iox :: dds :: DDS2IceoryxGateway ; DDS Gateway implementation for the DDS to iceoryx direction. Public Functions Documentation \ud83d\udd17 function DDS2IceoryxGateway \ud83d\udd17 DDS2IceoryxGateway () Creates a gateway with DDS set as interface. function loadConfiguration \ud83d\udd17 void loadConfiguration ( const config :: GatewayConfig & config ) function discover \ud83d\udd17 void discover ( const capro :: CaproMessage & msg ) function forward \ud83d\udd17 void forward ( const channel_t & channel ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::DDS2IceoryxGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#ioxddsdds2iceoryxgateway","text":"DDS Gateway implementation for the DDS to iceoryx direction. More... #include <iceoryx_dds/gateway/dds_to_iox.hpp> Inherits from gw::GatewayGeneric< gw::Channel< popo::UntypedPublisher, dds::data_reader_t > >","title":"iox::dds::DDS2IceoryxGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#public-functions","text":"Name DDS2IceoryxGateway () Creates a gateway with DDS set as interface. void loadConfiguration (const config::GatewayConfig & config) void discover (const capro::CaproMessage & msg) void forward (const channel_t & channel)","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#detailed-description","text":"template < typename channel_t = gw :: Channel < popo :: UntypedPublisher , dds :: data_reader_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class iox :: dds :: DDS2IceoryxGateway ; DDS Gateway implementation for the DDS to iceoryx direction.","title":"Detailed Description"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-dds2iceoryxgateway","text":"DDS2IceoryxGateway () Creates a gateway with DDS set as interface.","title":"function DDS2IceoryxGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-loadconfiguration","text":"void loadConfiguration ( const config :: GatewayConfig & config )","title":"function loadConfiguration"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-discover","text":"void discover ( const capro :: CaproMessage & msg )","title":"function discover"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DDS2IceoryxGateway/#function-forward","text":"void forward ( const channel_t & channel ) Updated on 18 December 2023 at 13:11:43 CET","title":"function forward"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/","text":"iox::dds::DataReader \ud83d\udd17 Abstraction for DDS Data Readers. #include <iceoryx_dds/dds/data_reader.hpp> Inherited by iox::dds::CycloneDataReader Public Functions \ud83d\udd17 Name virtual void connect () =0 Connect the DataReader to the underlying DDS network. virtual iox::cxx::optional< IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () =0 peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. virtual bool hasSamples () =0 Checks if new samples are ready to take. virtual iox::cxx::expected< DataReaderError > takeNext (const IoxChunkDatagramHeader datagramHeader, uint8_t const userHeaderBuffer, uint8_t const userPayloadBuffer) =0 take Take the next available sample from the DDS data space. virtual capro::IdString_t getServiceId () const =0 get ID of the service virtual capro::IdString_t getInstanceId () const =0 get ID of the instance virtual capro::IdString_t getEventId () const =0 get ID of the event Protected Functions \ud83d\udd17 Name DataReader () =default Public Functions Documentation \ud83d\udd17 function connect \ud83d\udd17 virtual void connect () = 0 Connect the DataReader to the underlying DDS network. Reimplemented by : iox::dds::CycloneDataReader::connect function peekNextIoxChunkDatagramHeader \ud83d\udd17 virtual iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () = 0 peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. Return : The IoxChunkDatagramHeader of the next sample if one is available. Reimplemented by : iox::dds::CycloneDataReader::peekNextIoxChunkDatagramHeader function hasSamples \ud83d\udd17 virtual bool hasSamples () = 0 Checks if new samples are ready to take. Return : True if new samples are available. Reimplemented by : iox::dds::CycloneDataReader::hasSamples function takeNext \ud83d\udd17 virtual iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) = 0 take Take the next available sample from the DDS data space. Parameters : datagramHeader with size information userHeaderBuffer buffer for the user-header userPayloadBuffer buffer for the user-payload Return : Error if unsuccessful. Reimplemented by : iox::dds::CycloneDataReader::takeNext function getServiceId \ud83d\udd17 virtual capro :: IdString_t getServiceId () const = 0 get ID of the service Reimplemented by : iox::dds::CycloneDataReader::getServiceId function getInstanceId \ud83d\udd17 virtual capro :: IdString_t getInstanceId () const = 0 get ID of the instance Reimplemented by : iox::dds::CycloneDataReader::getInstanceId function getEventId \ud83d\udd17 virtual capro :: IdString_t getEventId () const = 0 get ID of the event Reimplemented by : iox::dds::CycloneDataReader::getEventId Protected Functions Documentation \ud83d\udd17 function DataReader \ud83d\udd17 DataReader () = default Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::DataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#ioxddsdatareader","text":"Abstraction for DDS Data Readers. #include <iceoryx_dds/dds/data_reader.hpp> Inherited by iox::dds::CycloneDataReader","title":"iox::dds::DataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#public-functions","text":"Name virtual void connect () =0 Connect the DataReader to the underlying DDS network. virtual iox::cxx::optional< IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () =0 peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. virtual bool hasSamples () =0 Checks if new samples are ready to take. virtual iox::cxx::expected< DataReaderError > takeNext (const IoxChunkDatagramHeader datagramHeader, uint8_t const userHeaderBuffer, uint8_t const userPayloadBuffer) =0 take Take the next available sample from the DDS data space. virtual capro::IdString_t getServiceId () const =0 get ID of the service virtual capro::IdString_t getInstanceId () const =0 get ID of the instance virtual capro::IdString_t getEventId () const =0 get ID of the event","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#protected-functions","text":"Name DataReader () =default","title":"Protected Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-connect","text":"virtual void connect () = 0 Connect the DataReader to the underlying DDS network. Reimplemented by : iox::dds::CycloneDataReader::connect","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-peeknextioxchunkdatagramheader","text":"virtual iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () = 0 peekNextIoxChunkDatagramHeader Get the IoxChunkDatagramHeader of the next sample if one is available. Return : The IoxChunkDatagramHeader of the next sample if one is available. Reimplemented by : iox::dds::CycloneDataReader::peekNextIoxChunkDatagramHeader","title":"function peekNextIoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-hassamples","text":"virtual bool hasSamples () = 0 Checks if new samples are ready to take. Return : True if new samples are available. Reimplemented by : iox::dds::CycloneDataReader::hasSamples","title":"function hasSamples"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-takenext","text":"virtual iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) = 0 take Take the next available sample from the DDS data space. Parameters : datagramHeader with size information userHeaderBuffer buffer for the user-header userPayloadBuffer buffer for the user-payload Return : Error if unsuccessful. Reimplemented by : iox::dds::CycloneDataReader::takeNext","title":"function takeNext"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-getserviceid","text":"virtual capro :: IdString_t getServiceId () const = 0 get ID of the service Reimplemented by : iox::dds::CycloneDataReader::getServiceId","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-getinstanceid","text":"virtual capro :: IdString_t getInstanceId () const = 0 get ID of the instance Reimplemented by : iox::dds::CycloneDataReader::getInstanceId","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-geteventid","text":"virtual capro :: IdString_t getEventId () const = 0 get ID of the event Reimplemented by : iox::dds::CycloneDataReader::getEventId","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataReader/#function-datareader","text":"DataReader () = default Updated on 18 December 2023 at 13:11:43 CET","title":"function DataReader"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/","text":"iox::dds::DataWriter \ud83d\udd17 Abstraction for DDS Data Writers. More... #include <iceoryx_dds/dds/data_writer.hpp> Inherited by iox::dds::CycloneDataWriter Public Functions \ud83d\udd17 Name virtual ~DataWriter () =default virtual void connect () =0 Connect the DataWriter to the underlying DDS network. virtual void write ( iox::dds::IoxChunkDatagramHeader datagramHeader, const uint8_t const userHeaderBytes, const uint8_t const userPayloadBytes) =0 write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId virtual capro::IdString_t getServiceId () const =0 Get ID of the service. virtual capro::IdString_t getInstanceId () const =0 Get ID of the instance. virtual capro::IdString_t getEventId () const =0 Get ID of the event. Protected Functions \ud83d\udd17 Name DataWriter () =default Detailed Description \ud83d\udd17 class iox :: dds :: DataWriter ; Abstraction for DDS Data Writers. Note : Provides the minimum functionality required for posh-dds gateway implementations. Public Functions Documentation \ud83d\udd17 function ~DataWriter \ud83d\udd17 virtual ~ DataWriter () = default function connect \ud83d\udd17 virtual void connect () = 0 Connect the DataWriter to the underlying DDS network. Reimplemented by : iox::dds::CycloneDataWriter::connect function write \ud83d\udd17 virtual void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) = 0 write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId Parameters : datagramHeader with size information userHeaderBytes buffer with the user-header userPayloadBytes buffer with the user-payload Reimplemented by : iox::dds::CycloneDataWriter::write function getServiceId \ud83d\udd17 virtual capro :: IdString_t getServiceId () const = 0 Get ID of the service. Reimplemented by : iox::dds::CycloneDataWriter::getServiceId function getInstanceId \ud83d\udd17 virtual capro :: IdString_t getInstanceId () const = 0 Get ID of the instance. Reimplemented by : iox::dds::CycloneDataWriter::getInstanceId function getEventId \ud83d\udd17 virtual capro :: IdString_t getEventId () const = 0 Get ID of the event. Reimplemented by : iox::dds::CycloneDataWriter::getEventId Protected Functions Documentation \ud83d\udd17 function DataWriter \ud83d\udd17 DataWriter () = default Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#ioxddsdatawriter","text":"Abstraction for DDS Data Writers. More... #include <iceoryx_dds/dds/data_writer.hpp> Inherited by iox::dds::CycloneDataWriter","title":"iox::dds::DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#public-functions","text":"Name virtual ~DataWriter () =default virtual void connect () =0 Connect the DataWriter to the underlying DDS network. virtual void write ( iox::dds::IoxChunkDatagramHeader datagramHeader, const uint8_t const userHeaderBytes, const uint8_t const userPayloadBytes) =0 write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId virtual capro::IdString_t getServiceId () const =0 Get ID of the service. virtual capro::IdString_t getInstanceId () const =0 Get ID of the instance. virtual capro::IdString_t getEventId () const =0 Get ID of the event.","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#protected-functions","text":"Name DataWriter () =default","title":"Protected Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#detailed-description","text":"class iox :: dds :: DataWriter ; Abstraction for DDS Data Writers. Note : Provides the minimum functionality required for posh-dds gateway implementations.","title":"Detailed Description"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-datawriter","text":"virtual ~ DataWriter () = default","title":"function ~DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-connect","text":"virtual void connect () = 0 Connect the DataWriter to the underlying DDS network. Reimplemented by : iox::dds::CycloneDataWriter::connect","title":"function connect"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-write","text":"virtual void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) = 0 write Write the provided header and bytes on the DDS network on the topic: serviceId/instanceId/eventId Parameters : datagramHeader with size information userHeaderBytes buffer with the user-header userPayloadBytes buffer with the user-payload Reimplemented by : iox::dds::CycloneDataWriter::write","title":"function write"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-getserviceid","text":"virtual capro :: IdString_t getServiceId () const = 0 Get ID of the service. Reimplemented by : iox::dds::CycloneDataWriter::getServiceId","title":"function getServiceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-getinstanceid","text":"virtual capro :: IdString_t getInstanceId () const = 0 Get ID of the instance. Reimplemented by : iox::dds::CycloneDataWriter::getInstanceId","title":"function getInstanceId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-geteventid","text":"virtual capro :: IdString_t getEventId () const = 0 Get ID of the event. Reimplemented by : iox::dds::CycloneDataWriter::getEventId","title":"function getEventId"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1DataWriter/#function-datawriter_1","text":"DataWriter () = default Updated on 18 December 2023 at 13:11:43 CET","title":"function DataWriter"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/","text":"iox::dds::Iceoryx2DDSGateway \ud83d\udd17 DDS Gateway implementation for the iceoryx to DDS direction. More... #include <iceoryx_dds/gateway/iox_to_dds.hpp> Inherits from gw::GatewayGeneric< gw::Channel< popo::UntypedSubscriber, dds::data_writer_t > > Public Functions \ud83d\udd17 Name Iceoryx2DDSGateway () Creates a gateway with DDS set as interface. void loadConfiguration (const config::GatewayConfig & config) void discover (const capro::CaproMessage & msg) void forward (const channel_t & channel) Detailed Description \ud83d\udd17 template < typename channel_t = gw :: Channel < popo :: UntypedSubscriber , dds :: data_writer_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class iox :: dds :: Iceoryx2DDSGateway ; DDS Gateway implementation for the iceoryx to DDS direction. Public Functions Documentation \ud83d\udd17 function Iceoryx2DDSGateway \ud83d\udd17 Iceoryx2DDSGateway () Creates a gateway with DDS set as interface. function loadConfiguration \ud83d\udd17 void loadConfiguration ( const config :: GatewayConfig & config ) function discover \ud83d\udd17 void discover ( const capro :: CaproMessage & msg ) function forward \ud83d\udd17 void forward ( const channel_t & channel ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::Iceoryx2DDSGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#ioxddsiceoryx2ddsgateway","text":"DDS Gateway implementation for the iceoryx to DDS direction. More... #include <iceoryx_dds/gateway/iox_to_dds.hpp> Inherits from gw::GatewayGeneric< gw::Channel< popo::UntypedSubscriber, dds::data_writer_t > >","title":"iox::dds::Iceoryx2DDSGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#public-functions","text":"Name Iceoryx2DDSGateway () Creates a gateway with DDS set as interface. void loadConfiguration (const config::GatewayConfig & config) void discover (const capro::CaproMessage & msg) void forward (const channel_t & channel)","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#detailed-description","text":"template < typename channel_t = gw :: Channel < popo :: UntypedSubscriber , dds :: data_writer_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class iox :: dds :: Iceoryx2DDSGateway ; DDS Gateway implementation for the iceoryx to DDS direction.","title":"Detailed Description"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-iceoryx2ddsgateway","text":"Iceoryx2DDSGateway () Creates a gateway with DDS set as interface.","title":"function Iceoryx2DDSGateway"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-loadconfiguration","text":"void loadConfiguration ( const config :: GatewayConfig & config )","title":"function loadConfiguration"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-discover","text":"void discover ( const capro :: CaproMessage & msg )","title":"function discover"},{"location":"API-reference/DDS-gateway/Classes/classiox_1_1dds_1_1Iceoryx2DDSGateway/#function-forward","text":"void forward ( const channel_t & channel ) Updated on 18 December 2023 at 13:11:43 CET","title":"function forward"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/","text":"iox::dds::IoxChunkDatagramHeader \ud83d\udd17 The datagram header with chunk metadata for user-header and user-payload. #include <iceoryx_dds/dds/iox_chunk_datagram_header.hpp> Public Types \ud83d\udd17 Name using iox::cxx::vector< uint8_t, 16U > Serialized_t Public Functions \ud83d\udd17 Name Serialized_t serialize (const IoxChunkDatagramHeader & datagramHeader) Serializes a IoxChunkDatagramHeader into a vector of uint8_t. IoxChunkDatagramHeader deserialize (const Serialized_t & serializedDatagramHeader) Deserializes a vector of uint8_t into a IoxChunkDatagramHeader . Public Attributes \ud83d\udd17 Name constexpr uint8_t DATAGRAM_VERSION From the 1.0 release onward, this must be incremented for each incompatible change, e.g. uint8_t datagramVersion Endianess endianness uint16_t userHeaderId uint32_t userHeaderSize uint32_t userPayloadSize uint32_t userPayloadAlignment Public Types Documentation \ud83d\udd17 using Serialized_t \ud83d\udd17 using iox :: dds :: IoxChunkDatagramHeader :: Serialized_t = iox :: cxx :: vector < uint8_t , 16U > ; Public Functions Documentation \ud83d\udd17 function serialize \ud83d\udd17 static Serialized_t serialize ( const IoxChunkDatagramHeader & datagramHeader ) Serializes a IoxChunkDatagramHeader into a vector of uint8_t. Parameters : datagramHeader to serialize Return : the serialized IoxChunkDatagramHeader function deserialize \ud83d\udd17 static IoxChunkDatagramHeader deserialize ( const Serialized_t & serializedDatagramHeader ) Deserializes a vector of uint8_t into a IoxChunkDatagramHeader . Parameters : serializedDatagram is the serialized IoxChunkDatagramHeader Return : the deserialized IoxChunkDatagramHeader Public Attributes Documentation \ud83d\udd17 variable DATAGRAM_VERSION \ud83d\udd17 static constexpr uint8_t DATAGRAM_VERSION { 1U }; From the 1.0 release onward, this must be incremented for each incompatible change, e.g. data width of members changes members are rearranged semantic meaning of a member changes variable datagramVersion \ud83d\udd17 uint8_t datagramVersion {[ DATAGRAM_VERSION ]( / v2 .0.5 / API - reference / DDS - gateway / Classes / structiox_1_1dds_1_1IoxChunkDatagramHeader / # variable - datagram_version )}; Note : This must always be the first member and always 1 bytes in order to prevent issues with endianess when deserialized or incorrectly detected versions due to different size variable endianness \ud83d\udd17 Endianess endianness { Endianess :: UNDEFINED }; Note : This must always be 1 byte in order to prevent issues with endianess when deserialized variable userHeaderId \ud83d\udd17 uint16_t userHeaderId { 0xFFFF }; variable userHeaderSize \ud83d\udd17 uint32_t userHeaderSize { 0U }; variable userPayloadSize \ud83d\udd17 uint32_t userPayloadSize { 0U }; variable userPayloadAlignment \ud83d\udd17 uint32_t userPayloadAlignment { 0U }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds::IoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#ioxddsioxchunkdatagramheader","text":"The datagram header with chunk metadata for user-header and user-payload. #include <iceoryx_dds/dds/iox_chunk_datagram_header.hpp>","title":"iox::dds::IoxChunkDatagramHeader"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-types","text":"Name using iox::cxx::vector< uint8_t, 16U > Serialized_t","title":"Public Types"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-functions","text":"Name Serialized_t serialize (const IoxChunkDatagramHeader & datagramHeader) Serializes a IoxChunkDatagramHeader into a vector of uint8_t. IoxChunkDatagramHeader deserialize (const Serialized_t & serializedDatagramHeader) Deserializes a vector of uint8_t into a IoxChunkDatagramHeader .","title":"Public Functions"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-attributes","text":"Name constexpr uint8_t DATAGRAM_VERSION From the 1.0 release onward, this must be incremented for each incompatible change, e.g. uint8_t datagramVersion Endianess endianness uint16_t userHeaderId uint32_t userHeaderSize uint32_t userPayloadSize uint32_t userPayloadAlignment","title":"Public Attributes"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#using-serialized_t","text":"using iox :: dds :: IoxChunkDatagramHeader :: Serialized_t = iox :: cxx :: vector < uint8_t , 16U > ;","title":"using Serialized_t"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#function-serialize","text":"static Serialized_t serialize ( const IoxChunkDatagramHeader & datagramHeader ) Serializes a IoxChunkDatagramHeader into a vector of uint8_t. Parameters : datagramHeader to serialize Return : the serialized IoxChunkDatagramHeader","title":"function serialize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#function-deserialize","text":"static IoxChunkDatagramHeader deserialize ( const Serialized_t & serializedDatagramHeader ) Deserializes a vector of uint8_t into a IoxChunkDatagramHeader . Parameters : serializedDatagram is the serialized IoxChunkDatagramHeader Return : the deserialized IoxChunkDatagramHeader","title":"function deserialize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-datagram_version","text":"static constexpr uint8_t DATAGRAM_VERSION { 1U }; From the 1.0 release onward, this must be incremented for each incompatible change, e.g. data width of members changes members are rearranged semantic meaning of a member changes","title":"variable DATAGRAM_VERSION"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-datagramversion","text":"uint8_t datagramVersion {[ DATAGRAM_VERSION ]( / v2 .0.5 / API - reference / DDS - gateway / Classes / structiox_1_1dds_1_1IoxChunkDatagramHeader / # variable - datagram_version )}; Note : This must always be the first member and always 1 bytes in order to prevent issues with endianess when deserialized or incorrectly detected versions due to different size","title":"variable datagramVersion"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-endianness","text":"Endianess endianness { Endianess :: UNDEFINED }; Note : This must always be 1 byte in order to prevent issues with endianess when deserialized","title":"variable endianness"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userheaderid","text":"uint16_t userHeaderId { 0xFFFF };","title":"variable userHeaderId"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userheadersize","text":"uint32_t userHeaderSize { 0U };","title":"variable userHeaderSize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userpayloadsize","text":"uint32_t userPayloadSize { 0U };","title":"variable userPayloadSize"},{"location":"API-reference/DDS-gateway/Classes/structiox_1_1dds_1_1IoxChunkDatagramHeader/#variable-userpayloadalignment","text":"uint32_t userPayloadAlignment { 0U }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable userPayloadAlignment"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/","text":"iceoryx_dds/dds/cyclone_context.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::CycloneContext The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef CYCLONE_CONTEXT_HPP #define CYCLONE_CONTEXT_HPP #include <dds/dds.hpp> namespace iox { namespace dds { class CycloneContext { public : static :: dds :: domain :: DomainParticipant & getParticipant () noexcept ; }; } // namespace dds } // namespace iox #endif // CYCLONE_CONTEXT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/cyclone_context.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#iceoryx_ddsddscyclone_contexthpp","text":"","title":"iceoryx_dds/dds/cyclone_context.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#classes","text":"Name class iox::dds::CycloneContext The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/cyclone__context_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef CYCLONE_CONTEXT_HPP #define CYCLONE_CONTEXT_HPP #include <dds/dds.hpp> namespace iox { namespace dds { class CycloneContext { public : static :: dds :: domain :: DomainParticipant & getParticipant () noexcept ; }; } // namespace dds } // namespace iox #endif // CYCLONE_CONTEXT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/","text":"iceoryx_dds/dds/cyclone_data_reader.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::CycloneDataReader Implementation of the DataReader abstraction using the cyclonedds implementation. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_CYCLONE_DATA_READER_HPP #define IOX_DDS_DDS_CYCLONE_DATA_READER_HPP #include \"iceoryx_dds/Mempool.hpp\" #include \"iceoryx_dds/dds/data_reader.hpp\" #include <atomic> #include <dds/dds.hpp> namespace iox { namespace dds { class CycloneDataReader : public DataReader { public : CycloneDataReader () = delete ; CycloneDataReader ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) noexcept ; virtual ~ CycloneDataReader (); CycloneDataReader ( const CycloneDataReader & ) = delete ; CycloneDataReader & operator = ( const CycloneDataReader & ) = delete ; CycloneDataReader ( CycloneDataReader && ) = delete ; CycloneDataReader & operator = ( CycloneDataReader && ) = delete ; void connect () noexcept override ; iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () noexcept override ; bool hasSamples () noexcept override ; iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) noexcept override ; capro :: IdString_t getServiceId () const noexcept override ; capro :: IdString_t getInstanceId () const noexcept override ; capro :: IdString_t getEventId () const noexcept override ; private : capro :: IdString_t m_serviceId { \"\" }; capro :: IdString_t m_instanceId { \"\" }; capro :: IdString_t m_eventId { \"\" }; :: dds :: sub :: DataReader < Mempool :: Chunk > m_impl = :: dds :: core :: null ; std :: atomic_bool m_isConnected { false }; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_CYCLONE_DATA_READER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/cyclone_data_reader.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#iceoryx_ddsddscyclone_data_readerhpp","text":"","title":"iceoryx_dds/dds/cyclone_data_reader.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#classes","text":"Name class iox::dds::CycloneDataReader Implementation of the DataReader abstraction using the cyclonedds implementation.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__reader_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_CYCLONE_DATA_READER_HPP #define IOX_DDS_DDS_CYCLONE_DATA_READER_HPP #include \"iceoryx_dds/Mempool.hpp\" #include \"iceoryx_dds/dds/data_reader.hpp\" #include <atomic> #include <dds/dds.hpp> namespace iox { namespace dds { class CycloneDataReader : public DataReader { public : CycloneDataReader () = delete ; CycloneDataReader ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) noexcept ; virtual ~ CycloneDataReader (); CycloneDataReader ( const CycloneDataReader & ) = delete ; CycloneDataReader & operator = ( const CycloneDataReader & ) = delete ; CycloneDataReader ( CycloneDataReader && ) = delete ; CycloneDataReader & operator = ( CycloneDataReader && ) = delete ; void connect () noexcept override ; iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () noexcept override ; bool hasSamples () noexcept override ; iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) noexcept override ; capro :: IdString_t getServiceId () const noexcept override ; capro :: IdString_t getInstanceId () const noexcept override ; capro :: IdString_t getEventId () const noexcept override ; private : capro :: IdString_t m_serviceId { \"\" }; capro :: IdString_t m_instanceId { \"\" }; capro :: IdString_t m_eventId { \"\" }; :: dds :: sub :: DataReader < Mempool :: Chunk > m_impl = :: dds :: core :: null ; std :: atomic_bool m_isConnected { false }; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_CYCLONE_DATA_READER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/","text":"iceoryx_dds/dds/cyclone_data_writer.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::CycloneDataWriter Implementation of the DataWriter abstraction using the cyclonedds implementation. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP #define IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP #include \"iceoryx_dds/Mempool.hpp\" #include \"iceoryx_dds/dds/data_writer.hpp\" #include <dds/dds.hpp> namespace iox { namespace dds { class CycloneDataWriter : public iox :: dds :: DataWriter { public : CycloneDataWriter () = delete ; CycloneDataWriter ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) noexcept ; virtual ~ CycloneDataWriter (); CycloneDataWriter ( const CycloneDataWriter & ) = delete ; CycloneDataWriter & operator = ( const CycloneDataWriter & ) = delete ; CycloneDataWriter ( CycloneDataWriter && rhs ) = default ; CycloneDataWriter & operator = ( CycloneDataWriter && rhs ) = default ; void connect () noexcept override ; void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) noexcept override ; capro :: IdString_t getServiceId () const noexcept override ; capro :: IdString_t getInstanceId () const noexcept override ; capro :: IdString_t getEventId () const noexcept override ; private : capro :: IdString_t m_serviceId { \"\" }; capro :: IdString_t m_instanceId { \"\" }; capro :: IdString_t m_eventId { \"\" }; :: dds :: pub :: Publisher m_publisher = :: dds :: core :: null ; :: dds :: topic :: Topic < Mempool :: Chunk > m_topic = :: dds :: core :: null ; :: dds :: pub :: DataWriter < Mempool :: Chunk > m_writer = :: dds :: core :: null ; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/cyclone_data_writer.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#iceoryx_ddsddscyclone_data_writerhpp","text":"","title":"iceoryx_dds/dds/cyclone_data_writer.hpp"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#classes","text":"Name class iox::dds::CycloneDataWriter Implementation of the DataWriter abstraction using the cyclonedds implementation.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/cyclone__data__writer_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP #define IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP #include \"iceoryx_dds/Mempool.hpp\" #include \"iceoryx_dds/dds/data_writer.hpp\" #include <dds/dds.hpp> namespace iox { namespace dds { class CycloneDataWriter : public iox :: dds :: DataWriter { public : CycloneDataWriter () = delete ; CycloneDataWriter ( const capro :: IdString_t serviceId , const capro :: IdString_t instanceId , const capro :: IdString_t eventId ) noexcept ; virtual ~ CycloneDataWriter (); CycloneDataWriter ( const CycloneDataWriter & ) = delete ; CycloneDataWriter & operator = ( const CycloneDataWriter & ) = delete ; CycloneDataWriter ( CycloneDataWriter && rhs ) = default ; CycloneDataWriter & operator = ( CycloneDataWriter && rhs ) = default ; void connect () noexcept override ; void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) noexcept override ; capro :: IdString_t getServiceId () const noexcept override ; capro :: IdString_t getInstanceId () const noexcept override ; capro :: IdString_t getEventId () const noexcept override ; private : capro :: IdString_t m_serviceId { \"\" }; capro :: IdString_t m_instanceId { \"\" }; capro :: IdString_t m_eventId { \"\" }; :: dds :: pub :: Publisher m_publisher = :: dds :: core :: null ; :: dds :: topic :: Topic < Mempool :: Chunk > m_topic = :: dds :: core :: null ; :: dds :: pub :: DataWriter < Mempool :: Chunk > m_writer = :: dds :: core :: null ; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_CYCLONE_DATA_WRITER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/","text":"iceoryx_dds/dds/data_reader.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::DataReader Abstraction for DDS Data Readers. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_DATA_READER_HPP #define IOX_DDS_DDS_DATA_READER_HPP #include \"iceoryx_dds/dds/iox_chunk_datagram_header.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace dds { enum class DataReaderError : uint8_t { NOT_CONNECTED , INVALID_DATAGRAM_HEADER_SIZE , INVALID_BUFFER_PARAMETER_FOR_USER_HEADER , INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD , INVALID_DATA , BUFFER_SIZE_MISMATCH }; constexpr const char * DataReaderErrorString [] = { \"NOT_CONNECTED\" , \"INVALID_DATAGRAM_HEADER_SIZE\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_HEADER\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD\" , \"INVALID_DATA\" , \"BUFFER_SIZE_MISMATCH\" }; class DataReader { public : virtual void connect () noexcept = 0 ; virtual iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () noexcept = 0 ; virtual bool hasSamples () noexcept = 0 ; virtual iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) noexcept = 0 ; virtual capro :: IdString_t getServiceId () const noexcept = 0 ; virtual capro :: IdString_t getInstanceId () const noexcept = 0 ; virtual capro :: IdString_t getEventId () const noexcept = 0 ; protected : DataReader () noexcept = default ; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_DATA_READER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/data_reader.hpp"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#iceoryx_ddsddsdata_readerhpp","text":"","title":"iceoryx_dds/dds/data_reader.hpp"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#classes","text":"Name class iox::dds::DataReader Abstraction for DDS Data Readers.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/data__reader_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_DATA_READER_HPP #define IOX_DDS_DDS_DATA_READER_HPP #include \"iceoryx_dds/dds/iox_chunk_datagram_header.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace dds { enum class DataReaderError : uint8_t { NOT_CONNECTED , INVALID_DATAGRAM_HEADER_SIZE , INVALID_BUFFER_PARAMETER_FOR_USER_HEADER , INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD , INVALID_DATA , BUFFER_SIZE_MISMATCH }; constexpr const char * DataReaderErrorString [] = { \"NOT_CONNECTED\" , \"INVALID_DATAGRAM_HEADER_SIZE\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_HEADER\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD\" , \"INVALID_DATA\" , \"BUFFER_SIZE_MISMATCH\" }; class DataReader { public : virtual void connect () noexcept = 0 ; virtual iox :: cxx :: optional < IoxChunkDatagramHeader > peekNextIoxChunkDatagramHeader () noexcept = 0 ; virtual bool hasSamples () noexcept = 0 ; virtual iox :: cxx :: expected < DataReaderError > takeNext ( const IoxChunkDatagramHeader datagramHeader , uint8_t * const userHeaderBuffer , uint8_t * const userPayloadBuffer ) noexcept = 0 ; virtual capro :: IdString_t getServiceId () const noexcept = 0 ; virtual capro :: IdString_t getInstanceId () const noexcept = 0 ; virtual capro :: IdString_t getEventId () const noexcept = 0 ; protected : DataReader () noexcept = default ; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_DATA_READER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/","text":"iceoryx_dds/dds/data_writer.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::DataWriter Abstraction for DDS Data Writers. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_DATA_WRITER_HPP #define IOX_DDS_DDS_DATA_WRITER_HPP #include \"iceoryx_dds/dds/iox_chunk_datagram_header.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace dds { class DataWriter { public : virtual ~ DataWriter () = default ; virtual void connect () noexcept = 0 ; virtual void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) noexcept = 0 ; virtual capro :: IdString_t getServiceId () const noexcept = 0 ; virtual capro :: IdString_t getInstanceId () const noexcept = 0 ; virtual capro :: IdString_t getEventId () const noexcept = 0 ; protected : DataWriter () = default ; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_DATA_WRITER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/data_writer.hpp"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#iceoryx_ddsddsdata_writerhpp","text":"","title":"iceoryx_dds/dds/data_writer.hpp"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#classes","text":"Name class iox::dds::DataWriter Abstraction for DDS Data Writers.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/data__writer_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_DATA_WRITER_HPP #define IOX_DDS_DDS_DATA_WRITER_HPP #include \"iceoryx_dds/dds/iox_chunk_datagram_header.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace dds { class DataWriter { public : virtual ~ DataWriter () = default ; virtual void connect () noexcept = 0 ; virtual void write ( iox :: dds :: IoxChunkDatagramHeader datagramHeader , const uint8_t * const userHeaderBytes , const uint8_t * const userPayloadBytes ) noexcept = 0 ; virtual capro :: IdString_t getServiceId () const noexcept = 0 ; virtual capro :: IdString_t getInstanceId () const noexcept = 0 ; virtual capro :: IdString_t getEventId () const noexcept = 0 ; protected : DataWriter () = default ; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_DATA_WRITER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/","text":"iceoryx_dds/dds/dds_config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds units::duration_literals Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_CONFIG_HPP #define IOX_DDS_DDS_CONFIG_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace dds { using namespace units :: duration_literals ; static constexpr units :: Duration DISCOVERY_PERIOD = 1000 _ms ; static constexpr units :: Duration FORWARDING_PERIOD = 50 _ms ; static constexpr uint32_t SUBSCRIBER_CACHE_SIZE = 128u ; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/dds_config.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/#iceoryx_ddsddsdds_confighpp","text":"","title":"iceoryx_dds/dds/dds_config.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/#namespaces","text":"Name iox iox::dds units::duration_literals","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/dds__config_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_CONFIG_HPP #define IOX_DDS_DDS_CONFIG_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace dds { using namespace units :: duration_literals ; static constexpr units :: Duration DISCOVERY_PERIOD = 1000 _ms ; static constexpr units :: Duration FORWARDING_PERIOD = 50 _ms ; static constexpr uint32_t SUBSCRIBER_CACHE_SIZE = 128u ; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/","text":"iceoryx_dds/gateway/dds_to_iox.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::DDS2IceoryxGateway DDS Gateway implementation for the DDS to iceoryx direction. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_TO_IOX_HPP #define IOX_DDS_DDS_TO_IOX_HPP #include \"iceoryx_dds/dds/dds_types.hpp\" #include \"iceoryx_posh/gateway/channel.hpp\" #include \"iceoryx_posh/gateway/gateway_config.hpp\" #include \"iceoryx_posh/gateway/gateway_generic.hpp\" #include \"iceoryx_posh/popo/untyped_publisher.hpp\" namespace iox { namespace dds { template < typename channel_t = gw :: Channel < popo :: UntypedPublisher , dds :: data_reader_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class DDS2IceoryxGateway : public gateway_t { public : DDS2IceoryxGateway () noexcept ; void loadConfiguration ( const config :: GatewayConfig & config ) noexcept ; void discover ( const capro :: CaproMessage & msg ) noexcept ; void forward ( const channel_t & channel ) noexcept ; private : void * m_reservedChunk = nullptr ; cxx :: expected < channel_t , gw :: GatewayError > setupChannel ( const capro :: ServiceDescription & service , const popo :: PublisherOptions & publisherOptions ) noexcept ; }; } // namespace dds } // namespace iox #include \"iceoryx_dds/internal/gateway/dds_to_iox.inl\" #endif // IOX_DDS_DDS_TO_IOX_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/gateway/dds_to_iox.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#iceoryx_ddsgatewaydds_to_ioxhpp","text":"","title":"iceoryx_dds/gateway/dds_to_iox.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#classes","text":"Name class iox::dds::DDS2IceoryxGateway DDS Gateway implementation for the DDS to iceoryx direction.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/dds__to__iox_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_TO_IOX_HPP #define IOX_DDS_DDS_TO_IOX_HPP #include \"iceoryx_dds/dds/dds_types.hpp\" #include \"iceoryx_posh/gateway/channel.hpp\" #include \"iceoryx_posh/gateway/gateway_config.hpp\" #include \"iceoryx_posh/gateway/gateway_generic.hpp\" #include \"iceoryx_posh/popo/untyped_publisher.hpp\" namespace iox { namespace dds { template < typename channel_t = gw :: Channel < popo :: UntypedPublisher , dds :: data_reader_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class DDS2IceoryxGateway : public gateway_t { public : DDS2IceoryxGateway () noexcept ; void loadConfiguration ( const config :: GatewayConfig & config ) noexcept ; void discover ( const capro :: CaproMessage & msg ) noexcept ; void forward ( const channel_t & channel ) noexcept ; private : void * m_reservedChunk = nullptr ; cxx :: expected < channel_t , gw :: GatewayError > setupChannel ( const capro :: ServiceDescription & service , const popo :: PublisherOptions & publisherOptions ) noexcept ; }; } // namespace dds } // namespace iox #include \"iceoryx_dds/internal/gateway/dds_to_iox.inl\" #endif // IOX_DDS_DDS_TO_IOX_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/","text":"iceoryx_dds/dds/dds_types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_DDS_TYPES_HPP #define IOX_DDS_DDS_DDS_TYPES_HPP #ifdef USE_CYCLONE_DDS #include \"iceoryx_dds/dds/cyclone_data_reader.hpp\" #include \"iceoryx_dds/dds/cyclone_data_writer.hpp\" #else #error \"A DDS implementation must be provided.\" #endif namespace iox { namespace dds { // DDS implementation defined with compiler flags #ifdef USE_CYCLONE_DDS using data_reader_t = iox :: dds :: CycloneDataReader ; using data_writer_t = iox :: dds :: CycloneDataWriter ; #else #error \"A DDS implementation must be set.\" #endif } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_DDS_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/dds_types.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/#iceoryx_ddsddsdds_typeshpp","text":"","title":"iceoryx_dds/dds/dds_types.hpp"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/dds__types_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_DDS_TYPES_HPP #define IOX_DDS_DDS_DDS_TYPES_HPP #ifdef USE_CYCLONE_DDS #include \"iceoryx_dds/dds/cyclone_data_reader.hpp\" #include \"iceoryx_dds/dds/cyclone_data_writer.hpp\" #else #error \"A DDS implementation must be provided.\" #endif namespace iox { namespace dds { // DDS implementation defined with compiler flags #ifdef USE_CYCLONE_DDS using data_reader_t = iox :: dds :: CycloneDataReader ; using data_writer_t = iox :: dds :: CycloneDataWriter ; #else #error \"A DDS implementation must be set.\" #endif } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_DDS_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/dir_1a82753d8824303b9a4093edfd2a02d7/","text":"iceoryx_dds/dds \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_dds/dds/cyclone_context.hpp iceoryx_dds/dds/cyclone_data_reader.hpp iceoryx_dds/dds/cyclone_data_writer.hpp iceoryx_dds/dds/data_reader.hpp iceoryx_dds/dds/data_writer.hpp iceoryx_dds/dds/dds_config.hpp iceoryx_dds/dds/dds_types.hpp iceoryx_dds/dds/iox_chunk_datagram_header.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds"},{"location":"API-reference/DDS-gateway/Files/dir_1a82753d8824303b9a4093edfd2a02d7/#iceoryx_ddsdds","text":"","title":"iceoryx_dds/dds"},{"location":"API-reference/DDS-gateway/Files/dir_1a82753d8824303b9a4093edfd2a02d7/#files","text":"Name iceoryx_dds/dds/cyclone_context.hpp iceoryx_dds/dds/cyclone_data_reader.hpp iceoryx_dds/dds/cyclone_data_writer.hpp iceoryx_dds/dds/data_reader.hpp iceoryx_dds/dds/data_writer.hpp iceoryx_dds/dds/dds_config.hpp iceoryx_dds/dds/dds_types.hpp iceoryx_dds/dds/iox_chunk_datagram_header.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/DDS-gateway/Files/dir_afbf8928646817b6b649ce75b30863ef/","text":"iceoryx_dds \ud83d\udd17 Directories \ud83d\udd17 Name iceoryx_dds/dds iceoryx_dds/gateway Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds"},{"location":"API-reference/DDS-gateway/Files/dir_afbf8928646817b6b649ce75b30863ef/#iceoryx_dds","text":"","title":"iceoryx_dds"},{"location":"API-reference/DDS-gateway/Files/dir_afbf8928646817b6b649ce75b30863ef/#directories","text":"Name iceoryx_dds/dds iceoryx_dds/gateway Updated on 18 December 2023 at 13:11:43 CET","title":"Directories"},{"location":"API-reference/DDS-gateway/Files/dir_d89b9f530a1a11760f613e54bce77e1a/","text":"iceoryx_dds/gateway \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_dds/gateway/dds_to_iox.hpp iceoryx_dds/gateway/iox_to_dds.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/gateway"},{"location":"API-reference/DDS-gateway/Files/dir_d89b9f530a1a11760f613e54bce77e1a/#iceoryx_ddsgateway","text":"","title":"iceoryx_dds/gateway"},{"location":"API-reference/DDS-gateway/Files/dir_d89b9f530a1a11760f613e54bce77e1a/#files","text":"Name iceoryx_dds/gateway/dds_to_iox.hpp iceoryx_dds/gateway/iox_to_dds.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/","text":"iceoryx_dds/dds/iox_chunk_datagram_header.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name struct iox::dds::IoxChunkDatagramHeader The datagram header with chunk metadata for user-header and user-payload. Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP #define IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cstdint> namespace iox { namespace dds { enum class Endianess : uint8_t { UNDEFINED , LITTLE , BIG , MIXED , }; constexpr const char * EndianessString [] = { \"UNDEFINED\" , \"LITTLE\" , \"BIG\" , \"MIXED\" }; Endianess getEndianess (); struct IoxChunkDatagramHeader { using Serialized_t = iox :: cxx :: vector < uint8_t , 16U > ; static Serialized_t serialize ( const IoxChunkDatagramHeader & datagramHeader ); static IoxChunkDatagramHeader deserialize ( const Serialized_t & serializedDatagramHeader ); static constexpr uint8_t DATAGRAM_VERSION { 1U }; uint8_t datagramVersion { DATAGRAM_VERSION }; Endianess endianness { Endianess :: UNDEFINED }; uint16_t userHeaderId { 0xFFFF }; uint32_t userHeaderSize { 0U }; uint32_t userPayloadSize { 0U }; uint32_t userPayloadAlignment { 0U }; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/dds/iox_chunk_datagram_header.hpp"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#iceoryx_ddsddsiox_chunk_datagram_headerhpp","text":"","title":"iceoryx_dds/dds/iox_chunk_datagram_header.hpp"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#classes","text":"Name struct iox::dds::IoxChunkDatagramHeader The datagram header with chunk metadata for user-header and user-payload.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/iox__chunk__datagram__header_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP #define IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cstdint> namespace iox { namespace dds { enum class Endianess : uint8_t { UNDEFINED , LITTLE , BIG , MIXED , }; constexpr const char * EndianessString [] = { \"UNDEFINED\" , \"LITTLE\" , \"BIG\" , \"MIXED\" }; Endianess getEndianess (); struct IoxChunkDatagramHeader { using Serialized_t = iox :: cxx :: vector < uint8_t , 16U > ; static Serialized_t serialize ( const IoxChunkDatagramHeader & datagramHeader ); static IoxChunkDatagramHeader deserialize ( const Serialized_t & serializedDatagramHeader ); static constexpr uint8_t DATAGRAM_VERSION { 1U }; uint8_t datagramVersion { DATAGRAM_VERSION }; Endianess endianness { Endianess :: UNDEFINED }; uint16_t userHeaderId { 0xFFFF }; uint32_t userHeaderSize { 0U }; uint32_t userPayloadSize { 0U }; uint32_t userPayloadAlignment { 0U }; }; } // namespace dds } // namespace iox #endif // IOX_DDS_DDS_IOX_CHUNK_DATAGRAM_HEADER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/","text":"iceoryx_dds/gateway/iox_to_dds.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::dds Classes \ud83d\udd17 Name class iox::dds::Iceoryx2DDSGateway DDS Gateway implementation for the iceoryx to DDS direction. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_IOX_TO_DDS_HPP #define IOX_DDS_IOX_TO_DDS_HPP #include \"iceoryx_dds/dds/dds_types.hpp\" #include \"iceoryx_posh/gateway/channel.hpp\" #include \"iceoryx_posh/gateway/gateway_generic.hpp\" #include \"iceoryx_posh/popo/untyped_subscriber.hpp\" namespace iox { namespace dds { template < typename channel_t = gw :: Channel < popo :: UntypedSubscriber , dds :: data_writer_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class Iceoryx2DDSGateway : public gateway_t { public : Iceoryx2DDSGateway () noexcept ; void loadConfiguration ( const config :: GatewayConfig & config ) noexcept ; void discover ( const capro :: CaproMessage & msg ) noexcept ; void forward ( const channel_t & channel ) noexcept ; private : cxx :: expected < channel_t , gw :: GatewayError > setupChannel ( const capro :: ServiceDescription & service , const popo :: SubscriberOptions & subscriberOptions ) noexcept ; }; } // namespace dds } // namespace iox #include \"iceoryx_dds/internal/gateway/iox_to_dds.inl\" #endif // IOX_DDS_IOX_TO_DDS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_dds/gateway/iox_to_dds.hpp"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#iceoryx_ddsgatewayiox_to_ddshpp","text":"","title":"iceoryx_dds/gateway/iox_to_dds.hpp"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#namespaces","text":"Name iox iox::dds","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#classes","text":"Name class iox::dds::Iceoryx2DDSGateway DDS Gateway implementation for the iceoryx to DDS direction.","title":"Classes"},{"location":"API-reference/DDS-gateway/Files/iox__to__dds_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_DDS_IOX_TO_DDS_HPP #define IOX_DDS_IOX_TO_DDS_HPP #include \"iceoryx_dds/dds/dds_types.hpp\" #include \"iceoryx_posh/gateway/channel.hpp\" #include \"iceoryx_posh/gateway/gateway_generic.hpp\" #include \"iceoryx_posh/popo/untyped_subscriber.hpp\" namespace iox { namespace dds { template < typename channel_t = gw :: Channel < popo :: UntypedSubscriber , dds :: data_writer_t > , typename gateway_t = gw :: GatewayGeneric < channel_t >> class Iceoryx2DDSGateway : public gateway_t { public : Iceoryx2DDSGateway () noexcept ; void loadConfiguration ( const config :: GatewayConfig & config ) noexcept ; void discover ( const capro :: CaproMessage & msg ) noexcept ; void forward ( const channel_t & channel ) noexcept ; private : cxx :: expected < channel_t , gw :: GatewayError > setupChannel ( const capro :: ServiceDescription & service , const popo :: SubscriberOptions & subscriberOptions ) noexcept ; }; } // namespace dds } // namespace iox #include \"iceoryx_dds/internal/gateway/iox_to_dds.inl\" #endif // IOX_DDS_IOX_TO_DDS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox/","text":"iox \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::dds Updated on 18 December 2023 at 13:11:43 CET","title":"iox"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox/#iox","text":"","title":"iox"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox/#namespaces","text":"Name iox::dds Updated on 18 December 2023 at 13:11:43 CET","title":"Namespaces"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/","text":"iox::dds \ud83d\udd17 Classes \ud83d\udd17 Name class iox::dds::CycloneContext The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application. class iox::dds::CycloneDataReader Implementation of the DataReader abstraction using the cyclonedds implementation. class iox::dds::CycloneDataWriter Implementation of the DataWriter abstraction using the cyclonedds implementation. class iox::dds::DataReader Abstraction for DDS Data Readers. class iox::dds::DataWriter Abstraction for DDS Data Writers. class iox::dds::DDS2IceoryxGateway DDS Gateway implementation for the DDS to iceoryx direction. class iox::dds::Iceoryx2DDSGateway DDS Gateway implementation for the iceoryx to DDS direction. struct iox::dds::IoxChunkDatagramHeader The datagram header with chunk metadata for user-header and user-payload. Types \ud83d\udd17 Name enum uint8_t DataReaderError { NOT_CONNECTED, INVALID_DATAGRAM_HEADER_SIZE, INVALID_BUFFER_PARAMETER_FOR_USER_HEADER, INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD, INVALID_DATA, BUFFER_SIZE_MISMATCH} enum uint8_t Endianess { UNDEFINED, LITTLE, BIG, MIXED} the endianess of the serialized data Functions \ud83d\udd17 Name Endianess getEndianess () Detects the endianness of the system. Attributes \ud83d\udd17 Name constexpr const char * DataReaderErrorString constexpr units::Duration DISCOVERY_PERIOD constexpr units::Duration FORWARDING_PERIOD constexpr uint32_t SUBSCRIBER_CACHE_SIZE constexpr const char * EndianessString Types Documentation \ud83d\udd17 enum DataReaderError \ud83d\udd17 Enumerator Value Description NOT_CONNECTED INVALID_DATAGRAM_HEADER_SIZE INVALID_BUFFER_PARAMETER_FOR_USER_HEADER INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD INVALID_DATA BUFFER_SIZE_MISMATCH enum Endianess \ud83d\udd17 Enumerator Value Description UNDEFINED LITTLE BIG MIXED the endianess of the serialized data Functions Documentation \ud83d\udd17 function getEndianess \ud83d\udd17 Endianess getEndianess () Detects the endianness of the system. Attributes Documentation \ud83d\udd17 variable DataReaderErrorString \ud83d\udd17 constexpr const char * DataReaderErrorString = { \"NOT_CONNECTED\" , \"INVALID_DATAGRAM_HEADER_SIZE\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_HEADER\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD\" , \"INVALID_DATA\" , \"BUFFER_SIZE_MISMATCH\" }; variable DISCOVERY_PERIOD \ud83d\udd17 static constexpr units :: Duration DISCOVERY_PERIOD = 1000 _ms ; variable FORWARDING_PERIOD \ud83d\udd17 static constexpr units :: Duration FORWARDING_PERIOD = 50 _ms ; variable SUBSCRIBER_CACHE_SIZE \ud83d\udd17 static constexpr uint32_t SUBSCRIBER_CACHE_SIZE = 128u ; variable EndianessString \ud83d\udd17 constexpr const char * EndianessString = { \"UNDEFINED\" , \"LITTLE\" , \"BIG\" , \"MIXED\" }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::dds"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#ioxdds","text":"","title":"iox::dds"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#classes","text":"Name class iox::dds::CycloneContext The CycloneContext manages cyclone configurations and singleton artifacts shared throughout an application. class iox::dds::CycloneDataReader Implementation of the DataReader abstraction using the cyclonedds implementation. class iox::dds::CycloneDataWriter Implementation of the DataWriter abstraction using the cyclonedds implementation. class iox::dds::DataReader Abstraction for DDS Data Readers. class iox::dds::DataWriter Abstraction for DDS Data Writers. class iox::dds::DDS2IceoryxGateway DDS Gateway implementation for the DDS to iceoryx direction. class iox::dds::Iceoryx2DDSGateway DDS Gateway implementation for the iceoryx to DDS direction. struct iox::dds::IoxChunkDatagramHeader The datagram header with chunk metadata for user-header and user-payload.","title":"Classes"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#types","text":"Name enum uint8_t DataReaderError { NOT_CONNECTED, INVALID_DATAGRAM_HEADER_SIZE, INVALID_BUFFER_PARAMETER_FOR_USER_HEADER, INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD, INVALID_DATA, BUFFER_SIZE_MISMATCH} enum uint8_t Endianess { UNDEFINED, LITTLE, BIG, MIXED} the endianess of the serialized data","title":"Types"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#functions","text":"Name Endianess getEndianess () Detects the endianness of the system.","title":"Functions"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#attributes","text":"Name constexpr const char * DataReaderErrorString constexpr units::Duration DISCOVERY_PERIOD constexpr units::Duration FORWARDING_PERIOD constexpr uint32_t SUBSCRIBER_CACHE_SIZE constexpr const char * EndianessString","title":"Attributes"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#enum-datareadererror","text":"Enumerator Value Description NOT_CONNECTED INVALID_DATAGRAM_HEADER_SIZE INVALID_BUFFER_PARAMETER_FOR_USER_HEADER INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD INVALID_DATA BUFFER_SIZE_MISMATCH","title":"enum DataReaderError"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#enum-endianess","text":"Enumerator Value Description UNDEFINED LITTLE BIG MIXED the endianess of the serialized data","title":"enum Endianess"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#function-getendianess","text":"Endianess getEndianess () Detects the endianness of the system.","title":"function getEndianess"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-datareadererrorstring","text":"constexpr const char * DataReaderErrorString = { \"NOT_CONNECTED\" , \"INVALID_DATAGRAM_HEADER_SIZE\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_HEADER\" , \"INVALID_BUFFER_PARAMETER_FOR_USER_PAYLOAD\" , \"INVALID_DATA\" , \"BUFFER_SIZE_MISMATCH\" };","title":"variable DataReaderErrorString"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-discovery_period","text":"static constexpr units :: Duration DISCOVERY_PERIOD = 1000 _ms ;","title":"variable DISCOVERY_PERIOD"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-forwarding_period","text":"static constexpr units :: Duration FORWARDING_PERIOD = 50 _ms ;","title":"variable FORWARDING_PERIOD"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-subscriber_cache_size","text":"static constexpr uint32_t SUBSCRIBER_CACHE_SIZE = 128u ;","title":"variable SUBSCRIBER_CACHE_SIZE"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceiox_1_1dds/#variable-endianessstring","text":"constexpr const char * EndianessString = { \"UNDEFINED\" , \"LITTLE\" , \"BIG\" , \"MIXED\" }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable EndianessString"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceunits_1_1duration__literals/","text":"units::duration_literals \ud83d\udd17 Updated on 18 December 2023 at 13:11:43 CET","title":"units::duration_literals"},{"location":"API-reference/DDS-gateway/Namespaces/namespaceunits_1_1duration__literals/#unitsduration_literals","text":"Updated on 18 December 2023 at 13:11:43 CET","title":"units::duration_literals"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/","text":"iox_chunk_header_t \ud83d\udd17 handle of the chunk header #include <iceoryx_binding_c/types.h> Public Attributes \ud83d\udd17 Name uint8_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint8_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_chunk_header_t"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#iox_chunk_header_t","text":"handle of the chunk header #include <iceoryx_binding_c/types.h>","title":"iox_chunk_header_t"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#public-attributes","text":"Name uint8_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__chunk__header__t/#variable-do_not_touch_me","text":"uint8_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/","text":"iox_client_options_t \ud83d\udd17 options to be set for a client #include <iceoryx_binding_c/client.h> Public Attributes \ud83d\udd17 Name uint64_t responseQueueCapacity size of the response queue char nodeName name of the node the client belongs to bool connectOnCreate Indicates if the client should be connected when created. ENUM iox_QueueFullPolicy responseQueueFullPolicy Sets whether the server blocks when the client response queue is full. ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy Sets whether the client blocks when the server request queue is full. uint64_t initCheck this value will be set exclusively by iox_client_options_init and is not supposed to be modified otherwise Public Attributes Documentation \ud83d\udd17 variable responseQueueCapacity \ud83d\udd17 uint64_t responseQueueCapacity ; size of the response queue variable nodeName \ud83d\udd17 char nodeName ; name of the node the client belongs to variable connectOnCreate \ud83d\udd17 bool connectOnCreate ; Indicates if the client should be connected when created. variable responseQueueFullPolicy \ud83d\udd17 ENUM iox_QueueFullPolicy responseQueueFullPolicy ; Sets whether the server blocks when the client response queue is full. variable serverTooSlowPolicy \ud83d\udd17 ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy ; Sets whether the client blocks when the server request queue is full. variable initCheck \ud83d\udd17 uint64_t initCheck ; this value will be set exclusively by iox_client_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"iox_client_options_t"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#iox_client_options_t","text":"options to be set for a client #include <iceoryx_binding_c/client.h>","title":"iox_client_options_t"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#public-attributes","text":"Name uint64_t responseQueueCapacity size of the response queue char nodeName name of the node the client belongs to bool connectOnCreate Indicates if the client should be connected when created. ENUM iox_QueueFullPolicy responseQueueFullPolicy Sets whether the server blocks when the client response queue is full. ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy Sets whether the client blocks when the server request queue is full. uint64_t initCheck this value will be set exclusively by iox_client_options_init and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-responsequeuecapacity","text":"uint64_t responseQueueCapacity ; size of the response queue","title":"variable responseQueueCapacity"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-nodename","text":"char nodeName ; name of the node the client belongs to","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-connectoncreate","text":"bool connectOnCreate ; Indicates if the client should be connected when created.","title":"variable connectOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-responsequeuefullpolicy","text":"ENUM iox_QueueFullPolicy responseQueueFullPolicy ; Sets whether the server blocks when the client response queue is full.","title":"variable responseQueueFullPolicy"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-servertooslowpolicy","text":"ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy ; Sets whether the client blocks when the server request queue is full.","title":"variable serverTooSlowPolicy"},{"location":"API-reference/c-binding/Classes/structiox__client__options__t/#variable-initcheck","text":"uint64_t initCheck ; this value will be set exclusively by iox_client_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/","text":"iox_client_storage_t \ud83d\udd17 has exactly the size required to store the underlying object of iox_client_t #include <iceoryx_binding_c/types.h> Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_client_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#iox_client_storage_t","text":"has exactly the size required to store the underlying object of iox_client_t #include <iceoryx_binding_c/types.h>","title":"iox_client_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__client__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/","text":"iox_listener_storage_t \ud83d\udd17 Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_listener_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#iox_listener_storage_t","text":"","title":"iox_listener_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__listener__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/","text":"iox_pub_options_t \ud83d\udd17 options to be set for a publisher #include <iceoryx_binding_c/publisher.h> Public Attributes \ud83d\udd17 Name uint64_t historyCapacity Size of the history chunk queue. const char * nodeName Name of the node the publisher belongs to. bool offerOnCreate The option whether the publisher should already be offered when creating it. ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy describes whether a publisher blocks when subscriber queue is full uint64_t initCheck this value will be set exclusively by iox_pub_options_init and is not supposed to be modified otherwise Public Attributes Documentation \ud83d\udd17 variable historyCapacity \ud83d\udd17 uint64_t historyCapacity ; Size of the history chunk queue. variable nodeName \ud83d\udd17 const char * nodeName ; Name of the node the publisher belongs to. Note : nullptr indicates that the default node name is used variable offerOnCreate \ud83d\udd17 bool offerOnCreate ; The option whether the publisher should already be offered when creating it. variable subscriberTooSlowPolicy \ud83d\udd17 ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy ; describes whether a publisher blocks when subscriber queue is full variable initCheck \ud83d\udd17 uint64_t initCheck ; this value will be set exclusively by iox_pub_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"iox_pub_options_t"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#iox_pub_options_t","text":"options to be set for a publisher #include <iceoryx_binding_c/publisher.h>","title":"iox_pub_options_t"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#public-attributes","text":"Name uint64_t historyCapacity Size of the history chunk queue. const char * nodeName Name of the node the publisher belongs to. bool offerOnCreate The option whether the publisher should already be offered when creating it. ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy describes whether a publisher blocks when subscriber queue is full uint64_t initCheck this value will be set exclusively by iox_pub_options_init and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-historycapacity","text":"uint64_t historyCapacity ; Size of the history chunk queue.","title":"variable historyCapacity"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-nodename","text":"const char * nodeName ; Name of the node the publisher belongs to. Note : nullptr indicates that the default node name is used","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-offeroncreate","text":"bool offerOnCreate ; The option whether the publisher should already be offered when creating it.","title":"variable offerOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-subscribertooslowpolicy","text":"ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy ; describes whether a publisher blocks when subscriber queue is full","title":"variable subscriberTooSlowPolicy"},{"location":"API-reference/c-binding/Classes/structiox__pub__options__t/#variable-initcheck","text":"uint64_t initCheck ; this value will be set exclusively by iox_pub_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/","text":"iox_pub_storage_t \ud83d\udd17 Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_pub_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#iox_pub_storage_t","text":"","title":"iox_pub_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__pub__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/","text":"iox_server_options_t \ud83d\udd17 options to be set for a server #include <iceoryx_binding_c/server.h> Public Attributes \ud83d\udd17 Name uint64_t requestQueueCapacity size of the request queue char nodeName name of the node the server belongs to bool offerOnCreate Indicates if the server should be connected when created. ENUM iox_QueueFullPolicy requestQueueFullPolicy Sets whether the client blocks when the server request queue is full. ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy Sets whether the server blocks when the client response queue is full. uint64_t initCheck this value will be set exclusively by iox_server_options_init and is not supposed to be modified otherwise Public Attributes Documentation \ud83d\udd17 variable requestQueueCapacity \ud83d\udd17 uint64_t requestQueueCapacity ; size of the request queue variable nodeName \ud83d\udd17 char nodeName ; name of the node the server belongs to variable offerOnCreate \ud83d\udd17 bool offerOnCreate ; Indicates if the server should be connected when created. variable requestQueueFullPolicy \ud83d\udd17 ENUM iox_QueueFullPolicy requestQueueFullPolicy ; Sets whether the client blocks when the server request queue is full. variable clientTooSlowPolicy \ud83d\udd17 ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy ; Sets whether the server blocks when the client response queue is full. variable initCheck \ud83d\udd17 uint64_t initCheck ; this value will be set exclusively by iox_server_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"iox_server_options_t"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#iox_server_options_t","text":"options to be set for a server #include <iceoryx_binding_c/server.h>","title":"iox_server_options_t"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#public-attributes","text":"Name uint64_t requestQueueCapacity size of the request queue char nodeName name of the node the server belongs to bool offerOnCreate Indicates if the server should be connected when created. ENUM iox_QueueFullPolicy requestQueueFullPolicy Sets whether the client blocks when the server request queue is full. ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy Sets whether the server blocks when the client response queue is full. uint64_t initCheck this value will be set exclusively by iox_server_options_init and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-requestqueuecapacity","text":"uint64_t requestQueueCapacity ; size of the request queue","title":"variable requestQueueCapacity"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-nodename","text":"char nodeName ; name of the node the server belongs to","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-offeroncreate","text":"bool offerOnCreate ; Indicates if the server should be connected when created.","title":"variable offerOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-requestqueuefullpolicy","text":"ENUM iox_QueueFullPolicy requestQueueFullPolicy ; Sets whether the client blocks when the server request queue is full.","title":"variable requestQueueFullPolicy"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-clienttooslowpolicy","text":"ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy ; Sets whether the server blocks when the client response queue is full.","title":"variable clientTooSlowPolicy"},{"location":"API-reference/c-binding/Classes/structiox__server__options__t/#variable-initcheck","text":"uint64_t initCheck ; this value will be set exclusively by iox_server_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/","text":"iox_server_storage_t \ud83d\udd17 has exactly the size required to store the underlying object of iox_server_t #include <iceoryx_binding_c/types.h> Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_server_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#iox_server_storage_t","text":"has exactly the size required to store the underlying object of iox_server_t #include <iceoryx_binding_c/types.h>","title":"iox_server_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__server__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/","text":"iox_service_description_t \ud83d\udd17 Public Attributes \ud83d\udd17 Name char serviceString char instanceString char eventString Public Attributes Documentation \ud83d\udd17 variable serviceString \ud83d\udd17 char serviceString ; variable instanceString \ud83d\udd17 char instanceString ; variable eventString \ud83d\udd17 char eventString ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_service_description_t"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#iox_service_description_t","text":"","title":"iox_service_description_t"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#public-attributes","text":"Name char serviceString char instanceString char eventString","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#variable-servicestring","text":"char serviceString ;","title":"variable serviceString"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#variable-instancestring","text":"char instanceString ;","title":"variable instanceString"},{"location":"API-reference/c-binding/Classes/structiox__service__description__t/#variable-eventstring","text":"char eventString ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable eventString"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/","text":"iox_service_discovery_storage_t \ud83d\udd17 has exactly the size required to store the underlying object of iox_service_discovery_t #include <iceoryx_binding_c/types.h> Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_service_discovery_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#iox_service_discovery_storage_t","text":"has exactly the size required to store the underlying object of iox_service_discovery_t #include <iceoryx_binding_c/types.h>","title":"iox_service_discovery_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__service__discovery__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/","text":"iox_sub_options_t \ud83d\udd17 options to be set for a subscriber #include <iceoryx_binding_c/subscriber.h> Public Attributes \ud83d\udd17 Name uint64_t queueCapacity size of the history chunk queue uint64_t historyRequest number of chunks received after subscription if chunks are available const char * nodeName name of the node the subscriber belongs to bool subscribeOnCreate The option whether the subscriber shall try to subscribe when creating it. ENUM iox_QueueFullPolicy queueFullPolicy describes whether a publisher blocks when subscriber queue is full bool requirePublisherHistorySupport Indicates whether we require the publisher to have historyCapacity > 0. If true and the condition is not met (i.e. historyCapacity = 0), the subscriber will not be connected to the publisher. uint64_t initCheck this value will be set exclusively by iox_sub_options_init and is not supposed to be modified otherwise Public Attributes Documentation \ud83d\udd17 variable queueCapacity \ud83d\udd17 uint64_t queueCapacity ; size of the history chunk queue variable historyRequest \ud83d\udd17 uint64_t historyRequest ; number of chunks received after subscription if chunks are available variable nodeName \ud83d\udd17 const char * nodeName ; name of the node the subscriber belongs to Note : nullptr indicates that the default node name is used variable subscribeOnCreate \ud83d\udd17 bool subscribeOnCreate ; The option whether the subscriber shall try to subscribe when creating it. variable queueFullPolicy \ud83d\udd17 ENUM iox_QueueFullPolicy queueFullPolicy ; describes whether a publisher blocks when subscriber queue is full variable requirePublisherHistorySupport \ud83d\udd17 bool requirePublisherHistorySupport ; Indicates whether we require the publisher to have historyCapacity > 0. If true and the condition is not met (i.e. historyCapacity = 0), the subscriber will not be connected to the publisher. variable initCheck \ud83d\udd17 uint64_t initCheck ; this value will be set exclusively by iox_sub_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"iox_sub_options_t"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#iox_sub_options_t","text":"options to be set for a subscriber #include <iceoryx_binding_c/subscriber.h>","title":"iox_sub_options_t"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#public-attributes","text":"Name uint64_t queueCapacity size of the history chunk queue uint64_t historyRequest number of chunks received after subscription if chunks are available const char * nodeName name of the node the subscriber belongs to bool subscribeOnCreate The option whether the subscriber shall try to subscribe when creating it. ENUM iox_QueueFullPolicy queueFullPolicy describes whether a publisher blocks when subscriber queue is full bool requirePublisherHistorySupport Indicates whether we require the publisher to have historyCapacity > 0. If true and the condition is not met (i.e. historyCapacity = 0), the subscriber will not be connected to the publisher. uint64_t initCheck this value will be set exclusively by iox_sub_options_init and is not supposed to be modified otherwise","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-queuecapacity","text":"uint64_t queueCapacity ; size of the history chunk queue","title":"variable queueCapacity"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-historyrequest","text":"uint64_t historyRequest ; number of chunks received after subscription if chunks are available","title":"variable historyRequest"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-nodename","text":"const char * nodeName ; name of the node the subscriber belongs to Note : nullptr indicates that the default node name is used","title":"variable nodeName"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-subscribeoncreate","text":"bool subscribeOnCreate ; The option whether the subscriber shall try to subscribe when creating it.","title":"variable subscribeOnCreate"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-queuefullpolicy","text":"ENUM iox_QueueFullPolicy queueFullPolicy ; describes whether a publisher blocks when subscriber queue is full","title":"variable queueFullPolicy"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-requirepublisherhistorysupport","text":"bool requirePublisherHistorySupport ; Indicates whether we require the publisher to have historyCapacity > 0. If true and the condition is not met (i.e. historyCapacity = 0), the subscriber will not be connected to the publisher.","title":"variable requirePublisherHistorySupport"},{"location":"API-reference/c-binding/Classes/structiox__sub__options__t/#variable-initcheck","text":"uint64_t initCheck ; this value will be set exclusively by iox_sub_options_init and is not supposed to be modified otherwise Updated on 18 December 2023 at 13:11:43 CET","title":"variable initCheck"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/","text":"iox_sub_storage_t \ud83d\udd17 Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_sub_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#iox_sub_storage_t","text":"","title":"iox_sub_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__sub__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/","text":"iox_user_trigger_storage_t \ud83d\udd17 Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_user_trigger_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#iox_user_trigger_storage_t","text":"","title":"iox_user_trigger_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__user__trigger__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/","text":"iox_ws_storage_t \ud83d\udd17 More... #include <iceoryx_binding_c/types.h> Public Attributes \ud83d\udd17 Name uint64_t do_not_touch_me Detailed Description \ud83d\udd17 struct iox_ws_storage_t ; The issue iox-308: https://github.com/eclipse-iceoryx/iceoryx/issues/308 was created to explore other options then a magic number to create the structs of a specific size in C. The size and the alignment of all structs are verified by the binding c integration test iox_types_test Public Attributes Documentation \ud83d\udd17 variable do_not_touch_me \ud83d\udd17 uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox_ws_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#iox_ws_storage_t","text":"More... #include <iceoryx_binding_c/types.h>","title":"iox_ws_storage_t"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#public-attributes","text":"Name uint64_t do_not_touch_me","title":"Public Attributes"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#detailed-description","text":"struct iox_ws_storage_t ; The issue iox-308: https://github.com/eclipse-iceoryx/iceoryx/issues/308 was created to explore other options then a magic number to create the structs of a specific size in C. The size and the alignment of all structs are verified by the binding c integration test iox_types_test","title":"Detailed Description"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/c-binding/Classes/structiox__ws__storage__t/#variable-do_not_touch_me","text":"uint64_t do_not_touch_me ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable do_not_touch_me"},{"location":"API-reference/c-binding/Files/api_8h/","text":"iceoryx_binding_c/api.h \ud83d\udd17 Source code \ud83d\udd17 // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_API_H #define IOX_BINDING_C_API_H // Provides the complete iceoryx C API in one header. #include \"chunk.h\" #include \"client.h\" #include \"config.h\" #include \"enums.h\" #include \"listener.h\" #include \"log.h\" #include \"node.h\" #include \"notification_info.h\" #include \"publisher.h\" #include \"request_header.h\" #include \"response_header.h\" #include \"runtime.h\" #include \"server.h\" #include \"service_description.h\" #include \"service_discovery.h\" #include \"subscriber.h\" #include \"types.h\" #include \"user_trigger.h\" #include \"wait_set.h\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/api.h"},{"location":"API-reference/c-binding/Files/api_8h/#iceoryx_binding_capih","text":"","title":"iceoryx_binding_c/api.h"},{"location":"API-reference/c-binding/Files/api_8h/#source-code","text":"// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_API_H #define IOX_BINDING_C_API_H // Provides the complete iceoryx C API in one header. #include \"chunk.h\" #include \"client.h\" #include \"config.h\" #include \"enums.h\" #include \"listener.h\" #include \"log.h\" #include \"node.h\" #include \"notification_info.h\" #include \"publisher.h\" #include \"request_header.h\" #include \"response_header.h\" #include \"runtime.h\" #include \"server.h\" #include \"service_description.h\" #include \"service_discovery.h\" #include \"subscriber.h\" #include \"types.h\" #include \"user_trigger.h\" #include \"wait_set.h\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/chunk_8h/","text":"iceoryx_binding_c/chunk.h \ud83d\udd17 Functions \ud83d\udd17 Name void * iox_chunk_header_to_user_payload ( iox_chunk_header_t *const chunkHeader) gets the user-payload from the chunk-header const void * iox_chunk_header_to_user_payload_const (const iox_chunk_header_t *const chunkHeader) gets the const user-payload from the const chunk-header void * iox_chunk_header_to_user_header ( iox_chunk_header_t *const chunkHeader) gets the user-header from the chunk-header const void * iox_chunk_header_to_user_header_const (const iox_chunk_header_t *const chunkHeader) gets the const user-payload from the const chunk-header iox_chunk_header_t * iox_chunk_header_from_user_payload (void *const userPayload) gets the chunk-header from the user-payload const iox_chunk_header_t * iox_chunk_header_from_user_payload_const (const void *const userPayload) gets the const chunk-header from the const user-payload Functions Documentation \ud83d\udd17 function iox_chunk_header_to_user_payload \ud83d\udd17 void * iox_chunk_header_to_user_payload ( iox_chunk_header_t * const chunkHeader ) gets the user-payload from the chunk-header Parameters : chunkHeader pointer to the chunk-header Return : pointer to the user-payload function iox_chunk_header_to_user_payload_const \ud83d\udd17 const void * iox_chunk_header_to_user_payload_const ( const iox_chunk_header_t * const chunkHeader ) gets the const user-payload from the const chunk-header Parameters : chunkHeader const pointer to the chunk-header Return : const pointer to the user-payload function iox_chunk_header_to_user_header \ud83d\udd17 void * iox_chunk_header_to_user_header ( iox_chunk_header_t * const chunkHeader ) gets the user-header from the chunk-header Parameters : chunkHeader pointer to the chunk-header Return : pointer to the user-header function iox_chunk_header_to_user_header_const \ud83d\udd17 const void * iox_chunk_header_to_user_header_const ( const iox_chunk_header_t * const chunkHeader ) gets the const user-payload from the const chunk-header Parameters : chunkHeader const pointer to the chunk-header Return : const pointer to the user-header function iox_chunk_header_from_user_payload \ud83d\udd17 iox_chunk_header_t * iox_chunk_header_from_user_payload ( void * const userPayload ) gets the chunk-header from the user-payload Parameters : userPayload pointer to the user-payload Return : pointer to the chunk-header function iox_chunk_header_from_user_payload_const \ud83d\udd17 const iox_chunk_header_t * iox_chunk_header_from_user_payload_const ( const void * const userPayload ) gets the const chunk-header from the const user-payload Parameters : userPayload const pointer to the user-payload Return : const pointer to the chunk-header Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_CHUNK_H #define IOX_BINDING_C_CHUNK_H #include \"iceoryx_binding_c/types.h\" void * iox_chunk_header_to_user_payload ( iox_chunk_header_t * const chunkHeader ); const void * iox_chunk_header_to_user_payload_const ( const iox_chunk_header_t * const chunkHeader ); void * iox_chunk_header_to_user_header ( iox_chunk_header_t * const chunkHeader ); const void * iox_chunk_header_to_user_header_const ( const iox_chunk_header_t * const chunkHeader ); iox_chunk_header_t * iox_chunk_header_from_user_payload ( void * const userPayload ); const iox_chunk_header_t * iox_chunk_header_from_user_payload_const ( const void * const userPayload ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/chunk.h"},{"location":"API-reference/c-binding/Files/chunk_8h/#iceoryx_binding_cchunkh","text":"","title":"iceoryx_binding_c/chunk.h"},{"location":"API-reference/c-binding/Files/chunk_8h/#functions","text":"Name void * iox_chunk_header_to_user_payload ( iox_chunk_header_t *const chunkHeader) gets the user-payload from the chunk-header const void * iox_chunk_header_to_user_payload_const (const iox_chunk_header_t *const chunkHeader) gets the const user-payload from the const chunk-header void * iox_chunk_header_to_user_header ( iox_chunk_header_t *const chunkHeader) gets the user-header from the chunk-header const void * iox_chunk_header_to_user_header_const (const iox_chunk_header_t *const chunkHeader) gets the const user-payload from the const chunk-header iox_chunk_header_t * iox_chunk_header_from_user_payload (void *const userPayload) gets the chunk-header from the user-payload const iox_chunk_header_t * iox_chunk_header_from_user_payload_const (const void *const userPayload) gets the const chunk-header from the const user-payload","title":"Functions"},{"location":"API-reference/c-binding/Files/chunk_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_payload","text":"void * iox_chunk_header_to_user_payload ( iox_chunk_header_t * const chunkHeader ) gets the user-payload from the chunk-header Parameters : chunkHeader pointer to the chunk-header Return : pointer to the user-payload","title":"function iox_chunk_header_to_user_payload"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_payload_const","text":"const void * iox_chunk_header_to_user_payload_const ( const iox_chunk_header_t * const chunkHeader ) gets the const user-payload from the const chunk-header Parameters : chunkHeader const pointer to the chunk-header Return : const pointer to the user-payload","title":"function iox_chunk_header_to_user_payload_const"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_header","text":"void * iox_chunk_header_to_user_header ( iox_chunk_header_t * const chunkHeader ) gets the user-header from the chunk-header Parameters : chunkHeader pointer to the chunk-header Return : pointer to the user-header","title":"function iox_chunk_header_to_user_header"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_to_user_header_const","text":"const void * iox_chunk_header_to_user_header_const ( const iox_chunk_header_t * const chunkHeader ) gets the const user-payload from the const chunk-header Parameters : chunkHeader const pointer to the chunk-header Return : const pointer to the user-header","title":"function iox_chunk_header_to_user_header_const"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_from_user_payload","text":"iox_chunk_header_t * iox_chunk_header_from_user_payload ( void * const userPayload ) gets the chunk-header from the user-payload Parameters : userPayload pointer to the user-payload Return : pointer to the chunk-header","title":"function iox_chunk_header_from_user_payload"},{"location":"API-reference/c-binding/Files/chunk_8h/#function-iox_chunk_header_from_user_payload_const","text":"const iox_chunk_header_t * iox_chunk_header_from_user_payload_const ( const void * const userPayload ) gets the const chunk-header from the const user-payload Parameters : userPayload const pointer to the user-payload Return : const pointer to the chunk-header","title":"function iox_chunk_header_from_user_payload_const"},{"location":"API-reference/c-binding/Files/chunk_8h/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_CHUNK_H #define IOX_BINDING_C_CHUNK_H #include \"iceoryx_binding_c/types.h\" void * iox_chunk_header_to_user_payload ( iox_chunk_header_t * const chunkHeader ); const void * iox_chunk_header_to_user_payload_const ( const iox_chunk_header_t * const chunkHeader ); void * iox_chunk_header_to_user_header ( iox_chunk_header_t * const chunkHeader ); const void * iox_chunk_header_to_user_header_const ( const iox_chunk_header_t * const chunkHeader ); iox_chunk_header_t * iox_chunk_header_from_user_payload ( void * const userPayload ); const iox_chunk_header_t * iox_chunk_header_from_user_payload_const ( const void * const userPayload ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/client_8h/","text":"iceoryx_binding_c/client.h \ud83d\udd17 Classes \ud83d\udd17 Name struct iox_client_options_t options to be set for a client Types \ud83d\udd17 Name typedef CLASS UntypedClient * iox_client_t client handle Functions \ud83d\udd17 Name void iox_client_options_init ( iox_client_options_t * options) initialize client options to default values bool iox_client_options_is_initialized (const iox_client_options_t *const options) check whether the client options were initialized by iox_client_options_init iox_client_t iox_client_init ( iox_client_storage_t * self, const char const service, const char const instance, const char const event, const iox_client_options_t const options) creates a client handle void iox_client_deinit (iox_client_t const self) removes a client handle ENUM iox_AllocationResult iox_client_loan_request (iox_client_t const self, void **const payload, const uint32_t payloadSize) allocates a request in the shared memory ENUM iox_AllocationResult iox_client_loan_aligned_request (iox_client_t const self, void **const payload, const uint32_t payloadSize, const uint32_t payloadAlignment) allocates a request in the shared memory with a custom alignment for the user-payload void iox_client_release_request (iox_client_t const self, void *const payload) releases ownership of a previously allocated loaned request without sending it ENUM iox_ClientSendResult iox_client_send (iox_client_t const self, void *const payload) sends a previously loaned request void iox_client_connect (iox_client_t const self) connects to the service void iox_client_disconnect (iox_client_t const self) disconnects from the service ENUM iox_ConnectionState iox_client_get_connection_state (iox_client_t const self) what is the connection state? ENUM iox_ChunkReceiveResult iox_client_take_response (iox_client_t const self, const void **const payload) retrieve a received respone void iox_client_release_response (iox_client_t const self, const void *const payload) release a previously acquired response (via iox_client_take_response) void iox_client_release_queued_responses (iox_client_t const self) release all responses which are stored in the chunk queue bool iox_client_has_responses (iox_client_t const self) are new responses available? bool iox_client_has_missed_responses (iox_client_t const self) were responses missed? iox_service_description_t iox_client_get_service_description (iox_client_t const self) returns the service description of the client Types Documentation \ud83d\udd17 typedef iox_client_t \ud83d\udd17 typedef CLASS UntypedClient * iox_client_t ; client handle Functions Documentation \ud83d\udd17 function iox_client_options_init \ud83d\udd17 void iox_client_options_init ( iox_client_options_t * options ) initialize client options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. function iox_client_options_is_initialized \ud83d\udd17 bool iox_client_options_is_initialized ( const iox_client_options_t * const options ) check whether the client options were initialized by iox_client_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise function iox_client_init \ud83d\udd17 iox_client_t iox_client_init ( iox_client_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_client_options_t * const options ) creates a client handle Parameters : self pointer to preallocated memory of size = sizeof(iox_client_storage_t) service serviceString instance instanceString event eventString options client options set by the user, if it is a null pointer default options are used Return : handle of the client function iox_client_deinit \ud83d\udd17 void iox_client_deinit ( iox_client_t const self ) removes a client handle Parameters : self the handle which should be removed function iox_client_loan_request \ud83d\udd17 ENUM iox_AllocationResult iox_client_loan_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize ) allocates a request in the shared memory Parameters : self handle of the client payload pointer in which a pointer to the user-payload of the allocated chunk is stored payloadSize user-payload size of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error Note : for the user-payload alignment IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT is used for a custom user-payload alignment please use iox_client_loan_aligned_request function iox_client_loan_aligned_request \ud83d\udd17 ENUM iox_AllocationResult iox_client_loan_aligned_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ) allocates a request in the shared memory with a custom alignment for the user-payload Parameters : self handle of the client payload pointer in which a pointer to the user-payload of the allocated request is stored payloadSize user-payload size of the allocated request payloadAlignment user-payload alignment of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error function iox_client_release_request \ud83d\udd17 void iox_client_release_request ( iox_client_t const self , void * const payload ) releases ownership of a previously allocated loaned request without sending it Parameters : self handle of the client payload pointer to the user-payload of the loaned request which should be free'd function iox_client_send \ud83d\udd17 ENUM iox_ClientSendResult iox_client_send ( iox_client_t const self , void * const payload ) sends a previously loaned request Parameters : self handle of the client payload pointer to the user-payload of the request which should be send Return : on success it returns ClientSendResult_SUCCESS otherwise a value which describes the error function iox_client_connect \ud83d\udd17 void iox_client_connect ( iox_client_t const self ) connects to the service Parameters : self handle to the client function iox_client_disconnect \ud83d\udd17 void iox_client_disconnect ( iox_client_t const self ) disconnects from the service Parameters : self handle to the client function iox_client_get_connection_state \ud83d\udd17 ENUM iox_ConnectionState iox_client_get_connection_state ( iox_client_t const self ) what is the connection state? Parameters : self handle to the client Return : ConnectionState_CONNECTED when successfully connected otherwise an enum which describes the current state function iox_client_take_response \ud83d\udd17 ENUM iox_ChunkReceiveResult iox_client_take_response ( iox_client_t const self , const void ** const payload ) retrieve a received respone Parameters : self handle to the client payload pointer in which the pointer to the user-payload of the response is stored Return : if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error function iox_client_release_response \ud83d\udd17 void iox_client_release_response ( iox_client_t const self , const void * const payload ) release a previously acquired response (via iox_client_take_response) Parameters : self handle to the client payload pointer to the user-payload of chunk which should be released function iox_client_release_queued_responses \ud83d\udd17 void iox_client_release_queued_responses ( iox_client_t const self ) release all responses which are stored in the chunk queue Parameters : self handle to the client function iox_client_has_responses \ud83d\udd17 bool iox_client_has_responses ( iox_client_t const self ) are new responses available? Parameters : self handle to the client Return : true if there are responses, otherwise false function iox_client_has_missed_responses \ud83d\udd17 bool iox_client_has_missed_responses ( iox_client_t const self ) were responses missed? Parameters : self handle to the client Return : true if there are lost responses due to overflowing queue, otherwise false function iox_client_get_service_description \ud83d\udd17 iox_service_description_t iox_client_get_service_description ( iox_client_t const self ) returns the service description of the client Parameters : self handle to the client Return : the service description Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_CLIENT_H #define IOX_BINDING_C_CLIENT_H #include \"iceoryx_binding_c/config.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef CLASS UntypedClient * iox_client_t ; typedef struct { uint64_t responseQueueCapacity ; char nodeName [ IOX_CONFIG_NODE_NAME_SIZE ]; bool connectOnCreate ; ENUM iox_QueueFullPolicy responseQueueFullPolicy ; ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy ; uint64_t initCheck ; } iox_client_options_t ; void iox_client_options_init ( iox_client_options_t * options ); bool iox_client_options_is_initialized ( const iox_client_options_t * const options ); iox_client_t iox_client_init ( iox_client_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_client_options_t * const options ); void iox_client_deinit ( iox_client_t const self ); ENUM iox_AllocationResult iox_client_loan_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize ); ENUM iox_AllocationResult iox_client_loan_aligned_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ); void iox_client_release_request ( iox_client_t const self , void * const payload ); ENUM iox_ClientSendResult iox_client_send ( iox_client_t const self , void * const payload ); void iox_client_connect ( iox_client_t const self ); void iox_client_disconnect ( iox_client_t const self ); ENUM iox_ConnectionState iox_client_get_connection_state ( iox_client_t const self ); ENUM iox_ChunkReceiveResult iox_client_take_response ( iox_client_t const self , const void ** const payload ); void iox_client_release_response ( iox_client_t const self , const void * const payload ); void iox_client_release_queued_responses ( iox_client_t const self ); bool iox_client_has_responses ( iox_client_t const self ); bool iox_client_has_missed_responses ( iox_client_t const self ); iox_service_description_t iox_client_get_service_description ( iox_client_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/client.h"},{"location":"API-reference/c-binding/Files/client_8h/#iceoryx_binding_cclienth","text":"","title":"iceoryx_binding_c/client.h"},{"location":"API-reference/c-binding/Files/client_8h/#classes","text":"Name struct iox_client_options_t options to be set for a client","title":"Classes"},{"location":"API-reference/c-binding/Files/client_8h/#types","text":"Name typedef CLASS UntypedClient * iox_client_t client handle","title":"Types"},{"location":"API-reference/c-binding/Files/client_8h/#functions","text":"Name void iox_client_options_init ( iox_client_options_t * options) initialize client options to default values bool iox_client_options_is_initialized (const iox_client_options_t *const options) check whether the client options were initialized by iox_client_options_init iox_client_t iox_client_init ( iox_client_storage_t * self, const char const service, const char const instance, const char const event, const iox_client_options_t const options) creates a client handle void iox_client_deinit (iox_client_t const self) removes a client handle ENUM iox_AllocationResult iox_client_loan_request (iox_client_t const self, void **const payload, const uint32_t payloadSize) allocates a request in the shared memory ENUM iox_AllocationResult iox_client_loan_aligned_request (iox_client_t const self, void **const payload, const uint32_t payloadSize, const uint32_t payloadAlignment) allocates a request in the shared memory with a custom alignment for the user-payload void iox_client_release_request (iox_client_t const self, void *const payload) releases ownership of a previously allocated loaned request without sending it ENUM iox_ClientSendResult iox_client_send (iox_client_t const self, void *const payload) sends a previously loaned request void iox_client_connect (iox_client_t const self) connects to the service void iox_client_disconnect (iox_client_t const self) disconnects from the service ENUM iox_ConnectionState iox_client_get_connection_state (iox_client_t const self) what is the connection state? ENUM iox_ChunkReceiveResult iox_client_take_response (iox_client_t const self, const void **const payload) retrieve a received respone void iox_client_release_response (iox_client_t const self, const void *const payload) release a previously acquired response (via iox_client_take_response) void iox_client_release_queued_responses (iox_client_t const self) release all responses which are stored in the chunk queue bool iox_client_has_responses (iox_client_t const self) are new responses available? bool iox_client_has_missed_responses (iox_client_t const self) were responses missed? iox_service_description_t iox_client_get_service_description (iox_client_t const self) returns the service description of the client","title":"Functions"},{"location":"API-reference/c-binding/Files/client_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/client_8h/#typedef-iox_client_t","text":"typedef CLASS UntypedClient * iox_client_t ; client handle","title":"typedef iox_client_t"},{"location":"API-reference/c-binding/Files/client_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_options_init","text":"void iox_client_options_init ( iox_client_options_t * options ) initialize client options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future.","title":"function iox_client_options_init"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_options_is_initialized","text":"bool iox_client_options_is_initialized ( const iox_client_options_t * const options ) check whether the client options were initialized by iox_client_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise","title":"function iox_client_options_is_initialized"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_init","text":"iox_client_t iox_client_init ( iox_client_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_client_options_t * const options ) creates a client handle Parameters : self pointer to preallocated memory of size = sizeof(iox_client_storage_t) service serviceString instance instanceString event eventString options client options set by the user, if it is a null pointer default options are used Return : handle of the client","title":"function iox_client_init"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_deinit","text":"void iox_client_deinit ( iox_client_t const self ) removes a client handle Parameters : self the handle which should be removed","title":"function iox_client_deinit"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_loan_request","text":"ENUM iox_AllocationResult iox_client_loan_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize ) allocates a request in the shared memory Parameters : self handle of the client payload pointer in which a pointer to the user-payload of the allocated chunk is stored payloadSize user-payload size of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error Note : for the user-payload alignment IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT is used for a custom user-payload alignment please use iox_client_loan_aligned_request","title":"function iox_client_loan_request"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_loan_aligned_request","text":"ENUM iox_AllocationResult iox_client_loan_aligned_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ) allocates a request in the shared memory with a custom alignment for the user-payload Parameters : self handle of the client payload pointer in which a pointer to the user-payload of the allocated request is stored payloadSize user-payload size of the allocated request payloadAlignment user-payload alignment of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error","title":"function iox_client_loan_aligned_request"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_release_request","text":"void iox_client_release_request ( iox_client_t const self , void * const payload ) releases ownership of a previously allocated loaned request without sending it Parameters : self handle of the client payload pointer to the user-payload of the loaned request which should be free'd","title":"function iox_client_release_request"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_send","text":"ENUM iox_ClientSendResult iox_client_send ( iox_client_t const self , void * const payload ) sends a previously loaned request Parameters : self handle of the client payload pointer to the user-payload of the request which should be send Return : on success it returns ClientSendResult_SUCCESS otherwise a value which describes the error","title":"function iox_client_send"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_connect","text":"void iox_client_connect ( iox_client_t const self ) connects to the service Parameters : self handle to the client","title":"function iox_client_connect"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_disconnect","text":"void iox_client_disconnect ( iox_client_t const self ) disconnects from the service Parameters : self handle to the client","title":"function iox_client_disconnect"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_get_connection_state","text":"ENUM iox_ConnectionState iox_client_get_connection_state ( iox_client_t const self ) what is the connection state? Parameters : self handle to the client Return : ConnectionState_CONNECTED when successfully connected otherwise an enum which describes the current state","title":"function iox_client_get_connection_state"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_take_response","text":"ENUM iox_ChunkReceiveResult iox_client_take_response ( iox_client_t const self , const void ** const payload ) retrieve a received respone Parameters : self handle to the client payload pointer in which the pointer to the user-payload of the response is stored Return : if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error","title":"function iox_client_take_response"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_release_response","text":"void iox_client_release_response ( iox_client_t const self , const void * const payload ) release a previously acquired response (via iox_client_take_response) Parameters : self handle to the client payload pointer to the user-payload of chunk which should be released","title":"function iox_client_release_response"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_release_queued_responses","text":"void iox_client_release_queued_responses ( iox_client_t const self ) release all responses which are stored in the chunk queue Parameters : self handle to the client","title":"function iox_client_release_queued_responses"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_has_responses","text":"bool iox_client_has_responses ( iox_client_t const self ) are new responses available? Parameters : self handle to the client Return : true if there are responses, otherwise false","title":"function iox_client_has_responses"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_has_missed_responses","text":"bool iox_client_has_missed_responses ( iox_client_t const self ) were responses missed? Parameters : self handle to the client Return : true if there are lost responses due to overflowing queue, otherwise false","title":"function iox_client_has_missed_responses"},{"location":"API-reference/c-binding/Files/client_8h/#function-iox_client_get_service_description","text":"iox_service_description_t iox_client_get_service_description ( iox_client_t const self ) returns the service description of the client Parameters : self handle to the client Return : the service description","title":"function iox_client_get_service_description"},{"location":"API-reference/c-binding/Files/client_8h/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_CLIENT_H #define IOX_BINDING_C_CLIENT_H #include \"iceoryx_binding_c/config.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef CLASS UntypedClient * iox_client_t ; typedef struct { uint64_t responseQueueCapacity ; char nodeName [ IOX_CONFIG_NODE_NAME_SIZE ]; bool connectOnCreate ; ENUM iox_QueueFullPolicy responseQueueFullPolicy ; ENUM iox_ConsumerTooSlowPolicy serverTooSlowPolicy ; uint64_t initCheck ; } iox_client_options_t ; void iox_client_options_init ( iox_client_options_t * options ); bool iox_client_options_is_initialized ( const iox_client_options_t * const options ); iox_client_t iox_client_init ( iox_client_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_client_options_t * const options ); void iox_client_deinit ( iox_client_t const self ); ENUM iox_AllocationResult iox_client_loan_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize ); ENUM iox_AllocationResult iox_client_loan_aligned_request ( iox_client_t const self , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ); void iox_client_release_request ( iox_client_t const self , void * const payload ); ENUM iox_ClientSendResult iox_client_send ( iox_client_t const self , void * const payload ); void iox_client_connect ( iox_client_t const self ); void iox_client_disconnect ( iox_client_t const self ); ENUM iox_ConnectionState iox_client_get_connection_state ( iox_client_t const self ); ENUM iox_ChunkReceiveResult iox_client_take_response ( iox_client_t const self , const void ** const payload ); void iox_client_release_response ( iox_client_t const self , const void * const payload ); void iox_client_release_queued_responses ( iox_client_t const self ); bool iox_client_has_responses ( iox_client_t const self ); bool iox_client_has_missed_responses ( iox_client_t const self ); iox_service_description_t iox_client_get_service_description ( iox_client_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/config_8h/","text":"iceoryx_binding_c/config.h \ud83d\udd17 Functions \ud83d\udd17 Name uint32_t iox_cfg_max_publishers (void ) returns maximum supported amount of publishers uint32_t iox_cfg_max_subscribers_per_publisher (void ) returns maximum amount of subscribers which can be subscribed to one publisher uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously (void ) returns maximum amount of samples a publisher can acquire at the same time with loan uint64_t iox_cfg_max_publisher_history (void ) returns maximum history size for a publisher (e.g. samples which are hold back so uint32_t iox_cfg_max_subscribers (void ) returns maximum supported amount of subscribers uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously (void ) returns the maximum amount of samples which a subscriber can hold without releasing them uint32_t iox_cfg_max_subscriber_queue_capacity (void ) returns the maximum subscriber queue capacity which is used when the publisher delivers samples to the subscriber if the queue capacity is reached new samples will discard old samples uint32_t iox_cfg_max_number_of_condition_variables (void ) returns the maximum supported amount of condition variables. this determines how many listeners and waitsets can be used in one iceoryx system uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable (void ) returns the maximum supported amount of notifiers per condition variable. this determines how many attachments a listener or waitset can have uint32_t iox_cfg_max_number_of_attachments_per_waitset (void ) returns the maximum amount of attachments per waitset uint32_t iox_cfg_max_number_of_events_per_listener (void ) returns the maximum amount of evens per listener uint32_t iox_cfg_max_number_of_mempools (void ) returns the maximum amount of mempools for roudi. restricts also the number of mempools in the roudi config file uint32_t iox_cfg_max_shm_segments (void ) returns the maximum number of shared memory segments. restricts also the number of configurable segments in the roudi config file uint32_t iox_cfg_max_number_of_memory_provider (void ) returns the maximum supported amount of shared memory providers uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider (void ) returns the maximum supported amount of memory blocks per shared memory provider uint32_t iox_cfg_chunk_default_user_payload_alignment (void ) returns the alignment of the user payload when it is not set explicitly uint32_t iox_cfg_no_user_header_size (void ) returns the size of the user header when no user header is requested by the user uint32_t iox_cfg_no_user_header_alignment (void ) returns the alignment of the user header when no user header is requested by the user uint32_t iox_cfg_max_process_number (void ) returns the maximum supported amount of processes which can register at roudi by initializing the posh runtime uint32_t iox_cfg_service_registry_capacity (void ) returns the maximum number of services that are supported byt the service registry uint32_t iox_cfg_max_findservice_result_size (void ) returns the maximum number of services a findservice call can return uint32_t iox_cfg_max_runtime_name_length (void ) returns the maximum runtime name length Defines \ud83d\udd17 Name IOX_CONFIG_NODE_NAME_SIZE the maximum size of a node name string + \\0 terminator IOX_CONFIG_SERVICE_STRING_SIZE the maximum size of a service description string identifier + \\0 terminator Functions Documentation \ud83d\udd17 function iox_cfg_max_publishers \ud83d\udd17 uint32_t iox_cfg_max_publishers ( void ) returns maximum supported amount of publishers function iox_cfg_max_subscribers_per_publisher \ud83d\udd17 uint32_t iox_cfg_max_subscribers_per_publisher ( void ) returns maximum amount of subscribers which can be subscribed to one publisher function iox_cfg_max_chunks_allocated_per_publisher_simultaneously \ud83d\udd17 uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously ( void ) returns maximum amount of samples a publisher can acquire at the same time with loan function iox_cfg_max_publisher_history \ud83d\udd17 uint64_t iox_cfg_max_publisher_history ( void ) returns maximum history size for a publisher (e.g. samples which are hold back so function iox_cfg_max_subscribers \ud83d\udd17 uint32_t iox_cfg_max_subscribers ( void ) returns maximum supported amount of subscribers function iox_cfg_max_chunks_held_per_subscriber_simultaneously \ud83d\udd17 uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously ( void ) returns the maximum amount of samples which a subscriber can hold without releasing them function iox_cfg_max_subscriber_queue_capacity \ud83d\udd17 uint32_t iox_cfg_max_subscriber_queue_capacity ( void ) returns the maximum subscriber queue capacity which is used when the publisher delivers samples to the subscriber if the queue capacity is reached new samples will discard old samples function iox_cfg_max_number_of_condition_variables \ud83d\udd17 uint32_t iox_cfg_max_number_of_condition_variables ( void ) returns the maximum supported amount of condition variables. this determines how many listeners and waitsets can be used in one iceoryx system function iox_cfg_max_number_of_notifiers_per_condition_variable \ud83d\udd17 uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable ( void ) returns the maximum supported amount of notifiers per condition variable. this determines how many attachments a listener or waitset can have function iox_cfg_max_number_of_attachments_per_waitset \ud83d\udd17 uint32_t iox_cfg_max_number_of_attachments_per_waitset ( void ) returns the maximum amount of attachments per waitset Note : is less or equal to iox_cfg_max_number_of_notifiers_per_condition_variable function iox_cfg_max_number_of_events_per_listener \ud83d\udd17 uint32_t iox_cfg_max_number_of_events_per_listener ( void ) returns the maximum amount of evens per listener Note : is less or equal to iox_cfg_max_number_of_notifiers_per_condition_variable function iox_cfg_max_number_of_mempools \ud83d\udd17 uint32_t iox_cfg_max_number_of_mempools ( void ) returns the maximum amount of mempools for roudi. restricts also the number of mempools in the roudi config file function iox_cfg_max_shm_segments \ud83d\udd17 uint32_t iox_cfg_max_shm_segments ( void ) returns the maximum number of shared memory segments. restricts also the number of configurable segments in the roudi config file function iox_cfg_max_number_of_memory_provider \ud83d\udd17 uint32_t iox_cfg_max_number_of_memory_provider ( void ) returns the maximum supported amount of shared memory providers function iox_cfg_max_number_of_memory_blocks_per_memory_provider \ud83d\udd17 uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider ( void ) returns the maximum supported amount of memory blocks per shared memory provider function iox_cfg_chunk_default_user_payload_alignment \ud83d\udd17 uint32_t iox_cfg_chunk_default_user_payload_alignment ( void ) returns the alignment of the user payload when it is not set explicitly function iox_cfg_no_user_header_size \ud83d\udd17 uint32_t iox_cfg_no_user_header_size ( void ) returns the size of the user header when no user header is requested by the user function iox_cfg_no_user_header_alignment \ud83d\udd17 uint32_t iox_cfg_no_user_header_alignment ( void ) returns the alignment of the user header when no user header is requested by the user function iox_cfg_max_process_number \ud83d\udd17 uint32_t iox_cfg_max_process_number ( void ) returns the maximum supported amount of processes which can register at roudi by initializing the posh runtime function iox_cfg_service_registry_capacity \ud83d\udd17 uint32_t iox_cfg_service_registry_capacity ( void ) returns the maximum number of services that are supported byt the service registry function iox_cfg_max_findservice_result_size \ud83d\udd17 uint32_t iox_cfg_max_findservice_result_size ( void ) returns the maximum number of services a findservice call can return function iox_cfg_max_runtime_name_length \ud83d\udd17 uint32_t iox_cfg_max_runtime_name_length ( void ) returns the maximum runtime name length Macro Documentation \ud83d\udd17 define IOX_CONFIG_NODE_NAME_SIZE \ud83d\udd17 #define IOX_CONFIG_NODE_NAME_SIZE 101 the maximum size of a node name string + \\0 terminator define IOX_CONFIG_SERVICE_STRING_SIZE \ud83d\udd17 #define IOX_CONFIG_SERVICE_STRING_SIZE 101 the maximum size of a service description string identifier + \\0 terminator Source code \ud83d\udd17 // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_CONFIG_H #define IOX_BINDING_C_CONFIG_H #include <stdint.h> uint32_t iox_cfg_max_publishers ( void ); uint32_t iox_cfg_max_subscribers_per_publisher ( void ); uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously ( void ); // that new subscribers can acquire past data) uint64_t iox_cfg_max_publisher_history ( void ); uint32_t iox_cfg_max_subscribers ( void ); uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously ( void ); uint32_t iox_cfg_max_subscriber_queue_capacity ( void ); uint32_t iox_cfg_max_number_of_condition_variables ( void ); uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable ( void ); uint32_t iox_cfg_max_number_of_attachments_per_waitset ( void ); uint32_t iox_cfg_max_number_of_events_per_listener ( void ); uint32_t iox_cfg_max_number_of_mempools ( void ); uint32_t iox_cfg_max_shm_segments ( void ); uint32_t iox_cfg_max_number_of_memory_provider ( void ); uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider ( void ); uint32_t iox_cfg_chunk_default_user_payload_alignment ( void ); uint32_t iox_cfg_no_user_header_size ( void ); uint32_t iox_cfg_no_user_header_alignment ( void ); uint32_t iox_cfg_max_process_number ( void ); uint32_t iox_cfg_service_registry_capacity ( void ); uint32_t iox_cfg_max_findservice_result_size ( void ); uint32_t iox_cfg_max_runtime_name_length ( void ); #define IOX_CONFIG_NODE_NAME_SIZE 101 #define IOX_CONFIG_SERVICE_STRING_SIZE 101 #endif // IOX_BINDING_C_CONFIG_H Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/config.h"},{"location":"API-reference/c-binding/Files/config_8h/#iceoryx_binding_cconfigh","text":"","title":"iceoryx_binding_c/config.h"},{"location":"API-reference/c-binding/Files/config_8h/#functions","text":"Name uint32_t iox_cfg_max_publishers (void ) returns maximum supported amount of publishers uint32_t iox_cfg_max_subscribers_per_publisher (void ) returns maximum amount of subscribers which can be subscribed to one publisher uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously (void ) returns maximum amount of samples a publisher can acquire at the same time with loan uint64_t iox_cfg_max_publisher_history (void ) returns maximum history size for a publisher (e.g. samples which are hold back so uint32_t iox_cfg_max_subscribers (void ) returns maximum supported amount of subscribers uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously (void ) returns the maximum amount of samples which a subscriber can hold without releasing them uint32_t iox_cfg_max_subscriber_queue_capacity (void ) returns the maximum subscriber queue capacity which is used when the publisher delivers samples to the subscriber if the queue capacity is reached new samples will discard old samples uint32_t iox_cfg_max_number_of_condition_variables (void ) returns the maximum supported amount of condition variables. this determines how many listeners and waitsets can be used in one iceoryx system uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable (void ) returns the maximum supported amount of notifiers per condition variable. this determines how many attachments a listener or waitset can have uint32_t iox_cfg_max_number_of_attachments_per_waitset (void ) returns the maximum amount of attachments per waitset uint32_t iox_cfg_max_number_of_events_per_listener (void ) returns the maximum amount of evens per listener uint32_t iox_cfg_max_number_of_mempools (void ) returns the maximum amount of mempools for roudi. restricts also the number of mempools in the roudi config file uint32_t iox_cfg_max_shm_segments (void ) returns the maximum number of shared memory segments. restricts also the number of configurable segments in the roudi config file uint32_t iox_cfg_max_number_of_memory_provider (void ) returns the maximum supported amount of shared memory providers uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider (void ) returns the maximum supported amount of memory blocks per shared memory provider uint32_t iox_cfg_chunk_default_user_payload_alignment (void ) returns the alignment of the user payload when it is not set explicitly uint32_t iox_cfg_no_user_header_size (void ) returns the size of the user header when no user header is requested by the user uint32_t iox_cfg_no_user_header_alignment (void ) returns the alignment of the user header when no user header is requested by the user uint32_t iox_cfg_max_process_number (void ) returns the maximum supported amount of processes which can register at roudi by initializing the posh runtime uint32_t iox_cfg_service_registry_capacity (void ) returns the maximum number of services that are supported byt the service registry uint32_t iox_cfg_max_findservice_result_size (void ) returns the maximum number of services a findservice call can return uint32_t iox_cfg_max_runtime_name_length (void ) returns the maximum runtime name length","title":"Functions"},{"location":"API-reference/c-binding/Files/config_8h/#defines","text":"Name IOX_CONFIG_NODE_NAME_SIZE the maximum size of a node name string + \\0 terminator IOX_CONFIG_SERVICE_STRING_SIZE the maximum size of a service description string identifier + \\0 terminator","title":"Defines"},{"location":"API-reference/c-binding/Files/config_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_publishers","text":"uint32_t iox_cfg_max_publishers ( void ) returns maximum supported amount of publishers","title":"function iox_cfg_max_publishers"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_subscribers_per_publisher","text":"uint32_t iox_cfg_max_subscribers_per_publisher ( void ) returns maximum amount of subscribers which can be subscribed to one publisher","title":"function iox_cfg_max_subscribers_per_publisher"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_chunks_allocated_per_publisher_simultaneously","text":"uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously ( void ) returns maximum amount of samples a publisher can acquire at the same time with loan","title":"function iox_cfg_max_chunks_allocated_per_publisher_simultaneously"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_publisher_history","text":"uint64_t iox_cfg_max_publisher_history ( void ) returns maximum history size for a publisher (e.g. samples which are hold back so","title":"function iox_cfg_max_publisher_history"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_subscribers","text":"uint32_t iox_cfg_max_subscribers ( void ) returns maximum supported amount of subscribers","title":"function iox_cfg_max_subscribers"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_chunks_held_per_subscriber_simultaneously","text":"uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously ( void ) returns the maximum amount of samples which a subscriber can hold without releasing them","title":"function iox_cfg_max_chunks_held_per_subscriber_simultaneously"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_subscriber_queue_capacity","text":"uint32_t iox_cfg_max_subscriber_queue_capacity ( void ) returns the maximum subscriber queue capacity which is used when the publisher delivers samples to the subscriber if the queue capacity is reached new samples will discard old samples","title":"function iox_cfg_max_subscriber_queue_capacity"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_condition_variables","text":"uint32_t iox_cfg_max_number_of_condition_variables ( void ) returns the maximum supported amount of condition variables. this determines how many listeners and waitsets can be used in one iceoryx system","title":"function iox_cfg_max_number_of_condition_variables"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_notifiers_per_condition_variable","text":"uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable ( void ) returns the maximum supported amount of notifiers per condition variable. this determines how many attachments a listener or waitset can have","title":"function iox_cfg_max_number_of_notifiers_per_condition_variable"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_attachments_per_waitset","text":"uint32_t iox_cfg_max_number_of_attachments_per_waitset ( void ) returns the maximum amount of attachments per waitset Note : is less or equal to iox_cfg_max_number_of_notifiers_per_condition_variable","title":"function iox_cfg_max_number_of_attachments_per_waitset"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_events_per_listener","text":"uint32_t iox_cfg_max_number_of_events_per_listener ( void ) returns the maximum amount of evens per listener Note : is less or equal to iox_cfg_max_number_of_notifiers_per_condition_variable","title":"function iox_cfg_max_number_of_events_per_listener"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_mempools","text":"uint32_t iox_cfg_max_number_of_mempools ( void ) returns the maximum amount of mempools for roudi. restricts also the number of mempools in the roudi config file","title":"function iox_cfg_max_number_of_mempools"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_shm_segments","text":"uint32_t iox_cfg_max_shm_segments ( void ) returns the maximum number of shared memory segments. restricts also the number of configurable segments in the roudi config file","title":"function iox_cfg_max_shm_segments"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_memory_provider","text":"uint32_t iox_cfg_max_number_of_memory_provider ( void ) returns the maximum supported amount of shared memory providers","title":"function iox_cfg_max_number_of_memory_provider"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_number_of_memory_blocks_per_memory_provider","text":"uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider ( void ) returns the maximum supported amount of memory blocks per shared memory provider","title":"function iox_cfg_max_number_of_memory_blocks_per_memory_provider"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_chunk_default_user_payload_alignment","text":"uint32_t iox_cfg_chunk_default_user_payload_alignment ( void ) returns the alignment of the user payload when it is not set explicitly","title":"function iox_cfg_chunk_default_user_payload_alignment"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_no_user_header_size","text":"uint32_t iox_cfg_no_user_header_size ( void ) returns the size of the user header when no user header is requested by the user","title":"function iox_cfg_no_user_header_size"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_no_user_header_alignment","text":"uint32_t iox_cfg_no_user_header_alignment ( void ) returns the alignment of the user header when no user header is requested by the user","title":"function iox_cfg_no_user_header_alignment"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_process_number","text":"uint32_t iox_cfg_max_process_number ( void ) returns the maximum supported amount of processes which can register at roudi by initializing the posh runtime","title":"function iox_cfg_max_process_number"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_service_registry_capacity","text":"uint32_t iox_cfg_service_registry_capacity ( void ) returns the maximum number of services that are supported byt the service registry","title":"function iox_cfg_service_registry_capacity"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_findservice_result_size","text":"uint32_t iox_cfg_max_findservice_result_size ( void ) returns the maximum number of services a findservice call can return","title":"function iox_cfg_max_findservice_result_size"},{"location":"API-reference/c-binding/Files/config_8h/#function-iox_cfg_max_runtime_name_length","text":"uint32_t iox_cfg_max_runtime_name_length ( void ) returns the maximum runtime name length","title":"function iox_cfg_max_runtime_name_length"},{"location":"API-reference/c-binding/Files/config_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/c-binding/Files/config_8h/#define-iox_config_node_name_size","text":"#define IOX_CONFIG_NODE_NAME_SIZE 101 the maximum size of a node name string + \\0 terminator","title":"define IOX_CONFIG_NODE_NAME_SIZE"},{"location":"API-reference/c-binding/Files/config_8h/#define-iox_config_service_string_size","text":"#define IOX_CONFIG_SERVICE_STRING_SIZE 101 the maximum size of a service description string identifier + \\0 terminator","title":"define IOX_CONFIG_SERVICE_STRING_SIZE"},{"location":"API-reference/c-binding/Files/config_8h/#source-code","text":"// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_CONFIG_H #define IOX_BINDING_C_CONFIG_H #include <stdint.h> uint32_t iox_cfg_max_publishers ( void ); uint32_t iox_cfg_max_subscribers_per_publisher ( void ); uint32_t iox_cfg_max_chunks_allocated_per_publisher_simultaneously ( void ); // that new subscribers can acquire past data) uint64_t iox_cfg_max_publisher_history ( void ); uint32_t iox_cfg_max_subscribers ( void ); uint32_t iox_cfg_max_chunks_held_per_subscriber_simultaneously ( void ); uint32_t iox_cfg_max_subscriber_queue_capacity ( void ); uint32_t iox_cfg_max_number_of_condition_variables ( void ); uint32_t iox_cfg_max_number_of_notifiers_per_condition_variable ( void ); uint32_t iox_cfg_max_number_of_attachments_per_waitset ( void ); uint32_t iox_cfg_max_number_of_events_per_listener ( void ); uint32_t iox_cfg_max_number_of_mempools ( void ); uint32_t iox_cfg_max_shm_segments ( void ); uint32_t iox_cfg_max_number_of_memory_provider ( void ); uint32_t iox_cfg_max_number_of_memory_blocks_per_memory_provider ( void ); uint32_t iox_cfg_chunk_default_user_payload_alignment ( void ); uint32_t iox_cfg_no_user_header_size ( void ); uint32_t iox_cfg_no_user_header_alignment ( void ); uint32_t iox_cfg_max_process_number ( void ); uint32_t iox_cfg_service_registry_capacity ( void ); uint32_t iox_cfg_max_findservice_result_size ( void ); uint32_t iox_cfg_max_runtime_name_length ( void ); #define IOX_CONFIG_NODE_NAME_SIZE 101 #define IOX_CONFIG_SERVICE_STRING_SIZE 101 #endif // IOX_BINDING_C_CONFIG_H Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/dir_f58c26ce9a5339347f1023a5792ba649/","text":"iceoryx_binding_c \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_binding_c/api.h iceoryx_binding_c/chunk.h iceoryx_binding_c/client.h iceoryx_binding_c/config.h iceoryx_binding_c/enums.h iceoryx_binding_c/listener.h iceoryx_binding_c/log.h iceoryx_binding_c/node.h iceoryx_binding_c/notification_info.h iceoryx_binding_c/publisher.h iceoryx_binding_c/request_header.h iceoryx_binding_c/response_header.h iceoryx_binding_c/runtime.h iceoryx_binding_c/server.h iceoryx_binding_c/service_description.h iceoryx_binding_c/service_discovery.h iceoryx_binding_c/subscriber.h iceoryx_binding_c/types.h iceoryx_binding_c/user_trigger.h iceoryx_binding_c/wait_set.h Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c"},{"location":"API-reference/c-binding/Files/dir_f58c26ce9a5339347f1023a5792ba649/#iceoryx_binding_c","text":"","title":"iceoryx_binding_c"},{"location":"API-reference/c-binding/Files/dir_f58c26ce9a5339347f1023a5792ba649/#files","text":"Name iceoryx_binding_c/api.h iceoryx_binding_c/chunk.h iceoryx_binding_c/client.h iceoryx_binding_c/config.h iceoryx_binding_c/enums.h iceoryx_binding_c/listener.h iceoryx_binding_c/log.h iceoryx_binding_c/node.h iceoryx_binding_c/notification_info.h iceoryx_binding_c/publisher.h iceoryx_binding_c/request_header.h iceoryx_binding_c/response_header.h iceoryx_binding_c/runtime.h iceoryx_binding_c/server.h iceoryx_binding_c/service_description.h iceoryx_binding_c/service_discovery.h iceoryx_binding_c/subscriber.h iceoryx_binding_c/types.h iceoryx_binding_c/user_trigger.h iceoryx_binding_c/wait_set.h Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/c-binding/Files/enums_8h/","text":"iceoryx_binding_c/enums.h \ud83d\udd17 Types \ud83d\udd17 Name enum iox_SubscriberState { SubscriberState_HAS_DATA} describes states which can be triggered by a subscriber enum iox_SubscriberEvent { SubscriberEvent_DATA_RECEIVED} describes events which can be triggered by a subscriber enum iox_SubscribeState { SubscribeState_NOT_SUBSCRIBED = 0, SubscribeState_SUBSCRIBE_REQUESTED, SubscribeState_SUBSCRIBED, SubscribeState_UNSUBSCRIBE_REQUESTED, SubscribeState_WAIT_FOR_OFFER, SubscribeState_UNDEFINED_ERROR} describes the current state of a subscriber enum iox_ClientEvent { ClientEvent_RESPONSE_RECEIVED} describes events which can be triggered by a client enum iox_ClientState { ClientState_HAS_RESPONSE} describes states which can be triggered by a client enum iox_ServerEvent { ServerEvent_REQUEST_RECEIVED} describes events which can be triggered by a server enum iox_ServerState { ServerState_HAS_REQUEST} describes states which can be triggered by a server enum iox_ConnectionState { ConnectionState_NOT_CONNECTED = 0, ConnectionState_CONNECT_REQUESTED, ConnectionState_CONNECTED, ConnectionState_DISCONNECT_REQUESTED, ConnectionState_WAIT_FOR_OFFER} describes the current connection state of a client enum iox_ChunkReceiveResult { ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL, ChunkReceiveResult_NO_CHUNK_AVAILABLE, ChunkReceiveResult_UNDEFINED_ERROR, ChunkReceiveResult_SUCCESS} describes the state of getChunk in the subscriber enum iox_ServiceDiscoveryEvent { ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED} describes events which can be triggered by a service discovery enum iox_QueueFullPolicy { QueueFullPolicy_BLOCK_PRODUCER, QueueFullPolicy_DISCARD_OLDEST_DATA} Used by consumers to request a specific behavior from the producer; describes whether a producer blocks when consumer queue is full. enum iox_ConsumerTooSlowPolicy { ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER, ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA} Used by producers how to adjust to slow consumer; describes whether a producer blocks when consumer queue is full. enum iox_AllocationResult { AllocationResult_NO_MEMPOOLS_AVAILABLE, AllocationResult_RUNNING_OUT_OF_CHUNKS, AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL, AllocationResult_INVALID_CHUNK, AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER, AllocationResult_UNDEFINED_ERROR, AllocationResult_INVALID_PARAMETER_FOR_CHUNK, AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER, AllocationResult_SUCCESS} state of allocateChunk enum iox_ClientSendResult { ClientSendResult_SUCCESS, ClientSendResult_UNDEFINED_ERROR, ClientSendResult_NO_CONNECT_REQUESTED, ClientSendResult_SERVER_NOT_AVAILABLE, ClientSendResult_INVALID_REQUEST} client send result enum iox_ServerSendResult { ServerSendResult_SUCCESS, ServerSendResult_UNDEFINED_ERROR, ServerSendResult_NOT_OFFERED, ServerSendResult_CLIENT_NOT_AVAILABLE, ServerSendResult_INVALID_RESPONSE} server send result enum iox_WaitSetResult { WaitSetResult_WAIT_SET_FULL, WaitSetResult_ALREADY_ATTACHED, WaitSetResult_UNDEFINED_ERROR, WaitSetResult_SUCCESS} used to describe if attaching an object to a waitset was successful or the kind of attachment error enum iox_ListenerResult { ListenerResult_LISTENER_FULL, ListenerResult_EVENT_ALREADY_ATTACHED, ListenerResult_EMPTY_EVENT_CALLBACK, ListenerResult_EMPTY_INVALIDATION_CALLBACK, ListenerResult_UNDEFINED_ERROR, ListenerResult_SUCCESS} used to describe if attaching an object to a listener was successful or the kind of attachment error enum iox_ServerRequestResult { ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL, ServerRequestResult_NO_PENDING_REQUESTS, ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR, ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER, ServerRequestResult_SUCCESS} enum iox_MessagingPattern { MessagingPattern_PUB_SUB, MessagingPattern_REQ_RES} used to describe the messaging pattern Types Documentation \ud83d\udd17 enum iox_SubscriberState \ud83d\udd17 Enumerator Value Description SubscriberState_HAS_DATA describes states which can be triggered by a subscriber enum iox_SubscriberEvent \ud83d\udd17 Enumerator Value Description SubscriberEvent_DATA_RECEIVED describes events which can be triggered by a subscriber enum iox_SubscribeState \ud83d\udd17 Enumerator Value Description SubscribeState_NOT_SUBSCRIBED 0 SubscribeState_SUBSCRIBE_REQUESTED SubscribeState_SUBSCRIBED SubscribeState_UNSUBSCRIBE_REQUESTED SubscribeState_WAIT_FOR_OFFER SubscribeState_UNDEFINED_ERROR describes the current state of a subscriber enum iox_ClientEvent \ud83d\udd17 Enumerator Value Description ClientEvent_RESPONSE_RECEIVED describes events which can be triggered by a client enum iox_ClientState \ud83d\udd17 Enumerator Value Description ClientState_HAS_RESPONSE describes states which can be triggered by a client enum iox_ServerEvent \ud83d\udd17 Enumerator Value Description ServerEvent_REQUEST_RECEIVED describes events which can be triggered by a server enum iox_ServerState \ud83d\udd17 Enumerator Value Description ServerState_HAS_REQUEST describes states which can be triggered by a server enum iox_ConnectionState \ud83d\udd17 Enumerator Value Description ConnectionState_NOT_CONNECTED 0 ConnectionState_CONNECT_REQUESTED ConnectionState_CONNECTED ConnectionState_DISCONNECT_REQUESTED ConnectionState_WAIT_FOR_OFFER describes the current connection state of a client enum iox_ChunkReceiveResult \ud83d\udd17 Enumerator Value Description ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL ChunkReceiveResult_NO_CHUNK_AVAILABLE ChunkReceiveResult_UNDEFINED_ERROR ChunkReceiveResult_SUCCESS describes the state of getChunk in the subscriber enum iox_ServiceDiscoveryEvent \ud83d\udd17 Enumerator Value Description ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED describes events which can be triggered by a service discovery enum iox_QueueFullPolicy \ud83d\udd17 Enumerator Value Description QueueFullPolicy_BLOCK_PRODUCER QueueFullPolicy_DISCARD_OLDEST_DATA Used by consumers to request a specific behavior from the producer; describes whether a producer blocks when consumer queue is full. enum iox_ConsumerTooSlowPolicy \ud83d\udd17 Enumerator Value Description ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA Used by producers how to adjust to slow consumer; describes whether a producer blocks when consumer queue is full. enum iox_AllocationResult \ud83d\udd17 Enumerator Value Description AllocationResult_NO_MEMPOOLS_AVAILABLE AllocationResult_RUNNING_OUT_OF_CHUNKS AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL AllocationResult_INVALID_CHUNK AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER AllocationResult_UNDEFINED_ERROR AllocationResult_INVALID_PARAMETER_FOR_CHUNK AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER AllocationResult_SUCCESS state of allocateChunk enum iox_ClientSendResult \ud83d\udd17 Enumerator Value Description ClientSendResult_SUCCESS ClientSendResult_UNDEFINED_ERROR ClientSendResult_NO_CONNECT_REQUESTED ClientSendResult_SERVER_NOT_AVAILABLE ClientSendResult_INVALID_REQUEST client send result enum iox_ServerSendResult \ud83d\udd17 Enumerator Value Description ServerSendResult_SUCCESS ServerSendResult_UNDEFINED_ERROR ServerSendResult_NOT_OFFERED ServerSendResult_CLIENT_NOT_AVAILABLE ServerSendResult_INVALID_RESPONSE server send result enum iox_WaitSetResult \ud83d\udd17 Enumerator Value Description WaitSetResult_WAIT_SET_FULL WaitSetResult_ALREADY_ATTACHED WaitSetResult_UNDEFINED_ERROR WaitSetResult_SUCCESS used to describe if attaching an object to a waitset was successful or the kind of attachment error enum iox_ListenerResult \ud83d\udd17 Enumerator Value Description ListenerResult_LISTENER_FULL ListenerResult_EVENT_ALREADY_ATTACHED ListenerResult_EMPTY_EVENT_CALLBACK ListenerResult_EMPTY_INVALIDATION_CALLBACK ListenerResult_UNDEFINED_ERROR ListenerResult_SUCCESS used to describe if attaching an object to a listener was successful or the kind of attachment error enum iox_ServerRequestResult \ud83d\udd17 Enumerator Value Description ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL ServerRequestResult_NO_PENDING_REQUESTS ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER ServerRequestResult_SUCCESS enum iox_MessagingPattern \ud83d\udd17 Enumerator Value Description MessagingPattern_PUB_SUB MessagingPattern_REQ_RES used to describe the messaging pattern Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_ENUMS_H #define IOX_BINDING_C_ENUMS_H enum iox_SubscriberState { SubscriberState_HAS_DATA , }; enum iox_SubscriberEvent { SubscriberEvent_DATA_RECEIVED , }; enum iox_SubscribeState { SubscribeState_NOT_SUBSCRIBED = 0 , SubscribeState_SUBSCRIBE_REQUESTED , SubscribeState_SUBSCRIBED , SubscribeState_UNSUBSCRIBE_REQUESTED , SubscribeState_WAIT_FOR_OFFER , SubscribeState_UNDEFINED_ERROR , }; enum iox_ClientEvent { ClientEvent_RESPONSE_RECEIVED }; enum iox_ClientState { ClientState_HAS_RESPONSE }; enum iox_ServerEvent { ServerEvent_REQUEST_RECEIVED }; enum iox_ServerState { ServerState_HAS_REQUEST }; enum iox_ConnectionState { ConnectionState_NOT_CONNECTED = 0 , ConnectionState_CONNECT_REQUESTED , ConnectionState_CONNECTED , ConnectionState_DISCONNECT_REQUESTED , ConnectionState_WAIT_FOR_OFFER }; enum iox_ChunkReceiveResult { ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL , ChunkReceiveResult_NO_CHUNK_AVAILABLE , ChunkReceiveResult_UNDEFINED_ERROR , ChunkReceiveResult_SUCCESS , }; enum iox_ServiceDiscoveryEvent { ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED }; enum iox_QueueFullPolicy { QueueFullPolicy_BLOCK_PRODUCER , QueueFullPolicy_DISCARD_OLDEST_DATA , }; enum iox_ConsumerTooSlowPolicy { ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER , ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA , }; enum iox_AllocationResult { AllocationResult_NO_MEMPOOLS_AVAILABLE , AllocationResult_RUNNING_OUT_OF_CHUNKS , AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL , AllocationResult_INVALID_CHUNK , AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER , AllocationResult_UNDEFINED_ERROR , AllocationResult_INVALID_PARAMETER_FOR_CHUNK , AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER , AllocationResult_SUCCESS , }; enum iox_ClientSendResult { ClientSendResult_SUCCESS , ClientSendResult_UNDEFINED_ERROR , ClientSendResult_NO_CONNECT_REQUESTED , ClientSendResult_SERVER_NOT_AVAILABLE , ClientSendResult_INVALID_REQUEST , }; enum iox_ServerSendResult { ServerSendResult_SUCCESS , ServerSendResult_UNDEFINED_ERROR , ServerSendResult_NOT_OFFERED , ServerSendResult_CLIENT_NOT_AVAILABLE , ServerSendResult_INVALID_RESPONSE , }; enum iox_WaitSetResult { WaitSetResult_WAIT_SET_FULL , WaitSetResult_ALREADY_ATTACHED , WaitSetResult_UNDEFINED_ERROR , WaitSetResult_SUCCESS }; enum iox_ListenerResult { ListenerResult_LISTENER_FULL , ListenerResult_EVENT_ALREADY_ATTACHED , ListenerResult_EMPTY_EVENT_CALLBACK , ListenerResult_EMPTY_INVALIDATION_CALLBACK , ListenerResult_UNDEFINED_ERROR , ListenerResult_SUCCESS }; enum iox_ServerRequestResult { ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL , ServerRequestResult_NO_PENDING_REQUESTS , ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR , ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER , ServerRequestResult_SUCCESS }; enum iox_MessagingPattern { MessagingPattern_PUB_SUB , MessagingPattern_REQ_RES }; #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/enums.h"},{"location":"API-reference/c-binding/Files/enums_8h/#iceoryx_binding_cenumsh","text":"","title":"iceoryx_binding_c/enums.h"},{"location":"API-reference/c-binding/Files/enums_8h/#types","text":"Name enum iox_SubscriberState { SubscriberState_HAS_DATA} describes states which can be triggered by a subscriber enum iox_SubscriberEvent { SubscriberEvent_DATA_RECEIVED} describes events which can be triggered by a subscriber enum iox_SubscribeState { SubscribeState_NOT_SUBSCRIBED = 0, SubscribeState_SUBSCRIBE_REQUESTED, SubscribeState_SUBSCRIBED, SubscribeState_UNSUBSCRIBE_REQUESTED, SubscribeState_WAIT_FOR_OFFER, SubscribeState_UNDEFINED_ERROR} describes the current state of a subscriber enum iox_ClientEvent { ClientEvent_RESPONSE_RECEIVED} describes events which can be triggered by a client enum iox_ClientState { ClientState_HAS_RESPONSE} describes states which can be triggered by a client enum iox_ServerEvent { ServerEvent_REQUEST_RECEIVED} describes events which can be triggered by a server enum iox_ServerState { ServerState_HAS_REQUEST} describes states which can be triggered by a server enum iox_ConnectionState { ConnectionState_NOT_CONNECTED = 0, ConnectionState_CONNECT_REQUESTED, ConnectionState_CONNECTED, ConnectionState_DISCONNECT_REQUESTED, ConnectionState_WAIT_FOR_OFFER} describes the current connection state of a client enum iox_ChunkReceiveResult { ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL, ChunkReceiveResult_NO_CHUNK_AVAILABLE, ChunkReceiveResult_UNDEFINED_ERROR, ChunkReceiveResult_SUCCESS} describes the state of getChunk in the subscriber enum iox_ServiceDiscoveryEvent { ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED} describes events which can be triggered by a service discovery enum iox_QueueFullPolicy { QueueFullPolicy_BLOCK_PRODUCER, QueueFullPolicy_DISCARD_OLDEST_DATA} Used by consumers to request a specific behavior from the producer; describes whether a producer blocks when consumer queue is full. enum iox_ConsumerTooSlowPolicy { ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER, ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA} Used by producers how to adjust to slow consumer; describes whether a producer blocks when consumer queue is full. enum iox_AllocationResult { AllocationResult_NO_MEMPOOLS_AVAILABLE, AllocationResult_RUNNING_OUT_OF_CHUNKS, AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL, AllocationResult_INVALID_CHUNK, AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER, AllocationResult_UNDEFINED_ERROR, AllocationResult_INVALID_PARAMETER_FOR_CHUNK, AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER, AllocationResult_SUCCESS} state of allocateChunk enum iox_ClientSendResult { ClientSendResult_SUCCESS, ClientSendResult_UNDEFINED_ERROR, ClientSendResult_NO_CONNECT_REQUESTED, ClientSendResult_SERVER_NOT_AVAILABLE, ClientSendResult_INVALID_REQUEST} client send result enum iox_ServerSendResult { ServerSendResult_SUCCESS, ServerSendResult_UNDEFINED_ERROR, ServerSendResult_NOT_OFFERED, ServerSendResult_CLIENT_NOT_AVAILABLE, ServerSendResult_INVALID_RESPONSE} server send result enum iox_WaitSetResult { WaitSetResult_WAIT_SET_FULL, WaitSetResult_ALREADY_ATTACHED, WaitSetResult_UNDEFINED_ERROR, WaitSetResult_SUCCESS} used to describe if attaching an object to a waitset was successful or the kind of attachment error enum iox_ListenerResult { ListenerResult_LISTENER_FULL, ListenerResult_EVENT_ALREADY_ATTACHED, ListenerResult_EMPTY_EVENT_CALLBACK, ListenerResult_EMPTY_INVALIDATION_CALLBACK, ListenerResult_UNDEFINED_ERROR, ListenerResult_SUCCESS} used to describe if attaching an object to a listener was successful or the kind of attachment error enum iox_ServerRequestResult { ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL, ServerRequestResult_NO_PENDING_REQUESTS, ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR, ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER, ServerRequestResult_SUCCESS} enum iox_MessagingPattern { MessagingPattern_PUB_SUB, MessagingPattern_REQ_RES} used to describe the messaging pattern","title":"Types"},{"location":"API-reference/c-binding/Files/enums_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_subscriberstate","text":"Enumerator Value Description SubscriberState_HAS_DATA describes states which can be triggered by a subscriber","title":"enum iox_SubscriberState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_subscriberevent","text":"Enumerator Value Description SubscriberEvent_DATA_RECEIVED describes events which can be triggered by a subscriber","title":"enum iox_SubscriberEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_subscribestate","text":"Enumerator Value Description SubscribeState_NOT_SUBSCRIBED 0 SubscribeState_SUBSCRIBE_REQUESTED SubscribeState_SUBSCRIBED SubscribeState_UNSUBSCRIBE_REQUESTED SubscribeState_WAIT_FOR_OFFER SubscribeState_UNDEFINED_ERROR describes the current state of a subscriber","title":"enum iox_SubscribeState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_clientevent","text":"Enumerator Value Description ClientEvent_RESPONSE_RECEIVED describes events which can be triggered by a client","title":"enum iox_ClientEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_clientstate","text":"Enumerator Value Description ClientState_HAS_RESPONSE describes states which can be triggered by a client","title":"enum iox_ClientState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serverevent","text":"Enumerator Value Description ServerEvent_REQUEST_RECEIVED describes events which can be triggered by a server","title":"enum iox_ServerEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serverstate","text":"Enumerator Value Description ServerState_HAS_REQUEST describes states which can be triggered by a server","title":"enum iox_ServerState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_connectionstate","text":"Enumerator Value Description ConnectionState_NOT_CONNECTED 0 ConnectionState_CONNECT_REQUESTED ConnectionState_CONNECTED ConnectionState_DISCONNECT_REQUESTED ConnectionState_WAIT_FOR_OFFER describes the current connection state of a client","title":"enum iox_ConnectionState"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_chunkreceiveresult","text":"Enumerator Value Description ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL ChunkReceiveResult_NO_CHUNK_AVAILABLE ChunkReceiveResult_UNDEFINED_ERROR ChunkReceiveResult_SUCCESS describes the state of getChunk in the subscriber","title":"enum iox_ChunkReceiveResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_servicediscoveryevent","text":"Enumerator Value Description ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED describes events which can be triggered by a service discovery","title":"enum iox_ServiceDiscoveryEvent"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_queuefullpolicy","text":"Enumerator Value Description QueueFullPolicy_BLOCK_PRODUCER QueueFullPolicy_DISCARD_OLDEST_DATA Used by consumers to request a specific behavior from the producer; describes whether a producer blocks when consumer queue is full.","title":"enum iox_QueueFullPolicy"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_consumertooslowpolicy","text":"Enumerator Value Description ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA Used by producers how to adjust to slow consumer; describes whether a producer blocks when consumer queue is full.","title":"enum iox_ConsumerTooSlowPolicy"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_allocationresult","text":"Enumerator Value Description AllocationResult_NO_MEMPOOLS_AVAILABLE AllocationResult_RUNNING_OUT_OF_CHUNKS AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL AllocationResult_INVALID_CHUNK AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER AllocationResult_UNDEFINED_ERROR AllocationResult_INVALID_PARAMETER_FOR_CHUNK AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER AllocationResult_SUCCESS state of allocateChunk","title":"enum iox_AllocationResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_clientsendresult","text":"Enumerator Value Description ClientSendResult_SUCCESS ClientSendResult_UNDEFINED_ERROR ClientSendResult_NO_CONNECT_REQUESTED ClientSendResult_SERVER_NOT_AVAILABLE ClientSendResult_INVALID_REQUEST client send result","title":"enum iox_ClientSendResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serversendresult","text":"Enumerator Value Description ServerSendResult_SUCCESS ServerSendResult_UNDEFINED_ERROR ServerSendResult_NOT_OFFERED ServerSendResult_CLIENT_NOT_AVAILABLE ServerSendResult_INVALID_RESPONSE server send result","title":"enum iox_ServerSendResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_waitsetresult","text":"Enumerator Value Description WaitSetResult_WAIT_SET_FULL WaitSetResult_ALREADY_ATTACHED WaitSetResult_UNDEFINED_ERROR WaitSetResult_SUCCESS used to describe if attaching an object to a waitset was successful or the kind of attachment error","title":"enum iox_WaitSetResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_listenerresult","text":"Enumerator Value Description ListenerResult_LISTENER_FULL ListenerResult_EVENT_ALREADY_ATTACHED ListenerResult_EMPTY_EVENT_CALLBACK ListenerResult_EMPTY_INVALIDATION_CALLBACK ListenerResult_UNDEFINED_ERROR ListenerResult_SUCCESS used to describe if attaching an object to a listener was successful or the kind of attachment error","title":"enum iox_ListenerResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_serverrequestresult","text":"Enumerator Value Description ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL ServerRequestResult_NO_PENDING_REQUESTS ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER ServerRequestResult_SUCCESS","title":"enum iox_ServerRequestResult"},{"location":"API-reference/c-binding/Files/enums_8h/#enum-iox_messagingpattern","text":"Enumerator Value Description MessagingPattern_PUB_SUB MessagingPattern_REQ_RES used to describe the messaging pattern","title":"enum iox_MessagingPattern"},{"location":"API-reference/c-binding/Files/enums_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_ENUMS_H #define IOX_BINDING_C_ENUMS_H enum iox_SubscriberState { SubscriberState_HAS_DATA , }; enum iox_SubscriberEvent { SubscriberEvent_DATA_RECEIVED , }; enum iox_SubscribeState { SubscribeState_NOT_SUBSCRIBED = 0 , SubscribeState_SUBSCRIBE_REQUESTED , SubscribeState_SUBSCRIBED , SubscribeState_UNSUBSCRIBE_REQUESTED , SubscribeState_WAIT_FOR_OFFER , SubscribeState_UNDEFINED_ERROR , }; enum iox_ClientEvent { ClientEvent_RESPONSE_RECEIVED }; enum iox_ClientState { ClientState_HAS_RESPONSE }; enum iox_ServerEvent { ServerEvent_REQUEST_RECEIVED }; enum iox_ServerState { ServerState_HAS_REQUEST }; enum iox_ConnectionState { ConnectionState_NOT_CONNECTED = 0 , ConnectionState_CONNECT_REQUESTED , ConnectionState_CONNECTED , ConnectionState_DISCONNECT_REQUESTED , ConnectionState_WAIT_FOR_OFFER }; enum iox_ChunkReceiveResult { ChunkReceiveResult_TOO_MANY_CHUNKS_HELD_IN_PARALLEL , ChunkReceiveResult_NO_CHUNK_AVAILABLE , ChunkReceiveResult_UNDEFINED_ERROR , ChunkReceiveResult_SUCCESS , }; enum iox_ServiceDiscoveryEvent { ServiceDiscoveryEvent_SERVICE_REGISTRY_CHANGED }; enum iox_QueueFullPolicy { QueueFullPolicy_BLOCK_PRODUCER , QueueFullPolicy_DISCARD_OLDEST_DATA , }; enum iox_ConsumerTooSlowPolicy { ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER , ConsumerTooSlowPolicy_DISCARD_OLDEST_DATA , }; enum iox_AllocationResult { AllocationResult_NO_MEMPOOLS_AVAILABLE , AllocationResult_RUNNING_OUT_OF_CHUNKS , AllocationResult_TOO_MANY_CHUNKS_ALLOCATED_IN_PARALLEL , AllocationResult_INVALID_CHUNK , AllocationResult_INVALID_PARAMETER_FOR_USER_PAYLOAD_OR_USER_HEADER , AllocationResult_UNDEFINED_ERROR , AllocationResult_INVALID_PARAMETER_FOR_CHUNK , AllocationResult_INVALID_PARAMETER_FOR_REQUEST_HEADER , AllocationResult_SUCCESS , }; enum iox_ClientSendResult { ClientSendResult_SUCCESS , ClientSendResult_UNDEFINED_ERROR , ClientSendResult_NO_CONNECT_REQUESTED , ClientSendResult_SERVER_NOT_AVAILABLE , ClientSendResult_INVALID_REQUEST , }; enum iox_ServerSendResult { ServerSendResult_SUCCESS , ServerSendResult_UNDEFINED_ERROR , ServerSendResult_NOT_OFFERED , ServerSendResult_CLIENT_NOT_AVAILABLE , ServerSendResult_INVALID_RESPONSE , }; enum iox_WaitSetResult { WaitSetResult_WAIT_SET_FULL , WaitSetResult_ALREADY_ATTACHED , WaitSetResult_UNDEFINED_ERROR , WaitSetResult_SUCCESS }; enum iox_ListenerResult { ListenerResult_LISTENER_FULL , ListenerResult_EVENT_ALREADY_ATTACHED , ListenerResult_EMPTY_EVENT_CALLBACK , ListenerResult_EMPTY_INVALIDATION_CALLBACK , ListenerResult_UNDEFINED_ERROR , ListenerResult_SUCCESS }; enum iox_ServerRequestResult { ServerRequestResult_TOO_MANY_REQUESTS_HELD_IN_PARALLEL , ServerRequestResult_NO_PENDING_REQUESTS , ServerRequestResult_UNDEFINED_CHUNK_RECEIVE_ERROR , ServerRequestResult_NO_PENDING_REQUESTS_AND_SERVER_DOES_NOT_OFFER , ServerRequestResult_SUCCESS }; enum iox_MessagingPattern { MessagingPattern_PUB_SUB , MessagingPattern_REQ_RES }; #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/listener_8h/","text":"iceoryx_binding_c/listener.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS Listener * iox_listener_t Functions \ud83d\udd17 Name iox_listener_t iox_listener_init ( iox_listener_storage_t * self) initializes a listener struct from a storage struct pointer void iox_listener_deinit (iox_listener_t const self) after using an iox_listener_t it must be cleaned up with this function ENUM iox_ListenerResult iox_listener_attach_subscriber_event (iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, void(*)(iox_sub_t) callback) Attaches a subscriber event to the listener. ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data (iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, void( )(iox_sub_t, void ) callback, void *const contextData) Attaches a subscriber event to the listener. The callback has an additional contextData argument to provide access to user defined data. ENUM iox_ListenerResult iox_listener_attach_user_trigger_event (iox_listener_t const self, iox_user_trigger_t const userTrigger, void(*)(iox_user_trigger_t) callback) Attaches a user trigger to the listener. ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data (iox_listener_t const self, iox_user_trigger_t const userTrigger, void( )(iox_user_trigger_t, void ) callback, void *const contextData) Attaches a user trigger to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_subscriber_event (iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent) Detaches a subscriber event from the listener. void iox_listener_detach_user_trigger_event (iox_listener_t const self, iox_user_trigger_t const userTrigger) Detaches a user trigger from the listener. uint64_t iox_listener_size (iox_listener_t const self) Returns the size, the number of attached events of a listener. uint64_t iox_listener_capacity (iox_listener_t const self) Returns the capacity of a listener (how many events can be attached). ENUM iox_ListenerResult iox_listener_attach_client_event (iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, void(*)(iox_client_t) callback) Attaches a client event to the listener. ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data (iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, void( )(iox_client_t, void ) callback, void *const contextData) Attaches a client event to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_client_event (iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent) Detaches a client from the listener. ENUM iox_ListenerResult iox_listener_attach_server_event (iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, void(*)(iox_server_t) callback) Attaches a server event to the listener. ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data (iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, void( )(iox_server_t, void ) callback, void *const contextData) Attaches a server event to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_server_event (iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent) Detaches a server from the listener. ENUM iox_ListenerResult iox_listener_attach_service_discovery_event (iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, void(*)(iox_service_discovery_t) callback) Attaches a service discovery event to the listener. ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data (iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, void( )(iox_service_discovery_t, void ) callback, void *const contextData) Attaches a service discovery event to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_service_discovery_event (iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent) Detaches a service discovery event from the listener. Types Documentation \ud83d\udd17 typedef iox_listener_t \ud83d\udd17 typedef CLASS Listener * iox_listener_t ; Functions Documentation \ud83d\udd17 function iox_listener_init \ud83d\udd17 iox_listener_t iox_listener_init ( iox_listener_storage_t * self ) initializes a listener struct from a storage struct pointer Parameters : self pointer to raw memory which can hold a listener Return : an initialized iox_listener_t function iox_listener_deinit \ud83d\udd17 void iox_listener_deinit ( iox_listener_t const self ) after using an iox_listener_t it must be cleaned up with this function Parameters : self the listener which should be deinitialized function iox_listener_attach_subscriber_event \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * )( iox_sub_t ) callback ) Attaches a subscriber event to the listener. Parameters : self listener to which the event should be attached to subscriber subscriber which emits the event subscriberEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_attach_subscriber_event_with_context_data \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * )( iox_sub_t , void * ) callback , void * const contextData ) Attaches a subscriber event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to subscriber subscriber which emits the event subscriberEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_attach_user_trigger_event \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * )( iox_user_trigger_t ) callback ) Attaches a user trigger to the listener. Parameters : self listener to which the event should be attached to userTrigger user trigger which emits the event callback the callback which is called when the user trigger triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_attach_user_trigger_event_with_context_data \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * )( iox_user_trigger_t , void * ) callback , void * const contextData ) Attaches a user trigger to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to userTrigger user trigger which emits the event callback the callback which is called when the user trigger triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_detach_subscriber_event \ud83d\udd17 void iox_listener_detach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ) Detaches a subscriber event from the listener. Parameters : self listener from which the event should be detached subscriber the subscriber which emits the event subscriberEvent the subscriber event which is registered at the listener function iox_listener_detach_user_trigger_event \ud83d\udd17 void iox_listener_detach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger ) Detaches a user trigger from the listener. Parameters : self listener from which the event should be detached userTrigger the user trigger which emits the event function iox_listener_size \ud83d\udd17 uint64_t iox_listener_size ( iox_listener_t const self ) Returns the size, the number of attached events of a listener. Parameters : self listener where the size should be acquired Return : the size of the listener function iox_listener_capacity \ud83d\udd17 uint64_t iox_listener_capacity ( iox_listener_t const self ) Returns the capacity of a listener (how many events can be attached). Parameters : self listener where the capacity should be acquired Return : the capacity of the listener function iox_listener_attach_client_event \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * )( iox_client_t ) callback ) Attaches a client event to the listener. Parameters : self listener to which the event should be attached to client client which emits the event clientEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_attach_client_event_with_context_data \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * )( iox_client_t , void * ) callback , void * const contextData ) Attaches a client event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to client client which emits the event clientEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_detach_client_event \ud83d\udd17 void iox_listener_detach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ) Detaches a client from the listener. Parameters : self listener from which the event should be detached client the client which emits the event clientEvent the event which should be removed from the listener function iox_listener_attach_server_event \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * )( iox_server_t ) callback ) Attaches a server event to the listener. Parameters : self listener to which the event should be attached to server the server which emits the event serverEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_attach_server_event_with_context_data \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * )( iox_server_t , void * ) callback , void * const contextData ) Attaches a server event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to server the server which emits the event serverEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_detach_server_event \ud83d\udd17 void iox_listener_detach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ) Detaches a server from the listener. Parameters : self listener from which the event should be detached server the server which emits the event serverEvent the event which should be removed from the listener function iox_listener_attach_service_discovery_event \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * )( iox_service_discovery_t ) callback ) Attaches a service discovery event to the listener. Parameters : self listener to which the event should be attached to serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_attach_service_discovery_event_with_context_data \ud83d\udd17 ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * )( iox_service_discovery_t , void * ) callback , void * const contextData ) Attaches a service discovery event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error function iox_listener_detach_service_discovery_event \ud83d\udd17 void iox_listener_detach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ) Detaches a service discovery event from the listener. Parameters : self listener from which the event should be detached serviceDiscovery the service discovery which emits the event serviceDiscoveryEvent the service discovery event which should be removed from the listener Source code \ud83d\udd17 // Copyright (c) 2021 - 2022 Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_LISTENER_H #define IOX_BINDING_C_LISTENER_H #include \"iceoryx_binding_c/client.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/server.h\" #include \"iceoryx_binding_c/service_discovery.h\" #include \"iceoryx_binding_c/subscriber.h\" #include \"iceoryx_binding_c/types.h\" #include \"iceoryx_binding_c/user_trigger.h\" typedef CLASS Listener * iox_listener_t ; iox_listener_t iox_listener_init ( iox_listener_storage_t * self ); void iox_listener_deinit ( iox_listener_t const self ); ENUM iox_ListenerResult iox_listener_attach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * callback )( iox_sub_t )); ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * callback )( iox_sub_t , void * ), void * const contextData ); ENUM iox_ListenerResult iox_listener_attach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * callback )( iox_user_trigger_t )); ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * callback )( iox_user_trigger_t , void * ), void * const contextData ); void iox_listener_detach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ); void iox_listener_detach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger ); uint64_t iox_listener_size ( iox_listener_t const self ); uint64_t iox_listener_capacity ( iox_listener_t const self ); ENUM iox_ListenerResult iox_listener_attach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * callback )( iox_client_t )); ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * callback )( iox_client_t , void * ), void * const contextData ); void iox_listener_detach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ); ENUM iox_ListenerResult iox_listener_attach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * callback )( iox_server_t )); ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * callback )( iox_server_t , void * ), void * const contextData ); void iox_listener_detach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ); ENUM iox_ListenerResult iox_listener_attach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * callback )( iox_service_discovery_t )); ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * callback )( iox_service_discovery_t , void * ), void * const contextData ); void iox_listener_detach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/listener.h"},{"location":"API-reference/c-binding/Files/listener_8h/#iceoryx_binding_clistenerh","text":"","title":"iceoryx_binding_c/listener.h"},{"location":"API-reference/c-binding/Files/listener_8h/#types","text":"Name typedef CLASS Listener * iox_listener_t","title":"Types"},{"location":"API-reference/c-binding/Files/listener_8h/#functions","text":"Name iox_listener_t iox_listener_init ( iox_listener_storage_t * self) initializes a listener struct from a storage struct pointer void iox_listener_deinit (iox_listener_t const self) after using an iox_listener_t it must be cleaned up with this function ENUM iox_ListenerResult iox_listener_attach_subscriber_event (iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, void(*)(iox_sub_t) callback) Attaches a subscriber event to the listener. ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data (iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, void( )(iox_sub_t, void ) callback, void *const contextData) Attaches a subscriber event to the listener. The callback has an additional contextData argument to provide access to user defined data. ENUM iox_ListenerResult iox_listener_attach_user_trigger_event (iox_listener_t const self, iox_user_trigger_t const userTrigger, void(*)(iox_user_trigger_t) callback) Attaches a user trigger to the listener. ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data (iox_listener_t const self, iox_user_trigger_t const userTrigger, void( )(iox_user_trigger_t, void ) callback, void *const contextData) Attaches a user trigger to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_subscriber_event (iox_listener_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent) Detaches a subscriber event from the listener. void iox_listener_detach_user_trigger_event (iox_listener_t const self, iox_user_trigger_t const userTrigger) Detaches a user trigger from the listener. uint64_t iox_listener_size (iox_listener_t const self) Returns the size, the number of attached events of a listener. uint64_t iox_listener_capacity (iox_listener_t const self) Returns the capacity of a listener (how many events can be attached). ENUM iox_ListenerResult iox_listener_attach_client_event (iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, void(*)(iox_client_t) callback) Attaches a client event to the listener. ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data (iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, void( )(iox_client_t, void ) callback, void *const contextData) Attaches a client event to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_client_event (iox_listener_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent) Detaches a client from the listener. ENUM iox_ListenerResult iox_listener_attach_server_event (iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, void(*)(iox_server_t) callback) Attaches a server event to the listener. ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data (iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, void( )(iox_server_t, void ) callback, void *const contextData) Attaches a server event to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_server_event (iox_listener_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent) Detaches a server from the listener. ENUM iox_ListenerResult iox_listener_attach_service_discovery_event (iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, void(*)(iox_service_discovery_t) callback) Attaches a service discovery event to the listener. ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data (iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, void( )(iox_service_discovery_t, void ) callback, void *const contextData) Attaches a service discovery event to the listener. The callback has an additional contextData argument to provide access to user defined data. void iox_listener_detach_service_discovery_event (iox_listener_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent) Detaches a service discovery event from the listener.","title":"Functions"},{"location":"API-reference/c-binding/Files/listener_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/listener_8h/#typedef-iox_listener_t","text":"typedef CLASS Listener * iox_listener_t ;","title":"typedef iox_listener_t"},{"location":"API-reference/c-binding/Files/listener_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_init","text":"iox_listener_t iox_listener_init ( iox_listener_storage_t * self ) initializes a listener struct from a storage struct pointer Parameters : self pointer to raw memory which can hold a listener Return : an initialized iox_listener_t","title":"function iox_listener_init"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_deinit","text":"void iox_listener_deinit ( iox_listener_t const self ) after using an iox_listener_t it must be cleaned up with this function Parameters : self the listener which should be deinitialized","title":"function iox_listener_deinit"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_subscriber_event","text":"ENUM iox_ListenerResult iox_listener_attach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * )( iox_sub_t ) callback ) Attaches a subscriber event to the listener. Parameters : self listener to which the event should be attached to subscriber subscriber which emits the event subscriberEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_subscriber_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_subscriber_event_with_context_data","text":"ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * )( iox_sub_t , void * ) callback , void * const contextData ) Attaches a subscriber event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to subscriber subscriber which emits the event subscriberEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_subscriber_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_user_trigger_event","text":"ENUM iox_ListenerResult iox_listener_attach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * )( iox_user_trigger_t ) callback ) Attaches a user trigger to the listener. Parameters : self listener to which the event should be attached to userTrigger user trigger which emits the event callback the callback which is called when the user trigger triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_user_trigger_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_user_trigger_event_with_context_data","text":"ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * )( iox_user_trigger_t , void * ) callback , void * const contextData ) Attaches a user trigger to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to userTrigger user trigger which emits the event callback the callback which is called when the user trigger triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_user_trigger_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_subscriber_event","text":"void iox_listener_detach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ) Detaches a subscriber event from the listener. Parameters : self listener from which the event should be detached subscriber the subscriber which emits the event subscriberEvent the subscriber event which is registered at the listener","title":"function iox_listener_detach_subscriber_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_user_trigger_event","text":"void iox_listener_detach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger ) Detaches a user trigger from the listener. Parameters : self listener from which the event should be detached userTrigger the user trigger which emits the event","title":"function iox_listener_detach_user_trigger_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_size","text":"uint64_t iox_listener_size ( iox_listener_t const self ) Returns the size, the number of attached events of a listener. Parameters : self listener where the size should be acquired Return : the size of the listener","title":"function iox_listener_size"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_capacity","text":"uint64_t iox_listener_capacity ( iox_listener_t const self ) Returns the capacity of a listener (how many events can be attached). Parameters : self listener where the capacity should be acquired Return : the capacity of the listener","title":"function iox_listener_capacity"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_client_event","text":"ENUM iox_ListenerResult iox_listener_attach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * )( iox_client_t ) callback ) Attaches a client event to the listener. Parameters : self listener to which the event should be attached to client client which emits the event clientEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_client_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_client_event_with_context_data","text":"ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * )( iox_client_t , void * ) callback , void * const contextData ) Attaches a client event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to client client which emits the event clientEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_client_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_client_event","text":"void iox_listener_detach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ) Detaches a client from the listener. Parameters : self listener from which the event should be detached client the client which emits the event clientEvent the event which should be removed from the listener","title":"function iox_listener_detach_client_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_server_event","text":"ENUM iox_ListenerResult iox_listener_attach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * )( iox_server_t ) callback ) Attaches a server event to the listener. Parameters : self listener to which the event should be attached to server the server which emits the event serverEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_server_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_server_event_with_context_data","text":"ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * )( iox_server_t , void * ) callback , void * const contextData ) Attaches a server event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to server the server which emits the event serverEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_server_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_server_event","text":"void iox_listener_detach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ) Detaches a server from the listener. Parameters : self listener from which the event should be detached server the server which emits the event serverEvent the event which should be removed from the listener","title":"function iox_listener_detach_server_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_service_discovery_event","text":"ENUM iox_ListenerResult iox_listener_attach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * )( iox_service_discovery_t ) callback ) Attaches a service discovery event to the listener. Parameters : self listener to which the event should be attached to serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_service_discovery_event"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_attach_service_discovery_event_with_context_data","text":"ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * )( iox_service_discovery_t , void * ) callback , void * const contextData ) Attaches a service discovery event to the listener. The callback has an additional contextData argument to provide access to user defined data. Parameters : self listener to which the event should be attached to serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should trigger the listener callback the callback which is called when an event triggers the listener contextData a void pointer which is provided as second argument to the callback Return : when successful iox_ListenerResult::ListenerResult_SUCCESS otherwise an enum which describes the error","title":"function iox_listener_attach_service_discovery_event_with_context_data"},{"location":"API-reference/c-binding/Files/listener_8h/#function-iox_listener_detach_service_discovery_event","text":"void iox_listener_detach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ) Detaches a service discovery event from the listener. Parameters : self listener from which the event should be detached serviceDiscovery the service discovery which emits the event serviceDiscoveryEvent the service discovery event which should be removed from the listener","title":"function iox_listener_detach_service_discovery_event"},{"location":"API-reference/c-binding/Files/listener_8h/#source-code","text":"// Copyright (c) 2021 - 2022 Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_LISTENER_H #define IOX_BINDING_C_LISTENER_H #include \"iceoryx_binding_c/client.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/server.h\" #include \"iceoryx_binding_c/service_discovery.h\" #include \"iceoryx_binding_c/subscriber.h\" #include \"iceoryx_binding_c/types.h\" #include \"iceoryx_binding_c/user_trigger.h\" typedef CLASS Listener * iox_listener_t ; iox_listener_t iox_listener_init ( iox_listener_storage_t * self ); void iox_listener_deinit ( iox_listener_t const self ); ENUM iox_ListenerResult iox_listener_attach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * callback )( iox_sub_t )); ENUM iox_ListenerResult iox_listener_attach_subscriber_event_with_context_data ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , void ( * callback )( iox_sub_t , void * ), void * const contextData ); ENUM iox_ListenerResult iox_listener_attach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * callback )( iox_user_trigger_t )); ENUM iox_ListenerResult iox_listener_attach_user_trigger_event_with_context_data ( iox_listener_t const self , iox_user_trigger_t const userTrigger , void ( * callback )( iox_user_trigger_t , void * ), void * const contextData ); void iox_listener_detach_subscriber_event ( iox_listener_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ); void iox_listener_detach_user_trigger_event ( iox_listener_t const self , iox_user_trigger_t const userTrigger ); uint64_t iox_listener_size ( iox_listener_t const self ); uint64_t iox_listener_capacity ( iox_listener_t const self ); ENUM iox_ListenerResult iox_listener_attach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * callback )( iox_client_t )); ENUM iox_ListenerResult iox_listener_attach_client_event_with_context_data ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , void ( * callback )( iox_client_t , void * ), void * const contextData ); void iox_listener_detach_client_event ( iox_listener_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ); ENUM iox_ListenerResult iox_listener_attach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * callback )( iox_server_t )); ENUM iox_ListenerResult iox_listener_attach_server_event_with_context_data ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , void ( * callback )( iox_server_t , void * ), void * const contextData ); void iox_listener_detach_server_event ( iox_listener_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ); ENUM iox_ListenerResult iox_listener_attach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * callback )( iox_service_discovery_t )); ENUM iox_ListenerResult iox_listener_attach_service_discovery_event_with_context_data ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , void ( * callback )( iox_service_discovery_t , void * ), void * const contextData ); void iox_listener_detach_service_discovery_event ( iox_listener_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/log_8h/","text":"iceoryx_binding_c/log.h \ud83d\udd17 Types \ud83d\udd17 Name enum iox_LogLevel { Iceoryx_LogLevel_Off = 0, Iceoryx_LogLevel_Verbose, Iceoryx_LogLevel_Debug, Iceoryx_LogLevel_Info, Iceoryx_LogLevel_Warn, Iceoryx_LogLevel_Error, Iceoryx_LogLevel_Fatal} available log levels of the iceoryx runtime Functions \ud83d\udd17 Name void iox_set_loglevel (enum iox_LogLevel level) set the log level of the iceoryx runtime Types Documentation \ud83d\udd17 enum iox_LogLevel \ud83d\udd17 Enumerator Value Description Iceoryx_LogLevel_Off 0 Iceoryx_LogLevel_Verbose Iceoryx_LogLevel_Debug Iceoryx_LogLevel_Info Iceoryx_LogLevel_Warn Iceoryx_LogLevel_Error Iceoryx_LogLevel_Fatal available log levels of the iceoryx runtime Functions Documentation \ud83d\udd17 function iox_set_loglevel \ud83d\udd17 void iox_set_loglevel ( enum iox_LogLevel level ) set the log level of the iceoryx runtime Parameters : level log level to be set Note : must be called before the runtime is initialized Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_LOG_H #define IOX_BINDING_C_LOG_H enum iox_LogLevel { Iceoryx_LogLevel_Off = 0 , Iceoryx_LogLevel_Verbose , Iceoryx_LogLevel_Debug , Iceoryx_LogLevel_Info , Iceoryx_LogLevel_Warn , Iceoryx_LogLevel_Error , Iceoryx_LogLevel_Fatal }; void iox_set_loglevel ( enum iox_LogLevel level ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/log.h"},{"location":"API-reference/c-binding/Files/log_8h/#iceoryx_binding_clogh","text":"","title":"iceoryx_binding_c/log.h"},{"location":"API-reference/c-binding/Files/log_8h/#types","text":"Name enum iox_LogLevel { Iceoryx_LogLevel_Off = 0, Iceoryx_LogLevel_Verbose, Iceoryx_LogLevel_Debug, Iceoryx_LogLevel_Info, Iceoryx_LogLevel_Warn, Iceoryx_LogLevel_Error, Iceoryx_LogLevel_Fatal} available log levels of the iceoryx runtime","title":"Types"},{"location":"API-reference/c-binding/Files/log_8h/#functions","text":"Name void iox_set_loglevel (enum iox_LogLevel level) set the log level of the iceoryx runtime","title":"Functions"},{"location":"API-reference/c-binding/Files/log_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/log_8h/#enum-iox_loglevel","text":"Enumerator Value Description Iceoryx_LogLevel_Off 0 Iceoryx_LogLevel_Verbose Iceoryx_LogLevel_Debug Iceoryx_LogLevel_Info Iceoryx_LogLevel_Warn Iceoryx_LogLevel_Error Iceoryx_LogLevel_Fatal available log levels of the iceoryx runtime","title":"enum iox_LogLevel"},{"location":"API-reference/c-binding/Files/log_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/log_8h/#function-iox_set_loglevel","text":"void iox_set_loglevel ( enum iox_LogLevel level ) set the log level of the iceoryx runtime Parameters : level log level to be set Note : must be called before the runtime is initialized","title":"function iox_set_loglevel"},{"location":"API-reference/c-binding/Files/log_8h/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_LOG_H #define IOX_BINDING_C_LOG_H enum iox_LogLevel { Iceoryx_LogLevel_Off = 0 , Iceoryx_LogLevel_Verbose , Iceoryx_LogLevel_Debug , Iceoryx_LogLevel_Info , Iceoryx_LogLevel_Warn , Iceoryx_LogLevel_Error , Iceoryx_LogLevel_Fatal }; void iox_set_loglevel ( enum iox_LogLevel level ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/node_8h/","text":"iceoryx_binding_c/node.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS NodeData * iox_node_t Functions \ud83d\udd17 Name iox_node_t iox_node_create (const char *const nodeName) creates a node in the shared memory void iox_node_destroy (iox_node_t const self) removes a node from the shared memory uint64_t iox_node_get_name (iox_node_t const self, char *const name, const uint64_t nameCapacity) acquires the name of the node uint64_t iox_node_get_runtime_name (iox_node_t const self, char *const name, const uint64_t nameCapacity) acquires the name of the application's runtime in which the node is stored Types Documentation \ud83d\udd17 typedef iox_node_t \ud83d\udd17 typedef CLASS NodeData * iox_node_t ; Functions Documentation \ud83d\udd17 function iox_node_create \ud83d\udd17 iox_node_t iox_node_create ( const char * const nodeName ) creates a node in the shared memory Parameters : nodeName name of the node Return : handle to the node function iox_node_destroy \ud83d\udd17 void iox_node_destroy ( iox_node_t const self ) removes a node from the shared memory Parameters : self handle to the node function iox_node_get_name \ud83d\udd17 uint64_t iox_node_get_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ) acquires the name of the node Parameters : self handle to the node name pointer to a memory location where the name can be written to nameCapacity size of the memory location where the name is written to Return : the actual length of the node name, if the return value is greater then nameCapacity the name is truncated. If name is a nullptr, 0 will be returned. function iox_node_get_runtime_name \ud83d\udd17 uint64_t iox_node_get_runtime_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ) acquires the name of the application's runtime in which the node is stored Parameters : self handle to the node name pointer to a memory location where the name can be written to nameCapacity size of the memory location where the name is written to Return : the actual length of the runtime name, if the return value is greater than nameCapacity the name is truncated. If name is a nullptr, 0 will be returned. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_NODE_H #define IOX_BINDING_C_NODE_H #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" typedef CLASS NodeData * iox_node_t ; iox_node_t iox_node_create ( const char * const nodeName ); void iox_node_destroy ( iox_node_t const self ); uint64_t iox_node_get_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ); uint64_t iox_node_get_runtime_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/node.h"},{"location":"API-reference/c-binding/Files/node_8h/#iceoryx_binding_cnodeh","text":"","title":"iceoryx_binding_c/node.h"},{"location":"API-reference/c-binding/Files/node_8h/#types","text":"Name typedef CLASS NodeData * iox_node_t","title":"Types"},{"location":"API-reference/c-binding/Files/node_8h/#functions","text":"Name iox_node_t iox_node_create (const char *const nodeName) creates a node in the shared memory void iox_node_destroy (iox_node_t const self) removes a node from the shared memory uint64_t iox_node_get_name (iox_node_t const self, char *const name, const uint64_t nameCapacity) acquires the name of the node uint64_t iox_node_get_runtime_name (iox_node_t const self, char *const name, const uint64_t nameCapacity) acquires the name of the application's runtime in which the node is stored","title":"Functions"},{"location":"API-reference/c-binding/Files/node_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/node_8h/#typedef-iox_node_t","text":"typedef CLASS NodeData * iox_node_t ;","title":"typedef iox_node_t"},{"location":"API-reference/c-binding/Files/node_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_create","text":"iox_node_t iox_node_create ( const char * const nodeName ) creates a node in the shared memory Parameters : nodeName name of the node Return : handle to the node","title":"function iox_node_create"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_destroy","text":"void iox_node_destroy ( iox_node_t const self ) removes a node from the shared memory Parameters : self handle to the node","title":"function iox_node_destroy"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_get_name","text":"uint64_t iox_node_get_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ) acquires the name of the node Parameters : self handle to the node name pointer to a memory location where the name can be written to nameCapacity size of the memory location where the name is written to Return : the actual length of the node name, if the return value is greater then nameCapacity the name is truncated. If name is a nullptr, 0 will be returned.","title":"function iox_node_get_name"},{"location":"API-reference/c-binding/Files/node_8h/#function-iox_node_get_runtime_name","text":"uint64_t iox_node_get_runtime_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ) acquires the name of the application's runtime in which the node is stored Parameters : self handle to the node name pointer to a memory location where the name can be written to nameCapacity size of the memory location where the name is written to Return : the actual length of the runtime name, if the return value is greater than nameCapacity the name is truncated. If name is a nullptr, 0 will be returned.","title":"function iox_node_get_runtime_name"},{"location":"API-reference/c-binding/Files/node_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_NODE_H #define IOX_BINDING_C_NODE_H #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" typedef CLASS NodeData * iox_node_t ; iox_node_t iox_node_create ( const char * const nodeName ); void iox_node_destroy ( iox_node_t const self ); uint64_t iox_node_get_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ); uint64_t iox_node_get_runtime_name ( iox_node_t const self , char * const name , const uint64_t nameCapacity ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/notification__info_8h/","text":"iceoryx_binding_c/notification_info.h \ud83d\udd17 Functions \ud83d\udd17 Name uint64_t iox_notification_info_get_notification_id (iox_notification_info_t const self) returns the id of the notification bool iox_notification_info_does_originate_from_subscriber (iox_notification_info_t const self, iox_sub_t const subscriber) does the notification originate from a certain subscriber bool iox_notification_info_does_originate_from_user_trigger (iox_notification_info_t const self, iox_user_trigger_t const user_trigger) does the notification originate from a certain user trigger bool iox_notification_info_does_originate_from_client (iox_notification_info_t const self, iox_client_t const client) does the notification originate from a certain client bool iox_notification_info_does_originate_from_server (iox_notification_info_t const self, iox_server_t const server) does the notification originate from a certain server bool iox_notification_info_does_originate_from_service_discovery (iox_notification_info_t const self, iox_service_discovery_t const serviceDiscovery) does the notification originate from a certain service discovery iox_sub_t iox_notification_info_get_subscriber_origin (iox_notification_info_t const self) acquires the handle of the subscriber origin iox_user_trigger_t iox_notification_info_get_user_trigger_origin (iox_notification_info_t const self) acquires the handle of the user trigger origin iox_client_t iox_notification_info_get_client_origin (iox_notification_info_t const self) acquires the handle of the client origin iox_server_t iox_notification_info_get_server_origin (iox_notification_info_t const self) acquires the handle of the server origin iox_service_discovery_t iox_notification_info_get_service_discovery_origin (iox_notification_info_t const self) acquires the handle of the service discovery origin void iox_notification_info_call (iox_notification_info_t const self) calls the callback of the notification Attributes \ud83d\udd17 Name const typedef CLASS NotificationInfo * iox_notification_info_t notification info handle Functions Documentation \ud83d\udd17 function iox_notification_info_get_notification_id \ud83d\udd17 uint64_t iox_notification_info_get_notification_id ( iox_notification_info_t const self ) returns the id of the notification Parameters : self handle to notification info Return : notificationId function iox_notification_info_does_originate_from_subscriber \ud83d\udd17 bool iox_notification_info_does_originate_from_subscriber ( iox_notification_info_t const self , iox_sub_t const subscriber ) does the notification originate from a certain subscriber Parameters : self handle to notification info subscriber handle to the subscriber in question Return : true if the notification originates from the subscriber, otherwise false function iox_notification_info_does_originate_from_user_trigger \ud83d\udd17 bool iox_notification_info_does_originate_from_user_trigger ( iox_notification_info_t const self , iox_user_trigger_t const user_trigger ) does the notification originate from a certain user trigger Parameters : self handle to notification info user_trigger handle to the user trigger in question Return : true if the notification originates from the user trigger, otherwise false function iox_notification_info_does_originate_from_client \ud83d\udd17 bool iox_notification_info_does_originate_from_client ( iox_notification_info_t const self , iox_client_t const client ) does the notification originate from a certain client Parameters : self handle to notification info client handle to the client in question Return : true if the notification originates from the client, otherwise false function iox_notification_info_does_originate_from_server \ud83d\udd17 bool iox_notification_info_does_originate_from_server ( iox_notification_info_t const self , iox_server_t const server ) does the notification originate from a certain server Parameters : self handle to notification info server handle to the server in question Return : true if the notification originates from the server, otherwise false function iox_notification_info_does_originate_from_service_discovery \ud83d\udd17 bool iox_notification_info_does_originate_from_service_discovery ( iox_notification_info_t const self , iox_service_discovery_t const serviceDiscovery ) does the notification originate from a certain service discovery Parameters : self handle to notification info serviceDiscovery handle to serviceDiscovery in question Return : true if the notifiaction originates from the service discovery, otherwise false function iox_notification_info_get_subscriber_origin \ud83d\udd17 iox_sub_t iox_notification_info_get_subscriber_origin ( iox_notification_info_t const self ) acquires the handle of the subscriber origin Parameters : self handle to notification info Return : the handle to the subscriber if the notification originated from a subscriber, otherwise NULL function iox_notification_info_get_user_trigger_origin \ud83d\udd17 iox_user_trigger_t iox_notification_info_get_user_trigger_origin ( iox_notification_info_t const self ) acquires the handle of the user trigger origin Parameters : self handle to notification info Return : the handle to the user trigger if the notification originated from a user trigger, otherwise NULL function iox_notification_info_get_client_origin \ud83d\udd17 iox_client_t iox_notification_info_get_client_origin ( iox_notification_info_t const self ) acquires the handle of the client origin Parameters : self handle to notification info Return : the handle to the client if the notification originated from a client, otherwise NULL function iox_notification_info_get_server_origin \ud83d\udd17 iox_server_t iox_notification_info_get_server_origin ( iox_notification_info_t const self ) acquires the handle of the server origin Parameters : self handle to notification info Return : the handle to the server if the notification originated from a server, otherwise NULL function iox_notification_info_get_service_discovery_origin \ud83d\udd17 iox_service_discovery_t iox_notification_info_get_service_discovery_origin ( iox_notification_info_t const self ) acquires the handle of the service discovery origin Parameters : self handle to the notification info Return : the handle to the service discovery if the notification originated from a service discovery, otherwise NULL function iox_notification_info_call \ud83d\udd17 void iox_notification_info_call ( iox_notification_info_t const self ) calls the callback of the notification Parameters : self handle to notification info Attributes Documentation \ud83d\udd17 variable iox_notification_info_t \ud83d\udd17 const typedef CLASS NotificationInfo * iox_notification_info_t ; notification info handle Source code \ud83d\udd17 // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_EVENT_INFO_H #define IOX_BINDING_C_EVENT_INFO_H #include \"iceoryx_binding_c/client.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/server.h\" #include \"iceoryx_binding_c/service_discovery.h\" #include \"iceoryx_binding_c/subscriber.h\" #include \"iceoryx_binding_c/user_trigger.h\" typedef const CLASS NotificationInfo * iox_notification_info_t ; uint64_t iox_notification_info_get_notification_id ( iox_notification_info_t const self ); bool iox_notification_info_does_originate_from_subscriber ( iox_notification_info_t const self , iox_sub_t const subscriber ); bool iox_notification_info_does_originate_from_user_trigger ( iox_notification_info_t const self , iox_user_trigger_t const user_trigger ); bool iox_notification_info_does_originate_from_client ( iox_notification_info_t const self , iox_client_t const client ); bool iox_notification_info_does_originate_from_server ( iox_notification_info_t const self , iox_server_t const server ); bool iox_notification_info_does_originate_from_service_discovery ( iox_notification_info_t const self , iox_service_discovery_t const serviceDiscovery ); iox_sub_t iox_notification_info_get_subscriber_origin ( iox_notification_info_t const self ); iox_user_trigger_t iox_notification_info_get_user_trigger_origin ( iox_notification_info_t const self ); iox_client_t iox_notification_info_get_client_origin ( iox_notification_info_t const self ); iox_server_t iox_notification_info_get_server_origin ( iox_notification_info_t const self ); iox_service_discovery_t iox_notification_info_get_service_discovery_origin ( iox_notification_info_t const self ); void iox_notification_info_call ( iox_notification_info_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/notification_info.h"},{"location":"API-reference/c-binding/Files/notification__info_8h/#iceoryx_binding_cnotification_infoh","text":"","title":"iceoryx_binding_c/notification_info.h"},{"location":"API-reference/c-binding/Files/notification__info_8h/#functions","text":"Name uint64_t iox_notification_info_get_notification_id (iox_notification_info_t const self) returns the id of the notification bool iox_notification_info_does_originate_from_subscriber (iox_notification_info_t const self, iox_sub_t const subscriber) does the notification originate from a certain subscriber bool iox_notification_info_does_originate_from_user_trigger (iox_notification_info_t const self, iox_user_trigger_t const user_trigger) does the notification originate from a certain user trigger bool iox_notification_info_does_originate_from_client (iox_notification_info_t const self, iox_client_t const client) does the notification originate from a certain client bool iox_notification_info_does_originate_from_server (iox_notification_info_t const self, iox_server_t const server) does the notification originate from a certain server bool iox_notification_info_does_originate_from_service_discovery (iox_notification_info_t const self, iox_service_discovery_t const serviceDiscovery) does the notification originate from a certain service discovery iox_sub_t iox_notification_info_get_subscriber_origin (iox_notification_info_t const self) acquires the handle of the subscriber origin iox_user_trigger_t iox_notification_info_get_user_trigger_origin (iox_notification_info_t const self) acquires the handle of the user trigger origin iox_client_t iox_notification_info_get_client_origin (iox_notification_info_t const self) acquires the handle of the client origin iox_server_t iox_notification_info_get_server_origin (iox_notification_info_t const self) acquires the handle of the server origin iox_service_discovery_t iox_notification_info_get_service_discovery_origin (iox_notification_info_t const self) acquires the handle of the service discovery origin void iox_notification_info_call (iox_notification_info_t const self) calls the callback of the notification","title":"Functions"},{"location":"API-reference/c-binding/Files/notification__info_8h/#attributes","text":"Name const typedef CLASS NotificationInfo * iox_notification_info_t notification info handle","title":"Attributes"},{"location":"API-reference/c-binding/Files/notification__info_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_notification_id","text":"uint64_t iox_notification_info_get_notification_id ( iox_notification_info_t const self ) returns the id of the notification Parameters : self handle to notification info Return : notificationId","title":"function iox_notification_info_get_notification_id"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_subscriber","text":"bool iox_notification_info_does_originate_from_subscriber ( iox_notification_info_t const self , iox_sub_t const subscriber ) does the notification originate from a certain subscriber Parameters : self handle to notification info subscriber handle to the subscriber in question Return : true if the notification originates from the subscriber, otherwise false","title":"function iox_notification_info_does_originate_from_subscriber"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_user_trigger","text":"bool iox_notification_info_does_originate_from_user_trigger ( iox_notification_info_t const self , iox_user_trigger_t const user_trigger ) does the notification originate from a certain user trigger Parameters : self handle to notification info user_trigger handle to the user trigger in question Return : true if the notification originates from the user trigger, otherwise false","title":"function iox_notification_info_does_originate_from_user_trigger"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_client","text":"bool iox_notification_info_does_originate_from_client ( iox_notification_info_t const self , iox_client_t const client ) does the notification originate from a certain client Parameters : self handle to notification info client handle to the client in question Return : true if the notification originates from the client, otherwise false","title":"function iox_notification_info_does_originate_from_client"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_server","text":"bool iox_notification_info_does_originate_from_server ( iox_notification_info_t const self , iox_server_t const server ) does the notification originate from a certain server Parameters : self handle to notification info server handle to the server in question Return : true if the notification originates from the server, otherwise false","title":"function iox_notification_info_does_originate_from_server"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_does_originate_from_service_discovery","text":"bool iox_notification_info_does_originate_from_service_discovery ( iox_notification_info_t const self , iox_service_discovery_t const serviceDiscovery ) does the notification originate from a certain service discovery Parameters : self handle to notification info serviceDiscovery handle to serviceDiscovery in question Return : true if the notifiaction originates from the service discovery, otherwise false","title":"function iox_notification_info_does_originate_from_service_discovery"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_subscriber_origin","text":"iox_sub_t iox_notification_info_get_subscriber_origin ( iox_notification_info_t const self ) acquires the handle of the subscriber origin Parameters : self handle to notification info Return : the handle to the subscriber if the notification originated from a subscriber, otherwise NULL","title":"function iox_notification_info_get_subscriber_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_user_trigger_origin","text":"iox_user_trigger_t iox_notification_info_get_user_trigger_origin ( iox_notification_info_t const self ) acquires the handle of the user trigger origin Parameters : self handle to notification info Return : the handle to the user trigger if the notification originated from a user trigger, otherwise NULL","title":"function iox_notification_info_get_user_trigger_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_client_origin","text":"iox_client_t iox_notification_info_get_client_origin ( iox_notification_info_t const self ) acquires the handle of the client origin Parameters : self handle to notification info Return : the handle to the client if the notification originated from a client, otherwise NULL","title":"function iox_notification_info_get_client_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_server_origin","text":"iox_server_t iox_notification_info_get_server_origin ( iox_notification_info_t const self ) acquires the handle of the server origin Parameters : self handle to notification info Return : the handle to the server if the notification originated from a server, otherwise NULL","title":"function iox_notification_info_get_server_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_get_service_discovery_origin","text":"iox_service_discovery_t iox_notification_info_get_service_discovery_origin ( iox_notification_info_t const self ) acquires the handle of the service discovery origin Parameters : self handle to the notification info Return : the handle to the service discovery if the notification originated from a service discovery, otherwise NULL","title":"function iox_notification_info_get_service_discovery_origin"},{"location":"API-reference/c-binding/Files/notification__info_8h/#function-iox_notification_info_call","text":"void iox_notification_info_call ( iox_notification_info_t const self ) calls the callback of the notification Parameters : self handle to notification info","title":"function iox_notification_info_call"},{"location":"API-reference/c-binding/Files/notification__info_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/c-binding/Files/notification__info_8h/#variable-iox_notification_info_t","text":"const typedef CLASS NotificationInfo * iox_notification_info_t ; notification info handle","title":"variable iox_notification_info_t"},{"location":"API-reference/c-binding/Files/notification__info_8h/#source-code","text":"// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_EVENT_INFO_H #define IOX_BINDING_C_EVENT_INFO_H #include \"iceoryx_binding_c/client.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/server.h\" #include \"iceoryx_binding_c/service_discovery.h\" #include \"iceoryx_binding_c/subscriber.h\" #include \"iceoryx_binding_c/user_trigger.h\" typedef const CLASS NotificationInfo * iox_notification_info_t ; uint64_t iox_notification_info_get_notification_id ( iox_notification_info_t const self ); bool iox_notification_info_does_originate_from_subscriber ( iox_notification_info_t const self , iox_sub_t const subscriber ); bool iox_notification_info_does_originate_from_user_trigger ( iox_notification_info_t const self , iox_user_trigger_t const user_trigger ); bool iox_notification_info_does_originate_from_client ( iox_notification_info_t const self , iox_client_t const client ); bool iox_notification_info_does_originate_from_server ( iox_notification_info_t const self , iox_server_t const server ); bool iox_notification_info_does_originate_from_service_discovery ( iox_notification_info_t const self , iox_service_discovery_t const serviceDiscovery ); iox_sub_t iox_notification_info_get_subscriber_origin ( iox_notification_info_t const self ); iox_user_trigger_t iox_notification_info_get_user_trigger_origin ( iox_notification_info_t const self ); iox_client_t iox_notification_info_get_client_origin ( iox_notification_info_t const self ); iox_server_t iox_notification_info_get_server_origin ( iox_notification_info_t const self ); iox_service_discovery_t iox_notification_info_get_service_discovery_origin ( iox_notification_info_t const self ); void iox_notification_info_call ( iox_notification_info_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/publisher_8h/","text":"iceoryx_binding_c/publisher.h \ud83d\udd17 Classes \ud83d\udd17 Name struct iox_pub_options_t options to be set for a publisher Types \ud83d\udd17 Name typedef struct cpp2c_Publisher * iox_pub_t publisher handle Functions \ud83d\udd17 Name void iox_pub_options_init ( iox_pub_options_t * options) initialize publisher options to default values bool iox_pub_options_is_initialized (const iox_pub_options_t *const options) check whether the publisher options were initialized by iox_pub_options_init iox_pub_t iox_pub_init ( iox_pub_storage_t * self, const char const service, const char const instance, const char const event, const iox_pub_options_t const options) creates a publisher handle void iox_pub_deinit (iox_pub_t const self) removes a publisher handle ENUM iox_AllocationResult iox_pub_loan_chunk (iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize) allocates a chunk in the shared memory ENUM iox_AllocationResult iox_pub_loan_aligned_chunk (iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize, const uint32_t userPayloadAlignment) allocates a chunk in the shared memory with a custom alignment for the user-payload ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header (iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize, const uint32_t userPayloadAlignment, const uint32_t userHeaderSize, const uint32_t userHeaderAlignment) allocates a chunk in the shared memory with a section for the user-header and a custom alignment for the user-payload void iox_pub_release_chunk (iox_pub_t const self, void *const userPayload) releases ownership of a previously allocated chunk without sending it void iox_pub_publish_chunk (iox_pub_t const self, void *const userPayload) sends a previously allocated chunk void iox_pub_offer (iox_pub_t const self) offers the service void iox_pub_stop_offer (iox_pub_t const self) stop offering the service bool iox_pub_is_offered (iox_pub_t const self) is the service still offered bool iox_pub_has_subscribers (iox_pub_t const self) does the service have subscribers iox_service_description_t iox_pub_get_service_description (iox_pub_t const self) returns the service description of the publisher Types Documentation \ud83d\udd17 typedef iox_pub_t \ud83d\udd17 typedef struct cpp2c_Publisher * iox_pub_t ; publisher handle Functions Documentation \ud83d\udd17 function iox_pub_options_init \ud83d\udd17 void iox_pub_options_init ( iox_pub_options_t * options ) initialize publisher options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. function iox_pub_options_is_initialized \ud83d\udd17 bool iox_pub_options_is_initialized ( const iox_pub_options_t * const options ) check whether the publisher options were initialized by iox_pub_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise function iox_pub_init \ud83d\udd17 iox_pub_t iox_pub_init ( iox_pub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_pub_options_t * const options ) creates a publisher handle Parameters : self pointer to preallocated memory of size = sizeof(iox_pub_storage_t) service serviceString instance instanceString event eventString options publisher options set by the user, if it is a null pointer default options are used Return : handle of the publisher function iox_pub_deinit \ud83d\udd17 void iox_pub_deinit ( iox_pub_t const self ) removes a publisher handle Parameters : self the handle which should be removed function iox_pub_loan_chunk \ud83d\udd17 ENUM iox_AllocationResult iox_pub_loan_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize ) allocates a chunk in the shared memory Parameters : self handle of the publisher userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored userPayloadSize user-payload size of the allocated chunk Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error Note : for the user-payload alignment IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT is used for a custom user-payload alignment please use iox_pub_loan_aligned_chunk function iox_pub_loan_aligned_chunk \ud83d\udd17 ENUM iox_AllocationResult iox_pub_loan_aligned_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment ) allocates a chunk in the shared memory with a custom alignment for the user-payload Parameters : self handle of the publisher userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored userPayloadSize user-payload size of the allocated chunk userPayloadAlignment user-payload alignment of the allocated chunk Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error function iox_pub_loan_aligned_chunk_with_user_header \ud83d\udd17 ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize , const uint32_t userHeaderAlignment ) allocates a chunk in the shared memory with a section for the user-header and a custom alignment for the user-payload Parameters : self handle of the publisher userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored userPayloadSize user-payload size of the allocated chunk userPayloadAlignment user-payload alignment of the allocated chunk userHeaderSize user-header size of the allocated chunk userHeaderAlignment user-header alignment of the allocated chunk Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error function iox_pub_release_chunk \ud83d\udd17 void iox_pub_release_chunk ( iox_pub_t const self , void * const userPayload ) releases ownership of a previously allocated chunk without sending it Parameters : self handle of the publisher userPayload pointer to the user-payload of the chunk which should be free'd function iox_pub_publish_chunk \ud83d\udd17 void iox_pub_publish_chunk ( iox_pub_t const self , void * const userPayload ) sends a previously allocated chunk Parameters : self handle of the publisher userPayload pointer to the user-payload of the chunk which should be send function iox_pub_offer \ud83d\udd17 void iox_pub_offer ( iox_pub_t const self ) offers the service Parameters : self handle of the publisher function iox_pub_stop_offer \ud83d\udd17 void iox_pub_stop_offer ( iox_pub_t const self ) stop offering the service Parameters : self handle of the publisher function iox_pub_is_offered \ud83d\udd17 bool iox_pub_is_offered ( iox_pub_t const self ) is the service still offered Parameters : self handle of the publisher Return : true is the service is offered otherwise false function iox_pub_has_subscribers \ud83d\udd17 bool iox_pub_has_subscribers ( iox_pub_t const self ) does the service have subscribers Parameters : self handle of the publisher Return : true if there are subscribers otherwise false function iox_pub_get_service_description \ud83d\udd17 iox_service_description_t iox_pub_get_service_description ( iox_pub_t const self ) returns the service description of the publisher Parameters : self handle to the publisher Return : the service description Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_PUBLISHER_H #define IOX_BINDING_C_PUBLISHER_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef struct cpp2c_Publisher * iox_pub_t ; typedef struct { uint64_t historyCapacity ; const char * nodeName ; bool offerOnCreate ; ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy ; uint64_t initCheck ; } iox_pub_options_t ; void iox_pub_options_init ( iox_pub_options_t * options ); bool iox_pub_options_is_initialized ( const iox_pub_options_t * const options ); iox_pub_t iox_pub_init ( iox_pub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_pub_options_t * const options ); void iox_pub_deinit ( iox_pub_t const self ); ENUM iox_AllocationResult iox_pub_loan_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize ); ENUM iox_AllocationResult iox_pub_loan_aligned_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment ); ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize , const uint32_t userHeaderAlignment ); void iox_pub_release_chunk ( iox_pub_t const self , void * const userPayload ); void iox_pub_publish_chunk ( iox_pub_t const self , void * const userPayload ); void iox_pub_offer ( iox_pub_t const self ); void iox_pub_stop_offer ( iox_pub_t const self ); bool iox_pub_is_offered ( iox_pub_t const self ); bool iox_pub_has_subscribers ( iox_pub_t const self ); iox_service_description_t iox_pub_get_service_description ( iox_pub_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/publisher.h"},{"location":"API-reference/c-binding/Files/publisher_8h/#iceoryx_binding_cpublisherh","text":"","title":"iceoryx_binding_c/publisher.h"},{"location":"API-reference/c-binding/Files/publisher_8h/#classes","text":"Name struct iox_pub_options_t options to be set for a publisher","title":"Classes"},{"location":"API-reference/c-binding/Files/publisher_8h/#types","text":"Name typedef struct cpp2c_Publisher * iox_pub_t publisher handle","title":"Types"},{"location":"API-reference/c-binding/Files/publisher_8h/#functions","text":"Name void iox_pub_options_init ( iox_pub_options_t * options) initialize publisher options to default values bool iox_pub_options_is_initialized (const iox_pub_options_t *const options) check whether the publisher options were initialized by iox_pub_options_init iox_pub_t iox_pub_init ( iox_pub_storage_t * self, const char const service, const char const instance, const char const event, const iox_pub_options_t const options) creates a publisher handle void iox_pub_deinit (iox_pub_t const self) removes a publisher handle ENUM iox_AllocationResult iox_pub_loan_chunk (iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize) allocates a chunk in the shared memory ENUM iox_AllocationResult iox_pub_loan_aligned_chunk (iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize, const uint32_t userPayloadAlignment) allocates a chunk in the shared memory with a custom alignment for the user-payload ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header (iox_pub_t const self, void **const userPayload, const uint32_t userPayloadSize, const uint32_t userPayloadAlignment, const uint32_t userHeaderSize, const uint32_t userHeaderAlignment) allocates a chunk in the shared memory with a section for the user-header and a custom alignment for the user-payload void iox_pub_release_chunk (iox_pub_t const self, void *const userPayload) releases ownership of a previously allocated chunk without sending it void iox_pub_publish_chunk (iox_pub_t const self, void *const userPayload) sends a previously allocated chunk void iox_pub_offer (iox_pub_t const self) offers the service void iox_pub_stop_offer (iox_pub_t const self) stop offering the service bool iox_pub_is_offered (iox_pub_t const self) is the service still offered bool iox_pub_has_subscribers (iox_pub_t const self) does the service have subscribers iox_service_description_t iox_pub_get_service_description (iox_pub_t const self) returns the service description of the publisher","title":"Functions"},{"location":"API-reference/c-binding/Files/publisher_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/publisher_8h/#typedef-iox_pub_t","text":"typedef struct cpp2c_Publisher * iox_pub_t ; publisher handle","title":"typedef iox_pub_t"},{"location":"API-reference/c-binding/Files/publisher_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_options_init","text":"void iox_pub_options_init ( iox_pub_options_t * options ) initialize publisher options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future.","title":"function iox_pub_options_init"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_options_is_initialized","text":"bool iox_pub_options_is_initialized ( const iox_pub_options_t * const options ) check whether the publisher options were initialized by iox_pub_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise","title":"function iox_pub_options_is_initialized"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_init","text":"iox_pub_t iox_pub_init ( iox_pub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_pub_options_t * const options ) creates a publisher handle Parameters : self pointer to preallocated memory of size = sizeof(iox_pub_storage_t) service serviceString instance instanceString event eventString options publisher options set by the user, if it is a null pointer default options are used Return : handle of the publisher","title":"function iox_pub_init"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_deinit","text":"void iox_pub_deinit ( iox_pub_t const self ) removes a publisher handle Parameters : self the handle which should be removed","title":"function iox_pub_deinit"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_loan_chunk","text":"ENUM iox_AllocationResult iox_pub_loan_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize ) allocates a chunk in the shared memory Parameters : self handle of the publisher userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored userPayloadSize user-payload size of the allocated chunk Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error Note : for the user-payload alignment IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT is used for a custom user-payload alignment please use iox_pub_loan_aligned_chunk","title":"function iox_pub_loan_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_loan_aligned_chunk","text":"ENUM iox_AllocationResult iox_pub_loan_aligned_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment ) allocates a chunk in the shared memory with a custom alignment for the user-payload Parameters : self handle of the publisher userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored userPayloadSize user-payload size of the allocated chunk userPayloadAlignment user-payload alignment of the allocated chunk Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error","title":"function iox_pub_loan_aligned_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_loan_aligned_chunk_with_user_header","text":"ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize , const uint32_t userHeaderAlignment ) allocates a chunk in the shared memory with a section for the user-header and a custom alignment for the user-payload Parameters : self handle of the publisher userPayload pointer in which a pointer to the user-payload of the allocated chunk is stored userPayloadSize user-payload size of the allocated chunk userPayloadAlignment user-payload alignment of the allocated chunk userHeaderSize user-header size of the allocated chunk userHeaderAlignment user-header alignment of the allocated chunk Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error","title":"function iox_pub_loan_aligned_chunk_with_user_header"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_release_chunk","text":"void iox_pub_release_chunk ( iox_pub_t const self , void * const userPayload ) releases ownership of a previously allocated chunk without sending it Parameters : self handle of the publisher userPayload pointer to the user-payload of the chunk which should be free'd","title":"function iox_pub_release_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_publish_chunk","text":"void iox_pub_publish_chunk ( iox_pub_t const self , void * const userPayload ) sends a previously allocated chunk Parameters : self handle of the publisher userPayload pointer to the user-payload of the chunk which should be send","title":"function iox_pub_publish_chunk"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_offer","text":"void iox_pub_offer ( iox_pub_t const self ) offers the service Parameters : self handle of the publisher","title":"function iox_pub_offer"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_stop_offer","text":"void iox_pub_stop_offer ( iox_pub_t const self ) stop offering the service Parameters : self handle of the publisher","title":"function iox_pub_stop_offer"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_is_offered","text":"bool iox_pub_is_offered ( iox_pub_t const self ) is the service still offered Parameters : self handle of the publisher Return : true is the service is offered otherwise false","title":"function iox_pub_is_offered"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_has_subscribers","text":"bool iox_pub_has_subscribers ( iox_pub_t const self ) does the service have subscribers Parameters : self handle of the publisher Return : true if there are subscribers otherwise false","title":"function iox_pub_has_subscribers"},{"location":"API-reference/c-binding/Files/publisher_8h/#function-iox_pub_get_service_description","text":"iox_service_description_t iox_pub_get_service_description ( iox_pub_t const self ) returns the service description of the publisher Parameters : self handle to the publisher Return : the service description","title":"function iox_pub_get_service_description"},{"location":"API-reference/c-binding/Files/publisher_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_PUBLISHER_H #define IOX_BINDING_C_PUBLISHER_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef struct cpp2c_Publisher * iox_pub_t ; typedef struct { uint64_t historyCapacity ; const char * nodeName ; bool offerOnCreate ; ENUM iox_ConsumerTooSlowPolicy subscriberTooSlowPolicy ; uint64_t initCheck ; } iox_pub_options_t ; void iox_pub_options_init ( iox_pub_options_t * options ); bool iox_pub_options_is_initialized ( const iox_pub_options_t * const options ); iox_pub_t iox_pub_init ( iox_pub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_pub_options_t * const options ); void iox_pub_deinit ( iox_pub_t const self ); ENUM iox_AllocationResult iox_pub_loan_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize ); ENUM iox_AllocationResult iox_pub_loan_aligned_chunk ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment ); ENUM iox_AllocationResult iox_pub_loan_aligned_chunk_with_user_header ( iox_pub_t const self , void ** const userPayload , const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize , const uint32_t userHeaderAlignment ); void iox_pub_release_chunk ( iox_pub_t const self , void * const userPayload ); void iox_pub_publish_chunk ( iox_pub_t const self , void * const userPayload ); void iox_pub_offer ( iox_pub_t const self ); void iox_pub_stop_offer ( iox_pub_t const self ); bool iox_pub_is_offered ( iox_pub_t const self ); bool iox_pub_has_subscribers ( iox_pub_t const self ); iox_service_description_t iox_pub_get_service_description ( iox_pub_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/request__header_8h/","text":"iceoryx_binding_c/request_header.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS RequestHeader * iox_request_header_t request header handle Functions \ud83d\udd17 Name iox_request_header_t iox_request_header_from_payload (void *const payload) extract the request header from a given payload iox_const_request_header_t iox_request_header_from_payload_const (const void *const payload) extract the request header from a given payload void iox_request_header_set_sequence_id (iox_request_header_t const self, const int64_t sequenceId) set the sequence id of the request header uint8_t iox_request_header_get_rpc_header_version (iox_request_header_t const self) returns the rpc header version uint8_t iox_request_header_get_rpc_header_version_const (iox_const_request_header_t const self) returns the rpc header version int64_t iox_request_header_get_sequence_id (iox_request_header_t const self) returns the sequence id int64_t iox_request_header_get_sequence_id_const (iox_const_request_header_t const self) returns the sequence id void * iox_request_header_get_user_payload (iox_request_header_t const self) returns a pointer to the user payload const void * iox_request_header_get_user_payload_const (iox_const_request_header_t const self) returns a pointer to the user payload iox_chunk_header_t * iox_request_header_get_chunk_header (iox_request_header_t const self) returns a pointer to the chunk header const iox_chunk_header_t * iox_request_header_get_chunk_header_const (iox_const_request_header_t const self) returns a pointer to the chunk header Attributes \ud83d\udd17 Name const typedef CLASS RequestHeader * iox_const_request_header_t const request header handle Types Documentation \ud83d\udd17 typedef iox_request_header_t \ud83d\udd17 typedef CLASS RequestHeader * iox_request_header_t ; request header handle Functions Documentation \ud83d\udd17 function iox_request_header_from_payload \ud83d\udd17 iox_request_header_t iox_request_header_from_payload ( void * const payload ) extract the request header from a given payload Parameters : payload the pointer to the payload Return : a handle to the request header function iox_request_header_from_payload_const \ud83d\udd17 iox_const_request_header_t iox_request_header_from_payload_const ( const void * const payload ) extract the request header from a given payload Parameters : payload the pointer to the payload Return : a handle to the request header function iox_request_header_set_sequence_id \ud83d\udd17 void iox_request_header_set_sequence_id ( iox_request_header_t const self , const int64_t sequenceId ) set the sequence id of the request header Parameters : self handle to the request header sequenceId the new sequence id value function iox_request_header_get_rpc_header_version \ud83d\udd17 uint8_t iox_request_header_get_rpc_header_version ( iox_request_header_t const self ) returns the rpc header version Parameters : self handle to the request header Return : rpc header version function iox_request_header_get_rpc_header_version_const \ud83d\udd17 uint8_t iox_request_header_get_rpc_header_version_const ( iox_const_request_header_t const self ) returns the rpc header version Parameters : self handle to the request header Return : rpc header version function iox_request_header_get_sequence_id \ud83d\udd17 int64_t iox_request_header_get_sequence_id ( iox_request_header_t const self ) returns the sequence id Parameters : self handle to the request header Return : sequence id function iox_request_header_get_sequence_id_const \ud83d\udd17 int64_t iox_request_header_get_sequence_id_const ( iox_const_request_header_t const self ) returns the sequence id Parameters : self handle to the request header Return : sequence id function iox_request_header_get_user_payload \ud83d\udd17 void * iox_request_header_get_user_payload ( iox_request_header_t const self ) returns a pointer to the user payload Parameters : self handle to the request header Return : pointer to the payload function iox_request_header_get_user_payload_const \ud83d\udd17 const void * iox_request_header_get_user_payload_const ( iox_const_request_header_t const self ) returns a pointer to the user payload Parameters : self handle to the request header Return : pointer to the payload function iox_request_header_get_chunk_header \ud83d\udd17 iox_chunk_header_t * iox_request_header_get_chunk_header ( iox_request_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the request header Return : pointer to the chunk header function iox_request_header_get_chunk_header_const \ud83d\udd17 const iox_chunk_header_t * iox_request_header_get_chunk_header_const ( iox_const_request_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the request header Return : pointer to the chunk header Attributes Documentation \ud83d\udd17 variable iox_const_request_header_t \ud83d\udd17 const typedef CLASS RequestHeader * iox_const_request_header_t ; const request header handle Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_REQUEST_HEADER_H #define IOX_BINDING_C_REQUEST_HEADER_H #include \"iceoryx_binding_c/chunk.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" typedef CLASS RequestHeader * iox_request_header_t ; typedef const CLASS RequestHeader * iox_const_request_header_t ; iox_request_header_t iox_request_header_from_payload ( void * const payload ); iox_const_request_header_t iox_request_header_from_payload_const ( const void * const payload ); void iox_request_header_set_sequence_id ( iox_request_header_t const self , const int64_t sequenceId ); uint8_t iox_request_header_get_rpc_header_version ( iox_request_header_t const self ); uint8_t iox_request_header_get_rpc_header_version_const ( iox_const_request_header_t const self ); int64_t iox_request_header_get_sequence_id ( iox_request_header_t const self ); int64_t iox_request_header_get_sequence_id_const ( iox_const_request_header_t const self ); void * iox_request_header_get_user_payload ( iox_request_header_t const self ); const void * iox_request_header_get_user_payload_const ( iox_const_request_header_t const self ); iox_chunk_header_t * iox_request_header_get_chunk_header ( iox_request_header_t const self ); const iox_chunk_header_t * iox_request_header_get_chunk_header_const ( iox_const_request_header_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/request_header.h"},{"location":"API-reference/c-binding/Files/request__header_8h/#iceoryx_binding_crequest_headerh","text":"","title":"iceoryx_binding_c/request_header.h"},{"location":"API-reference/c-binding/Files/request__header_8h/#types","text":"Name typedef CLASS RequestHeader * iox_request_header_t request header handle","title":"Types"},{"location":"API-reference/c-binding/Files/request__header_8h/#functions","text":"Name iox_request_header_t iox_request_header_from_payload (void *const payload) extract the request header from a given payload iox_const_request_header_t iox_request_header_from_payload_const (const void *const payload) extract the request header from a given payload void iox_request_header_set_sequence_id (iox_request_header_t const self, const int64_t sequenceId) set the sequence id of the request header uint8_t iox_request_header_get_rpc_header_version (iox_request_header_t const self) returns the rpc header version uint8_t iox_request_header_get_rpc_header_version_const (iox_const_request_header_t const self) returns the rpc header version int64_t iox_request_header_get_sequence_id (iox_request_header_t const self) returns the sequence id int64_t iox_request_header_get_sequence_id_const (iox_const_request_header_t const self) returns the sequence id void * iox_request_header_get_user_payload (iox_request_header_t const self) returns a pointer to the user payload const void * iox_request_header_get_user_payload_const (iox_const_request_header_t const self) returns a pointer to the user payload iox_chunk_header_t * iox_request_header_get_chunk_header (iox_request_header_t const self) returns a pointer to the chunk header const iox_chunk_header_t * iox_request_header_get_chunk_header_const (iox_const_request_header_t const self) returns a pointer to the chunk header","title":"Functions"},{"location":"API-reference/c-binding/Files/request__header_8h/#attributes","text":"Name const typedef CLASS RequestHeader * iox_const_request_header_t const request header handle","title":"Attributes"},{"location":"API-reference/c-binding/Files/request__header_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/request__header_8h/#typedef-iox_request_header_t","text":"typedef CLASS RequestHeader * iox_request_header_t ; request header handle","title":"typedef iox_request_header_t"},{"location":"API-reference/c-binding/Files/request__header_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_from_payload","text":"iox_request_header_t iox_request_header_from_payload ( void * const payload ) extract the request header from a given payload Parameters : payload the pointer to the payload Return : a handle to the request header","title":"function iox_request_header_from_payload"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_from_payload_const","text":"iox_const_request_header_t iox_request_header_from_payload_const ( const void * const payload ) extract the request header from a given payload Parameters : payload the pointer to the payload Return : a handle to the request header","title":"function iox_request_header_from_payload_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_set_sequence_id","text":"void iox_request_header_set_sequence_id ( iox_request_header_t const self , const int64_t sequenceId ) set the sequence id of the request header Parameters : self handle to the request header sequenceId the new sequence id value","title":"function iox_request_header_set_sequence_id"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_rpc_header_version","text":"uint8_t iox_request_header_get_rpc_header_version ( iox_request_header_t const self ) returns the rpc header version Parameters : self handle to the request header Return : rpc header version","title":"function iox_request_header_get_rpc_header_version"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_rpc_header_version_const","text":"uint8_t iox_request_header_get_rpc_header_version_const ( iox_const_request_header_t const self ) returns the rpc header version Parameters : self handle to the request header Return : rpc header version","title":"function iox_request_header_get_rpc_header_version_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_sequence_id","text":"int64_t iox_request_header_get_sequence_id ( iox_request_header_t const self ) returns the sequence id Parameters : self handle to the request header Return : sequence id","title":"function iox_request_header_get_sequence_id"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_sequence_id_const","text":"int64_t iox_request_header_get_sequence_id_const ( iox_const_request_header_t const self ) returns the sequence id Parameters : self handle to the request header Return : sequence id","title":"function iox_request_header_get_sequence_id_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_user_payload","text":"void * iox_request_header_get_user_payload ( iox_request_header_t const self ) returns a pointer to the user payload Parameters : self handle to the request header Return : pointer to the payload","title":"function iox_request_header_get_user_payload"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_user_payload_const","text":"const void * iox_request_header_get_user_payload_const ( iox_const_request_header_t const self ) returns a pointer to the user payload Parameters : self handle to the request header Return : pointer to the payload","title":"function iox_request_header_get_user_payload_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_chunk_header","text":"iox_chunk_header_t * iox_request_header_get_chunk_header ( iox_request_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the request header Return : pointer to the chunk header","title":"function iox_request_header_get_chunk_header"},{"location":"API-reference/c-binding/Files/request__header_8h/#function-iox_request_header_get_chunk_header_const","text":"const iox_chunk_header_t * iox_request_header_get_chunk_header_const ( iox_const_request_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the request header Return : pointer to the chunk header","title":"function iox_request_header_get_chunk_header_const"},{"location":"API-reference/c-binding/Files/request__header_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/c-binding/Files/request__header_8h/#variable-iox_const_request_header_t","text":"const typedef CLASS RequestHeader * iox_const_request_header_t ; const request header handle","title":"variable iox_const_request_header_t"},{"location":"API-reference/c-binding/Files/request__header_8h/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_REQUEST_HEADER_H #define IOX_BINDING_C_REQUEST_HEADER_H #include \"iceoryx_binding_c/chunk.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" typedef CLASS RequestHeader * iox_request_header_t ; typedef const CLASS RequestHeader * iox_const_request_header_t ; iox_request_header_t iox_request_header_from_payload ( void * const payload ); iox_const_request_header_t iox_request_header_from_payload_const ( const void * const payload ); void iox_request_header_set_sequence_id ( iox_request_header_t const self , const int64_t sequenceId ); uint8_t iox_request_header_get_rpc_header_version ( iox_request_header_t const self ); uint8_t iox_request_header_get_rpc_header_version_const ( iox_const_request_header_t const self ); int64_t iox_request_header_get_sequence_id ( iox_request_header_t const self ); int64_t iox_request_header_get_sequence_id_const ( iox_const_request_header_t const self ); void * iox_request_header_get_user_payload ( iox_request_header_t const self ); const void * iox_request_header_get_user_payload_const ( iox_const_request_header_t const self ); iox_chunk_header_t * iox_request_header_get_chunk_header ( iox_request_header_t const self ); const iox_chunk_header_t * iox_request_header_get_chunk_header_const ( iox_const_request_header_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/response__header_8h/","text":"iceoryx_binding_c/response_header.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS ResponseHeader * iox_response_header_t response header handle Functions \ud83d\udd17 Name iox_response_header_t iox_response_header_from_payload (void *const payload) extract the response header from a given payload iox_const_response_header_t iox_response_header_from_payload_const (const void *const payload) extract the response header from a given payload void iox_response_header_set_server_error (iox_response_header_t const self) set the response header into server error state bool iox_response_header_has_server_error (iox_response_header_t const self) is the response header in an error state bool iox_response_header_has_server_error_const (iox_const_response_header_t const self) is the response header in an error state uint8_t iox_response_header_get_rpc_header_version (iox_response_header_t const self) returns the rpc header version uint8_t iox_response_header_get_rpc_header_version_const (iox_const_response_header_t const self) returns the rpc header version int64_t iox_response_header_get_sequence_id (iox_response_header_t const self) returns the sequence id int64_t iox_response_header_get_sequence_id_const (iox_const_response_header_t const self) returns the sequence id void * iox_response_header_get_user_payload (iox_response_header_t const self) returns a pointer to the user payload const void * iox_response_header_get_user_payload_const (iox_const_response_header_t const self) returns a pointer to the user payload iox_chunk_header_t * iox_response_header_get_chunk_header (iox_response_header_t const self) returns a pointer to the chunk header const iox_chunk_header_t * iox_response_header_get_chunk_header_const (iox_const_response_header_t const self) returns a pointer to the chunk header Attributes \ud83d\udd17 Name const typedef CLASS ResponseHeader * iox_const_response_header_t const response header handle Types Documentation \ud83d\udd17 typedef iox_response_header_t \ud83d\udd17 typedef CLASS ResponseHeader * iox_response_header_t ; response header handle Functions Documentation \ud83d\udd17 function iox_response_header_from_payload \ud83d\udd17 iox_response_header_t iox_response_header_from_payload ( void * const payload ) extract the response header from a given payload Parameters : payload the pointer to the payload Return : a handle to the response header function iox_response_header_from_payload_const \ud83d\udd17 iox_const_response_header_t iox_response_header_from_payload_const ( const void * const payload ) extract the response header from a given payload Parameters : payload the pointer to the payload Return : a handle to the response header function iox_response_header_set_server_error \ud83d\udd17 void iox_response_header_set_server_error ( iox_response_header_t const self ) set the response header into server error state Parameters : self handle to the response header function iox_response_header_has_server_error \ud83d\udd17 bool iox_response_header_has_server_error ( iox_response_header_t const self ) is the response header in an error state Parameters : self handle to the response header Return : true if it is in an error state, otherwise false function iox_response_header_has_server_error_const \ud83d\udd17 bool iox_response_header_has_server_error_const ( iox_const_response_header_t const self ) is the response header in an error state Parameters : self handle to the response header Return : true if it is in an error state, otherwise false function iox_response_header_get_rpc_header_version \ud83d\udd17 uint8_t iox_response_header_get_rpc_header_version ( iox_response_header_t const self ) returns the rpc header version Parameters : self handle to the response header Return : rpc header version function iox_response_header_get_rpc_header_version_const \ud83d\udd17 uint8_t iox_response_header_get_rpc_header_version_const ( iox_const_response_header_t const self ) returns the rpc header version Parameters : self handle to the response header Return : rpc header version function iox_response_header_get_sequence_id \ud83d\udd17 int64_t iox_response_header_get_sequence_id ( iox_response_header_t const self ) returns the sequence id Parameters : self handle to the response header Return : sequence id function iox_response_header_get_sequence_id_const \ud83d\udd17 int64_t iox_response_header_get_sequence_id_const ( iox_const_response_header_t const self ) returns the sequence id Parameters : self handle to the response header Return : sequence id function iox_response_header_get_user_payload \ud83d\udd17 void * iox_response_header_get_user_payload ( iox_response_header_t const self ) returns a pointer to the user payload Parameters : self handle to the response header Return : pointer to the payload function iox_response_header_get_user_payload_const \ud83d\udd17 const void * iox_response_header_get_user_payload_const ( iox_const_response_header_t const self ) returns a pointer to the user payload Parameters : self handle to the response header Return : pointer to the payload function iox_response_header_get_chunk_header \ud83d\udd17 iox_chunk_header_t * iox_response_header_get_chunk_header ( iox_response_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the response header Return : pointer to the chunk header function iox_response_header_get_chunk_header_const \ud83d\udd17 const iox_chunk_header_t * iox_response_header_get_chunk_header_const ( iox_const_response_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the response header Return : pointer to the chunk header Attributes Documentation \ud83d\udd17 variable iox_const_response_header_t \ud83d\udd17 const typedef CLASS ResponseHeader * iox_const_response_header_t ; const response header handle Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_RESPONSE_HEADER_H #define IOX_BINDING_C_RESPONSE_HEADER_H #include \"iceoryx_binding_c/chunk.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" typedef CLASS ResponseHeader * iox_response_header_t ; typedef const CLASS ResponseHeader * iox_const_response_header_t ; iox_response_header_t iox_response_header_from_payload ( void * const payload ); iox_const_response_header_t iox_response_header_from_payload_const ( const void * const payload ); void iox_response_header_set_server_error ( iox_response_header_t const self ); bool iox_response_header_has_server_error ( iox_response_header_t const self ); bool iox_response_header_has_server_error_const ( iox_const_response_header_t const self ); uint8_t iox_response_header_get_rpc_header_version ( iox_response_header_t const self ); uint8_t iox_response_header_get_rpc_header_version_const ( iox_const_response_header_t const self ); int64_t iox_response_header_get_sequence_id ( iox_response_header_t const self ); int64_t iox_response_header_get_sequence_id_const ( iox_const_response_header_t const self ); void * iox_response_header_get_user_payload ( iox_response_header_t const self ); const void * iox_response_header_get_user_payload_const ( iox_const_response_header_t const self ); iox_chunk_header_t * iox_response_header_get_chunk_header ( iox_response_header_t const self ); const iox_chunk_header_t * iox_response_header_get_chunk_header_const ( iox_const_response_header_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/response_header.h"},{"location":"API-reference/c-binding/Files/response__header_8h/#iceoryx_binding_cresponse_headerh","text":"","title":"iceoryx_binding_c/response_header.h"},{"location":"API-reference/c-binding/Files/response__header_8h/#types","text":"Name typedef CLASS ResponseHeader * iox_response_header_t response header handle","title":"Types"},{"location":"API-reference/c-binding/Files/response__header_8h/#functions","text":"Name iox_response_header_t iox_response_header_from_payload (void *const payload) extract the response header from a given payload iox_const_response_header_t iox_response_header_from_payload_const (const void *const payload) extract the response header from a given payload void iox_response_header_set_server_error (iox_response_header_t const self) set the response header into server error state bool iox_response_header_has_server_error (iox_response_header_t const self) is the response header in an error state bool iox_response_header_has_server_error_const (iox_const_response_header_t const self) is the response header in an error state uint8_t iox_response_header_get_rpc_header_version (iox_response_header_t const self) returns the rpc header version uint8_t iox_response_header_get_rpc_header_version_const (iox_const_response_header_t const self) returns the rpc header version int64_t iox_response_header_get_sequence_id (iox_response_header_t const self) returns the sequence id int64_t iox_response_header_get_sequence_id_const (iox_const_response_header_t const self) returns the sequence id void * iox_response_header_get_user_payload (iox_response_header_t const self) returns a pointer to the user payload const void * iox_response_header_get_user_payload_const (iox_const_response_header_t const self) returns a pointer to the user payload iox_chunk_header_t * iox_response_header_get_chunk_header (iox_response_header_t const self) returns a pointer to the chunk header const iox_chunk_header_t * iox_response_header_get_chunk_header_const (iox_const_response_header_t const self) returns a pointer to the chunk header","title":"Functions"},{"location":"API-reference/c-binding/Files/response__header_8h/#attributes","text":"Name const typedef CLASS ResponseHeader * iox_const_response_header_t const response header handle","title":"Attributes"},{"location":"API-reference/c-binding/Files/response__header_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/response__header_8h/#typedef-iox_response_header_t","text":"typedef CLASS ResponseHeader * iox_response_header_t ; response header handle","title":"typedef iox_response_header_t"},{"location":"API-reference/c-binding/Files/response__header_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_from_payload","text":"iox_response_header_t iox_response_header_from_payload ( void * const payload ) extract the response header from a given payload Parameters : payload the pointer to the payload Return : a handle to the response header","title":"function iox_response_header_from_payload"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_from_payload_const","text":"iox_const_response_header_t iox_response_header_from_payload_const ( const void * const payload ) extract the response header from a given payload Parameters : payload the pointer to the payload Return : a handle to the response header","title":"function iox_response_header_from_payload_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_set_server_error","text":"void iox_response_header_set_server_error ( iox_response_header_t const self ) set the response header into server error state Parameters : self handle to the response header","title":"function iox_response_header_set_server_error"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_has_server_error","text":"bool iox_response_header_has_server_error ( iox_response_header_t const self ) is the response header in an error state Parameters : self handle to the response header Return : true if it is in an error state, otherwise false","title":"function iox_response_header_has_server_error"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_has_server_error_const","text":"bool iox_response_header_has_server_error_const ( iox_const_response_header_t const self ) is the response header in an error state Parameters : self handle to the response header Return : true if it is in an error state, otherwise false","title":"function iox_response_header_has_server_error_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_rpc_header_version","text":"uint8_t iox_response_header_get_rpc_header_version ( iox_response_header_t const self ) returns the rpc header version Parameters : self handle to the response header Return : rpc header version","title":"function iox_response_header_get_rpc_header_version"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_rpc_header_version_const","text":"uint8_t iox_response_header_get_rpc_header_version_const ( iox_const_response_header_t const self ) returns the rpc header version Parameters : self handle to the response header Return : rpc header version","title":"function iox_response_header_get_rpc_header_version_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_sequence_id","text":"int64_t iox_response_header_get_sequence_id ( iox_response_header_t const self ) returns the sequence id Parameters : self handle to the response header Return : sequence id","title":"function iox_response_header_get_sequence_id"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_sequence_id_const","text":"int64_t iox_response_header_get_sequence_id_const ( iox_const_response_header_t const self ) returns the sequence id Parameters : self handle to the response header Return : sequence id","title":"function iox_response_header_get_sequence_id_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_user_payload","text":"void * iox_response_header_get_user_payload ( iox_response_header_t const self ) returns a pointer to the user payload Parameters : self handle to the response header Return : pointer to the payload","title":"function iox_response_header_get_user_payload"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_user_payload_const","text":"const void * iox_response_header_get_user_payload_const ( iox_const_response_header_t const self ) returns a pointer to the user payload Parameters : self handle to the response header Return : pointer to the payload","title":"function iox_response_header_get_user_payload_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_chunk_header","text":"iox_chunk_header_t * iox_response_header_get_chunk_header ( iox_response_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the response header Return : pointer to the chunk header","title":"function iox_response_header_get_chunk_header"},{"location":"API-reference/c-binding/Files/response__header_8h/#function-iox_response_header_get_chunk_header_const","text":"const iox_chunk_header_t * iox_response_header_get_chunk_header_const ( iox_const_response_header_t const self ) returns a pointer to the chunk header Parameters : self handle to the response header Return : pointer to the chunk header","title":"function iox_response_header_get_chunk_header_const"},{"location":"API-reference/c-binding/Files/response__header_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/c-binding/Files/response__header_8h/#variable-iox_const_response_header_t","text":"const typedef CLASS ResponseHeader * iox_const_response_header_t ; const response header handle","title":"variable iox_const_response_header_t"},{"location":"API-reference/c-binding/Files/response__header_8h/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_RESPONSE_HEADER_H #define IOX_BINDING_C_RESPONSE_HEADER_H #include \"iceoryx_binding_c/chunk.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" typedef CLASS ResponseHeader * iox_response_header_t ; typedef const CLASS ResponseHeader * iox_const_response_header_t ; iox_response_header_t iox_response_header_from_payload ( void * const payload ); iox_const_response_header_t iox_response_header_from_payload_const ( const void * const payload ); void iox_response_header_set_server_error ( iox_response_header_t const self ); bool iox_response_header_has_server_error ( iox_response_header_t const self ); bool iox_response_header_has_server_error_const ( iox_const_response_header_t const self ); uint8_t iox_response_header_get_rpc_header_version ( iox_response_header_t const self ); uint8_t iox_response_header_get_rpc_header_version_const ( iox_const_response_header_t const self ); int64_t iox_response_header_get_sequence_id ( iox_response_header_t const self ); int64_t iox_response_header_get_sequence_id_const ( iox_const_response_header_t const self ); void * iox_response_header_get_user_payload ( iox_response_header_t const self ); const void * iox_response_header_get_user_payload_const ( iox_const_response_header_t const self ); iox_chunk_header_t * iox_response_header_get_chunk_header ( iox_response_header_t const self ); const iox_chunk_header_t * iox_response_header_get_chunk_header_const ( iox_const_response_header_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/runtime_8h/","text":"iceoryx_binding_c/runtime.h \ud83d\udd17 Functions \ud83d\udd17 Name void iox_runtime_init (const char *const name) initializes a new posh runtime with a given name uint64_t iox_runtime_get_instance_name (char *const name, const uint64_t nameLength) retrieves the instance-name of the current posh runtime instance void iox_runtime_shutdown () initiates the shutdown of the runtime to unblock all potentially blocking producer with the iox_ConsumerTooSlowPolicy::ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER option set Functions Documentation \ud83d\udd17 function iox_runtime_init \ud83d\udd17 void iox_runtime_init ( const char * const name ) initializes a new posh runtime with a given name Parameters : name name of the posh runtime function iox_runtime_get_instance_name \ud83d\udd17 uint64_t iox_runtime_get_instance_name ( char * const name , const uint64_t nameLength ) retrieves the instance-name of the current posh runtime instance Parameters : name char pointer to preallocated memory nameLength size of the preallocated memory. Return : The length of the instance-name. If the instance-name is longer then nameLength a number greater nameLength is returned and the instance-name, truncated to nameLength, is written into the memory location of name. If name is a nullptr, 0 will be returned. function iox_runtime_shutdown \ud83d\udd17 void iox_runtime_shutdown () initiates the shutdown of the runtime to unblock all potentially blocking producer with the iox_ConsumerTooSlowPolicy::ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER option set Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_POSH_RUNTIME_H #define IOX_BINDING_C_POSH_RUNTIME_H #include \"internal/c2cpp_binding.h\" void iox_runtime_init ( const char * const name ); uint64_t iox_runtime_get_instance_name ( char * const name , const uint64_t nameLength ); void iox_runtime_shutdown (); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/runtime.h"},{"location":"API-reference/c-binding/Files/runtime_8h/#iceoryx_binding_cruntimeh","text":"","title":"iceoryx_binding_c/runtime.h"},{"location":"API-reference/c-binding/Files/runtime_8h/#functions","text":"Name void iox_runtime_init (const char *const name) initializes a new posh runtime with a given name uint64_t iox_runtime_get_instance_name (char *const name, const uint64_t nameLength) retrieves the instance-name of the current posh runtime instance void iox_runtime_shutdown () initiates the shutdown of the runtime to unblock all potentially blocking producer with the iox_ConsumerTooSlowPolicy::ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER option set","title":"Functions"},{"location":"API-reference/c-binding/Files/runtime_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/runtime_8h/#function-iox_runtime_init","text":"void iox_runtime_init ( const char * const name ) initializes a new posh runtime with a given name Parameters : name name of the posh runtime","title":"function iox_runtime_init"},{"location":"API-reference/c-binding/Files/runtime_8h/#function-iox_runtime_get_instance_name","text":"uint64_t iox_runtime_get_instance_name ( char * const name , const uint64_t nameLength ) retrieves the instance-name of the current posh runtime instance Parameters : name char pointer to preallocated memory nameLength size of the preallocated memory. Return : The length of the instance-name. If the instance-name is longer then nameLength a number greater nameLength is returned and the instance-name, truncated to nameLength, is written into the memory location of name. If name is a nullptr, 0 will be returned.","title":"function iox_runtime_get_instance_name"},{"location":"API-reference/c-binding/Files/runtime_8h/#function-iox_runtime_shutdown","text":"void iox_runtime_shutdown () initiates the shutdown of the runtime to unblock all potentially blocking producer with the iox_ConsumerTooSlowPolicy::ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER option set","title":"function iox_runtime_shutdown"},{"location":"API-reference/c-binding/Files/runtime_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_POSH_RUNTIME_H #define IOX_BINDING_C_POSH_RUNTIME_H #include \"internal/c2cpp_binding.h\" void iox_runtime_init ( const char * const name ); uint64_t iox_runtime_get_instance_name ( char * const name , const uint64_t nameLength ); void iox_runtime_shutdown (); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/server_8h/","text":"iceoryx_binding_c/server.h \ud83d\udd17 Classes \ud83d\udd17 Name struct iox_server_options_t options to be set for a server Types \ud83d\udd17 Name typedef CLASS UntypedServer * iox_server_t server handle Functions \ud83d\udd17 Name void iox_server_options_init ( iox_server_options_t *const options) initialize server options to default values bool iox_server_options_is_initialized (const iox_server_options_t *const options) check whether the server options were initialized by iox_server_options_init iox_server_t iox_server_init ( iox_server_storage_t * self, const char const service, const char const instance, const char const event, const iox_server_options_t const options) creates a server handle void iox_server_deinit (iox_server_t const self) removes a server handle ENUM iox_ServerRequestResult iox_server_take_request (iox_server_t const self, const void **const payload) retrieve a received request void iox_server_release_request (iox_server_t const self, const void *const payload) release a previously acquired request (via iox_server_take_request) ENUM iox_AllocationResult iox_server_loan_response (iox_server_t const self, const void const requestPayload, void *const payload, const uint32_t payloadSize) allocates a response in the shared memory ENUM iox_AllocationResult iox_server_loan_aligned_response (iox_server_t const self, const void const requestPayload, void *const payload, const uint32_t payloadSize, const uint32_t payloadAlignment) allocates a response in the shared memory ENUM iox_ServerSendResult iox_server_send (iox_server_t const self, void *const payload) sends a previously loaned response void iox_server_release_response (iox_server_t const self, void *const payload) releases ownership of a previously allocated loaned response without sending it iox_service_description_t iox_server_get_service_description (iox_server_t const self) returns the service description of the server void iox_server_offer (iox_server_t const self) offers the servers service void iox_server_stop_offer (iox_server_t const self) stops offering the servers service bool iox_server_is_offered (iox_server_t const self) is the server currently offering? bool iox_server_has_clients (iox_server_t const self) are clients connected to the server? bool iox_server_has_requests (iox_server_t const self) are requests from clients available? bool iox_server_has_missed_requests (iox_server_t const self) were requests missed? void iox_server_release_queued_requests (iox_server_t const self) release a previously acquired request (via iox_server_take_request) Types Documentation \ud83d\udd17 typedef iox_server_t \ud83d\udd17 typedef CLASS UntypedServer * iox_server_t ; server handle Functions Documentation \ud83d\udd17 function iox_server_options_init \ud83d\udd17 void iox_server_options_init ( iox_server_options_t * const options ) initialize server options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. function iox_server_options_is_initialized \ud83d\udd17 bool iox_server_options_is_initialized ( const iox_server_options_t * const options ) check whether the server options were initialized by iox_server_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise function iox_server_init \ud83d\udd17 iox_server_t iox_server_init ( iox_server_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_server_options_t * const options ) creates a server handle Parameters : self pointer to preallocated memory of size = sizeof(iox_server_storage_t) service serviceString instance instanceString event eventString options server options set by the user, if it is a null pointer default options are used Return : handle of the server function iox_server_deinit \ud83d\udd17 void iox_server_deinit ( iox_server_t const self ) removes a server handle Parameters : self the handle which should be removed function iox_server_take_request \ud83d\udd17 ENUM iox_ServerRequestResult iox_server_take_request ( iox_server_t const self , const void ** const payload ) retrieve a received request Parameters : self handle to the server payload pointer in which the pointer to the user-payload of the request is stored Return : if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error function iox_server_release_request \ud83d\udd17 void iox_server_release_request ( iox_server_t const self , const void * const payload ) release a previously acquired request (via iox_server_take_request) Parameters : self handle to the server payload pointer to the user-payload of chunk which should be released function iox_server_loan_response \ud83d\udd17 ENUM iox_AllocationResult iox_server_loan_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize ) allocates a response in the shared memory Parameters : self handle of the server requestPayload pointer to the payload of the received request payload pointer in which a pointer to the user-payload of the allocated chunk is stored payloadSize user-payload size of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error Note : for the user-payload alignment IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT is used for a custom user-payload alignment please use iox_server_loan_aligned_response function iox_server_loan_aligned_response \ud83d\udd17 ENUM iox_AllocationResult iox_server_loan_aligned_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ) allocates a response in the shared memory Parameters : self handle of the server requestPayload pointer to the payload of the received request payload pointer in which a pointer to the user-payload of the allocated chunk is stored payloadSize user-payload size of the allocated request payloadAlignment user-payload alignment of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error function iox_server_send \ud83d\udd17 ENUM iox_ServerSendResult iox_server_send ( iox_server_t const self , void * const payload ) sends a previously loaned response Parameters : self handle of the server payload pointer to the user-payload of the response which should be send Return : on success it returns ServerSendResult_SUCCESS otherwise a value which describes the error function iox_server_release_response \ud83d\udd17 void iox_server_release_response ( iox_server_t const self , void * const payload ) releases ownership of a previously allocated loaned response without sending it Parameters : self handle of the server payload pointer to the user-payload of the loaned request which should be free'd function iox_server_get_service_description \ud83d\udd17 iox_service_description_t iox_server_get_service_description ( iox_server_t const self ) returns the service description of the server Parameters : self handle to the server Return : the service description function iox_server_offer \ud83d\udd17 void iox_server_offer ( iox_server_t const self ) offers the servers service Parameters : self handle to the server function iox_server_stop_offer \ud83d\udd17 void iox_server_stop_offer ( iox_server_t const self ) stops offering the servers service Parameters : self handle to the server function iox_server_is_offered \ud83d\udd17 bool iox_server_is_offered ( iox_server_t const self ) is the server currently offering? Parameters : self handle to the server Return : true if the server is offering, otherwise false function iox_server_has_clients \ud83d\udd17 bool iox_server_has_clients ( iox_server_t const self ) are clients connected to the server? Parameters : self handle to the server Return : true if the server has connected clients, otherwise false function iox_server_has_requests \ud83d\udd17 bool iox_server_has_requests ( iox_server_t const self ) are requests from clients available? Parameters : self handle to the server Return : true if the requests are available to take, otherwise false function iox_server_has_missed_requests \ud83d\udd17 bool iox_server_has_missed_requests ( iox_server_t const self ) were requests missed? Parameters : self handle to the server Return : true if there are lost requests due to overflowing queue, otherwise false function iox_server_release_queued_requests \ud83d\udd17 void iox_server_release_queued_requests ( iox_server_t const self ) release a previously acquired request (via iox_server_take_request) Parameters : self handle to the server Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SERVER_H #define IOX_BINDING_C_SERVER_H #include \"iceoryx_binding_c/config.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef CLASS UntypedServer * iox_server_t ; typedef struct { uint64_t requestQueueCapacity ; char nodeName [ IOX_CONFIG_NODE_NAME_SIZE ]; bool offerOnCreate ; ENUM iox_QueueFullPolicy requestQueueFullPolicy ; ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy ; uint64_t initCheck ; } iox_server_options_t ; void iox_server_options_init ( iox_server_options_t * const options ); bool iox_server_options_is_initialized ( const iox_server_options_t * const options ); iox_server_t iox_server_init ( iox_server_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_server_options_t * const options ); void iox_server_deinit ( iox_server_t const self ); ENUM iox_ServerRequestResult iox_server_take_request ( iox_server_t const self , const void ** const payload ); void iox_server_release_request ( iox_server_t const self , const void * const payload ); ENUM iox_AllocationResult iox_server_loan_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize ); ENUM iox_AllocationResult iox_server_loan_aligned_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ); ENUM iox_ServerSendResult iox_server_send ( iox_server_t const self , void * const payload ); void iox_server_release_response ( iox_server_t const self , void * const payload ); iox_service_description_t iox_server_get_service_description ( iox_server_t const self ); void iox_server_offer ( iox_server_t const self ); void iox_server_stop_offer ( iox_server_t const self ); bool iox_server_is_offered ( iox_server_t const self ); bool iox_server_has_clients ( iox_server_t const self ); bool iox_server_has_requests ( iox_server_t const self ); bool iox_server_has_missed_requests ( iox_server_t const self ); void iox_server_release_queued_requests ( iox_server_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/server.h"},{"location":"API-reference/c-binding/Files/server_8h/#iceoryx_binding_cserverh","text":"","title":"iceoryx_binding_c/server.h"},{"location":"API-reference/c-binding/Files/server_8h/#classes","text":"Name struct iox_server_options_t options to be set for a server","title":"Classes"},{"location":"API-reference/c-binding/Files/server_8h/#types","text":"Name typedef CLASS UntypedServer * iox_server_t server handle","title":"Types"},{"location":"API-reference/c-binding/Files/server_8h/#functions","text":"Name void iox_server_options_init ( iox_server_options_t *const options) initialize server options to default values bool iox_server_options_is_initialized (const iox_server_options_t *const options) check whether the server options were initialized by iox_server_options_init iox_server_t iox_server_init ( iox_server_storage_t * self, const char const service, const char const instance, const char const event, const iox_server_options_t const options) creates a server handle void iox_server_deinit (iox_server_t const self) removes a server handle ENUM iox_ServerRequestResult iox_server_take_request (iox_server_t const self, const void **const payload) retrieve a received request void iox_server_release_request (iox_server_t const self, const void *const payload) release a previously acquired request (via iox_server_take_request) ENUM iox_AllocationResult iox_server_loan_response (iox_server_t const self, const void const requestPayload, void *const payload, const uint32_t payloadSize) allocates a response in the shared memory ENUM iox_AllocationResult iox_server_loan_aligned_response (iox_server_t const self, const void const requestPayload, void *const payload, const uint32_t payloadSize, const uint32_t payloadAlignment) allocates a response in the shared memory ENUM iox_ServerSendResult iox_server_send (iox_server_t const self, void *const payload) sends a previously loaned response void iox_server_release_response (iox_server_t const self, void *const payload) releases ownership of a previously allocated loaned response without sending it iox_service_description_t iox_server_get_service_description (iox_server_t const self) returns the service description of the server void iox_server_offer (iox_server_t const self) offers the servers service void iox_server_stop_offer (iox_server_t const self) stops offering the servers service bool iox_server_is_offered (iox_server_t const self) is the server currently offering? bool iox_server_has_clients (iox_server_t const self) are clients connected to the server? bool iox_server_has_requests (iox_server_t const self) are requests from clients available? bool iox_server_has_missed_requests (iox_server_t const self) were requests missed? void iox_server_release_queued_requests (iox_server_t const self) release a previously acquired request (via iox_server_take_request)","title":"Functions"},{"location":"API-reference/c-binding/Files/server_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/server_8h/#typedef-iox_server_t","text":"typedef CLASS UntypedServer * iox_server_t ; server handle","title":"typedef iox_server_t"},{"location":"API-reference/c-binding/Files/server_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_options_init","text":"void iox_server_options_init ( iox_server_options_t * const options ) initialize server options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future.","title":"function iox_server_options_init"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_options_is_initialized","text":"bool iox_server_options_is_initialized ( const iox_server_options_t * const options ) check whether the server options were initialized by iox_server_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise","title":"function iox_server_options_is_initialized"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_init","text":"iox_server_t iox_server_init ( iox_server_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_server_options_t * const options ) creates a server handle Parameters : self pointer to preallocated memory of size = sizeof(iox_server_storage_t) service serviceString instance instanceString event eventString options server options set by the user, if it is a null pointer default options are used Return : handle of the server","title":"function iox_server_init"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_deinit","text":"void iox_server_deinit ( iox_server_t const self ) removes a server handle Parameters : self the handle which should be removed","title":"function iox_server_deinit"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_take_request","text":"ENUM iox_ServerRequestResult iox_server_take_request ( iox_server_t const self , const void ** const payload ) retrieve a received request Parameters : self handle to the server payload pointer in which the pointer to the user-payload of the request is stored Return : if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error","title":"function iox_server_take_request"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_release_request","text":"void iox_server_release_request ( iox_server_t const self , const void * const payload ) release a previously acquired request (via iox_server_take_request) Parameters : self handle to the server payload pointer to the user-payload of chunk which should be released","title":"function iox_server_release_request"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_loan_response","text":"ENUM iox_AllocationResult iox_server_loan_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize ) allocates a response in the shared memory Parameters : self handle of the server requestPayload pointer to the payload of the received request payload pointer in which a pointer to the user-payload of the allocated chunk is stored payloadSize user-payload size of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error Note : for the user-payload alignment IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT is used for a custom user-payload alignment please use iox_server_loan_aligned_response","title":"function iox_server_loan_response"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_loan_aligned_response","text":"ENUM iox_AllocationResult iox_server_loan_aligned_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ) allocates a response in the shared memory Parameters : self handle of the server requestPayload pointer to the payload of the received request payload pointer in which a pointer to the user-payload of the allocated chunk is stored payloadSize user-payload size of the allocated request payloadAlignment user-payload alignment of the allocated request Return : on success it returns AllocationResult_SUCCESS otherwise a value which describes the error","title":"function iox_server_loan_aligned_response"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_send","text":"ENUM iox_ServerSendResult iox_server_send ( iox_server_t const self , void * const payload ) sends a previously loaned response Parameters : self handle of the server payload pointer to the user-payload of the response which should be send Return : on success it returns ServerSendResult_SUCCESS otherwise a value which describes the error","title":"function iox_server_send"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_release_response","text":"void iox_server_release_response ( iox_server_t const self , void * const payload ) releases ownership of a previously allocated loaned response without sending it Parameters : self handle of the server payload pointer to the user-payload of the loaned request which should be free'd","title":"function iox_server_release_response"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_get_service_description","text":"iox_service_description_t iox_server_get_service_description ( iox_server_t const self ) returns the service description of the server Parameters : self handle to the server Return : the service description","title":"function iox_server_get_service_description"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_offer","text":"void iox_server_offer ( iox_server_t const self ) offers the servers service Parameters : self handle to the server","title":"function iox_server_offer"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_stop_offer","text":"void iox_server_stop_offer ( iox_server_t const self ) stops offering the servers service Parameters : self handle to the server","title":"function iox_server_stop_offer"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_is_offered","text":"bool iox_server_is_offered ( iox_server_t const self ) is the server currently offering? Parameters : self handle to the server Return : true if the server is offering, otherwise false","title":"function iox_server_is_offered"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_has_clients","text":"bool iox_server_has_clients ( iox_server_t const self ) are clients connected to the server? Parameters : self handle to the server Return : true if the server has connected clients, otherwise false","title":"function iox_server_has_clients"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_has_requests","text":"bool iox_server_has_requests ( iox_server_t const self ) are requests from clients available? Parameters : self handle to the server Return : true if the requests are available to take, otherwise false","title":"function iox_server_has_requests"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_has_missed_requests","text":"bool iox_server_has_missed_requests ( iox_server_t const self ) were requests missed? Parameters : self handle to the server Return : true if there are lost requests due to overflowing queue, otherwise false","title":"function iox_server_has_missed_requests"},{"location":"API-reference/c-binding/Files/server_8h/#function-iox_server_release_queued_requests","text":"void iox_server_release_queued_requests ( iox_server_t const self ) release a previously acquired request (via iox_server_take_request) Parameters : self handle to the server","title":"function iox_server_release_queued_requests"},{"location":"API-reference/c-binding/Files/server_8h/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SERVER_H #define IOX_BINDING_C_SERVER_H #include \"iceoryx_binding_c/config.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef CLASS UntypedServer * iox_server_t ; typedef struct { uint64_t requestQueueCapacity ; char nodeName [ IOX_CONFIG_NODE_NAME_SIZE ]; bool offerOnCreate ; ENUM iox_QueueFullPolicy requestQueueFullPolicy ; ENUM iox_ConsumerTooSlowPolicy clientTooSlowPolicy ; uint64_t initCheck ; } iox_server_options_t ; void iox_server_options_init ( iox_server_options_t * const options ); bool iox_server_options_is_initialized ( const iox_server_options_t * const options ); iox_server_t iox_server_init ( iox_server_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_server_options_t * const options ); void iox_server_deinit ( iox_server_t const self ); ENUM iox_ServerRequestResult iox_server_take_request ( iox_server_t const self , const void ** const payload ); void iox_server_release_request ( iox_server_t const self , const void * const payload ); ENUM iox_AllocationResult iox_server_loan_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize ); ENUM iox_AllocationResult iox_server_loan_aligned_response ( iox_server_t const self , const void * const requestPayload , void ** const payload , const uint32_t payloadSize , const uint32_t payloadAlignment ); ENUM iox_ServerSendResult iox_server_send ( iox_server_t const self , void * const payload ); void iox_server_release_response ( iox_server_t const self , void * const payload ); iox_service_description_t iox_server_get_service_description ( iox_server_t const self ); void iox_server_offer ( iox_server_t const self ); void iox_server_stop_offer ( iox_server_t const self ); bool iox_server_is_offered ( iox_server_t const self ); bool iox_server_has_clients ( iox_server_t const self ); bool iox_server_has_requests ( iox_server_t const self ); bool iox_server_has_missed_requests ( iox_server_t const self ); void iox_server_release_queued_requests ( iox_server_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/service__description_8h/","text":"iceoryx_binding_c/service_description.h \ud83d\udd17 Classes \ud83d\udd17 Name struct iox_service_description_t Source code \ud83d\udd17 // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SERVICE_DESCRIPTION_H #define IOX_BINDING_C_SERVICE_DESCRIPTION_H #include \"iceoryx_binding_c/config.h\" #include <stdint.h> typedef struct { char serviceString [ IOX_CONFIG_SERVICE_STRING_SIZE ]; char instanceString [ IOX_CONFIG_SERVICE_STRING_SIZE ]; char eventString [ IOX_CONFIG_SERVICE_STRING_SIZE ]; } iox_service_description_t ; #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/service_description.h"},{"location":"API-reference/c-binding/Files/service__description_8h/#iceoryx_binding_cservice_descriptionh","text":"","title":"iceoryx_binding_c/service_description.h"},{"location":"API-reference/c-binding/Files/service__description_8h/#classes","text":"Name struct iox_service_description_t","title":"Classes"},{"location":"API-reference/c-binding/Files/service__description_8h/#source-code","text":"// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SERVICE_DESCRIPTION_H #define IOX_BINDING_C_SERVICE_DESCRIPTION_H #include \"iceoryx_binding_c/config.h\" #include <stdint.h> typedef struct { char serviceString [ IOX_CONFIG_SERVICE_STRING_SIZE ]; char instanceString [ IOX_CONFIG_SERVICE_STRING_SIZE ]; char eventString [ IOX_CONFIG_SERVICE_STRING_SIZE ]; } iox_service_description_t ; #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/service__discovery_8h/","text":"iceoryx_binding_c/service_discovery.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS ServiceDiscovery * iox_service_discovery_t service discovery handle Functions \ud83d\udd17 Name iox_service_discovery_t iox_service_discovery_init ( iox_service_discovery_storage_t * self) initializes a service discovery from a storage struct pointer void iox_service_discovery_deinit (iox_service_discovery_t const self) after using an iox_service_discovery_t it must be cleaned up with this function uint64_t iox_service_discovery_find_service (iox_service_discovery_t const self, const char const service, const char const instance, const char const event, iox_service_description_t const serviceContainer, const uint64_t serviceContainerCapacity, uint64_t * missedServices, const ENUM iox_MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description. void iox_service_discovery_find_service_apply_callable (iox_service_discovery_t const self, const char const service, const char const instance, const char const event, void( )(const iox_service_description_t ) callable, const ENUM iox_MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. void iox_service_discovery_find_service_apply_callable_with_context_data (iox_service_discovery_t const self, const char const service, const char const instance, const char const event, void( )(const iox_service_description_t , void ) callable, void const contextData, const ENUM iox_MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. A second parameter for the function can be provided as contextData. Types Documentation \ud83d\udd17 typedef iox_service_discovery_t \ud83d\udd17 typedef CLASS ServiceDiscovery * iox_service_discovery_t ; service discovery handle Functions Documentation \ud83d\udd17 function iox_service_discovery_init \ud83d\udd17 iox_service_discovery_t iox_service_discovery_init ( iox_service_discovery_storage_t * self ) initializes a service discovery from a storage struct pointer Parameters : self pointer to raw memory which can hold a service discovery Return : an initialized iox_service_discovery_t function iox_service_discovery_deinit \ud83d\udd17 void iox_service_discovery_deinit ( iox_service_discovery_t const self ) after using an iox_service_discovery_t it must be cleaned up with this function Parameters : self the service discovery which should be deinitialized function iox_service_discovery_find_service \ud83d\udd17 uint64_t iox_service_discovery_find_service ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , iox_service_description_t * const serviceContainer , const uint64_t serviceContainerCapacity , uint64_t * missedServices , const ENUM iox_MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description. Parameters : self handle of the service discovery service service string to search for, a nullptr corresponds to a wildcard instance instance string to search for, a nullptr corresponds to a wildcard event event string to search for, a nullptr corresponds to a wildcard serviceContainer preallocated memory to an array of iox_service_description_t in which the matching services can be written serviceContainerCapacity the capacity of the preallocated serviceContainer missedServices if the serviceContainer has insufficient size the number of missed services which could not be written into the serviceContainer are stored here pattern messaging pattern of the service to search Return : the number of services which were written into the serviceContainer function iox_service_discovery_find_service_apply_callable \ud83d\udd17 void iox_service_discovery_find_service_apply_callable ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * )( const iox_service_description_t ) callable , const ENUM iox_MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. Parameters : self handle of the service discovery service service string to search for, a nullptr corresponds to a wildcard instance instance string to search for, a nullptr corresponds to a wildcard event event string to search for, a nullptr corresponds to a wildcard callable to apply to all matching services pattern messaging pattern of the service to search function iox_service_discovery_find_service_apply_callable_with_context_data \ud83d\udd17 void iox_service_discovery_find_service_apply_callable_with_context_data ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * )( const iox_service_description_t , void * ) callable , void * const contextData , const ENUM iox_MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. A second parameter for the function can be provided as contextData. Parameters : self handle of the service discovery service service string to search for, a nullptr corresponds to a wildcard instance instance string to search for, a nullptr corresponds to a wildcard event event string to search for, a nullptr corresponds to a wildcard callable to apply to all matching services contextData a void pointer which is provided as second argument to the callback pattern messaging pattern of the service to search Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SERVICE_DISCOVERY_H #define IOX_BINDING_C_SERVICE_DISCOVERY_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/types.h\" #include \"service_description.h\" typedef CLASS ServiceDiscovery * iox_service_discovery_t ; iox_service_discovery_t iox_service_discovery_init ( iox_service_discovery_storage_t * self ); void iox_service_discovery_deinit ( iox_service_discovery_t const self ); uint64_t iox_service_discovery_find_service ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , iox_service_description_t * const serviceContainer , const uint64_t serviceContainerCapacity , uint64_t * missedServices , const ENUM iox_MessagingPattern pattern ); void iox_service_discovery_find_service_apply_callable ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * callable )( const iox_service_description_t ), const ENUM iox_MessagingPattern pattern ); void iox_service_discovery_find_service_apply_callable_with_context_data ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * callable )( const iox_service_description_t , void * ), void * const contextData , const ENUM iox_MessagingPattern pattern ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/service_discovery.h"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#iceoryx_binding_cservice_discoveryh","text":"","title":"iceoryx_binding_c/service_discovery.h"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#types","text":"Name typedef CLASS ServiceDiscovery * iox_service_discovery_t service discovery handle","title":"Types"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#functions","text":"Name iox_service_discovery_t iox_service_discovery_init ( iox_service_discovery_storage_t * self) initializes a service discovery from a storage struct pointer void iox_service_discovery_deinit (iox_service_discovery_t const self) after using an iox_service_discovery_t it must be cleaned up with this function uint64_t iox_service_discovery_find_service (iox_service_discovery_t const self, const char const service, const char const instance, const char const event, iox_service_description_t const serviceContainer, const uint64_t serviceContainerCapacity, uint64_t * missedServices, const ENUM iox_MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description. void iox_service_discovery_find_service_apply_callable (iox_service_discovery_t const self, const char const service, const char const instance, const char const event, void( )(const iox_service_description_t ) callable, const ENUM iox_MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. void iox_service_discovery_find_service_apply_callable_with_context_data (iox_service_discovery_t const self, const char const service, const char const instance, const char const event, void( )(const iox_service_description_t , void ) callable, void const contextData, const ENUM iox_MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. A second parameter for the function can be provided as contextData.","title":"Functions"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#typedef-iox_service_discovery_t","text":"typedef CLASS ServiceDiscovery * iox_service_discovery_t ; service discovery handle","title":"typedef iox_service_discovery_t"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_init","text":"iox_service_discovery_t iox_service_discovery_init ( iox_service_discovery_storage_t * self ) initializes a service discovery from a storage struct pointer Parameters : self pointer to raw memory which can hold a service discovery Return : an initialized iox_service_discovery_t","title":"function iox_service_discovery_init"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_deinit","text":"void iox_service_discovery_deinit ( iox_service_discovery_t const self ) after using an iox_service_discovery_t it must be cleaned up with this function Parameters : self the service discovery which should be deinitialized","title":"function iox_service_discovery_deinit"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_find_service","text":"uint64_t iox_service_discovery_find_service ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , iox_service_description_t * const serviceContainer , const uint64_t serviceContainerCapacity , uint64_t * missedServices , const ENUM iox_MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description. Parameters : self handle of the service discovery service service string to search for, a nullptr corresponds to a wildcard instance instance string to search for, a nullptr corresponds to a wildcard event event string to search for, a nullptr corresponds to a wildcard serviceContainer preallocated memory to an array of iox_service_description_t in which the matching services can be written serviceContainerCapacity the capacity of the preallocated serviceContainer missedServices if the serviceContainer has insufficient size the number of missed services which could not be written into the serviceContainer are stored here pattern messaging pattern of the service to search Return : the number of services which were written into the serviceContainer","title":"function iox_service_discovery_find_service"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_find_service_apply_callable","text":"void iox_service_discovery_find_service_apply_callable ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * )( const iox_service_description_t ) callable , const ENUM iox_MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. Parameters : self handle of the service discovery service service string to search for, a nullptr corresponds to a wildcard instance instance string to search for, a nullptr corresponds to a wildcard event event string to search for, a nullptr corresponds to a wildcard callable to apply to all matching services pattern messaging pattern of the service to search","title":"function iox_service_discovery_find_service_apply_callable"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#function-iox_service_discovery_find_service_apply_callable_with_context_data","text":"void iox_service_discovery_find_service_apply_callable_with_context_data ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * )( const iox_service_description_t , void * ) callable , void * const contextData , const ENUM iox_MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. A second parameter for the function can be provided as contextData. Parameters : self handle of the service discovery service service string to search for, a nullptr corresponds to a wildcard instance instance string to search for, a nullptr corresponds to a wildcard event event string to search for, a nullptr corresponds to a wildcard callable to apply to all matching services contextData a void pointer which is provided as second argument to the callback pattern messaging pattern of the service to search","title":"function iox_service_discovery_find_service_apply_callable_with_context_data"},{"location":"API-reference/c-binding/Files/service__discovery_8h/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SERVICE_DISCOVERY_H #define IOX_BINDING_C_SERVICE_DISCOVERY_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/types.h\" #include \"service_description.h\" typedef CLASS ServiceDiscovery * iox_service_discovery_t ; iox_service_discovery_t iox_service_discovery_init ( iox_service_discovery_storage_t * self ); void iox_service_discovery_deinit ( iox_service_discovery_t const self ); uint64_t iox_service_discovery_find_service ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , iox_service_description_t * const serviceContainer , const uint64_t serviceContainerCapacity , uint64_t * missedServices , const ENUM iox_MessagingPattern pattern ); void iox_service_discovery_find_service_apply_callable ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * callable )( const iox_service_description_t ), const ENUM iox_MessagingPattern pattern ); void iox_service_discovery_find_service_apply_callable_with_context_data ( iox_service_discovery_t const self , const char * const service , const char * const instance , const char * const event , void ( * callable )( const iox_service_description_t , void * ), void * const contextData , const ENUM iox_MessagingPattern pattern ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/subscriber_8h/","text":"iceoryx_binding_c/subscriber.h \ud83d\udd17 Classes \ud83d\udd17 Name struct iox_sub_options_t options to be set for a subscriber Types \ud83d\udd17 Name typedef struct cpp2c_Subscriber * iox_sub_t Subscriber handle. Functions \ud83d\udd17 Name void iox_sub_options_init ( iox_sub_options_t *const options) initialize subscriber options to default values bool iox_sub_options_is_initialized (const iox_sub_options_t *const options) check whether the subscriber options were initialized by iox_sub_options_init iox_sub_t iox_sub_init ( iox_sub_storage_t * self, const char const service, const char const instance, const char const event, const iox_sub_options_t const options) initialize subscriber handle void iox_sub_deinit (iox_sub_t const self) deinitialize a subscriber handle void iox_sub_subscribe (iox_sub_t const self) subscribes to the service void iox_sub_unsubscribe (iox_sub_t const self) unsubscribes from a service ENUM iox_SubscribeState iox_sub_get_subscription_state (iox_sub_t const self) what is the subscription state? ENUM iox_ChunkReceiveResult iox_sub_take_chunk (iox_sub_t const self, const void **const userPayload) retrieve a received chunk void iox_sub_release_chunk (iox_sub_t const self, const void *const userPayload) release a previously acquired chunk (via iox_sub_take_chunk) void iox_sub_release_queued_chunks (iox_sub_t const self) release all chunks which are stored in the chunk queue bool iox_sub_has_chunks (iox_sub_t const self) are new chunks available? bool iox_sub_has_lost_chunks (iox_sub_t const self) are chunks lost? iox_service_description_t iox_sub_get_service_description (iox_sub_t const self) returns the service description of the subscriber Types Documentation \ud83d\udd17 typedef iox_sub_t \ud83d\udd17 typedef struct cpp2c_Subscriber * iox_sub_t ; Subscriber handle. Functions Documentation \ud83d\udd17 function iox_sub_options_init \ud83d\udd17 void iox_sub_options_init ( iox_sub_options_t * const options ) initialize subscriber options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future. function iox_sub_options_is_initialized \ud83d\udd17 bool iox_sub_options_is_initialized ( const iox_sub_options_t * const options ) check whether the subscriber options were initialized by iox_sub_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise function iox_sub_init \ud83d\udd17 iox_sub_t iox_sub_init ( iox_sub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_sub_options_t * const options ) initialize subscriber handle Parameters : self pointer to preallocated memory of size = sizeof(iox_sub_storage_t) service serviceString instance instanceString event eventString options subscriber options set by the user, if it is a null pointer default options are used Return : handle of the subscriber function iox_sub_deinit \ud83d\udd17 void iox_sub_deinit ( iox_sub_t const self ) deinitialize a subscriber handle Parameters : self the handle which should be removed function iox_sub_subscribe \ud83d\udd17 void iox_sub_subscribe ( iox_sub_t const self ) subscribes to the service Parameters : self handle to the subscriber function iox_sub_unsubscribe \ud83d\udd17 void iox_sub_unsubscribe ( iox_sub_t const self ) unsubscribes from a service Parameters : self handle to the subscriber function iox_sub_get_subscription_state \ud83d\udd17 ENUM iox_SubscribeState iox_sub_get_subscription_state ( iox_sub_t const self ) what is the subscription state? Parameters : self handle to the subscriber Return : SubscribeState_SUBSCRIBED when successfully subscribed otherwise an enum which describes the current state function iox_sub_take_chunk \ud83d\udd17 ENUM iox_ChunkReceiveResult iox_sub_take_chunk ( iox_sub_t const self , const void ** const userPayload ) retrieve a received chunk Parameters : self handle to the subscriber userPayload pointer in which the pointer to the user-payload of the chunk is stored Return : if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error function iox_sub_release_chunk \ud83d\udd17 void iox_sub_release_chunk ( iox_sub_t const self , const void * const userPayload ) release a previously acquired chunk (via iox_sub_take_chunk) Parameters : self handle to the subscriber userPayload pointer to the user-payload of chunk which should be released function iox_sub_release_queued_chunks \ud83d\udd17 void iox_sub_release_queued_chunks ( iox_sub_t const self ) release all chunks which are stored in the chunk queue Parameters : self handle to the subscriber function iox_sub_has_chunks \ud83d\udd17 bool iox_sub_has_chunks ( iox_sub_t const self ) are new chunks available? Parameters : self handle to the subscriber Return : true if there are chunks, otherwise false function iox_sub_has_lost_chunks \ud83d\udd17 bool iox_sub_has_lost_chunks ( iox_sub_t const self ) are chunks lost? Parameters : self handle to the subscriber Return : true if there are lost chunks due to overflowing queue, otherwise false function iox_sub_get_service_description \ud83d\udd17 iox_service_description_t iox_sub_get_service_description ( iox_sub_t const self ) returns the service description of the subscriber Parameters : self handle to the subscriber Return : the service description Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SUBSCRIBER_H #define IOX_BINDING_C_SUBSCRIBER_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef struct cpp2c_Subscriber * iox_sub_t ; typedef struct { uint64_t queueCapacity ; uint64_t historyRequest ; const char * nodeName ; bool subscribeOnCreate ; ENUM iox_QueueFullPolicy queueFullPolicy ; bool requirePublisherHistorySupport ; uint64_t initCheck ; } iox_sub_options_t ; void iox_sub_options_init ( iox_sub_options_t * const options ); bool iox_sub_options_is_initialized ( const iox_sub_options_t * const options ); iox_sub_t iox_sub_init ( iox_sub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_sub_options_t * const options ); void iox_sub_deinit ( iox_sub_t const self ); void iox_sub_subscribe ( iox_sub_t const self ); void iox_sub_unsubscribe ( iox_sub_t const self ); ENUM iox_SubscribeState iox_sub_get_subscription_state ( iox_sub_t const self ); ENUM iox_ChunkReceiveResult iox_sub_take_chunk ( iox_sub_t const self , const void ** const userPayload ); void iox_sub_release_chunk ( iox_sub_t const self , const void * const userPayload ); void iox_sub_release_queued_chunks ( iox_sub_t const self ); bool iox_sub_has_chunks ( iox_sub_t const self ); bool iox_sub_has_lost_chunks ( iox_sub_t const self ); iox_service_description_t iox_sub_get_service_description ( iox_sub_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/subscriber.h"},{"location":"API-reference/c-binding/Files/subscriber_8h/#iceoryx_binding_csubscriberh","text":"","title":"iceoryx_binding_c/subscriber.h"},{"location":"API-reference/c-binding/Files/subscriber_8h/#classes","text":"Name struct iox_sub_options_t options to be set for a subscriber","title":"Classes"},{"location":"API-reference/c-binding/Files/subscriber_8h/#types","text":"Name typedef struct cpp2c_Subscriber * iox_sub_t Subscriber handle.","title":"Types"},{"location":"API-reference/c-binding/Files/subscriber_8h/#functions","text":"Name void iox_sub_options_init ( iox_sub_options_t *const options) initialize subscriber options to default values bool iox_sub_options_is_initialized (const iox_sub_options_t *const options) check whether the subscriber options were initialized by iox_sub_options_init iox_sub_t iox_sub_init ( iox_sub_storage_t * self, const char const service, const char const instance, const char const event, const iox_sub_options_t const options) initialize subscriber handle void iox_sub_deinit (iox_sub_t const self) deinitialize a subscriber handle void iox_sub_subscribe (iox_sub_t const self) subscribes to the service void iox_sub_unsubscribe (iox_sub_t const self) unsubscribes from a service ENUM iox_SubscribeState iox_sub_get_subscription_state (iox_sub_t const self) what is the subscription state? ENUM iox_ChunkReceiveResult iox_sub_take_chunk (iox_sub_t const self, const void **const userPayload) retrieve a received chunk void iox_sub_release_chunk (iox_sub_t const self, const void *const userPayload) release a previously acquired chunk (via iox_sub_take_chunk) void iox_sub_release_queued_chunks (iox_sub_t const self) release all chunks which are stored in the chunk queue bool iox_sub_has_chunks (iox_sub_t const self) are new chunks available? bool iox_sub_has_lost_chunks (iox_sub_t const self) are chunks lost? iox_service_description_t iox_sub_get_service_description (iox_sub_t const self) returns the service description of the subscriber","title":"Functions"},{"location":"API-reference/c-binding/Files/subscriber_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/subscriber_8h/#typedef-iox_sub_t","text":"typedef struct cpp2c_Subscriber * iox_sub_t ; Subscriber handle.","title":"typedef iox_sub_t"},{"location":"API-reference/c-binding/Files/subscriber_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_options_init","text":"void iox_sub_options_init ( iox_sub_options_t * const options ) initialize subscriber options to default values Parameters : options pointer to options to be initialized, emit warning if it is a null pointer Attention : This must always be called on a newly created options struct to prevent uninitialized values. The options may get extended in the future.","title":"function iox_sub_options_init"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_options_is_initialized","text":"bool iox_sub_options_is_initialized ( const iox_sub_options_t * const options ) check whether the subscriber options were initialized by iox_sub_options_init Parameters : options pointer to options to be checked Return : true if options are not null and were initialized, false otherwise","title":"function iox_sub_options_is_initialized"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_init","text":"iox_sub_t iox_sub_init ( iox_sub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_sub_options_t * const options ) initialize subscriber handle Parameters : self pointer to preallocated memory of size = sizeof(iox_sub_storage_t) service serviceString instance instanceString event eventString options subscriber options set by the user, if it is a null pointer default options are used Return : handle of the subscriber","title":"function iox_sub_init"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_deinit","text":"void iox_sub_deinit ( iox_sub_t const self ) deinitialize a subscriber handle Parameters : self the handle which should be removed","title":"function iox_sub_deinit"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_subscribe","text":"void iox_sub_subscribe ( iox_sub_t const self ) subscribes to the service Parameters : self handle to the subscriber","title":"function iox_sub_subscribe"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_unsubscribe","text":"void iox_sub_unsubscribe ( iox_sub_t const self ) unsubscribes from a service Parameters : self handle to the subscriber","title":"function iox_sub_unsubscribe"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_get_subscription_state","text":"ENUM iox_SubscribeState iox_sub_get_subscription_state ( iox_sub_t const self ) what is the subscription state? Parameters : self handle to the subscriber Return : SubscribeState_SUBSCRIBED when successfully subscribed otherwise an enum which describes the current state","title":"function iox_sub_get_subscription_state"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_take_chunk","text":"ENUM iox_ChunkReceiveResult iox_sub_take_chunk ( iox_sub_t const self , const void ** const userPayload ) retrieve a received chunk Parameters : self handle to the subscriber userPayload pointer in which the pointer to the user-payload of the chunk is stored Return : if a chunk could be received it returns ChunkReceiveResult_SUCCESS otherwise an enum which describes the error","title":"function iox_sub_take_chunk"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_release_chunk","text":"void iox_sub_release_chunk ( iox_sub_t const self , const void * const userPayload ) release a previously acquired chunk (via iox_sub_take_chunk) Parameters : self handle to the subscriber userPayload pointer to the user-payload of chunk which should be released","title":"function iox_sub_release_chunk"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_release_queued_chunks","text":"void iox_sub_release_queued_chunks ( iox_sub_t const self ) release all chunks which are stored in the chunk queue Parameters : self handle to the subscriber","title":"function iox_sub_release_queued_chunks"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_has_chunks","text":"bool iox_sub_has_chunks ( iox_sub_t const self ) are new chunks available? Parameters : self handle to the subscriber Return : true if there are chunks, otherwise false","title":"function iox_sub_has_chunks"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_has_lost_chunks","text":"bool iox_sub_has_lost_chunks ( iox_sub_t const self ) are chunks lost? Parameters : self handle to the subscriber Return : true if there are lost chunks due to overflowing queue, otherwise false","title":"function iox_sub_has_lost_chunks"},{"location":"API-reference/c-binding/Files/subscriber_8h/#function-iox_sub_get_service_description","text":"iox_service_description_t iox_sub_get_service_description ( iox_sub_t const self ) returns the service description of the subscriber Parameters : self handle to the subscriber Return : the service description","title":"function iox_sub_get_service_description"},{"location":"API-reference/c-binding/Files/subscriber_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_SUBSCRIBER_H #define IOX_BINDING_C_SUBSCRIBER_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/service_description.h\" #include \"iceoryx_binding_c/types.h\" typedef struct cpp2c_Subscriber * iox_sub_t ; typedef struct { uint64_t queueCapacity ; uint64_t historyRequest ; const char * nodeName ; bool subscribeOnCreate ; ENUM iox_QueueFullPolicy queueFullPolicy ; bool requirePublisherHistorySupport ; uint64_t initCheck ; } iox_sub_options_t ; void iox_sub_options_init ( iox_sub_options_t * const options ); bool iox_sub_options_is_initialized ( const iox_sub_options_t * const options ); iox_sub_t iox_sub_init ( iox_sub_storage_t * self , const char * const service , const char * const instance , const char * const event , const iox_sub_options_t * const options ); void iox_sub_deinit ( iox_sub_t const self ); void iox_sub_subscribe ( iox_sub_t const self ); void iox_sub_unsubscribe ( iox_sub_t const self ); ENUM iox_SubscribeState iox_sub_get_subscription_state ( iox_sub_t const self ); ENUM iox_ChunkReceiveResult iox_sub_take_chunk ( iox_sub_t const self , const void ** const userPayload ); void iox_sub_release_chunk ( iox_sub_t const self , const void * const userPayload ); void iox_sub_release_queued_chunks ( iox_sub_t const self ); bool iox_sub_has_chunks ( iox_sub_t const self ); bool iox_sub_has_lost_chunks ( iox_sub_t const self ); iox_service_description_t iox_sub_get_service_description ( iox_sub_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/types_8h/","text":"iceoryx_binding_c/types.h \ud83d\udd17 Classes \ud83d\udd17 Name struct iox_ws_storage_t struct iox_user_trigger_storage_t struct iox_sub_storage_t struct iox_pub_storage_t struct iox_listener_storage_t struct iox_chunk_header_t handle of the chunk header struct iox_client_storage_t has exactly the size required to store the underlying object of iox_client_t struct iox_server_storage_t has exactly the size required to store the underlying object of iox_server_t struct iox_service_discovery_storage_t has exactly the size required to store the underlying object of iox_service_discovery_t Defines \ud83d\udd17 Name IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT IOX_C_CHUNK_NO_USER_HEADER_SIZE IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT Macro Documentation \ud83d\udd17 define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT \ud83d\udd17 #define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT 8 define IOX_C_CHUNK_NO_USER_HEADER_SIZE \ud83d\udd17 #define IOX_C_CHUNK_NO_USER_HEADER_SIZE 0 define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT \ud83d\udd17 #define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT 1 Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_TYPES_H #define IOX_BINDING_C_TYPES_H #include \"internal/c2cpp_binding.h\" #define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT 8 #define IOX_C_CHUNK_NO_USER_HEADER_SIZE 0 #define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT 1 typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_ws_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_user_trigger_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_sub_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_pub_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_listener_storage_t ; typedef struct { // could be empty but then we get `struct has no members` warning uint8_t do_not_touch_me [ 1 ]; } iox_chunk_header_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_client_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_server_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_service_discovery_storage_t ; #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/types.h"},{"location":"API-reference/c-binding/Files/types_8h/#iceoryx_binding_ctypesh","text":"","title":"iceoryx_binding_c/types.h"},{"location":"API-reference/c-binding/Files/types_8h/#classes","text":"Name struct iox_ws_storage_t struct iox_user_trigger_storage_t struct iox_sub_storage_t struct iox_pub_storage_t struct iox_listener_storage_t struct iox_chunk_header_t handle of the chunk header struct iox_client_storage_t has exactly the size required to store the underlying object of iox_client_t struct iox_server_storage_t has exactly the size required to store the underlying object of iox_server_t struct iox_service_discovery_storage_t has exactly the size required to store the underlying object of iox_service_discovery_t","title":"Classes"},{"location":"API-reference/c-binding/Files/types_8h/#defines","text":"Name IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT IOX_C_CHUNK_NO_USER_HEADER_SIZE IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT","title":"Defines"},{"location":"API-reference/c-binding/Files/types_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/c-binding/Files/types_8h/#define-iox_c_chunk_default_user_payload_alignment","text":"#define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT 8","title":"define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT"},{"location":"API-reference/c-binding/Files/types_8h/#define-iox_c_chunk_no_user_header_size","text":"#define IOX_C_CHUNK_NO_USER_HEADER_SIZE 0","title":"define IOX_C_CHUNK_NO_USER_HEADER_SIZE"},{"location":"API-reference/c-binding/Files/types_8h/#define-iox_c_chunk_no_user_header_alignment","text":"#define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT 1","title":"define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT"},{"location":"API-reference/c-binding/Files/types_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_TYPES_H #define IOX_BINDING_C_TYPES_H #include \"internal/c2cpp_binding.h\" #define IOX_C_CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT 8 #define IOX_C_CHUNK_NO_USER_HEADER_SIZE 0 #define IOX_C_CHUNK_NO_USER_HEADER_ALIGNMENT 1 typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_ws_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_user_trigger_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_sub_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_pub_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_listener_storage_t ; typedef struct { // could be empty but then we get `struct has no members` warning uint8_t do_not_touch_me [ 1 ]; } iox_chunk_header_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_client_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_server_storage_t ; typedef struct { // only size for pointer is necessary uint64_t do_not_touch_me [ 1 ]; } iox_service_discovery_storage_t ; #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/user__trigger_8h/","text":"iceoryx_binding_c/user_trigger.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS UserTrigger * iox_user_trigger_t user trigger handle Functions \ud83d\udd17 Name iox_user_trigger_t iox_user_trigger_init ( iox_user_trigger_storage_t * self) initialize user trigger handle void iox_user_trigger_deinit (iox_user_trigger_t const self) deinitialize user trigger handle void iox_user_trigger_trigger (iox_user_trigger_t const self) trigger a user trigger bool iox_user_trigger_has_triggered (iox_user_trigger_t const self) was the user trigger triggered Types Documentation \ud83d\udd17 typedef iox_user_trigger_t \ud83d\udd17 typedef CLASS UserTrigger * iox_user_trigger_t ; user trigger handle Functions Documentation \ud83d\udd17 function iox_user_trigger_init \ud83d\udd17 iox_user_trigger_t iox_user_trigger_init ( iox_user_trigger_storage_t * self ) initialize user trigger handle Parameters : self pointer to preallocated memory of size = sizeof(iox_user_trigger_storage_t) Return : handle to user trigger function iox_user_trigger_deinit \ud83d\udd17 void iox_user_trigger_deinit ( iox_user_trigger_t const self ) deinitialize user trigger handle Parameters : self handle to user trigger function iox_user_trigger_trigger \ud83d\udd17 void iox_user_trigger_trigger ( iox_user_trigger_t const self ) trigger a user trigger Parameters : self handle to user trigger Note : a user trigger cannot be triggered when it is not attached function iox_user_trigger_has_triggered \ud83d\udd17 bool iox_user_trigger_has_triggered ( iox_user_trigger_t const self ) was the user trigger triggered Parameters : self handle to user trigger Return : returns true if the user trigger was triggered, otherwise false Note : The hasTrigger state will be reset after it was handled by a WaitSet/Listener Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_USER_TRIGGER_H #define IOX_BINDING_C_USER_TRIGGER_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/types.h\" typedef CLASS UserTrigger * iox_user_trigger_t ; iox_user_trigger_t iox_user_trigger_init ( iox_user_trigger_storage_t * self ); void iox_user_trigger_deinit ( iox_user_trigger_t const self ); void iox_user_trigger_trigger ( iox_user_trigger_t const self ); bool iox_user_trigger_has_triggered ( iox_user_trigger_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/user_trigger.h"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#iceoryx_binding_cuser_triggerh","text":"","title":"iceoryx_binding_c/user_trigger.h"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#types","text":"Name typedef CLASS UserTrigger * iox_user_trigger_t user trigger handle","title":"Types"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#functions","text":"Name iox_user_trigger_t iox_user_trigger_init ( iox_user_trigger_storage_t * self) initialize user trigger handle void iox_user_trigger_deinit (iox_user_trigger_t const self) deinitialize user trigger handle void iox_user_trigger_trigger (iox_user_trigger_t const self) trigger a user trigger bool iox_user_trigger_has_triggered (iox_user_trigger_t const self) was the user trigger triggered","title":"Functions"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#typedef-iox_user_trigger_t","text":"typedef CLASS UserTrigger * iox_user_trigger_t ; user trigger handle","title":"typedef iox_user_trigger_t"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_init","text":"iox_user_trigger_t iox_user_trigger_init ( iox_user_trigger_storage_t * self ) initialize user trigger handle Parameters : self pointer to preallocated memory of size = sizeof(iox_user_trigger_storage_t) Return : handle to user trigger","title":"function iox_user_trigger_init"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_deinit","text":"void iox_user_trigger_deinit ( iox_user_trigger_t const self ) deinitialize user trigger handle Parameters : self handle to user trigger","title":"function iox_user_trigger_deinit"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_trigger","text":"void iox_user_trigger_trigger ( iox_user_trigger_t const self ) trigger a user trigger Parameters : self handle to user trigger Note : a user trigger cannot be triggered when it is not attached","title":"function iox_user_trigger_trigger"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#function-iox_user_trigger_has_triggered","text":"bool iox_user_trigger_has_triggered ( iox_user_trigger_t const self ) was the user trigger triggered Parameters : self handle to user trigger Return : returns true if the user trigger was triggered, otherwise false Note : The hasTrigger state will be reset after it was handled by a WaitSet/Listener","title":"function iox_user_trigger_has_triggered"},{"location":"API-reference/c-binding/Files/user__trigger_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_USER_TRIGGER_H #define IOX_BINDING_C_USER_TRIGGER_H #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/types.h\" typedef CLASS UserTrigger * iox_user_trigger_t ; iox_user_trigger_t iox_user_trigger_init ( iox_user_trigger_storage_t * self ); void iox_user_trigger_deinit ( iox_user_trigger_t const self ); void iox_user_trigger_trigger ( iox_user_trigger_t const self ); bool iox_user_trigger_has_triggered ( iox_user_trigger_t const self ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/c-binding/Files/wait__set_8h/","text":"iceoryx_binding_c/wait_set.h \ud83d\udd17 Types \ud83d\udd17 Name typedef CLASS cpp2c_WaitSet * iox_ws_t wait set handle Functions \ud83d\udd17 Name iox_ws_t iox_ws_init ( iox_ws_storage_t * self) initialize wait set handle void iox_ws_deinit (iox_ws_t const self) deinitialize wait set handle uint64_t iox_ws_timed_wait (iox_ws_t const self, struct timespec timeout, iox_notification_info_t *const notificationInfoArray, const uint64_t notificationInfoArrayCapacity, uint64_t * missedElements) waits until an event occurred or the timeout was reached uint64_t iox_ws_wait (iox_ws_t const self, iox_notification_info_t *const notificationInfoArray, const uint64_t notificationInfoArrayCapacity, uint64_t * missedElements) waits until an event occurred uint64_t iox_ws_size (iox_ws_t const self) returns the number of registered events/states uint64_t iox_ws_capacity (iox_ws_t const self) returns the maximum amount of events/states which can be registered at the waitset void iox_ws_mark_for_destruction (iox_ws_t const self) Non-reversible call. After this call iox_ws_wait() and iox_ws_timed_wait() do not block any longer and never return triggered events/states. This function can be used to manually initialize destruction and to wakeup any thread which is waiting in iox_ws_wait() or iox_ws_timed_wait(). ENUM iox_WaitSetResult iox_ws_attach_subscriber_state (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState, const uint64_t id, void(*)(iox_sub_t) callback) attaches a subscriber state to a waitset ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState, const uint64_t id, void( )(iox_sub_t, void ) callback, void *const contextData) attaches a subscriber state to a waitset. The callback has an additional contextData argument to provide access to user defined data. ENUM iox_WaitSetResult iox_ws_attach_subscriber_event (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, const uint64_t eventId, void(*)(iox_sub_t) callback) attaches a subscriber event to a waitset ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, const uint64_t eventId, void( )(iox_sub_t, void ) callback, void *const contextData) attaches a subscriber event to a waitset. The callback has an additional contextData argument to provide access to user defined data. ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event (iox_ws_t const self, iox_user_trigger_t const userTrigger, const uint64_t eventId, void(*)(iox_user_trigger_t) callback) attaches a user trigger event to a waitset ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data (iox_ws_t const self, iox_user_trigger_t const userTrigger, const uint64_t eventId, void( )(iox_user_trigger_t, void ) callback, void *const contextData) attaches a user trigger event to a waitset. The callback has an additional contextData argument to provide access to user defined data. void iox_ws_detach_subscriber_event (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent) detaches a subscriber event from a waitset void iox_ws_detach_subscriber_state (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState) detaches a subscriber state from a waitset void iox_ws_detach_user_trigger_event (iox_ws_t const self, iox_user_trigger_t const userTrigger) detaches a user trigger event from a waitset ENUM iox_WaitSetResult iox_ws_attach_client_event (const iox_ws_t self, const iox_client_t client, const ENUM iox_ClientEvent clientEvent, const uint64_t eventId, void(*)(iox_client_t) callback) attaches a client event to a waitset ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, const uint64_t eventId, void( )(iox_client_t, void ) callback, void *const contextData) attaches a client event to a waitset with additional context data for the callback ENUM iox_WaitSetResult iox_ws_attach_client_state (const iox_ws_t self, const iox_client_t client, const ENUM iox_ClientState clientState, const uint64_t eventId, void(*)(iox_client_t) callback) attaches a client state to a waitset ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState, const uint64_t eventId, void( )(iox_client_t, void ) callback, void *const contextData) attaches a client state to a waitset with additional context data for the callback void iox_ws_detach_client_event (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent) detaches a client event from a waitset void iox_ws_detach_client_state (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState) detaches a client state from a waitset ENUM iox_WaitSetResult iox_ws_attach_server_event (const iox_ws_t self, const iox_server_t server, const ENUM iox_ServerEvent serverEvent, const uint64_t eventId, void(*)(iox_server_t) callback) attaches a server event to a waitset ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, const uint64_t eventId, void( )(iox_server_t, void ) callback, void *const contextData) attaches a server event to a waitset with additional context data for the callback ENUM iox_WaitSetResult iox_ws_attach_server_state (const iox_ws_t self, const iox_server_t server, const ENUM iox_ServerState serverState, const uint64_t eventId, void(*)(iox_server_t) callback) attaches a server state to a waitset ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState, const uint64_t eventId, void( )(iox_server_t, void ) callback, void *const contextData) attaches a server state to a waitset with additional context data for the callback void iox_ws_detach_server_event (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent) detaches a server event from a waitset void iox_ws_detach_server_state (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState) detaches a server state from a waitset ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event (const iox_ws_t self, const iox_service_discovery_t serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, const uint64_t eventId, void(*)(iox_service_discovery_t) callback) attaches a service discovery event to a waitset ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data (iox_ws_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, const uint64_t eventId, void( )(iox_service_discovery_t, void ) callback, void *const contextData) attaches a service discovery event to a waitset with additional context data for the callback void iox_ws_detach_service_discovery_event (iox_ws_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent) detaches a service discovery event from a waitset Types Documentation \ud83d\udd17 typedef iox_ws_t \ud83d\udd17 typedef CLASS cpp2c_WaitSet * iox_ws_t ; wait set handle Functions Documentation \ud83d\udd17 function iox_ws_init \ud83d\udd17 iox_ws_t iox_ws_init ( iox_ws_storage_t * self ) initialize wait set handle Parameters : self pointer to preallocated memory of size = sizeof(iox_ws_storage_t) Return : handle to wait set function iox_ws_deinit \ud83d\udd17 void iox_ws_deinit ( iox_ws_t const self ) deinitialize wait set handle Parameters : self the handle which should be deinitialized function iox_ws_timed_wait \ud83d\udd17 uint64_t iox_ws_timed_wait ( iox_ws_t const self , struct timespec timeout , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ) waits until an event occurred or the timeout was reached Parameters : self handle to the wait set timeout duration how long this method should wait notificationInfoArray preallocated memory to an array of iox_notification_info_t in which the notification infos, which are describing the occurred event, can be written to notificationInfoArrayCapacity the capacity of the preallocated notificationInfoArray missedElements if the notificationInfoArray has insufficient size the number of missed elements which could not be written into the array are stored here Return : number of elements which were written into the notificationInfoArray function iox_ws_wait \ud83d\udd17 uint64_t iox_ws_wait ( iox_ws_t const self , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ) waits until an event occurred Parameters : self handle to the wait set notificationInfoArray preallocated memory to an array of iox_notification_info_t in which the notification infos, which are describing the occurred event, can be written to notificationInfoArrayCapacity the capacity of the preallocated notificationInfoArray missedElements if the notificationInfoArray has insufficient size the number of missed elements which could not be written into the array are stored here Return : number of elements which were written into the notificationInfoArray function iox_ws_size \ud83d\udd17 uint64_t iox_ws_size ( iox_ws_t const self ) returns the number of registered events/states function iox_ws_capacity \ud83d\udd17 uint64_t iox_ws_capacity ( iox_ws_t const self ) returns the maximum amount of events/states which can be registered at the waitset function iox_ws_mark_for_destruction \ud83d\udd17 void iox_ws_mark_for_destruction ( iox_ws_t const self ) Non-reversible call. After this call iox_ws_wait() and iox_ws_timed_wait() do not block any longer and never return triggered events/states. This function can be used to manually initialize destruction and to wakeup any thread which is waiting in iox_ws_wait() or iox_ws_timed_wait(). function iox_ws_attach_subscriber_state \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * )( iox_sub_t ) callback ) attaches a subscriber state to a waitset Parameters : self handle to the waitset subscriber the subscriber of the state which should be attached subscriberState the state which should be attached id an arbitrary id which will be tagged to the state callback a callback which is attached to the state Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_subscriber_state_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * )( iox_sub_t , void * ) callback , void * const contextData ) attaches a subscriber state to a waitset. The callback has an additional contextData argument to provide access to user defined data. Parameters : self handle to the waitset subscriber the subscriber of the state which should be attached subscriberState the state which should be attached id an arbitrary id which will be tagged to the state callback a callback which is attached to the state contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_subscriber_event \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * )( iox_sub_t ) callback ) attaches a subscriber event to a waitset Parameters : self handle to the waitset subscriber the subscriber of the event which should be attached subscriberEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_subscriber_event_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * )( iox_sub_t , void * ) callback , void * const contextData ) attaches a subscriber event to a waitset. The callback has an additional contextData argument to provide access to user defined data. Parameters : self handle to the waitset subscriber the subscriber of the event which should be attached subscriberEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_user_trigger_event \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * )( iox_user_trigger_t ) callback ) attaches a user trigger event to a waitset Parameters : self handle to the waitset userTrigger the user trigger of the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_user_trigger_event_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * )( iox_user_trigger_t , void * ) callback , void * const contextData ) attaches a user trigger event to a waitset. The callback has an additional contextData argument to provide access to user defined data. Parameters : self handle to the waitset userTrigger the user trigger of the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_detach_subscriber_event \ud83d\udd17 void iox_ws_detach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ) detaches a subscriber event from a waitset Parameters : self handle to the waitset subscriber the subscriber from which the event should be detached subscriberEvent the event which should be detached from the subscriber function iox_ws_detach_subscriber_state \ud83d\udd17 void iox_ws_detach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState ) detaches a subscriber state from a waitset Parameters : self handle to the waitset subscriber the subscriber from which the state should be detached subscriberState the state which should be detached from the subscriber function iox_ws_detach_user_trigger_event \ud83d\udd17 void iox_ws_detach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger ) detaches a user trigger event from a waitset Parameters : self handle to the waitset usertrigger the user trigger which should be detached function iox_ws_attach_client_event \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_client_event ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * )( iox_client_t ) callback ) attaches a client event to a waitset Parameters : self handle to the waitset client the client of the event which should be attached clientEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_client_event_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * )( iox_client_t , void * ) callback , void * const contextData ) attaches a client event to a waitset with additional context data for the callback Parameters : self handle to the waitset client the client of the event which should be attached clientEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_client_state \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_client_state ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * )( iox_client_t ) callback ) attaches a client state to a waitset Parameters : self handle to the waitset client the client of the state which should be attached clientState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_client_state_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * )( iox_client_t , void * ) callback , void * const contextData ) attaches a client state to a waitset with additional context data for the callback Parameters : self handle to the waitset client the client of the state which should be attached clientState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_detach_client_event \ud83d\udd17 void iox_ws_detach_client_event ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ) detaches a client event from a waitset Parameters : self handle to the waitset client the client which should be detached clientEvent the event which should be detached from the client function iox_ws_detach_client_state \ud83d\udd17 void iox_ws_detach_client_state ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState ) detaches a client state from a waitset Parameters : self handle to the waitset client the client which should be detached clientState the state which should be detached from the client function iox_ws_attach_server_event \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_server_event ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * )( iox_server_t ) callback ) attaches a server event to a waitset Parameters : self handle to the waitset server the server of the event which should be attached serverEvent the server which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_server_event_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * )( iox_server_t , void * ) callback , void * const contextData ) attaches a server event to a waitset with additional context data for the callback Parameters : self handle to the waitset server the server of the event which should be attached serverEvent the server which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_server_state \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_server_state ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * )( iox_server_t ) callback ) attaches a server state to a waitset Parameters : self handle to the waitset server the server of the state which should be attached serverState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_server_state_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * )( iox_server_t , void * ) callback , void * const contextData ) attaches a server state to a waitset with additional context data for the callback Parameters : self handle to the waitset server the server of the state which should be attached serverState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_detach_server_event \ud83d\udd17 void iox_ws_detach_server_event ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ) detaches a server event from a waitset Parameters : self handle to the waitset server the server which should be detached serverEvent the event which should be detached from the server function iox_ws_detach_server_state \ud83d\udd17 void iox_ws_detach_server_state ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState ) detaches a server state from a waitset Parameters : self handle to the waitset server the server which should be detached serverState the state which should be detached from the server function iox_ws_attach_service_discovery_event \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event ( const iox_ws_t self , const iox_service_discovery_t serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * )( iox_service_discovery_t ) callback ) attaches a service discovery event to a waitset Parameters : self handle to the waitset serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_attach_service_discovery_event_with_context_data \ud83d\udd17 ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * )( iox_service_discovery_t , void * ) callback , void * const contextData ) attaches a service discovery event to a waitset with additional context data for the callback Parameters : self handle to the waitset serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error function iox_ws_detach_service_discovery_event \ud83d\udd17 void iox_ws_detach_service_discovery_event ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ) detaches a service discovery event from a waitset Parameters : self handle to the waitset serviceDiscovery the service discovery which should be detached serviceDiscoveryEvent the event which should be detached from the service discovery Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_WAIT_SET_H #define IOX_BINDING_C_WAIT_SET_H #include \"iceoryx_binding_c/client.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/notification_info.h\" #include \"iceoryx_binding_c/service_discovery.h\" #include \"iceoryx_binding_c/subscriber.h\" #include \"iceoryx_binding_c/types.h\" #include \"iceoryx_binding_c/user_trigger.h\" #include <time.h> typedef CLASS cpp2c_WaitSet * iox_ws_t ; iox_ws_t iox_ws_init ( iox_ws_storage_t * self ); void iox_ws_deinit ( iox_ws_t const self ); uint64_t iox_ws_timed_wait ( iox_ws_t const self , struct timespec timeout , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ); uint64_t iox_ws_wait ( iox_ws_t const self , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ); uint64_t iox_ws_size ( iox_ws_t const self ); uint64_t iox_ws_capacity ( iox_ws_t const self ); void iox_ws_mark_for_destruction ( iox_ws_t const self ); ENUM iox_WaitSetResult iox_ws_attach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * callback )( iox_sub_t )); ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * callback )( iox_sub_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * callback )( iox_sub_t )); ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * callback )( iox_sub_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * callback )( iox_user_trigger_t )); ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * callback )( iox_user_trigger_t , void * ), void * const contextData ); void iox_ws_detach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ); void iox_ws_detach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState ); void iox_ws_detach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger ); ENUM iox_WaitSetResult iox_ws_attach_client_event ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * callback )( iox_client_t )); ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * callback )( iox_client_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_client_state ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * callback )( iox_client_t )); ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * callback )( iox_client_t , void * ), void * const contextData ); void iox_ws_detach_client_event ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ); void iox_ws_detach_client_state ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState ); ENUM iox_WaitSetResult iox_ws_attach_server_event ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * callback )( iox_server_t )); ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * callback )( iox_server_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_server_state ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * callback )( iox_server_t )); ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * callback )( iox_server_t , void * ), void * const contextData ); void iox_ws_detach_server_event ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ); void iox_ws_detach_server_state ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState ); ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event ( const iox_ws_t self , const iox_service_discovery_t serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * callback )( iox_service_discovery_t )); ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * callback )( iox_service_discovery_t , void * ), void * const contextData ); void iox_ws_detach_service_discovery_event ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_binding_c/wait_set.h"},{"location":"API-reference/c-binding/Files/wait__set_8h/#iceoryx_binding_cwait_seth","text":"","title":"iceoryx_binding_c/wait_set.h"},{"location":"API-reference/c-binding/Files/wait__set_8h/#types","text":"Name typedef CLASS cpp2c_WaitSet * iox_ws_t wait set handle","title":"Types"},{"location":"API-reference/c-binding/Files/wait__set_8h/#functions","text":"Name iox_ws_t iox_ws_init ( iox_ws_storage_t * self) initialize wait set handle void iox_ws_deinit (iox_ws_t const self) deinitialize wait set handle uint64_t iox_ws_timed_wait (iox_ws_t const self, struct timespec timeout, iox_notification_info_t *const notificationInfoArray, const uint64_t notificationInfoArrayCapacity, uint64_t * missedElements) waits until an event occurred or the timeout was reached uint64_t iox_ws_wait (iox_ws_t const self, iox_notification_info_t *const notificationInfoArray, const uint64_t notificationInfoArrayCapacity, uint64_t * missedElements) waits until an event occurred uint64_t iox_ws_size (iox_ws_t const self) returns the number of registered events/states uint64_t iox_ws_capacity (iox_ws_t const self) returns the maximum amount of events/states which can be registered at the waitset void iox_ws_mark_for_destruction (iox_ws_t const self) Non-reversible call. After this call iox_ws_wait() and iox_ws_timed_wait() do not block any longer and never return triggered events/states. This function can be used to manually initialize destruction and to wakeup any thread which is waiting in iox_ws_wait() or iox_ws_timed_wait(). ENUM iox_WaitSetResult iox_ws_attach_subscriber_state (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState, const uint64_t id, void(*)(iox_sub_t) callback) attaches a subscriber state to a waitset ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState, const uint64_t id, void( )(iox_sub_t, void ) callback, void *const contextData) attaches a subscriber state to a waitset. The callback has an additional contextData argument to provide access to user defined data. ENUM iox_WaitSetResult iox_ws_attach_subscriber_event (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, const uint64_t eventId, void(*)(iox_sub_t) callback) attaches a subscriber event to a waitset ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent, const uint64_t eventId, void( )(iox_sub_t, void ) callback, void *const contextData) attaches a subscriber event to a waitset. The callback has an additional contextData argument to provide access to user defined data. ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event (iox_ws_t const self, iox_user_trigger_t const userTrigger, const uint64_t eventId, void(*)(iox_user_trigger_t) callback) attaches a user trigger event to a waitset ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data (iox_ws_t const self, iox_user_trigger_t const userTrigger, const uint64_t eventId, void( )(iox_user_trigger_t, void ) callback, void *const contextData) attaches a user trigger event to a waitset. The callback has an additional contextData argument to provide access to user defined data. void iox_ws_detach_subscriber_event (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberEvent subscriberEvent) detaches a subscriber event from a waitset void iox_ws_detach_subscriber_state (iox_ws_t const self, iox_sub_t const subscriber, const ENUM iox_SubscriberState subscriberState) detaches a subscriber state from a waitset void iox_ws_detach_user_trigger_event (iox_ws_t const self, iox_user_trigger_t const userTrigger) detaches a user trigger event from a waitset ENUM iox_WaitSetResult iox_ws_attach_client_event (const iox_ws_t self, const iox_client_t client, const ENUM iox_ClientEvent clientEvent, const uint64_t eventId, void(*)(iox_client_t) callback) attaches a client event to a waitset ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent, const uint64_t eventId, void( )(iox_client_t, void ) callback, void *const contextData) attaches a client event to a waitset with additional context data for the callback ENUM iox_WaitSetResult iox_ws_attach_client_state (const iox_ws_t self, const iox_client_t client, const ENUM iox_ClientState clientState, const uint64_t eventId, void(*)(iox_client_t) callback) attaches a client state to a waitset ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState, const uint64_t eventId, void( )(iox_client_t, void ) callback, void *const contextData) attaches a client state to a waitset with additional context data for the callback void iox_ws_detach_client_event (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientEvent clientEvent) detaches a client event from a waitset void iox_ws_detach_client_state (iox_ws_t const self, iox_client_t const client, const ENUM iox_ClientState clientState) detaches a client state from a waitset ENUM iox_WaitSetResult iox_ws_attach_server_event (const iox_ws_t self, const iox_server_t server, const ENUM iox_ServerEvent serverEvent, const uint64_t eventId, void(*)(iox_server_t) callback) attaches a server event to a waitset ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent, const uint64_t eventId, void( )(iox_server_t, void ) callback, void *const contextData) attaches a server event to a waitset with additional context data for the callback ENUM iox_WaitSetResult iox_ws_attach_server_state (const iox_ws_t self, const iox_server_t server, const ENUM iox_ServerState serverState, const uint64_t eventId, void(*)(iox_server_t) callback) attaches a server state to a waitset ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState, const uint64_t eventId, void( )(iox_server_t, void ) callback, void *const contextData) attaches a server state to a waitset with additional context data for the callback void iox_ws_detach_server_event (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerEvent serverEvent) detaches a server event from a waitset void iox_ws_detach_server_state (iox_ws_t const self, iox_server_t const server, const ENUM iox_ServerState serverState) detaches a server state from a waitset ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event (const iox_ws_t self, const iox_service_discovery_t serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, const uint64_t eventId, void(*)(iox_service_discovery_t) callback) attaches a service discovery event to a waitset ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data (iox_ws_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent, const uint64_t eventId, void( )(iox_service_discovery_t, void ) callback, void *const contextData) attaches a service discovery event to a waitset with additional context data for the callback void iox_ws_detach_service_discovery_event (iox_ws_t const self, iox_service_discovery_t const serviceDiscovery, const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent) detaches a service discovery event from a waitset","title":"Functions"},{"location":"API-reference/c-binding/Files/wait__set_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/c-binding/Files/wait__set_8h/#typedef-iox_ws_t","text":"typedef CLASS cpp2c_WaitSet * iox_ws_t ; wait set handle","title":"typedef iox_ws_t"},{"location":"API-reference/c-binding/Files/wait__set_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_init","text":"iox_ws_t iox_ws_init ( iox_ws_storage_t * self ) initialize wait set handle Parameters : self pointer to preallocated memory of size = sizeof(iox_ws_storage_t) Return : handle to wait set","title":"function iox_ws_init"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_deinit","text":"void iox_ws_deinit ( iox_ws_t const self ) deinitialize wait set handle Parameters : self the handle which should be deinitialized","title":"function iox_ws_deinit"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_timed_wait","text":"uint64_t iox_ws_timed_wait ( iox_ws_t const self , struct timespec timeout , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ) waits until an event occurred or the timeout was reached Parameters : self handle to the wait set timeout duration how long this method should wait notificationInfoArray preallocated memory to an array of iox_notification_info_t in which the notification infos, which are describing the occurred event, can be written to notificationInfoArrayCapacity the capacity of the preallocated notificationInfoArray missedElements if the notificationInfoArray has insufficient size the number of missed elements which could not be written into the array are stored here Return : number of elements which were written into the notificationInfoArray","title":"function iox_ws_timed_wait"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_wait","text":"uint64_t iox_ws_wait ( iox_ws_t const self , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ) waits until an event occurred Parameters : self handle to the wait set notificationInfoArray preallocated memory to an array of iox_notification_info_t in which the notification infos, which are describing the occurred event, can be written to notificationInfoArrayCapacity the capacity of the preallocated notificationInfoArray missedElements if the notificationInfoArray has insufficient size the number of missed elements which could not be written into the array are stored here Return : number of elements which were written into the notificationInfoArray","title":"function iox_ws_wait"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_size","text":"uint64_t iox_ws_size ( iox_ws_t const self ) returns the number of registered events/states","title":"function iox_ws_size"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_capacity","text":"uint64_t iox_ws_capacity ( iox_ws_t const self ) returns the maximum amount of events/states which can be registered at the waitset","title":"function iox_ws_capacity"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_mark_for_destruction","text":"void iox_ws_mark_for_destruction ( iox_ws_t const self ) Non-reversible call. After this call iox_ws_wait() and iox_ws_timed_wait() do not block any longer and never return triggered events/states. This function can be used to manually initialize destruction and to wakeup any thread which is waiting in iox_ws_wait() or iox_ws_timed_wait().","title":"function iox_ws_mark_for_destruction"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_state","text":"ENUM iox_WaitSetResult iox_ws_attach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * )( iox_sub_t ) callback ) attaches a subscriber state to a waitset Parameters : self handle to the waitset subscriber the subscriber of the state which should be attached subscriberState the state which should be attached id an arbitrary id which will be tagged to the state callback a callback which is attached to the state Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_subscriber_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_state_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * )( iox_sub_t , void * ) callback , void * const contextData ) attaches a subscriber state to a waitset. The callback has an additional contextData argument to provide access to user defined data. Parameters : self handle to the waitset subscriber the subscriber of the state which should be attached subscriberState the state which should be attached id an arbitrary id which will be tagged to the state callback a callback which is attached to the state contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_subscriber_state_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_event","text":"ENUM iox_WaitSetResult iox_ws_attach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * )( iox_sub_t ) callback ) attaches a subscriber event to a waitset Parameters : self handle to the waitset subscriber the subscriber of the event which should be attached subscriberEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_subscriber_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_subscriber_event_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * )( iox_sub_t , void * ) callback , void * const contextData ) attaches a subscriber event to a waitset. The callback has an additional contextData argument to provide access to user defined data. Parameters : self handle to the waitset subscriber the subscriber of the event which should be attached subscriberEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_subscriber_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_user_trigger_event","text":"ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * )( iox_user_trigger_t ) callback ) attaches a user trigger event to a waitset Parameters : self handle to the waitset userTrigger the user trigger of the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_user_trigger_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_user_trigger_event_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * )( iox_user_trigger_t , void * ) callback , void * const contextData ) attaches a user trigger event to a waitset. The callback has an additional contextData argument to provide access to user defined data. Parameters : self handle to the waitset userTrigger the user trigger of the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_user_trigger_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_subscriber_event","text":"void iox_ws_detach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ) detaches a subscriber event from a waitset Parameters : self handle to the waitset subscriber the subscriber from which the event should be detached subscriberEvent the event which should be detached from the subscriber","title":"function iox_ws_detach_subscriber_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_subscriber_state","text":"void iox_ws_detach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState ) detaches a subscriber state from a waitset Parameters : self handle to the waitset subscriber the subscriber from which the state should be detached subscriberState the state which should be detached from the subscriber","title":"function iox_ws_detach_subscriber_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_user_trigger_event","text":"void iox_ws_detach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger ) detaches a user trigger event from a waitset Parameters : self handle to the waitset usertrigger the user trigger which should be detached","title":"function iox_ws_detach_user_trigger_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_event","text":"ENUM iox_WaitSetResult iox_ws_attach_client_event ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * )( iox_client_t ) callback ) attaches a client event to a waitset Parameters : self handle to the waitset client the client of the event which should be attached clientEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_client_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_event_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * )( iox_client_t , void * ) callback , void * const contextData ) attaches a client event to a waitset with additional context data for the callback Parameters : self handle to the waitset client the client of the event which should be attached clientEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_client_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_state","text":"ENUM iox_WaitSetResult iox_ws_attach_client_state ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * )( iox_client_t ) callback ) attaches a client state to a waitset Parameters : self handle to the waitset client the client of the state which should be attached clientState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_client_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_client_state_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * )( iox_client_t , void * ) callback , void * const contextData ) attaches a client state to a waitset with additional context data for the callback Parameters : self handle to the waitset client the client of the state which should be attached clientState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_client_state_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_client_event","text":"void iox_ws_detach_client_event ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ) detaches a client event from a waitset Parameters : self handle to the waitset client the client which should be detached clientEvent the event which should be detached from the client","title":"function iox_ws_detach_client_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_client_state","text":"void iox_ws_detach_client_state ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState ) detaches a client state from a waitset Parameters : self handle to the waitset client the client which should be detached clientState the state which should be detached from the client","title":"function iox_ws_detach_client_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_event","text":"ENUM iox_WaitSetResult iox_ws_attach_server_event ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * )( iox_server_t ) callback ) attaches a server event to a waitset Parameters : self handle to the waitset server the server of the event which should be attached serverEvent the server which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_server_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_event_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * )( iox_server_t , void * ) callback , void * const contextData ) attaches a server event to a waitset with additional context data for the callback Parameters : self handle to the waitset server the server of the event which should be attached serverEvent the server which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_server_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_state","text":"ENUM iox_WaitSetResult iox_ws_attach_server_state ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * )( iox_server_t ) callback ) attaches a server state to a waitset Parameters : self handle to the waitset server the server of the state which should be attached serverState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_server_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_server_state_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * )( iox_server_t , void * ) callback , void * const contextData ) attaches a server state to a waitset with additional context data for the callback Parameters : self handle to the waitset server the server of the state which should be attached serverState the state which should be attached eventId an arbitrary id which will be tagged to the state callback a callback which is attached to the state contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_server_state_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_server_event","text":"void iox_ws_detach_server_event ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ) detaches a server event from a waitset Parameters : self handle to the waitset server the server which should be detached serverEvent the event which should be detached from the server","title":"function iox_ws_detach_server_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_server_state","text":"void iox_ws_detach_server_state ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState ) detaches a server state from a waitset Parameters : self handle to the waitset server the server which should be detached serverState the state which should be detached from the server","title":"function iox_ws_detach_server_state"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_service_discovery_event","text":"ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event ( const iox_ws_t self , const iox_service_discovery_t serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * )( iox_service_discovery_t ) callback ) attaches a service discovery event to a waitset Parameters : self handle to the waitset serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_service_discovery_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_attach_service_discovery_event_with_context_data","text":"ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * )( iox_service_discovery_t , void * ) callback , void * const contextData ) attaches a service discovery event to a waitset with additional context data for the callback Parameters : self handle to the waitset serviceDiscovery service discovery which emits the event serviceDiscoveryEvent the event which should be attached eventId an arbitrary id which will be tagged to the event callback a callback which is attached to the event contextData a void pointer which is provided as second argument to the callback Return : if the attaching was successfull it returns WaitSetResult_SUCCESS, otherwise an enum which describes the error","title":"function iox_ws_attach_service_discovery_event_with_context_data"},{"location":"API-reference/c-binding/Files/wait__set_8h/#function-iox_ws_detach_service_discovery_event","text":"void iox_ws_detach_service_discovery_event ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ) detaches a service discovery event from a waitset Parameters : self handle to the waitset serviceDiscovery the service discovery which should be detached serviceDiscoveryEvent the event which should be detached from the service discovery","title":"function iox_ws_detach_service_discovery_event"},{"location":"API-reference/c-binding/Files/wait__set_8h/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_BINDING_C_WAIT_SET_H #define IOX_BINDING_C_WAIT_SET_H #include \"iceoryx_binding_c/client.h\" #include \"iceoryx_binding_c/enums.h\" #include \"iceoryx_binding_c/internal/c2cpp_binding.h\" #include \"iceoryx_binding_c/notification_info.h\" #include \"iceoryx_binding_c/service_discovery.h\" #include \"iceoryx_binding_c/subscriber.h\" #include \"iceoryx_binding_c/types.h\" #include \"iceoryx_binding_c/user_trigger.h\" #include <time.h> typedef CLASS cpp2c_WaitSet * iox_ws_t ; iox_ws_t iox_ws_init ( iox_ws_storage_t * self ); void iox_ws_deinit ( iox_ws_t const self ); uint64_t iox_ws_timed_wait ( iox_ws_t const self , struct timespec timeout , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ); uint64_t iox_ws_wait ( iox_ws_t const self , iox_notification_info_t * const notificationInfoArray , const uint64_t notificationInfoArrayCapacity , uint64_t * missedElements ); uint64_t iox_ws_size ( iox_ws_t const self ); uint64_t iox_ws_capacity ( iox_ws_t const self ); void iox_ws_mark_for_destruction ( iox_ws_t const self ); ENUM iox_WaitSetResult iox_ws_attach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * callback )( iox_sub_t )); ENUM iox_WaitSetResult iox_ws_attach_subscriber_state_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState , const uint64_t id , void ( * callback )( iox_sub_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * callback )( iox_sub_t )); ENUM iox_WaitSetResult iox_ws_attach_subscriber_event_with_context_data ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent , const uint64_t eventId , void ( * callback )( iox_sub_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * callback )( iox_user_trigger_t )); ENUM iox_WaitSetResult iox_ws_attach_user_trigger_event_with_context_data ( iox_ws_t const self , iox_user_trigger_t const userTrigger , const uint64_t eventId , void ( * callback )( iox_user_trigger_t , void * ), void * const contextData ); void iox_ws_detach_subscriber_event ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberEvent subscriberEvent ); void iox_ws_detach_subscriber_state ( iox_ws_t const self , iox_sub_t const subscriber , const ENUM iox_SubscriberState subscriberState ); void iox_ws_detach_user_trigger_event ( iox_ws_t const self , iox_user_trigger_t const userTrigger ); ENUM iox_WaitSetResult iox_ws_attach_client_event ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * callback )( iox_client_t )); ENUM iox_WaitSetResult iox_ws_attach_client_event_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent , const uint64_t eventId , void ( * callback )( iox_client_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_client_state ( const iox_ws_t self , const iox_client_t client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * callback )( iox_client_t )); ENUM iox_WaitSetResult iox_ws_attach_client_state_with_context_data ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState , const uint64_t eventId , void ( * callback )( iox_client_t , void * ), void * const contextData ); void iox_ws_detach_client_event ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientEvent clientEvent ); void iox_ws_detach_client_state ( iox_ws_t const self , iox_client_t const client , const ENUM iox_ClientState clientState ); ENUM iox_WaitSetResult iox_ws_attach_server_event ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * callback )( iox_server_t )); ENUM iox_WaitSetResult iox_ws_attach_server_event_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent , const uint64_t eventId , void ( * callback )( iox_server_t , void * ), void * const contextData ); ENUM iox_WaitSetResult iox_ws_attach_server_state ( const iox_ws_t self , const iox_server_t server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * callback )( iox_server_t )); ENUM iox_WaitSetResult iox_ws_attach_server_state_with_context_data ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState , const uint64_t eventId , void ( * callback )( iox_server_t , void * ), void * const contextData ); void iox_ws_detach_server_event ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerEvent serverEvent ); void iox_ws_detach_server_state ( iox_ws_t const self , iox_server_t const server , const ENUM iox_ServerState serverState ); ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event ( const iox_ws_t self , const iox_service_discovery_t serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * callback )( iox_service_discovery_t )); ENUM iox_WaitSetResult iox_ws_attach_service_discovery_event_with_context_data ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent , const uint64_t eventId , void ( * callback )( iox_service_discovery_t , void * ), void * const contextData ); void iox_ws_detach_service_discovery_event ( iox_ws_t const self , iox_service_discovery_t const serviceDiscovery , const ENUM iox_ServiceDiscoveryEvent serviceDiscoveryEvent ); #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/","text":"DesignPattern::Creation \ud83d\udd17 This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. More... #include <iceoryx_hoofs/design_pattern/creation.hpp> Inherited by iox::posix::FileLock , iox::posix::Semaphore Public Types \ud83d\udd17 Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions \ud83d\udd17 Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation & operator= ( Creation && rhs) Creation (const Creation & rhs) =default Creation & operator= (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes \ud83d\udd17 Name bool m_isInitialized ErrorType m_errorValue Detailed Description \ud83d\udd17 template < typename DerivedClass , typename ErrorType > class DesignPattern :: Creation ; This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. Template Parameters : DerivedClass the class which inherits from the creation pattern ErrorType the error type which is going to be used when an error occurs enum class MyResourceAbstractionError { ResourceNotAvailable , BlaBlubError }; class MyResourceAbstraction : public Creation < MyResourceAbstraction , MyResourceAbstractionError > { public : // some public methods MyResourceAbstraction & operator = ( MyResourceAbstraction && rhs ) noexcept { if ( this != & rhs ) { // always call the creation move assignment operator when you have a user defined // move operation CreationPattern_t :: operator = ( std :: move ( rhs )); // user move code } return * this ; } // the creation pattern is the only one which should be allowed to construct // the class, therefore it has to be friend of that class friend class Creation < MyResourceAbstraction , MyResourceAbstractionError > ; private : MyResourceAbstraction ( int a ) { if ( a > 0 ) { // we are able to initialize the class an set m_isInitialized to true m_isInitialized = true ; } else { // we are unable to construct the class therefore we have to set // m_isInitialized to false and store the error code in the // provided m_errorValue member m_errorValue = MyResourceAbstractionError :: ResourceNotAvailable ; m_isInitialized = false ; } } } // if the system resource is movable auto resource = MyResourceAbstraction :: Create ( 123 ); if ( resource . has_error () && resource . get_error () == MyResourceAbstractionError :: ResourceNotAvailable ) // perform error handling else // perform some work // if the system resource is not movable MyResourceAbstraction * resource = malloc ( sizeof ( MyResourceAbstraction )); auto result = MyResourceAbstraction :: placementCreate ( resource , 123 ); if ( result . has_error () ) // perform error handling else resource -> DoStuff (); delete resource ; Public Types Documentation \ud83d\udd17 using CreationPattern_t \ud83d\udd17 using DesignPattern :: Creation < DerivedClass , ErrorType >:: CreationPattern_t = Creation < DerivedClass , ErrorType > ; using result_t \ud83d\udd17 using DesignPattern :: Creation < DerivedClass , ErrorType >:: result_t = iox :: cxx :: expected < DerivedClass , ErrorType > ; using errorType_t \ud83d\udd17 using DesignPattern :: Creation < DerivedClass , ErrorType >:: errorType_t = ErrorType ; Public Functions Documentation \ud83d\udd17 function create \ud83d\udd17 template < typename ... Targs > static result_t create ( Targs && ... args ) factory method which guarantees that either a working object is produced or an error value describing the error during construction Parameters : args the argument values which will be forwarded to the ctor Template Parameters : Targs the argument types which will be forwarded to the ctor Return : returns an expected which either contains the object in a valid constructed state or an error value stating why the construction failed. function verify \ud83d\udd17 static result_t verify ( DerivedClass && newObject ) verifies if a class was created successfully Parameters : newObject rvalue of the object which should be verified Return : returns an expected which either contains the object in a valid constructed state or an error value stating why it was in an invalid state. function placementCreate \ud83d\udd17 template < typename ... Targs > static iox :: cxx :: expected < ErrorType > placementCreate ( void * const memory , Targs && ... args ) factory method which guarantees that either a working object is produced or an error value describing the error during construction Parameters : memory a piece of memory where the object is created into with placement new args the argument values which will be forwarded to the ctor Template Parameters : Targs the argument types which will be forwarded to the ctor Return : returns an expected which either contains the object in a valid constructed state or an error value stating why the construction failed. function Creation \ud83d\udd17 Creation () = default function Creation \ud83d\udd17 Creation ( Creation && rhs ) function operator= \ud83d\udd17 Creation & operator = ( Creation && rhs ) function Creation \ud83d\udd17 Creation ( const Creation & rhs ) = default function operator= \ud83d\udd17 Creation & operator = ( const Creation & rhs ) = default function isInitialized \ud83d\udd17 bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes Documentation \ud83d\udd17 variable m_isInitialized \ud83d\udd17 bool m_isInitialized { false }; variable m_errorValue \ud83d\udd17 ErrorType m_errorValue ; Updated on 18 December 2023 at 13:11:42 CET","title":"DesignPattern::Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#designpatterncreation","text":"This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. More... #include <iceoryx_hoofs/design_pattern/creation.hpp> Inherited by iox::posix::FileLock , iox::posix::Semaphore","title":"DesignPattern::Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-types","text":"Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-functions","text":"Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation & operator= ( Creation && rhs) Creation (const Creation & rhs) =default Creation & operator= (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#protected-attributes","text":"Name bool m_isInitialized ErrorType m_errorValue","title":"Protected Attributes"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#detailed-description","text":"template < typename DerivedClass , typename ErrorType > class DesignPattern :: Creation ; This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. Template Parameters : DerivedClass the class which inherits from the creation pattern ErrorType the error type which is going to be used when an error occurs enum class MyResourceAbstractionError { ResourceNotAvailable , BlaBlubError }; class MyResourceAbstraction : public Creation < MyResourceAbstraction , MyResourceAbstractionError > { public : // some public methods MyResourceAbstraction & operator = ( MyResourceAbstraction && rhs ) noexcept { if ( this != & rhs ) { // always call the creation move assignment operator when you have a user defined // move operation CreationPattern_t :: operator = ( std :: move ( rhs )); // user move code } return * this ; } // the creation pattern is the only one which should be allowed to construct // the class, therefore it has to be friend of that class friend class Creation < MyResourceAbstraction , MyResourceAbstractionError > ; private : MyResourceAbstraction ( int a ) { if ( a > 0 ) { // we are able to initialize the class an set m_isInitialized to true m_isInitialized = true ; } else { // we are unable to construct the class therefore we have to set // m_isInitialized to false and store the error code in the // provided m_errorValue member m_errorValue = MyResourceAbstractionError :: ResourceNotAvailable ; m_isInitialized = false ; } } } // if the system resource is movable auto resource = MyResourceAbstraction :: Create ( 123 ); if ( resource . has_error () && resource . get_error () == MyResourceAbstractionError :: ResourceNotAvailable ) // perform error handling else // perform some work // if the system resource is not movable MyResourceAbstraction * resource = malloc ( sizeof ( MyResourceAbstraction )); auto result = MyResourceAbstraction :: placementCreate ( resource , 123 ); if ( result . has_error () ) // perform error handling else resource -> DoStuff (); delete resource ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#using-creationpattern_t","text":"using DesignPattern :: Creation < DerivedClass , ErrorType >:: CreationPattern_t = Creation < DerivedClass , ErrorType > ;","title":"using CreationPattern_t"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#using-result_t","text":"using DesignPattern :: Creation < DerivedClass , ErrorType >:: result_t = iox :: cxx :: expected < DerivedClass , ErrorType > ;","title":"using result_t"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#using-errortype_t","text":"using DesignPattern :: Creation < DerivedClass , ErrorType >:: errorType_t = ErrorType ;","title":"using errorType_t"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-create","text":"template < typename ... Targs > static result_t create ( Targs && ... args ) factory method which guarantees that either a working object is produced or an error value describing the error during construction Parameters : args the argument values which will be forwarded to the ctor Template Parameters : Targs the argument types which will be forwarded to the ctor Return : returns an expected which either contains the object in a valid constructed state or an error value stating why the construction failed.","title":"function create"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-verify","text":"static result_t verify ( DerivedClass && newObject ) verifies if a class was created successfully Parameters : newObject rvalue of the object which should be verified Return : returns an expected which either contains the object in a valid constructed state or an error value stating why it was in an invalid state.","title":"function verify"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-placementcreate","text":"template < typename ... Targs > static iox :: cxx :: expected < ErrorType > placementCreate ( void * const memory , Targs && ... args ) factory method which guarantees that either a working object is produced or an error value describing the error during construction Parameters : memory a piece of memory where the object is created into with placement new args the argument values which will be forwarded to the ctor Template Parameters : Targs the argument types which will be forwarded to the ctor Return : returns an expected which either contains the object in a valid constructed state or an error value stating why the construction failed.","title":"function placementCreate"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-creation","text":"Creation () = default","title":"function Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-creation_1","text":"Creation ( Creation && rhs )","title":"function Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-operator","text":"Creation & operator = ( Creation && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-creation_2","text":"Creation ( const Creation & rhs ) = default","title":"function Creation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-operator_1","text":"Creation & operator = ( const Creation & rhs ) = default","title":"function operator="},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#function-isinitialized","text":"bool isInitialized () const returns true if the object was constructed successfully, otherwise false","title":"function isInitialized"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#variable-m_isinitialized","text":"bool m_isInitialized { false };","title":"variable m_isInitialized"},{"location":"API-reference/hoofs/Classes/classDesignPattern_1_1Creation/#variable-m_errorvalue","text":"ErrorType m_errorValue ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable m_errorValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/","text":"iox::ErrorHandler \ud83d\udd17 This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling. #include <iceoryx_hoofs/error_handling/error_handling.hpp> Public Functions \ud83d\udd17 Name cxx::GenericRAII setTemporaryErrorHandler (const HandlerFunction & newHandler) const char * toString (const Error error) Protected Functions \ud83d\udd17 Name void reactOnErrorLevel (const ErrorLevel level, const char * errorText) Friends \ud83d\udd17 Name void errorHandler (const Error error, const std::function< void()> & errorCallBack, const ErrorLevel level) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! Public Functions Documentation \ud83d\udd17 function setTemporaryErrorHandler \ud83d\udd17 static cxx :: GenericRAII setTemporaryErrorHandler ( const HandlerFunction & newHandler ) function toString \ud83d\udd17 static const char * toString ( const Error error ) Protected Functions Documentation \ud83d\udd17 function reactOnErrorLevel \ud83d\udd17 static void reactOnErrorLevel ( const ErrorLevel level , const char * errorText ) Friends \ud83d\udd17 friend errorHandler \ud83d\udd17 friend void errorHandler ( const Error error , const std :: function < void () > & errorCallBack , const ErrorLevel level ); Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! 2.) Call errorHandler(Error::kMODULE_NAME__MY_FUNKY_ERROR); Please pay attention to the \"k\" prefix The defaults for errorCallback and ErrorLevel can also be overwritten: errorHandler( Error::kMODULE_NAME__MY_FUNKY_ERROR, []{ std::cout << \"MyCustomCallback\" << std::endl; }, ErrorLevel::MODERATE ); class PrettyClass { float division ( float a , float b ) { if ( b == 0.0f ) { errorHandler ( Error :: kPRETTY_CLASS__DIVISION_BY_ZERO ); } } }; bool called = false ; auto temporaryErrorHandler = ErrorHandler :: setTemporaryErrorHandler ( [ & ]( const Error e , std :: function < void () > , const ErrorLevel ) { called = true ; }); errorHandler ( Error :: kTEST__ASSERT_CALLED ); ASSERT_TRUE ( called ); Updated on 18 December 2023 at 13:11:42 CET","title":"iox::ErrorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#ioxerrorhandler","text":"This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling. #include <iceoryx_hoofs/error_handling/error_handling.hpp>","title":"iox::ErrorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#public-functions","text":"Name cxx::GenericRAII setTemporaryErrorHandler (const HandlerFunction & newHandler) const char * toString (const Error error)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#protected-functions","text":"Name void reactOnErrorLevel (const ErrorLevel level, const char * errorText)","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#friends","text":"Name void errorHandler (const Error error, const std::function< void()> & errorCallBack, const ErrorLevel level) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright!","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#function-settemporaryerrorhandler","text":"static cxx :: GenericRAII setTemporaryErrorHandler ( const HandlerFunction & newHandler )","title":"function setTemporaryErrorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#function-tostring","text":"static const char * toString ( const Error error )","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#function-reactonerrorlevel","text":"static void reactOnErrorLevel ( const ErrorLevel level , const char * errorText )","title":"function reactOnErrorLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1ErrorHandler/#friend-errorhandler","text":"friend void errorHandler ( const Error error , const std :: function < void () > & errorCallBack , const ErrorLevel level ); Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! 2.) Call errorHandler(Error::kMODULE_NAME__MY_FUNKY_ERROR); Please pay attention to the \"k\" prefix The defaults for errorCallback and ErrorLevel can also be overwritten: errorHandler( Error::kMODULE_NAME__MY_FUNKY_ERROR, []{ std::cout << \"MyCustomCallback\" << std::endl; }, ErrorLevel::MODERATE ); class PrettyClass { float division ( float a , float b ) { if ( b == 0.0f ) { errorHandler ( Error :: kPRETTY_CLASS__DIVISION_BY_ZERO ); } } }; bool called = false ; auto temporaryErrorHandler = ErrorHandler :: setTemporaryErrorHandler ( [ & ]( const Error e , std :: function < void () > , const ErrorLevel ) { called = true ; }); errorHandler ( Error :: kTEST__ASSERT_CALLED ); ASSERT_TRUE ( called ); Updated on 18 December 2023 at 13:11:42 CET","title":"friend errorHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/","text":"iox::concurrent::LockFreeQueue \ud83d\udd17 implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity More... #include <iceoryx_hoofs/concurrent/lockfree_queue.hpp> Public Types \ud83d\udd17 Name using ElementType element_t Protected Types \ud83d\udd17 Name using IndexQueue< Capacity > Queue using typename Queue::value_t BufferIndex Public Functions \ud83d\udd17 Name LockFreeQueue () creates and initalizes an empty LockFreeQueue ~LockFreeQueue () =default LockFreeQueue (const LockFreeQueue & ) LockFreeQueue ( LockFreeQueue && ) LockFreeQueue & operator= (const LockFreeQueue & ) LockFreeQueue & operator= ( LockFreeQueue && ) constexpr uint64_t capacity () const returns the capacity of the queue bool tryPush (ElementType && value) tries to insert value in FIFO order, moves the value internally bool tryPush (const ElementType & value) tries to insert value in FIFO order, copies the value internally iox::cxx::optional < ElementType > push (const ElementType & value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) iox::cxx::optional < ElementType > push (ElementType && value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) iox::cxx::optional < ElementType > pop () tries to remove value in FIFO order bool empty () const check whether the queue is empty uint64_t size () const get the number of stored elements in the queue Protected Functions \ud83d\udd17 Name template <typename T > void writeBufferAt (const BufferIndex & , T && ) template <typename T > iox::cxx::optional < ElementType > pushImpl (T && value) cxx::optional < ElementType > readBufferAt (const BufferIndex & ) Protected Attributes \ud83d\udd17 Name Queue m_freeIndices Queue m_usedIndices Buffer< ElementType, Capacity, BufferIndex > m_buffer std::atomic< uint64_t > m_size Detailed Description \ud83d\udd17 template < typename ElementType , uint64_t Capacity > class iox :: concurrent :: LockFreeQueue ; implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity Public Types Documentation \ud83d\udd17 using element_t \ud83d\udd17 using iox :: concurrent :: LockFreeQueue < ElementType , Capacity >:: element_t = ElementType ; Protected Types Documentation \ud83d\udd17 using Queue \ud83d\udd17 using iox :: concurrent :: LockFreeQueue < ElementType , Capacity >:: Queue = IndexQueue < Capacity > ; using BufferIndex \ud83d\udd17 using iox :: concurrent :: LockFreeQueue < ElementType , Capacity >:: BufferIndex = typename Queue :: value_t ; Public Functions Documentation \ud83d\udd17 function LockFreeQueue \ud83d\udd17 LockFreeQueue () creates and initalizes an empty LockFreeQueue function ~LockFreeQueue \ud83d\udd17 ~ LockFreeQueue () = default function LockFreeQueue \ud83d\udd17 LockFreeQueue ( const LockFreeQueue & ) function LockFreeQueue \ud83d\udd17 LockFreeQueue ( LockFreeQueue && ) function operator= \ud83d\udd17 LockFreeQueue & operator = ( const LockFreeQueue & ) function operator= \ud83d\udd17 LockFreeQueue & operator = ( LockFreeQueue && ) function capacity \ud83d\udd17 constexpr uint64_t capacity () const returns the capacity of the queue Note : threadsafe, lockfree function tryPush \ud83d\udd17 bool tryPush ( ElementType && value ) tries to insert value in FIFO order, moves the value internally Parameters : value to be inserted Return : true if insertion was successful (i.e. queue was not full during push), false otherwise Note : threadsafe, lockfree function tryPush \ud83d\udd17 bool tryPush ( const ElementType & value ) tries to insert value in FIFO order, copies the value internally Parameters : value to be inserted Return : true if insertion was successful (i.e. queue was not full during push), false otherwise Note : threadsafe, lockfree function push \ud83d\udd17 iox :: cxx :: optional < ElementType > push ( const ElementType & value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is copied into the queue Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree function push \ud83d\udd17 iox :: cxx :: optional < ElementType > push ( ElementType && value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is moved into the queue if possible Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree function pop \ud83d\udd17 iox :: cxx :: optional < ElementType > pop () tries to remove value in FIFO order Return : value if removal was successful, empty optional otherwise Note : threadsafe, lockfree function empty \ud83d\udd17 bool empty () const check whether the queue is empty Return : true iff the queue is empty Note : that if the queue is used concurrently it might not be empty anymore after the call (but it was at some point during the call) threadsafe, lockfree function size \ud83d\udd17 uint64_t size () const get the number of stored elements in the queue Return : number of stored elements in the queue Note : that this will not be perfectly in sync with the actual number of contained elements during concurrent operation but will always be at most capacity threadsafe, lockfree Protected Functions Documentation \ud83d\udd17 function writeBufferAt \ud83d\udd17 template < typename T > void writeBufferAt ( const BufferIndex & , T && ) function pushImpl \ud83d\udd17 template < typename T > iox :: cxx :: optional < ElementType > pushImpl ( T && value ) function readBufferAt \ud83d\udd17 cxx :: optional < ElementType > readBufferAt ( const BufferIndex & ) Protected Attributes Documentation \ud83d\udd17 variable m_freeIndices \ud83d\udd17 Queue m_freeIndices ; variable m_usedIndices \ud83d\udd17 Queue m_usedIndices ; variable m_buffer \ud83d\udd17 Buffer < ElementType , Capacity , BufferIndex > m_buffer ; variable m_size \ud83d\udd17 std :: atomic < uint64_t > m_size { 0u }; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::concurrent::LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#ioxconcurrentlockfreequeue","text":"implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity More... #include <iceoryx_hoofs/concurrent/lockfree_queue.hpp>","title":"iox::concurrent::LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-types","text":"Name using ElementType element_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-types","text":"Name using IndexQueue< Capacity > Queue using typename Queue::value_t BufferIndex","title":"Protected Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-functions","text":"Name LockFreeQueue () creates and initalizes an empty LockFreeQueue ~LockFreeQueue () =default LockFreeQueue (const LockFreeQueue & ) LockFreeQueue ( LockFreeQueue && ) LockFreeQueue & operator= (const LockFreeQueue & ) LockFreeQueue & operator= ( LockFreeQueue && ) constexpr uint64_t capacity () const returns the capacity of the queue bool tryPush (ElementType && value) tries to insert value in FIFO order, moves the value internally bool tryPush (const ElementType & value) tries to insert value in FIFO order, copies the value internally iox::cxx::optional < ElementType > push (const ElementType & value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) iox::cxx::optional < ElementType > push (ElementType && value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) iox::cxx::optional < ElementType > pop () tries to remove value in FIFO order bool empty () const check whether the queue is empty uint64_t size () const get the number of stored elements in the queue","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-functions","text":"Name template <typename T > void writeBufferAt (const BufferIndex & , T && ) template <typename T > iox::cxx::optional < ElementType > pushImpl (T && value) cxx::optional < ElementType > readBufferAt (const BufferIndex & )","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-attributes","text":"Name Queue m_freeIndices Queue m_usedIndices Buffer< ElementType, Capacity, BufferIndex > m_buffer std::atomic< uint64_t > m_size","title":"Protected Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#detailed-description","text":"template < typename ElementType , uint64_t Capacity > class iox :: concurrent :: LockFreeQueue ; implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#using-element_t","text":"using iox :: concurrent :: LockFreeQueue < ElementType , Capacity >:: element_t = ElementType ;","title":"using element_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#using-queue","text":"using iox :: concurrent :: LockFreeQueue < ElementType , Capacity >:: Queue = IndexQueue < Capacity > ;","title":"using Queue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#using-bufferindex","text":"using iox :: concurrent :: LockFreeQueue < ElementType , Capacity >:: BufferIndex = typename Queue :: value_t ;","title":"using BufferIndex"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue","text":"LockFreeQueue () creates and initalizes an empty LockFreeQueue","title":"function LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue_1","text":"~ LockFreeQueue () = default","title":"function ~LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue_2","text":"LockFreeQueue ( const LockFreeQueue & )","title":"function LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-lockfreequeue_3","text":"LockFreeQueue ( LockFreeQueue && )","title":"function LockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-operator","text":"LockFreeQueue & operator = ( const LockFreeQueue & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-operator_1","text":"LockFreeQueue & operator = ( LockFreeQueue && )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-capacity","text":"constexpr uint64_t capacity () const returns the capacity of the queue Note : threadsafe, lockfree","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-trypush","text":"bool tryPush ( ElementType && value ) tries to insert value in FIFO order, moves the value internally Parameters : value to be inserted Return : true if insertion was successful (i.e. queue was not full during push), false otherwise Note : threadsafe, lockfree","title":"function tryPush"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-trypush_1","text":"bool tryPush ( const ElementType & value ) tries to insert value in FIFO order, copies the value internally Parameters : value to be inserted Return : true if insertion was successful (i.e. queue was not full during push), false otherwise Note : threadsafe, lockfree","title":"function tryPush"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-push","text":"iox :: cxx :: optional < ElementType > push ( const ElementType & value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is copied into the queue Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-push_1","text":"iox :: cxx :: optional < ElementType > push ( ElementType && value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is moved into the queue if possible Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-pop","text":"iox :: cxx :: optional < ElementType > pop () tries to remove value in FIFO order Return : value if removal was successful, empty optional otherwise Note : threadsafe, lockfree","title":"function pop"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-empty","text":"bool empty () const check whether the queue is empty Return : true iff the queue is empty Note : that if the queue is used concurrently it might not be empty anymore after the call (but it was at some point during the call) threadsafe, lockfree","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-size","text":"uint64_t size () const get the number of stored elements in the queue Return : number of stored elements in the queue Note : that this will not be perfectly in sync with the actual number of contained elements during concurrent operation but will always be at most capacity threadsafe, lockfree","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-writebufferat","text":"template < typename T > void writeBufferAt ( const BufferIndex & , T && )","title":"function writeBufferAt"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-pushimpl","text":"template < typename T > iox :: cxx :: optional < ElementType > pushImpl ( T && value )","title":"function pushImpl"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#function-readbufferat","text":"cxx :: optional < ElementType > readBufferAt ( const BufferIndex & )","title":"function readBufferAt"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_freeindices","text":"Queue m_freeIndices ;","title":"variable m_freeIndices"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_usedindices","text":"Queue m_usedIndices ;","title":"variable m_usedIndices"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_buffer","text":"Buffer < ElementType , Capacity , BufferIndex > m_buffer ;","title":"variable m_buffer"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1LockFreeQueue/#variable-m_size","text":"std :: atomic < uint64_t > m_size { 0u }; Updated on 18 December 2023 at 13:11:42 CET","title":"variable m_size"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/","text":"iox::concurrent::ResizeableLockFreeQueue \ud83d\udd17 implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). More... #include <iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp> Inherits from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Public Types \ud83d\udd17 Name using ElementType element_t Public Functions \ud83d\udd17 Name ResizeableLockFreeQueue () =default ~ResizeableLockFreeQueue () =default ResizeableLockFreeQueue (const ResizeableLockFreeQueue & ) ResizeableLockFreeQueue ( ResizeableLockFreeQueue && ) ResizeableLockFreeQueue & operator= (const ResizeableLockFreeQueue & ) ResizeableLockFreeQueue & operator= ( ResizeableLockFreeQueue && ) ResizeableLockFreeQueue (const uint64_t initialCapacity) uint64_t capacity () const returns the current capacity of the queue iox::cxx::optional < ElementType > push (const ElementType & value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) iox::cxx::optional < ElementType > push (ElementType && value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) template <typename Function ,typename =typename std::enable_if ::value>::type> bool setCapacity (const uint64_t newCapacity, Function && removeHandler) Set the capacity to some value. bool setCapacity (const uint64_t newCapacity) Set the capacity to a new capacity between 0 and MaxCapacity, if the capacity is reduced it may be necessary to remove the least recent elements which are then discarded. constexpr uint64_t maxCapacity () returns the maximum capacity of the queue Public Attributes \ud83d\udd17 Name constexpr uint64_t MAX_CAPACITY Additional inherited members \ud83d\udd17 Protected Types inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name using IndexQueue< Capacity > Queue Public Functions inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name LockFreeQueue () creates and initalizes an empty LockFreeQueue ~LockFreeQueue () =default LockFreeQueue (const LockFreeQueue & ) LockFreeQueue ( LockFreeQueue && ) bool tryPush (ElementType && value) tries to insert value in FIFO order, moves the value internally bool tryPush (const ElementType & value) tries to insert value in FIFO order, copies the value internally iox::cxx::optional < ElementType > pop () tries to remove value in FIFO order bool empty () const check whether the queue is empty uint64_t size () const get the number of stored elements in the queue Protected Functions inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name template <typename T > void writeBufferAt (const BufferIndex & , T && ) cxx::optional < ElementType > readBufferAt (const BufferIndex & ) Protected Attributes inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name Queue m_freeIndices Queue m_usedIndices Buffer< ElementType, Capacity, BufferIndex > m_buffer std::atomic< uint64_t > m_size Detailed Description \ud83d\udd17 template < typename ElementType , uint64_t MaxCapacity > class iox :: concurrent :: ResizeableLockFreeQueue ; implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). Public Types Documentation \ud83d\udd17 using element_t \ud83d\udd17 using iox :: concurrent :: ResizeableLockFreeQueue < ElementType , MaxCapacity >:: element_t = ElementType ; Public Functions Documentation \ud83d\udd17 function ResizeableLockFreeQueue \ud83d\udd17 ResizeableLockFreeQueue () = default function ~ResizeableLockFreeQueue \ud83d\udd17 ~ ResizeableLockFreeQueue () = default function ResizeableLockFreeQueue \ud83d\udd17 ResizeableLockFreeQueue ( const ResizeableLockFreeQueue & ) function ResizeableLockFreeQueue \ud83d\udd17 ResizeableLockFreeQueue ( ResizeableLockFreeQueue && ) function operator= \ud83d\udd17 ResizeableLockFreeQueue & operator = ( const ResizeableLockFreeQueue & ) function operator= \ud83d\udd17 ResizeableLockFreeQueue & operator = ( ResizeableLockFreeQueue && ) function ResizeableLockFreeQueue \ud83d\udd17 ResizeableLockFreeQueue ( const uint64_t initialCapacity ) function capacity \ud83d\udd17 uint64_t capacity () const returns the current capacity of the queue Return : the current capacity Note : threadsafe, lockfree function push \ud83d\udd17 iox :: cxx :: optional < ElementType > push ( const ElementType & value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is copied into the queue Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree function push \ud83d\udd17 iox :: cxx :: optional < ElementType > push ( ElementType && value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is moved into the queue if possible Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree function setCapacity \ud83d\udd17 template < typename Function , typename = typename std :: enable_if < cxx :: is_invocable < Function , ElementType >:: value >:: type > bool setCapacity ( const uint64_t newCapacity , Function && removeHandler ) Set the capacity to some value. Parameters : newCapacity capacity to be set removeHandler is a function taking an element which specifies what to do with removed elements should the need for removal arise. Return : true if the capacity was successfully set, false otherwise Note : setCapacity is lockfree, but if an application crashes during setCapacity it currently may prevent other applications from setting the capacity (they will not block though). This is not a problem if for example there is only one application calling setCapacity or setCapacity is only called from vital applications (which if they crash will lead to system shutdown) and there is only one (non-vital, i.e. allowed to crash) application reading the data via pop. The reader application may also call setCapacity, since if it crashes there is no one reading the data and the capacity can be considered meaningless. function setCapacity \ud83d\udd17 bool setCapacity ( const uint64_t newCapacity ) Set the capacity to a new capacity between 0 and MaxCapacity, if the capacity is reduced it may be necessary to remove the least recent elements which are then discarded. Parameters : newCapacity new capacity to be set, if it is larger than MaxCapacity the call fails Return : true setting if the new capacity was successful, false otherwise (newCapacity > MaxCapacity) Note : threadsafe, lockfree but multiple concurrent calls may have no effect function maxCapacity \ud83d\udd17 static constexpr uint64_t maxCapacity () returns the maximum capacity of the queue Return : the maximum capacity Public Attributes Documentation \ud83d\udd17 variable MAX_CAPACITY \ud83d\udd17 static constexpr uint64_t MAX_CAPACITY = MaxCapacity ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::concurrent::ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#ioxconcurrentresizeablelockfreequeue","text":"implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). More... #include <iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp> Inherits from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity >","title":"iox::concurrent::ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-types","text":"Name using ElementType element_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-functions","text":"Name ResizeableLockFreeQueue () =default ~ResizeableLockFreeQueue () =default ResizeableLockFreeQueue (const ResizeableLockFreeQueue & ) ResizeableLockFreeQueue ( ResizeableLockFreeQueue && ) ResizeableLockFreeQueue & operator= (const ResizeableLockFreeQueue & ) ResizeableLockFreeQueue & operator= ( ResizeableLockFreeQueue && ) ResizeableLockFreeQueue (const uint64_t initialCapacity) uint64_t capacity () const returns the current capacity of the queue iox::cxx::optional < ElementType > push (const ElementType & value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) iox::cxx::optional < ElementType > push (ElementType && value) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) template <typename Function ,typename =typename std::enable_if ::value>::type> bool setCapacity (const uint64_t newCapacity, Function && removeHandler) Set the capacity to some value. bool setCapacity (const uint64_t newCapacity) Set the capacity to a new capacity between 0 and MaxCapacity, if the capacity is reduced it may be necessary to remove the least recent elements which are then discarded. constexpr uint64_t maxCapacity () returns the maximum capacity of the queue","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-attributes","text":"Name constexpr uint64_t MAX_CAPACITY","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#additional-inherited-members","text":"Protected Types inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name using IndexQueue< Capacity > Queue Public Functions inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name LockFreeQueue () creates and initalizes an empty LockFreeQueue ~LockFreeQueue () =default LockFreeQueue (const LockFreeQueue & ) LockFreeQueue ( LockFreeQueue && ) bool tryPush (ElementType && value) tries to insert value in FIFO order, moves the value internally bool tryPush (const ElementType & value) tries to insert value in FIFO order, copies the value internally iox::cxx::optional < ElementType > pop () tries to remove value in FIFO order bool empty () const check whether the queue is empty uint64_t size () const get the number of stored elements in the queue Protected Functions inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name template <typename T > void writeBufferAt (const BufferIndex & , T && ) cxx::optional < ElementType > readBufferAt (const BufferIndex & ) Protected Attributes inherited from iox::concurrent::LockFreeQueue< ElementType, MaxCapacity > Name Queue m_freeIndices Queue m_usedIndices Buffer< ElementType, Capacity, BufferIndex > m_buffer std::atomic< uint64_t > m_size","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#detailed-description","text":"template < typename ElementType , uint64_t MaxCapacity > class iox :: concurrent :: ResizeableLockFreeQueue ; implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread).","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#using-element_t","text":"using iox :: concurrent :: ResizeableLockFreeQueue < ElementType , MaxCapacity >:: element_t = ElementType ;","title":"using element_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue","text":"ResizeableLockFreeQueue () = default","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_1","text":"~ ResizeableLockFreeQueue () = default","title":"function ~ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_2","text":"ResizeableLockFreeQueue ( const ResizeableLockFreeQueue & )","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_3","text":"ResizeableLockFreeQueue ( ResizeableLockFreeQueue && )","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-operator","text":"ResizeableLockFreeQueue & operator = ( const ResizeableLockFreeQueue & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-operator_1","text":"ResizeableLockFreeQueue & operator = ( ResizeableLockFreeQueue && )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-resizeablelockfreequeue_4","text":"ResizeableLockFreeQueue ( const uint64_t initialCapacity )","title":"function ResizeableLockFreeQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-capacity","text":"uint64_t capacity () const returns the current capacity of the queue Return : the current capacity Note : threadsafe, lockfree","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-push","text":"iox :: cxx :: optional < ElementType > push ( const ElementType & value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is copied into the queue Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-push_1","text":"iox :: cxx :: optional < ElementType > push ( ElementType && value ) inserts value in FIFO order, always succeeds by removing the oldest value when the queue is detected to be full (overflow) Parameters : value to be inserted is moved into the queue if possible Return : removed value if an overflow occured, empty optional otherwise Note : threadsafe, lockfree","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-setcapacity","text":"template < typename Function , typename = typename std :: enable_if < cxx :: is_invocable < Function , ElementType >:: value >:: type > bool setCapacity ( const uint64_t newCapacity , Function && removeHandler ) Set the capacity to some value. Parameters : newCapacity capacity to be set removeHandler is a function taking an element which specifies what to do with removed elements should the need for removal arise. Return : true if the capacity was successfully set, false otherwise Note : setCapacity is lockfree, but if an application crashes during setCapacity it currently may prevent other applications from setting the capacity (they will not block though). This is not a problem if for example there is only one application calling setCapacity or setCapacity is only called from vital applications (which if they crash will lead to system shutdown) and there is only one (non-vital, i.e. allowed to crash) application reading the data via pop. The reader application may also call setCapacity, since if it crashes there is no one reading the data and the capacity can be considered meaningless.","title":"function setCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-setcapacity_1","text":"bool setCapacity ( const uint64_t newCapacity ) Set the capacity to a new capacity between 0 and MaxCapacity, if the capacity is reduced it may be necessary to remove the least recent elements which are then discarded. Parameters : newCapacity new capacity to be set, if it is larger than MaxCapacity the call fails Return : true setting if the new capacity was successful, false otherwise (newCapacity > MaxCapacity) Note : threadsafe, lockfree but multiple concurrent calls may have no effect","title":"function setCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#function-maxcapacity","text":"static constexpr uint64_t maxCapacity () returns the maximum capacity of the queue Return : the maximum capacity","title":"function maxCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1concurrent_1_1ResizeableLockFreeQueue/#variable-max_capacity","text":"static constexpr uint64_t MAX_CAPACITY = MaxCapacity ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable MAX_CAPACITY"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/","text":"iox::cxx::ConstMethodCallback \ud83d\udd17 More... Public Types \ud83d\udd17 Name template <typename T > using ReturnValue(T::*)(Args...) const ConstMethodPointer Public Functions \ud83d\udd17 Name ConstMethodCallback () =default ConstMethodCallback (const ConstMethodCallback & rhs) =default ConstMethodCallback & operator= (const ConstMethodCallback & rhs) =default ~ConstMethodCallback () =default template <typename ClassType > ConstMethodCallback (const ClassType & objectRef, ConstMethodPointer< ClassType > const methodPtr) Constructs a ConstMethodCallback from a pointer to a specific object and a pointer to a method of that class. ConstMethodCallback ( ConstMethodCallback && rhs) Move constructor. ConstMethodCallback & operator= ( ConstMethodCallback && rhs) Move assignment operator. template <typename... MethodArguments> expected< ReturnValue, MethodCallbackError > operator() (MethodArguments &&... args) const Calls the method if the ConstMethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. bool operator== (const ConstMethodCallback & rhs) const Comparison operator. Two ConstMethodCallbacks are equal if they have the same object pointer and method pointer. bool operator!= (const ConstMethodCallback & rhs) const Inequality operator. Two ConstMethodCallback are not equal if they have different object or method pointer. operator bool () const Verifies if the ConstMethodCallback is valid. bool isValid () const Verifies if the ConstMethodCallback is valid. template <typename ClassType > void setCallback (const ClassType & objectRef, ConstMethodPointer< ClassType > methodPtr) Sets a new callback. template <typename ClassType > const ClassType * getObjectPointer () const Returns object pointer. template <typename ClassType > auto getMethodPointer () const Returns cond method pointer. Detailed Description \ud83d\udd17 template < typename ReturnValue , typename ... Args > class iox :: cxx :: ConstMethodCallback ; Public Types Documentation \ud83d\udd17 using ConstMethodPointer \ud83d\udd17 template < typename T > using iox :: cxx :: ConstMethodCallback < ReturnValue , Args >:: ConstMethodPointer = ReturnValue ( T ::* )( Args ...) const ; Public Functions Documentation \ud83d\udd17 function ConstMethodCallback \ud83d\udd17 ConstMethodCallback () = default function ConstMethodCallback \ud83d\udd17 ConstMethodCallback ( const ConstMethodCallback & rhs ) = default function operator= \ud83d\udd17 ConstMethodCallback & operator = ( const ConstMethodCallback & rhs ) = default function ~ConstMethodCallback \ud83d\udd17 ~ ConstMethodCallback () = default function ConstMethodCallback \ud83d\udd17 template < typename ClassType > ConstMethodCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > const methodPtr ) Constructs a ConstMethodCallback from a pointer to a specific object and a pointer to a method of that class. Parameters : objectRef const object reference methodPtr pointer to a const method function ConstMethodCallback \ud83d\udd17 ConstMethodCallback ( ConstMethodCallback && rhs ) Move constructor. Parameters : rhs move origin function operator= \ud83d\udd17 ConstMethodCallback & operator = ( ConstMethodCallback && rhs ) Move assignment operator. Parameters : rhs move origin Return : reference to this function operator() \ud83d\udd17 template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) const Calls the method if the ConstMethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. Parameters : args... arguments which will be perfectly forwarded to the method Return : If ConstMethodCallback is valid the return value of the method, otherwise an error. function operator== \ud83d\udd17 bool operator == ( const ConstMethodCallback & rhs ) const Comparison operator. Two ConstMethodCallbacks are equal if they have the same object pointer and method pointer. function operator!= \ud83d\udd17 bool operator != ( const ConstMethodCallback & rhs ) const Inequality operator. Two ConstMethodCallback are not equal if they have different object or method pointer. function operator bool \ud83d\udd17 explicit operator bool () const Verifies if the ConstMethodCallback is valid. Return : true if objectRef != nullptr otherwise false function isValid \ud83d\udd17 bool isValid () const Verifies if the ConstMethodCallback is valid. Return : true if objectRef != nullptr otherwise false function setCallback \ud83d\udd17 template < typename ClassType > void setCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > methodPtr ) Sets a new callback. Parameters : objectRef const reference to the object methodPtr pointer to the method function getObjectPointer \ud83d\udd17 template < typename ClassType > const ClassType * getObjectPointer () const Returns object pointer. function getMethodPointer \ud83d\udd17 template < typename ClassType > auto getMethodPointer () const Returns cond method pointer. Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#ioxcxxconstmethodcallback","text":"More...","title":"iox::cxx::ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-types","text":"Name template <typename T > using ReturnValue(T::*)(Args...) const ConstMethodPointer","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-functions","text":"Name ConstMethodCallback () =default ConstMethodCallback (const ConstMethodCallback & rhs) =default ConstMethodCallback & operator= (const ConstMethodCallback & rhs) =default ~ConstMethodCallback () =default template <typename ClassType > ConstMethodCallback (const ClassType & objectRef, ConstMethodPointer< ClassType > const methodPtr) Constructs a ConstMethodCallback from a pointer to a specific object and a pointer to a method of that class. ConstMethodCallback ( ConstMethodCallback && rhs) Move constructor. ConstMethodCallback & operator= ( ConstMethodCallback && rhs) Move assignment operator. template <typename... MethodArguments> expected< ReturnValue, MethodCallbackError > operator() (MethodArguments &&... args) const Calls the method if the ConstMethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. bool operator== (const ConstMethodCallback & rhs) const Comparison operator. Two ConstMethodCallbacks are equal if they have the same object pointer and method pointer. bool operator!= (const ConstMethodCallback & rhs) const Inequality operator. Two ConstMethodCallback are not equal if they have different object or method pointer. operator bool () const Verifies if the ConstMethodCallback is valid. bool isValid () const Verifies if the ConstMethodCallback is valid. template <typename ClassType > void setCallback (const ClassType & objectRef, ConstMethodPointer< ClassType > methodPtr) Sets a new callback. template <typename ClassType > const ClassType * getObjectPointer () const Returns object pointer. template <typename ClassType > auto getMethodPointer () const Returns cond method pointer.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#detailed-description","text":"template < typename ReturnValue , typename ... Args > class iox :: cxx :: ConstMethodCallback ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#using-constmethodpointer","text":"template < typename T > using iox :: cxx :: ConstMethodCallback < ReturnValue , Args >:: ConstMethodPointer = ReturnValue ( T ::* )( Args ...) const ;","title":"using ConstMethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback","text":"ConstMethodCallback () = default","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_1","text":"ConstMethodCallback ( const ConstMethodCallback & rhs ) = default","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator","text":"ConstMethodCallback & operator = ( const ConstMethodCallback & rhs ) = default","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_2","text":"~ ConstMethodCallback () = default","title":"function ~ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_3","text":"template < typename ClassType > ConstMethodCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > const methodPtr ) Constructs a ConstMethodCallback from a pointer to a specific object and a pointer to a method of that class. Parameters : objectRef const object reference methodPtr pointer to a const method","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-constmethodcallback_4","text":"ConstMethodCallback ( ConstMethodCallback && rhs ) Move constructor. Parameters : rhs move origin","title":"function ConstMethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_1","text":"ConstMethodCallback & operator = ( ConstMethodCallback && rhs ) Move assignment operator. Parameters : rhs move origin Return : reference to this","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_2","text":"template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) const Calls the method if the ConstMethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. Parameters : args... arguments which will be perfectly forwarded to the method Return : If ConstMethodCallback is valid the return value of the method, otherwise an error.","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_3","text":"bool operator == ( const ConstMethodCallback & rhs ) const Comparison operator. Two ConstMethodCallbacks are equal if they have the same object pointer and method pointer.","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator_4","text":"bool operator != ( const ConstMethodCallback & rhs ) const Inequality operator. Two ConstMethodCallback are not equal if they have different object or method pointer.","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-operator-bool","text":"explicit operator bool () const Verifies if the ConstMethodCallback is valid. Return : true if objectRef != nullptr otherwise false","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-isvalid","text":"bool isValid () const Verifies if the ConstMethodCallback is valid. Return : true if objectRef != nullptr otherwise false","title":"function isValid"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-setcallback","text":"template < typename ClassType > void setCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > methodPtr ) Sets a new callback. Parameters : objectRef const reference to the object methodPtr pointer to the method","title":"function setCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-getobjectpointer","text":"template < typename ClassType > const ClassType * getObjectPointer () const Returns object pointer.","title":"function getObjectPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1ConstMethodCallback/#function-getmethodpointer","text":"template < typename ClassType > auto getMethodPointer () const Returns cond method pointer. Updated on 18 December 2023 at 13:11:42 CET","title":"function getMethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/","text":"iox::cxx::DeadlineTimer \ud83d\udd17 This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. More... #include <iceoryx_hoofs/cxx/deadline_timer.hpp> Public Functions \ud83d\udd17 Name DeadlineTimer (const iox::units::Duration timeToWait) Constructor. bool hasExpired () const Checks if the timer has expired compared to its absolute end time. void reset () reinitializes the ending time for the timer. The absolute end time is calculated by adding time to wait to the current time. void reset (const iox::units::Duration timeToWait) reinitializes the ending time for the timer to the given new time to wait. The absolute end time is calculated by adding new time to wait to the current time. iox::units::Duration remainingTime () const calculates the remaining time before the timer goes off Detailed Description \ud83d\udd17 class iox :: cxx :: DeadlineTimer ; This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. iox :: cxx :: DeadlineTimer deadlineTimer ( 1000 _ms ); // to check if the timer is active if ( deadlineTimer . hasExpired ()){ ... } // to reset the timer and start again with the same duration deadlineTimer . reset (); Public Functions Documentation \ud83d\udd17 function DeadlineTimer \ud83d\udd17 explicit DeadlineTimer ( const iox :: units :: Duration timeToWait ) Constructor. Parameters : timeToWait duration until the timer expires function hasExpired \ud83d\udd17 bool hasExpired () const Checks if the timer has expired compared to its absolute end time. Return : false if the timer is still active and true if it is expired function reset \ud83d\udd17 void reset () reinitializes the ending time for the timer. The absolute end time is calculated by adding time to wait to the current time. function reset \ud83d\udd17 void reset ( const iox :: units :: Duration timeToWait ) reinitializes the ending time for the timer to the given new time to wait. The absolute end time is calculated by adding new time to wait to the current time. Parameters : timeToWait duration until the timer expires. This value overwrites the earlier value which was set during the timer creation. function remainingTime \ud83d\udd17 iox :: units :: Duration remainingTime () const calculates the remaining time before the timer goes off Return : the time duration before the timer expires Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::DeadlineTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#ioxcxxdeadlinetimer","text":"This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. More... #include <iceoryx_hoofs/cxx/deadline_timer.hpp>","title":"iox::cxx::DeadlineTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#public-functions","text":"Name DeadlineTimer (const iox::units::Duration timeToWait) Constructor. bool hasExpired () const Checks if the timer has expired compared to its absolute end time. void reset () reinitializes the ending time for the timer. The absolute end time is calculated by adding time to wait to the current time. void reset (const iox::units::Duration timeToWait) reinitializes the ending time for the timer to the given new time to wait. The absolute end time is calculated by adding new time to wait to the current time. iox::units::Duration remainingTime () const calculates the remaining time before the timer goes off","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#detailed-description","text":"class iox :: cxx :: DeadlineTimer ; This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. iox :: cxx :: DeadlineTimer deadlineTimer ( 1000 _ms ); // to check if the timer is active if ( deadlineTimer . hasExpired ()){ ... } // to reset the timer and start again with the same duration deadlineTimer . reset ();","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-deadlinetimer","text":"explicit DeadlineTimer ( const iox :: units :: Duration timeToWait ) Constructor. Parameters : timeToWait duration until the timer expires","title":"function DeadlineTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-hasexpired","text":"bool hasExpired () const Checks if the timer has expired compared to its absolute end time. Return : false if the timer is still active and true if it is expired","title":"function hasExpired"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-reset","text":"void reset () reinitializes the ending time for the timer. The absolute end time is calculated by adding time to wait to the current time.","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-reset_1","text":"void reset ( const iox :: units :: Duration timeToWait ) reinitializes the ending time for the timer to the given new time to wait. The absolute end time is calculated by adding new time to wait to the current time. Parameters : timeToWait duration until the timer expires. This value overwrites the earlier value which was set during the timer creation.","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1DeadlineTimer/#function-remainingtime","text":"iox :: units :: Duration remainingTime () const calculates the remaining time before the timer goes off Return : the time duration before the timer expires Updated on 18 December 2023 at 13:11:42 CET","title":"function remainingTime"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/","text":"iox::cxx::GenericRAII \ud83d\udd17 The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. More... #include <iceoryx_hoofs/cxx/generic_raii.hpp> Public Functions \ud83d\udd17 Name GenericRAII (const std::function< void()> & cleanupFunction) constructor which creates GenericRAII that calls only the cleanupFunction on destruction GenericRAII (const function_ref < void()> & initFunction, const std::function< void()> & cleanupFunction) constructor which calls initFunction and stores the cleanupFunction which will be called in the destructor ~GenericRAII () calls m_cleanupFunction callable if it was set in the constructor GenericRAII (const GenericRAII & ) GenericRAII & operator= (const GenericRAII & ) GenericRAII ( GenericRAII && rhs) move constructor which moves a generic raii object without calling the cleanupFunction GenericRAII & operator= ( GenericRAII && rhs) move assignment which moves a generic raii object without calling the cleanupFunction Detailed Description \ud83d\udd17 class iox :: cxx :: GenericRAII ; The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. // This example leads to a console output of: // hello world // I am doing stuff // goodbye void someFunc () { auto raii {[](){ std :: cout << \"hello world \\n \" ; }, [](){ std :: cout << \"goodbye \\n \" ; }}; std :: cout << \"I am doing stuff \\n \" ; // raii goes out of scope here and the cleanupFunction is called in the // destructor } Public Functions Documentation \ud83d\udd17 function GenericRAII \ud83d\udd17 explicit GenericRAII ( const std :: function < void () > & cleanupFunction ) constructor which creates GenericRAII that calls only the cleanupFunction on destruction Parameters : cleanupFunction callable which will be called in the destructor function GenericRAII \ud83d\udd17 GenericRAII ( const function_ref < void () > & initFunction , const std :: function < void () > & cleanupFunction ) constructor which calls initFunction and stores the cleanupFunction which will be called in the destructor Parameters : initFunction callable which will be called in the constructor cleanupFunction callable which will be called in the destructor function ~GenericRAII \ud83d\udd17 ~ GenericRAII () calls m_cleanupFunction callable if it was set in the constructor function GenericRAII \ud83d\udd17 GenericRAII ( const GenericRAII & ) function operator= \ud83d\udd17 GenericRAII & operator = ( const GenericRAII & ) function GenericRAII \ud83d\udd17 GenericRAII ( GenericRAII && rhs ) move constructor which moves a generic raii object without calling the cleanupFunction function operator= \ud83d\udd17 GenericRAII & operator = ( GenericRAII && rhs ) move assignment which moves a generic raii object without calling the cleanupFunction Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#ioxcxxgenericraii","text":"The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. More... #include <iceoryx_hoofs/cxx/generic_raii.hpp>","title":"iox::cxx::GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#public-functions","text":"Name GenericRAII (const std::function< void()> & cleanupFunction) constructor which creates GenericRAII that calls only the cleanupFunction on destruction GenericRAII (const function_ref < void()> & initFunction, const std::function< void()> & cleanupFunction) constructor which calls initFunction and stores the cleanupFunction which will be called in the destructor ~GenericRAII () calls m_cleanupFunction callable if it was set in the constructor GenericRAII (const GenericRAII & ) GenericRAII & operator= (const GenericRAII & ) GenericRAII ( GenericRAII && rhs) move constructor which moves a generic raii object without calling the cleanupFunction GenericRAII & operator= ( GenericRAII && rhs) move assignment which moves a generic raii object without calling the cleanupFunction","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#detailed-description","text":"class iox :: cxx :: GenericRAII ; The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. // This example leads to a console output of: // hello world // I am doing stuff // goodbye void someFunc () { auto raii {[](){ std :: cout << \"hello world \\n \" ; }, [](){ std :: cout << \"goodbye \\n \" ; }}; std :: cout << \"I am doing stuff \\n \" ; // raii goes out of scope here and the cleanupFunction is called in the // destructor }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii","text":"explicit GenericRAII ( const std :: function < void () > & cleanupFunction ) constructor which creates GenericRAII that calls only the cleanupFunction on destruction Parameters : cleanupFunction callable which will be called in the destructor","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_1","text":"GenericRAII ( const function_ref < void () > & initFunction , const std :: function < void () > & cleanupFunction ) constructor which calls initFunction and stores the cleanupFunction which will be called in the destructor Parameters : initFunction callable which will be called in the constructor cleanupFunction callable which will be called in the destructor","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_2","text":"~ GenericRAII () calls m_cleanupFunction callable if it was set in the constructor","title":"function ~GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_3","text":"GenericRAII ( const GenericRAII & )","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-operator","text":"GenericRAII & operator = ( const GenericRAII & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-genericraii_4","text":"GenericRAII ( GenericRAII && rhs ) move constructor which moves a generic raii object without calling the cleanupFunction","title":"function GenericRAII"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1GenericRAII/#function-operator_1","text":"GenericRAII & operator = ( GenericRAII && rhs ) move assignment which moves a generic raii object without calling the cleanupFunction Updated on 18 December 2023 at 13:11:42 CET","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/","text":"iox::cxx::MethodCallback \ud83d\udd17 More... Public Types \ud83d\udd17 Name template <typename T > using ReturnValue(T::*)(Args...) MethodPointer Public Functions \ud83d\udd17 Name MethodCallback () =default MethodCallback (const MethodCallback & rhs) =default MethodCallback & operator= (const MethodCallback & rhs) =default ~MethodCallback () =default template <typename ClassType > MethodCallback (ClassType & objectRef, MethodPointer< ClassType > methodPtr) Constructs a MethodCallback from a pointer to a specific object and a pointer to a method of that object. MethodCallback ( MethodCallback && rhs) Move constructor. MethodCallback & operator= ( MethodCallback && rhs) Move assignment operator. template <typename... MethodArguments> expected< ReturnValue, MethodCallbackError > operator() (MethodArguments &&... args) Calls the method if the MethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. bool operator== (const MethodCallback & rhs) const Comparison operator. Two MethodCallbacks are equal if they have the same object pointer and method pointer. bool operator!= (const MethodCallback & rhs) const Inequality operator. Two MethodCallbacks are not equal if they have different object or method pointer. operator bool () const Verifies if the MethodCallback is valid. bool isValid () const Verifies if the MethodCallback is valid. template <typename ClassType > void setCallback (ClassType & objectRef, MethodPointer< ClassType > methodPtr) Sets a new callback. template <typename ClassType > ClassType * getObjectPointer () const Returns objectRef. template <typename ClassType > auto getMethodPointer () const Returns cond method pointer. Detailed Description \ud83d\udd17 template < typename ReturnValue , typename ... Args > class iox :: cxx :: MethodCallback ; Public Types Documentation \ud83d\udd17 using MethodPointer \ud83d\udd17 template < typename T > using iox :: cxx :: MethodCallback < ReturnValue , Args >:: MethodPointer = ReturnValue ( T ::* )( Args ...); Public Functions Documentation \ud83d\udd17 function MethodCallback \ud83d\udd17 MethodCallback () = default function MethodCallback \ud83d\udd17 MethodCallback ( const MethodCallback & rhs ) = default function operator= \ud83d\udd17 MethodCallback & operator = ( const MethodCallback & rhs ) = default function ~MethodCallback \ud83d\udd17 ~ MethodCallback () = default function MethodCallback \ud83d\udd17 template < typename ClassType > MethodCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) Constructs a MethodCallback from a pointer to a specific object and a pointer to a method of that object. Parameters : objectRef object reference methodPtr pointer to a method function MethodCallback \ud83d\udd17 MethodCallback ( MethodCallback && rhs ) Move constructor. Parameters : rhs move origin function operator= \ud83d\udd17 MethodCallback & operator = ( MethodCallback && rhs ) Move assignment operator. Parameters : rhs move origin Return : reference to this function operator() \ud83d\udd17 template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) Calls the method if the MethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. Parameters : args... arguments which will be perfectly forwarded to the method Return : If MethodCallback is valid the return value of the method, otherwise an error. function operator== \ud83d\udd17 bool operator == ( const MethodCallback & rhs ) const Comparison operator. Two MethodCallbacks are equal if they have the same object pointer and method pointer. function operator!= \ud83d\udd17 bool operator != ( const MethodCallback & rhs ) const Inequality operator. Two MethodCallbacks are not equal if they have different object or method pointer. function operator bool \ud83d\udd17 explicit operator bool () const Verifies if the MethodCallback is valid. Return : true if objectRef != nullptr otherwise false function isValid \ud83d\udd17 bool isValid () const Verifies if the MethodCallback is valid. Return : true if objectRef != nullptr otherwise false function setCallback \ud83d\udd17 template < typename ClassType > void setCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) Sets a new callback. Parameters : objectRef const reference to the object methodPtr pointer to the method function getObjectPointer \ud83d\udd17 template < typename ClassType > ClassType * getObjectPointer () const Returns objectRef. function getMethodPointer \ud83d\udd17 template < typename ClassType > auto getMethodPointer () const Returns cond method pointer. Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#ioxcxxmethodcallback","text":"More...","title":"iox::cxx::MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-types","text":"Name template <typename T > using ReturnValue(T::*)(Args...) MethodPointer","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-functions","text":"Name MethodCallback () =default MethodCallback (const MethodCallback & rhs) =default MethodCallback & operator= (const MethodCallback & rhs) =default ~MethodCallback () =default template <typename ClassType > MethodCallback (ClassType & objectRef, MethodPointer< ClassType > methodPtr) Constructs a MethodCallback from a pointer to a specific object and a pointer to a method of that object. MethodCallback ( MethodCallback && rhs) Move constructor. MethodCallback & operator= ( MethodCallback && rhs) Move assignment operator. template <typename... MethodArguments> expected< ReturnValue, MethodCallbackError > operator() (MethodArguments &&... args) Calls the method if the MethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. bool operator== (const MethodCallback & rhs) const Comparison operator. Two MethodCallbacks are equal if they have the same object pointer and method pointer. bool operator!= (const MethodCallback & rhs) const Inequality operator. Two MethodCallbacks are not equal if they have different object or method pointer. operator bool () const Verifies if the MethodCallback is valid. bool isValid () const Verifies if the MethodCallback is valid. template <typename ClassType > void setCallback (ClassType & objectRef, MethodPointer< ClassType > methodPtr) Sets a new callback. template <typename ClassType > ClassType * getObjectPointer () const Returns objectRef. template <typename ClassType > auto getMethodPointer () const Returns cond method pointer.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#detailed-description","text":"template < typename ReturnValue , typename ... Args > class iox :: cxx :: MethodCallback ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#using-methodpointer","text":"template < typename T > using iox :: cxx :: MethodCallback < ReturnValue , Args >:: MethodPointer = ReturnValue ( T ::* )( Args ...);","title":"using MethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback","text":"MethodCallback () = default","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_1","text":"MethodCallback ( const MethodCallback & rhs ) = default","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator","text":"MethodCallback & operator = ( const MethodCallback & rhs ) = default","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_2","text":"~ MethodCallback () = default","title":"function ~MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_3","text":"template < typename ClassType > MethodCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) Constructs a MethodCallback from a pointer to a specific object and a pointer to a method of that object. Parameters : objectRef object reference methodPtr pointer to a method","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-methodcallback_4","text":"MethodCallback ( MethodCallback && rhs ) Move constructor. Parameters : rhs move origin","title":"function MethodCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_1","text":"MethodCallback & operator = ( MethodCallback && rhs ) Move assignment operator. Parameters : rhs move origin Return : reference to this","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_2","text":"template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) Calls the method if the MethodCallback is valid, otherwise it will return MethodCallbackError::UNINITIALIZED_CALLBACK. Parameters : args... arguments which will be perfectly forwarded to the method Return : If MethodCallback is valid the return value of the method, otherwise an error.","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_3","text":"bool operator == ( const MethodCallback & rhs ) const Comparison operator. Two MethodCallbacks are equal if they have the same object pointer and method pointer.","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator_4","text":"bool operator != ( const MethodCallback & rhs ) const Inequality operator. Two MethodCallbacks are not equal if they have different object or method pointer.","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-operator-bool","text":"explicit operator bool () const Verifies if the MethodCallback is valid. Return : true if objectRef != nullptr otherwise false","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-isvalid","text":"bool isValid () const Verifies if the MethodCallback is valid. Return : true if objectRef != nullptr otherwise false","title":"function isValid"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-setcallback","text":"template < typename ClassType > void setCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) Sets a new callback. Parameters : objectRef const reference to the object methodPtr pointer to the method","title":"function setCallback"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-getobjectpointer","text":"template < typename ClassType > ClassType * getObjectPointer () const Returns objectRef.","title":"function getObjectPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1MethodCallback/#function-getmethodpointer","text":"template < typename ClassType > auto getMethodPointer () const Returns cond method pointer. Updated on 18 December 2023 at 13:11:42 CET","title":"function getMethodPointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/","text":"iox::cxx::NewType \ud83d\udd17 Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. More... #include <iceoryx_hoofs/cxx/newtype.hpp> Inherits from Policies< NewType< T, Policies... > > Public Types \ud83d\udd17 Name using NewType < T, Policies... > ThisType the type of *this using T value_type the type of the underlying value Public Functions \ud83d\udd17 Name NewType () default constructor NewType (const T & rhs) construct with value copy NewType (const NewType & rhs) copy constructor NewType ( NewType && rhs) move constructor NewType & operator= (const NewType & rhs) copy assignment NewType & operator= ( NewType && rhs) move assignment NewType & operator= (const T & rhs) copy by value assignment NewType & operator= (T && rhs) copy by value assignment operator T () const conversion operator Protected Functions \ud83d\udd17 Name NewType (newtype::internal::ProtectedConstructor_t , const T & rhs) Detailed Description \ud83d\udd17 template < typename T , template < typename > class ... Policies > class iox :: cxx :: NewType ; Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. class Index : public NewType < int , newtype :: ConstructByValueCopy , newtype :: Comparable , newtype :: Sortable , newtype :: AssignByValueCopy > { public : // VERY IMPORTANT: we have to put the constructors and operator= in scope // otherwise the code will not compile using ThisType :: ThisType ; // this makes all constructors of NewType available for Index using ThisType :: operator = ; // put the assignment operators in scope // implement ctors and assignment operators when they are implemented by the base class // this is necessary to prevent warnings from some compilers Index () noexcept = default ; Index ( const Index & ) noexcept = default ; Index ( Index && ) noexcept = default ; Index & operator = ( const Index & ) noexcept = default ; Index & operator = ( Index && ) noexcept = default ; }; Index a ( 123 ), c ( 456 ); // allowed since we are using the policy ConstructByValueCopy // Index b; // not allowed since we are not using the policy DefaultConstructable if ( a < c ) {} // allowed since we are Sortable a = 567 ; // allowed since we are assignable Public Types Documentation \ud83d\udd17 using ThisType \ud83d\udd17 using iox :: cxx :: NewType < T , Policies >:: ThisType = NewType < T , Policies ... > ; the type of *this using value_type \ud83d\udd17 using iox :: cxx :: NewType < T , Policies >:: value_type = T ; the type of the underlying value Public Functions Documentation \ud83d\udd17 function NewType \ud83d\udd17 NewType () default constructor function NewType \ud83d\udd17 explicit NewType ( const T & rhs ) construct with value copy function NewType \ud83d\udd17 NewType ( const NewType & rhs ) copy constructor function NewType \ud83d\udd17 NewType ( NewType && rhs ) move constructor function operator= \ud83d\udd17 NewType & operator = ( const NewType & rhs ) copy assignment function operator= \ud83d\udd17 NewType & operator = ( NewType && rhs ) move assignment function operator= \ud83d\udd17 NewType & operator = ( const T & rhs ) copy by value assignment function operator= \ud83d\udd17 NewType & operator = ( T && rhs ) copy by value assignment function operator T \ud83d\udd17 explicit operator T () const conversion operator Protected Functions Documentation \ud83d\udd17 function NewType \ud83d\udd17 NewType ( newtype :: internal :: ProtectedConstructor_t , const T & rhs ) Updated on 18 December 2023 at 13:11:42 CET","title":"classiox 1 1cxx 1 1NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#ioxcxxnewtype","text":"Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. More... #include <iceoryx_hoofs/cxx/newtype.hpp> Inherits from Policies< NewType< T, Policies... > >","title":"iox::cxx::NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-types","text":"Name using NewType < T, Policies... > ThisType the type of *this using T value_type the type of the underlying value","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-functions","text":"Name NewType () default constructor NewType (const T & rhs) construct with value copy NewType (const NewType & rhs) copy constructor NewType ( NewType && rhs) move constructor NewType & operator= (const NewType & rhs) copy assignment NewType & operator= ( NewType && rhs) move assignment NewType & operator= (const T & rhs) copy by value assignment NewType & operator= (T && rhs) copy by value assignment operator T () const conversion operator","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#protected-functions","text":"Name NewType (newtype::internal::ProtectedConstructor_t , const T & rhs)","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#detailed-description","text":"template < typename T , template < typename > class ... Policies > class iox :: cxx :: NewType ; Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. class Index : public NewType < int , newtype :: ConstructByValueCopy , newtype :: Comparable , newtype :: Sortable , newtype :: AssignByValueCopy > { public : // VERY IMPORTANT: we have to put the constructors and operator= in scope // otherwise the code will not compile using ThisType :: ThisType ; // this makes all constructors of NewType available for Index using ThisType :: operator = ; // put the assignment operators in scope // implement ctors and assignment operators when they are implemented by the base class // this is necessary to prevent warnings from some compilers Index () noexcept = default ; Index ( const Index & ) noexcept = default ; Index ( Index && ) noexcept = default ; Index & operator = ( const Index & ) noexcept = default ; Index & operator = ( Index && ) noexcept = default ; }; Index a ( 123 ), c ( 456 ); // allowed since we are using the policy ConstructByValueCopy // Index b; // not allowed since we are not using the policy DefaultConstructable if ( a < c ) {} // allowed since we are Sortable a = 567 ; // allowed since we are assignable","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#using-thistype","text":"using iox :: cxx :: NewType < T , Policies >:: ThisType = NewType < T , Policies ... > ; the type of *this","title":"using ThisType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#using-value_type","text":"using iox :: cxx :: NewType < T , Policies >:: value_type = T ; the type of the underlying value","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype","text":"NewType () default constructor","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_1","text":"explicit NewType ( const T & rhs ) construct with value copy","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_2","text":"NewType ( const NewType & rhs ) copy constructor","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_3","text":"NewType ( NewType && rhs ) move constructor","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator","text":"NewType & operator = ( const NewType & rhs ) copy assignment","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator_1","text":"NewType & operator = ( NewType && rhs ) move assignment","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator_2","text":"NewType & operator = ( const T & rhs ) copy by value assignment","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator_3","text":"NewType & operator = ( T && rhs ) copy by value assignment","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-operator-t","text":"explicit operator T () const conversion operator","title":"function operator T"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1NewType/#function-newtype_4","text":"NewType ( newtype :: internal :: ProtectedConstructor_t , const T & rhs ) Updated on 18 December 2023 at 13:11:42 CET","title":"function NewType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/","text":"iox::cxx::PoorMansHeap \ud83d\udd17 Reserves space on stack for placement new instatiation. More... #include <iceoryx_hoofs/cxx/poor_mans_heap.hpp> Public Functions \ud83d\udd17 Name PoorMansHeap () =default ~PoorMansHeap () template <typename Type ,typename... CTorArgs> PoorMansHeap ( PoorMansHeapType < Type > , CTorArgs &&... ctorArgs) PoorMansHeap ( PoorMansHeap && other) PoorMansHeap & operator= ( PoorMansHeap && rhs) PoorMansHeap (const PoorMansHeap & ) PoorMansHeap & operator= (const PoorMansHeap & ) template <typename Type ,typename... CTorArgs> void newInstance (CTorArgs &&... ctorArgs) void deleteInstance () Calls the destructor if there is a valid instance, otherwise nothing happens. bool hasInstance () const Interface * operator-> () const Interface & operator* () const Detailed Description \ud83d\udd17 template < typename Interface , size_t TypeSize , size_t TypeAlignment = 8 > class iox :: cxx :: PoorMansHeap ; Reserves space on stack for placement new instatiation. Parameters : Interface base type of all classes which should be stored in here TypeSize maximum size of a child of Interface TypeAlignment alignment which is required for the types #include \"iceoryx_hoofs/cxx/poor_mans_heap.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <iostream> class Base { public : virtual ~ Base () = default ; virtual void doStuff () = 0 ; }; class Foo : public Base { public : Foo ( int stuff ) : m_stuff ( stuff ) { } void doStuff () override { std :: cout << __PRETTY_FUNCTION__ << \": \" << m_stuff << std :: endl ; } private : int m_stuff ; }; class Bar : public Base { public : void doStuff () override { std :: cout << __PRETTY_FUNCTION__ << std :: endl ; } }; int main () { constexpr auto MaxSize = cxx :: maxSize < Foo , Bar > (); constexpr auto MaxAlignment = cxx :: maxAlignment < Foo , Bar > (); using FooBar = cxx :: PoorMansHeap < Base , MaxSize , MaxAlignment > ; FooBar fooBar1 { cxx :: PoorMansHeapType < Foo > (), 42 }; fooBar1 -> doStuff (); fooBar1 . newInstance < Bar > (); fooBar1 -> doStuff (); fooBar1 . newInstance < Foo > ( 13 ); fooBar1 -> doStuff (); FooBar fooBar2 ; if ( ! fooBar2 . hasInstance ()) { std :: cout << \"There is no instance!\" << std :: endl ; } fooBar2 . newInstance < Bar > (); fooBar2 -> doStuff (); fooBar2 . deleteInstance (); if ( ! fooBar2 . hasInstance ()) { std :: cout << \"There is again no instance!\" << std :: endl ; } return 0 ; } Public Functions Documentation \ud83d\udd17 function PoorMansHeap \ud83d\udd17 PoorMansHeap () = default function ~PoorMansHeap \ud83d\udd17 ~ PoorMansHeap () function PoorMansHeap \ud83d\udd17 template < typename Type , typename ... CTorArgs > PoorMansHeap ( PoorMansHeapType < Type > , CTorArgs && ... ctorArgs ) Parameters : Type the type to instantiate, wrapped in PoorMansHeapType ctorArgs ctor arguments for the type to instantiate Constructor for immediate construction of an instance function PoorMansHeap \ud83d\udd17 PoorMansHeap ( PoorMansHeap && other ) function operator= \ud83d\udd17 PoorMansHeap & operator = ( PoorMansHeap && rhs ) function PoorMansHeap \ud83d\udd17 PoorMansHeap ( const PoorMansHeap & ) function operator= \ud83d\udd17 PoorMansHeap & operator = ( const PoorMansHeap & ) function newInstance \ud83d\udd17 template < typename Type , typename ... CTorArgs > void newInstance ( CTorArgs && ... ctorArgs ) Parameters : Type the type to instantiate, wrapped in PoorMansHeapType ctorArgs ctor arguments for the type to instantiate Create a new instance of the Type function deleteInstance \ud83d\udd17 void deleteInstance () Calls the destructor if there is a valid instance, otherwise nothing happens. function hasInstance \ud83d\udd17 bool hasInstance () const Return : true if there is a valid instance Checks is there is a valid instance function operator-> \ud83d\udd17 Interface * operator -> () const Return : pointer to the underlying instance or nullptr if there is no valid instance Returns a pointer to the underlying instance function operator* \ud83d\udd17 Interface & operator * () const Return : reference to the underlying instance Returns a reference to the underlying instance. If there is no valid instance, the behaviour is undefined Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#ioxcxxpoormansheap","text":"Reserves space on stack for placement new instatiation. More... #include <iceoryx_hoofs/cxx/poor_mans_heap.hpp>","title":"iox::cxx::PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#public-functions","text":"Name PoorMansHeap () =default ~PoorMansHeap () template <typename Type ,typename... CTorArgs> PoorMansHeap ( PoorMansHeapType < Type > , CTorArgs &&... ctorArgs) PoorMansHeap ( PoorMansHeap && other) PoorMansHeap & operator= ( PoorMansHeap && rhs) PoorMansHeap (const PoorMansHeap & ) PoorMansHeap & operator= (const PoorMansHeap & ) template <typename Type ,typename... CTorArgs> void newInstance (CTorArgs &&... ctorArgs) void deleteInstance () Calls the destructor if there is a valid instance, otherwise nothing happens. bool hasInstance () const Interface * operator-> () const Interface & operator* () const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#detailed-description","text":"template < typename Interface , size_t TypeSize , size_t TypeAlignment = 8 > class iox :: cxx :: PoorMansHeap ; Reserves space on stack for placement new instatiation. Parameters : Interface base type of all classes which should be stored in here TypeSize maximum size of a child of Interface TypeAlignment alignment which is required for the types #include \"iceoryx_hoofs/cxx/poor_mans_heap.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <iostream> class Base { public : virtual ~ Base () = default ; virtual void doStuff () = 0 ; }; class Foo : public Base { public : Foo ( int stuff ) : m_stuff ( stuff ) { } void doStuff () override { std :: cout << __PRETTY_FUNCTION__ << \": \" << m_stuff << std :: endl ; } private : int m_stuff ; }; class Bar : public Base { public : void doStuff () override { std :: cout << __PRETTY_FUNCTION__ << std :: endl ; } }; int main () { constexpr auto MaxSize = cxx :: maxSize < Foo , Bar > (); constexpr auto MaxAlignment = cxx :: maxAlignment < Foo , Bar > (); using FooBar = cxx :: PoorMansHeap < Base , MaxSize , MaxAlignment > ; FooBar fooBar1 { cxx :: PoorMansHeapType < Foo > (), 42 }; fooBar1 -> doStuff (); fooBar1 . newInstance < Bar > (); fooBar1 -> doStuff (); fooBar1 . newInstance < Foo > ( 13 ); fooBar1 -> doStuff (); FooBar fooBar2 ; if ( ! fooBar2 . hasInstance ()) { std :: cout << \"There is no instance!\" << std :: endl ; } fooBar2 . newInstance < Bar > (); fooBar2 -> doStuff (); fooBar2 . deleteInstance (); if ( ! fooBar2 . hasInstance ()) { std :: cout << \"There is again no instance!\" << std :: endl ; } return 0 ; }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap","text":"PoorMansHeap () = default","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_1","text":"~ PoorMansHeap ()","title":"function ~PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_2","text":"template < typename Type , typename ... CTorArgs > PoorMansHeap ( PoorMansHeapType < Type > , CTorArgs && ... ctorArgs ) Parameters : Type the type to instantiate, wrapped in PoorMansHeapType ctorArgs ctor arguments for the type to instantiate Constructor for immediate construction of an instance","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_3","text":"PoorMansHeap ( PoorMansHeap && other )","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator","text":"PoorMansHeap & operator = ( PoorMansHeap && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-poormansheap_4","text":"PoorMansHeap ( const PoorMansHeap & )","title":"function PoorMansHeap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator_1","text":"PoorMansHeap & operator = ( const PoorMansHeap & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-newinstance","text":"template < typename Type , typename ... CTorArgs > void newInstance ( CTorArgs && ... ctorArgs ) Parameters : Type the type to instantiate, wrapped in PoorMansHeapType ctorArgs ctor arguments for the type to instantiate Create a new instance of the Type","title":"function newInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-deleteinstance","text":"void deleteInstance () Calls the destructor if there is a valid instance, otherwise nothing happens.","title":"function deleteInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-hasinstance","text":"bool hasInstance () const Return : true if there is a valid instance Checks is there is a valid instance","title":"function hasInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator-","text":"Interface * operator -> () const Return : pointer to the underlying instance or nullptr if there is no valid instance Returns a pointer to the underlying instance","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeap/#function-operator_2","text":"Interface & operator * () const Return : reference to the underlying instance Returns a reference to the underlying instance. If there is no valid instance, the behaviour is undefined Updated on 18 December 2023 at 13:11:42 CET","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/","text":"iox::cxx::PoorMansHeapType \ud83d\udd17 This is a proxy which must be used for the non default PoorMansHeap ctor. More... #include <iceoryx_hoofs/cxx/poor_mans_heap.hpp> Detailed Description \ud83d\udd17 template < typename Type > class iox :: cxx :: PoorMansHeapType ; This is a proxy which must be used for the non default PoorMansHeap ctor. \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::PoorMansHeapType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/#ioxcxxpoormansheaptype","text":"This is a proxy which must be used for the non default PoorMansHeap ctor. More... #include <iceoryx_hoofs/cxx/poor_mans_heap.hpp>","title":"iox::cxx::PoorMansHeapType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/#detailed-description","text":"template < typename Type > class iox :: cxx :: PoorMansHeapType ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1PoorMansHeapType/#this-is-a-proxy-which-must-be-used-for-the-non-default-poormansheap-ctor","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"This is a proxy which must be used for the non default PoorMansHeap ctor."},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/","text":"iox::cxx::Serialization \ud83d\udd17 Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. More... #include <iceoryx_hoofs/cxx/serialization.hpp> Public Types \ud83d\udd17 Name enum Error { DESERIALIZATION_FAILED} This is an error which can be used for cxx::expected on a custom deserialization when extract fails. Public Functions \ud83d\udd17 Name Serialization (const std::string & value) Creates a serialization object from a given raw serialization. std::string toString () const string conversion operator, returns the raw serialized string operator std::string () const string conversion operator, returns the raw serialized string template <typename T ,typename... Targs> bool extract (T & t, Targs &... args) const Extracts the values from the serialization and writes them into the the given args, if one value is not convertable it returns false (e.g. convert \"hello\" to an integer) It also returns false if the underlying serialization string has a wrong syntax. template <typename T > bool getNth (const unsigned int index, T & t) const Extracts the value at index and writes it into t. If the conversion failed it returns false It also returns false if the underlying serialization string has a wrong syntax. template <typename... Targs> Serialization create (const Targs &... args) Create Serialization if every arguments is convertable to string via cxx::convert::toString , this means if the argument is either a pod (plain old data) type or is convertable to string (operator std::string()) Detailed Description \ud83d\udd17 class iox :: cxx :: Serialization ; Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. auto serial = cxx :: Serialization :: create ( \"fuu\" , 123 , 12.12f , 'c' ); std :: cout << serial . toString () << std :: endl ; std :: string v1 ; int v2 ; float v3 ; char v4 ; if ( serial . extract ( v1 , v2 , v3 , v4 ) ) {} // succeeds since every value is convertable if ( serial . getNth ( 0 , v2 ) ) {} // fails since \"fuu\" is not an integer // if you'd like to write a serializable class they need to have a CTor // with a cxx::Serialization argument and an operator cxx::Serialization class Fuu { public : Fuu ( const cxx :: Serialization & s ) { if ( ! s . Extract ( v1 , v2 , v3 ) ) {} // error handling } operator cxx :: Serialization () const { return cxx :: Serialization :: Create ( v1 , v2 , v3 ); } private : int v1 = 123 ; char v2 = 'c' ; std :: string v3 = \"hello world\" ; }; Public Types Documentation \ud83d\udd17 enum Error \ud83d\udd17 Enumerator Value Description DESERIALIZATION_FAILED indicates a failed deserialization This is an error which can be used for cxx::expected on a custom deserialization when extract fails. Public Functions Documentation \ud83d\udd17 function Serialization \ud83d\udd17 explicit Serialization ( const std :: string & value ) Creates a serialization object from a given raw serialization. Parameters : value string of serialized data function toString \ud83d\udd17 std :: string toString () const string conversion operator, returns the raw serialized string Return : serialized string function operator std::string \ud83d\udd17 operator std :: string () const string conversion operator, returns the raw serialized string Return : serialized string function extract \ud83d\udd17 template < typename T , typename ... Targs > bool extract ( T & t , Targs & ... args ) const Extracts the values from the serialization and writes them into the the given args, if one value is not convertable it returns false (e.g. convert \"hello\" to an integer) It also returns false if the underlying serialization string has a wrong syntax. Parameters : t reference where the first value in the serialization will be stored in args reference where the remainding values in the serialization will be stored in Return : true if extraction of all values was successfull, otherwise false function getNth \ud83d\udd17 template < typename T > bool getNth ( const unsigned int index , T & t ) const Extracts the value at index and writes it into t. If the conversion failed it returns false It also returns false if the underlying serialization string has a wrong syntax. Parameters : index index to the value which should be extracted t variable where the value should be stored Return : true if extraction was successful, otherwise false function create \ud83d\udd17 template < typename ... Targs > static Serialization create ( const Targs & ... args ) Create Serialization if every arguments is convertable to string via cxx::convert::toString , this means if the argument is either a pod (plain old data) type or is convertable to string (operator std::string()) Parameters : args list of string convertable data Return : Serialization object which contains the serialized data Updated on 18 December 2023 at 13:11:42 CET","title":"classiox 1 1cxx 1 1Serialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#ioxcxxserialization","text":"Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. More... #include <iceoryx_hoofs/cxx/serialization.hpp>","title":"iox::cxx::Serialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-types","text":"Name enum Error { DESERIALIZATION_FAILED} This is an error which can be used for cxx::expected on a custom deserialization when extract fails.","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-functions","text":"Name Serialization (const std::string & value) Creates a serialization object from a given raw serialization. std::string toString () const string conversion operator, returns the raw serialized string operator std::string () const string conversion operator, returns the raw serialized string template <typename T ,typename... Targs> bool extract (T & t, Targs &... args) const Extracts the values from the serialization and writes them into the the given args, if one value is not convertable it returns false (e.g. convert \"hello\" to an integer) It also returns false if the underlying serialization string has a wrong syntax. template <typename T > bool getNth (const unsigned int index, T & t) const Extracts the value at index and writes it into t. If the conversion failed it returns false It also returns false if the underlying serialization string has a wrong syntax. template <typename... Targs> Serialization create (const Targs &... args) Create Serialization if every arguments is convertable to string via cxx::convert::toString , this means if the argument is either a pod (plain old data) type or is convertable to string (operator std::string())","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#detailed-description","text":"class iox :: cxx :: Serialization ; Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. auto serial = cxx :: Serialization :: create ( \"fuu\" , 123 , 12.12f , 'c' ); std :: cout << serial . toString () << std :: endl ; std :: string v1 ; int v2 ; float v3 ; char v4 ; if ( serial . extract ( v1 , v2 , v3 , v4 ) ) {} // succeeds since every value is convertable if ( serial . getNth ( 0 , v2 ) ) {} // fails since \"fuu\" is not an integer // if you'd like to write a serializable class they need to have a CTor // with a cxx::Serialization argument and an operator cxx::Serialization class Fuu { public : Fuu ( const cxx :: Serialization & s ) { if ( ! s . Extract ( v1 , v2 , v3 ) ) {} // error handling } operator cxx :: Serialization () const { return cxx :: Serialization :: Create ( v1 , v2 , v3 ); } private : int v1 = 123 ; char v2 = 'c' ; std :: string v3 = \"hello world\" ; };","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#enum-error","text":"Enumerator Value Description DESERIALIZATION_FAILED indicates a failed deserialization This is an error which can be used for cxx::expected on a custom deserialization when extract fails.","title":"enum Error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-serialization","text":"explicit Serialization ( const std :: string & value ) Creates a serialization object from a given raw serialization. Parameters : value string of serialized data","title":"function Serialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-tostring","text":"std :: string toString () const string conversion operator, returns the raw serialized string Return : serialized string","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-operator-stdstring","text":"operator std :: string () const string conversion operator, returns the raw serialized string Return : serialized string","title":"function operator std::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-extract","text":"template < typename T , typename ... Targs > bool extract ( T & t , Targs & ... args ) const Extracts the values from the serialization and writes them into the the given args, if one value is not convertable it returns false (e.g. convert \"hello\" to an integer) It also returns false if the underlying serialization string has a wrong syntax. Parameters : t reference where the first value in the serialization will be stored in args reference where the remainding values in the serialization will be stored in Return : true if extraction of all values was successfull, otherwise false","title":"function extract"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-getnth","text":"template < typename T > bool getNth ( const unsigned int index , T & t ) const Extracts the value at index and writes it into t. If the conversion failed it returns false It also returns false if the underlying serialization string has a wrong syntax. Parameters : index index to the value which should be extracted t variable where the value should be stored Return : true if extraction was successful, otherwise false","title":"function getNth"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1Serialization/#function-create","text":"template < typename ... Targs > static Serialization create ( const Targs & ... args ) Create Serialization if every arguments is convertable to string via cxx::convert::toString , this means if the argument is either a pod (plain old data) type or is convertable to string (operator std::string()) Parameters : args list of string convertable data Return : Serialization object which contains the serialized data Updated on 18 December 2023 at 13:11:42 CET","title":"function create"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/","text":"iox::cxx::VariantQueue \ud83d\udd17 wrapper of multiple fifo's More... #include <iceoryx_hoofs/cxx/variant_queue.hpp> Public Types \ud83d\udd17 Name using variant < concurrent::FiFo< ValueType, Capacity >, concurrent::SoFi< ValueType, Capacity >, concurrent::ResizeableLockFreeQueue < ValueType, Capacity >, concurrent::ResizeableLockFreeQueue < ValueType, Capacity > > fifo_t Public Functions \ud83d\udd17 Name VariantQueue (const VariantQueueTypes type) Constructor of a VariantQueue . optional < ValueType > push (const ValueType & value) pushs an element into the fifo optional < ValueType > pop () pops an element from the fifo bool empty () const returns true if empty otherwise true uint64_t size () get the current size of the queue. Caution, another thread can have changed the size just after reading it bool setCapacity (const uint64_t newCapacity) set the capacity of the queue uint64_t capacity () const get the capacity of the queue. fifo_t & getUnderlyingFiFo () returns reference to the underlying fifo Detailed Description \ud83d\udd17 template < typename ValueType , uint64_t Capacity > class iox :: cxx :: VariantQueue ; wrapper of multiple fifo's Parameters : ValueType type which should be stored Capacity capacity of the underlying fifo cxx :: VariantQueue < int , 5 > nonOverflowingQueue ( cxx :: VariantQueueTypes :: FiFo_SingleProducerSingleConsumer ); cxx :: VariantQueue < int , 5 > overflowingQueue ( cxx :: VariantQueueTypes :: SoFi_SingleProducerSingleConsumer ); // overflow case auto status = nonOverflowingQueue . push ( 123 ); if ( ! status ) { std :: cout << \"queue is full\" << std :: endl ; } auto overriddenElement = overflowingQueue . push ( 123 ); if ( overriddenElement -> has_value () ) { std :: cout << \"element \" << overriddenElement -> value () << \" was overridden \\n \" ; } Public Types Documentation \ud83d\udd17 using fifo_t \ud83d\udd17 using iox :: cxx :: VariantQueue < ValueType , Capacity >:: fifo_t = variant < concurrent :: FiFo < ValueType , Capacity > , concurrent :: SoFi < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity > > ; Public Functions Documentation \ud83d\udd17 function VariantQueue \ud83d\udd17 VariantQueue ( const VariantQueueTypes type ) Constructor of a VariantQueue . Parameters : type type of the underlying queue function push \ud83d\udd17 optional < ValueType > push ( const ValueType & value ) pushs an element into the fifo Parameters : value value which should be added in the fifo Return : if the underlying queue has an overflow the optional will contain the value which was overridden (SOFI) or which was dropped (FIFO) otherwise the optional contains nullopt_t function pop \ud83d\udd17 optional < ValueType > pop () pops an element from the fifo Return : if the fifo did contain an element it is returned inside the optional otherwise the optional contains nullopt_t function empty \ud83d\udd17 bool empty () const returns true if empty otherwise true function size \ud83d\udd17 uint64_t size () get the current size of the queue. Caution, another thread can have changed the size just after reading it Return : queue size function setCapacity \ud83d\udd17 bool setCapacity ( const uint64_t newCapacity ) set the capacity of the queue Parameters : newCapacity valid values are 0 < newCapacity < MAX_SUBSCRIBER_QUEUE_CAPACITY Return : true if setting the new capacity succeeded, false otherwise Note : depending on the internal queue used, concurrent pushes and pops are possible (for FiFo_MultiProducerSingleConsumer and SoFi_MultiProducerSingleConsumer) Precondition : it is important that no pop or push calls occur during this call function capacity \ud83d\udd17 uint64_t capacity () const get the capacity of the queue. Return : queue size function getUnderlyingFiFo \ud83d\udd17 fifo_t & getUnderlyingFiFo () returns reference to the underlying fifo VariantQueueTypes < int , 10 > myFifo ( VariantQueueTypes :: FiFo_SingleProducerSingleConsumer ); // access the underlying fifo directly and call empty on it myFifo . getUnderlyingFiFo (). template get_at_index < VariantQueueTypes :: FiFo_SingleProducerSingleConsumer > () -> empty (); Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::VariantQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#ioxcxxvariantqueue","text":"wrapper of multiple fifo's More... #include <iceoryx_hoofs/cxx/variant_queue.hpp>","title":"iox::cxx::VariantQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-types","text":"Name using variant < concurrent::FiFo< ValueType, Capacity >, concurrent::SoFi< ValueType, Capacity >, concurrent::ResizeableLockFreeQueue < ValueType, Capacity >, concurrent::ResizeableLockFreeQueue < ValueType, Capacity > > fifo_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-functions","text":"Name VariantQueue (const VariantQueueTypes type) Constructor of a VariantQueue . optional < ValueType > push (const ValueType & value) pushs an element into the fifo optional < ValueType > pop () pops an element from the fifo bool empty () const returns true if empty otherwise true uint64_t size () get the current size of the queue. Caution, another thread can have changed the size just after reading it bool setCapacity (const uint64_t newCapacity) set the capacity of the queue uint64_t capacity () const get the capacity of the queue. fifo_t & getUnderlyingFiFo () returns reference to the underlying fifo","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#detailed-description","text":"template < typename ValueType , uint64_t Capacity > class iox :: cxx :: VariantQueue ; wrapper of multiple fifo's Parameters : ValueType type which should be stored Capacity capacity of the underlying fifo cxx :: VariantQueue < int , 5 > nonOverflowingQueue ( cxx :: VariantQueueTypes :: FiFo_SingleProducerSingleConsumer ); cxx :: VariantQueue < int , 5 > overflowingQueue ( cxx :: VariantQueueTypes :: SoFi_SingleProducerSingleConsumer ); // overflow case auto status = nonOverflowingQueue . push ( 123 ); if ( ! status ) { std :: cout << \"queue is full\" << std :: endl ; } auto overriddenElement = overflowingQueue . push ( 123 ); if ( overriddenElement -> has_value () ) { std :: cout << \"element \" << overriddenElement -> value () << \" was overridden \\n \" ; }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#using-fifo_t","text":"using iox :: cxx :: VariantQueue < ValueType , Capacity >:: fifo_t = variant < concurrent :: FiFo < ValueType , Capacity > , concurrent :: SoFi < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity > > ;","title":"using fifo_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-variantqueue","text":"VariantQueue ( const VariantQueueTypes type ) Constructor of a VariantQueue . Parameters : type type of the underlying queue","title":"function VariantQueue"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-push","text":"optional < ValueType > push ( const ValueType & value ) pushs an element into the fifo Parameters : value value which should be added in the fifo Return : if the underlying queue has an overflow the optional will contain the value which was overridden (SOFI) or which was dropped (FIFO) otherwise the optional contains nullopt_t","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-pop","text":"optional < ValueType > pop () pops an element from the fifo Return : if the fifo did contain an element it is returned inside the optional otherwise the optional contains nullopt_t","title":"function pop"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-empty","text":"bool empty () const returns true if empty otherwise true","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-size","text":"uint64_t size () get the current size of the queue. Caution, another thread can have changed the size just after reading it Return : queue size","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-setcapacity","text":"bool setCapacity ( const uint64_t newCapacity ) set the capacity of the queue Parameters : newCapacity valid values are 0 < newCapacity < MAX_SUBSCRIBER_QUEUE_CAPACITY Return : true if setting the new capacity succeeded, false otherwise Note : depending on the internal queue used, concurrent pushes and pops are possible (for FiFo_MultiProducerSingleConsumer and SoFi_MultiProducerSingleConsumer) Precondition : it is important that no pop or push calls occur during this call","title":"function setCapacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-capacity","text":"uint64_t capacity () const get the capacity of the queue. Return : queue size","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1VariantQueue/#function-getunderlyingfifo","text":"fifo_t & getUnderlyingFiFo () returns reference to the underlying fifo VariantQueueTypes < int , 10 > myFifo ( VariantQueueTypes :: FiFo_SingleProducerSingleConsumer ); // access the underlying fifo directly and call empty on it myFifo . getUnderlyingFiFo (). template get_at_index < VariantQueueTypes :: FiFo_SingleProducerSingleConsumer > () -> empty (); Updated on 18 December 2023 at 13:11:42 CET","title":"function getUnderlyingFiFo"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/","text":"iox::cxx::convert \ud83d\udd17 Collection of static methods for conversion from and to string. More... #include <iceoryx_hoofs/cxx/convert.hpp> Public Types \ud83d\udd17 Name enum NumberType { INTEGER, UNSIGNED_INTEGER, FLOAT} Public Functions \ud83d\udd17 Name template <typename Source > std::enable_if<!std::is_convertible< Source, std::string >::value, std::string >::type toString (const Source & t) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) template <typename Source > std::enable_if< std::is_convertible< Source, std::string >::value, std::string >::type toString (const Source & t) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) template <typename Destination > bool fromString (const char * v, Destination & dest) Sets dest from a given string. If the conversion fails false is returned and the value of dest is undefined. bool stringIsNumber (const char * v, const NumberType type) checks if a given string v is a number Public Attributes \ud83d\udd17 Name constexpr int32_t STRTOULL_BASE Detailed Description \ud83d\udd17 class iox :: cxx :: convert ; Collection of static methods for conversion from and to string. std :: string number = cxx :: convert :: toString ( 123 ); std :: string someClass = cxx :: convert :: toString ( someToStringConvertableObject ); int i ; unsigned int a ; if ( cxx :: convert :: fromString ( \"123\" , i ) ) {} // will succeed if ( cxx :: convert :: fromString ( \"-123\" , a ) ) {} // will fail since -123 is not unsigned Public Types Documentation \ud83d\udd17 enum NumberType \ud83d\udd17 Enumerator Value Description INTEGER UNSIGNED_INTEGER FLOAT Public Functions Documentation \ud83d\udd17 function toString \ud83d\udd17 template < typename Source > static std :: enable_if <! std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) Parameters : Source type of the value which should be converted to a string t value which should be converted to a string Return : string representation of t function toString \ud83d\udd17 template < typename Source > static std :: enable_if < std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) Parameters : Source type of the value which should be converted to a string t value which should be converted to a string Return : string representation of t function fromString \ud83d\udd17 template < typename Destination > static bool fromString ( const char * v , Destination & dest ) Sets dest from a given string. If the conversion fails false is returned and the value of dest is undefined. Parameters : v string which contains the value of dest dest destination to which the value should be written Return : false = if the conversion fails otherwise true function stringIsNumber \ud83d\udd17 static bool stringIsNumber ( const char * v , const NumberType type ) checks if a given string v is a number Parameters : v string which contains the number type is the expected contained type in v Return : true if the given string is a number, otherwise false Public Attributes Documentation \ud83d\udd17 variable STRTOULL_BASE \ud83d\udd17 static constexpr int32_t STRTOULL_BASE = 10 ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::convert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#ioxcxxconvert","text":"Collection of static methods for conversion from and to string. More... #include <iceoryx_hoofs/cxx/convert.hpp>","title":"iox::cxx::convert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-types","text":"Name enum NumberType { INTEGER, UNSIGNED_INTEGER, FLOAT}","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-functions","text":"Name template <typename Source > std::enable_if<!std::is_convertible< Source, std::string >::value, std::string >::type toString (const Source & t) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) template <typename Source > std::enable_if< std::is_convertible< Source, std::string >::value, std::string >::type toString (const Source & t) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) template <typename Destination > bool fromString (const char * v, Destination & dest) Sets dest from a given string. If the conversion fails false is returned and the value of dest is undefined. bool stringIsNumber (const char * v, const NumberType type) checks if a given string v is a number","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-attributes","text":"Name constexpr int32_t STRTOULL_BASE","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#detailed-description","text":"class iox :: cxx :: convert ; Collection of static methods for conversion from and to string. std :: string number = cxx :: convert :: toString ( 123 ); std :: string someClass = cxx :: convert :: toString ( someToStringConvertableObject ); int i ; unsigned int a ; if ( cxx :: convert :: fromString ( \"123\" , i ) ) {} // will succeed if ( cxx :: convert :: fromString ( \"-123\" , a ) ) {} // will fail since -123 is not unsigned","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#enum-numbertype","text":"Enumerator Value Description INTEGER UNSIGNED_INTEGER FLOAT","title":"enum NumberType"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-tostring","text":"template < typename Source > static std :: enable_if <! std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) Parameters : Source type of the value which should be converted to a string t value which should be converted to a string Return : string representation of t","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-tostring_1","text":"template < typename Source > static std :: enable_if < std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) Converts every type which is either a pod (plain old data) type or is convertable to a string (this means that the operator std::string() is defined) Parameters : Source type of the value which should be converted to a string t value which should be converted to a string Return : string representation of t","title":"function toString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-fromstring","text":"template < typename Destination > static bool fromString ( const char * v , Destination & dest ) Sets dest from a given string. If the conversion fails false is returned and the value of dest is undefined. Parameters : v string which contains the value of dest dest destination to which the value should be written Return : false = if the conversion fails otherwise true","title":"function fromString"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#function-stringisnumber","text":"static bool stringIsNumber ( const char * v , const NumberType type ) checks if a given string v is a number Parameters : v string which contains the number type is the expected contained type in v Return : true if the given string is a number, otherwise false","title":"function stringIsNumber"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1convert/#variable-strtoull_base","text":"static constexpr int32_t STRTOULL_BASE = 10 ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable STRTOULL_BASE"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/","text":"iox::cxx::expected< ErrorType > \ud83d\udd17 expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. More... #include <iceoryx_hoofs/cxx/expected.hpp> Inherited by iox::cxx::expected< void, ErrorType > Public Functions \ud83d\udd17 Name expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value expected (const expected & ) =default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected expected (expected && rhs) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected ~expected () =default calls the destructor of the success value or error value - depending on what is stored in the expected expected & operator= (const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected expected & operator= ( expected && rhs) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected expected (const success < void > & successValue) constructs an expected which is signaling success expected (const error < ErrorType > & errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue expected ( error < ErrorType > && errorValue) constructs an expected which is signaling an error and stores the error value provided by value operator bool () const returns true if the expected contains an error otherwise false bool has_error () const returns true if the expected contains an error otherwise false ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior const expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable const expected & and_then (const cxx::function_ref < void()> & callable) const if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected & and_then (const cxx::function_ref < void()> & callable) if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected create_value () creates an expected which is signaling success template <typename... Targs> expected create_error (Targs &&... args) creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType Detailed Description \ud83d\udd17 template < typename ErrorType > class iox :: cxx :: expected < ErrorType > ; expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. Parameters : ErrorType type of the error which can be stored in the expected cxx :: expected < int , float > callMe () { bool l_errorOccured ; // ... do stuff if ( l_errorOccured ) { return cxx :: error < float > ( 55.1f ); } else if ( ! l_errorOccured ) { return cxx :: success < int > ( 123 ); } } cxx :: expected < float > errorOnlyMethod () { return callMe (). or_else ([]{ std :: cerr << \"Error Occured \\n \" ; /// perform some action }). and_then ([]( cxx :: expected < int , float > & result ){ std :: cout << \"Success, got \" << result . value () << std :: endl ; /// perform some action }); } cxx :: expected < std :: vector < int > , int > allHailHypnotoad ( success < std :: vector < int >> ({ 6 , 6 , 6 })); allHailHypnotoad -> push_back ( 7 ); Public Functions Documentation \ud83d\udd17 function expected \ud83d\udd17 expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value function expected \ud83d\udd17 expected ( const expected & ) = default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected function expected \ud83d\udd17 expected ( expected && rhs ) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected function ~expected \ud83d\udd17 ~ expected () = default calls the destructor of the success value or error value - depending on what is stored in the expected function operator= \ud83d\udd17 expected & operator = ( const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected function operator= \ud83d\udd17 expected & operator = ( expected && rhs ) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected function expected \ud83d\udd17 expected ( const success < void > & successValue ) constructs an expected which is signaling success Parameters : successValue value which will be stored in the expected function expected \ud83d\udd17 expected ( const error < ErrorType > & errorValue ) constructs an expected which is signaling an error and stores the error value provided by errorValue Parameters : errorValue error value which will be stored in the expected function expected \ud83d\udd17 expected ( error < ErrorType > && errorValue ) constructs an expected which is signaling an error and stores the error value provided by value Parameters : errorValue error value which will be moved into the expected function operator bool \ud83d\udd17 explicit operator bool () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error function has_error \ud83d\udd17 bool has_error () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error function get_error \ud83d\udd17 ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : reference to the internally contained error function get_error \ud83d\udd17 const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : const reference to the internally contained error function get_error \ud83d\udd17 ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : rvalue reference to the internally contained error function or_else \ud83d\udd17 const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : const reference to the expected itself someExpected . or_else ([]( float & error ){ std :: cout << \"error occured : \" << error << std :: endl ; }) function or_else \ud83d\udd17 expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : const reference to the expected itself someExpected . or_else ([]( float & error ){ std :: cout << \"error occured : \" << error << std :: endl ; }) function and_then \ud83d\udd17 const expected & and_then ( const cxx :: function_ref < void () > & callable ) const if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : const reference to the expected itself someExpected . and_then ([]{ std :: cout << \"we are successful!\" << std :: endl ; }) function and_then \ud83d\udd17 expected & and_then ( const cxx :: function_ref < void () > & callable ) if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : const reference to the expected itself someExpected . and_then ([]{ std :: cout << \"we are successful!\" << std :: endl ; }) function create_value \ud83d\udd17 static expected create_value () creates an expected which is signaling success Return : expected signalling success function create_error \ud83d\udd17 template < typename ... Targs > static expected create_error ( Targs && ... args ) creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType Parameters : args... arguments which will be forwarded to the ErrorType constructor Return : expected signalling error Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::expected< ErrorType >"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#ioxcxxexpected-errortype","text":"expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. More... #include <iceoryx_hoofs/cxx/expected.hpp> Inherited by iox::cxx::expected< void, ErrorType >","title":"iox::cxx::expected&lt; ErrorType &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#public-functions","text":"Name expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value expected (const expected & ) =default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected expected (expected && rhs) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected ~expected () =default calls the destructor of the success value or error value - depending on what is stored in the expected expected & operator= (const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected expected & operator= ( expected && rhs) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected expected (const success < void > & successValue) constructs an expected which is signaling success expected (const error < ErrorType > & errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue expected ( error < ErrorType > && errorValue) constructs an expected which is signaling an error and stores the error value provided by value operator bool () const returns true if the expected contains an error otherwise false bool has_error () const returns true if the expected contains an error otherwise false ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior const expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable const expected & and_then (const cxx::function_ref < void()> & callable) const if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected & and_then (const cxx::function_ref < void()> & callable) if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected create_value () creates an expected which is signaling success template <typename... Targs> expected create_error (Targs &&... args) creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#detailed-description","text":"template < typename ErrorType > class iox :: cxx :: expected < ErrorType > ; expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. Parameters : ErrorType type of the error which can be stored in the expected cxx :: expected < int , float > callMe () { bool l_errorOccured ; // ... do stuff if ( l_errorOccured ) { return cxx :: error < float > ( 55.1f ); } else if ( ! l_errorOccured ) { return cxx :: success < int > ( 123 ); } } cxx :: expected < float > errorOnlyMethod () { return callMe (). or_else ([]{ std :: cerr << \"Error Occured \\n \" ; /// perform some action }). and_then ([]( cxx :: expected < int , float > & result ){ std :: cout << \"Success, got \" << result . value () << std :: endl ; /// perform some action }); } cxx :: expected < std :: vector < int > , int > allHailHypnotoad ( success < std :: vector < int >> ({ 6 , 6 , 6 })); allHailHypnotoad -> push_back ( 7 );","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected","text":"expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_1","text":"expected ( const expected & ) = default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_2","text":"expected ( expected && rhs ) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_3","text":"~ expected () = default calls the destructor of the success value or error value - depending on what is stored in the expected","title":"function ~expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-operator","text":"expected & operator = ( const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-operator_1","text":"expected & operator = ( expected && rhs ) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_4","text":"expected ( const success < void > & successValue ) constructs an expected which is signaling success Parameters : successValue value which will be stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_5","text":"expected ( const error < ErrorType > & errorValue ) constructs an expected which is signaling an error and stores the error value provided by errorValue Parameters : errorValue error value which will be stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-expected_6","text":"expected ( error < ErrorType > && errorValue ) constructs an expected which is signaling an error and stores the error value provided by value Parameters : errorValue error value which will be moved into the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-operator-bool","text":"explicit operator bool () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-has_error","text":"bool has_error () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error","title":"function has_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-get_error","text":"ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : reference to the internally contained error","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-get_error_1","text":"const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : const reference to the internally contained error","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-get_error_2","text":"ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : rvalue reference to the internally contained error","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-or_else","text":"const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : const reference to the expected itself someExpected . or_else ([]( float & error ){ std :: cout << \"error occured : \" << error << std :: endl ; })","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-or_else_1","text":"expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : const reference to the expected itself someExpected . or_else ([]( float & error ){ std :: cout << \"error occured : \" << error << std :: endl ; })","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-and_then","text":"const expected & and_then ( const cxx :: function_ref < void () > & callable ) const if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : const reference to the expected itself someExpected . and_then ([]{ std :: cout << \"we are successful!\" << std :: endl ; })","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-and_then_1","text":"expected & and_then ( const cxx :: function_ref < void () > & callable ) if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : const reference to the expected itself someExpected . and_then ([]{ std :: cout << \"we are successful!\" << std :: endl ; })","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-create_value","text":"static expected create_value () creates an expected which is signaling success Return : expected signalling success","title":"function create_value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ErrorType_01_4/#function-create_error","text":"template < typename ... Targs > static expected create_error ( Targs && ... args ) creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType Parameters : args... arguments which will be forwarded to the ErrorType constructor Return : expected signalling error Updated on 18 December 2023 at 13:11:42 CET","title":"function create_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/","text":"iox::cxx::expected< ValueType, ErrorType > \ud83d\udd17 specialization of the expected class which can contain an error as well as a success value More... #include <iceoryx_hoofs/cxx/expected.hpp> Public Functions \ud83d\udd17 Name expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value expected (const expected & ) =default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected expected (expected && rhs) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected ~expected () =default calls the destructor of the success value or error value - depending on what is stored in the expected expected & operator= (const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected expected & operator= ( expected && rhs) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected expected (const success < ValueType > & successValue) constructs an expected which is signaling success and uses the value provided by successValue to copy construct its success value expected ( success < ValueType > && successValue) constructs an expected which is signaling success and uses the value provided by successValue to move construct its success value expected (const error < ErrorType > & errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue expected ( error < ErrorType > && errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue operator bool () const returns true if the expected contains an error otherwise false bool has_error () const returns true if the expected contains an error otherwise false ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior ValueType & value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior const ValueType & value () const returns a const reference to the contained success value, if the expected does not contain a success value this is undefined behavior ValueType && value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior ValueType value_or (const ValueType & value) const returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value ValueType value_or (const ValueType & value) returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value ValueType & operator* () dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. const ValueType & operator* () const dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. ValueType * operator-> () arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. const ValueType * operator-> () const arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. template <typename T > operator expected< T > () conversion operator to an error only expected which can be useful if you would like to return only the success of a function template <typename T > operator expected< T > () const conversion operator to an error only expected which can be useful if you would like to return only the success of a function const expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable const expected & and_then (const cxx::function_ref < void(ValueType &)> & callable) const if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable expected & and_then (const cxx::function_ref < void(ValueType &)> & callable) if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> const expected & and_then (const cxx::function_ref < void(typename Optional::type &)> & callable) const if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> expected & and_then (const cxx::function_ref < void(typename Optional::type &)> & callable) if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> const expected & if_empty (const cxx::function_ref < void()> & callable) const if the expected contains a success value and its type is an empty optional, calls the provided callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> expected & if_empty (const cxx::function_ref < void()> & callable) if the expected contains a success value and its type is an empty optional, calls the provided callable optional < ValueType > to_optional () const template <typename... Targs> expected create_value (Targs &&... args) creates an expected which is signaling success and perfectly forwards the args to the constructor of ValueType template <typename... Targs> expected create_error (Targs &&... args) creates an expected which is signaling an error and perfectly forwards the args to the constructor of ErrorType Detailed Description \ud83d\udd17 template < typename ValueType , typename ErrorType > class iox :: cxx :: expected < ValueType , ErrorType > ; specialization of the expected class which can contain an error as well as a success value Parameters : ValueType type of the value which can be stored in the expected ErrorType type of the error which can be stored in the expected Public Functions Documentation \ud83d\udd17 function expected \ud83d\udd17 expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value function expected \ud83d\udd17 expected ( const expected & ) = default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected function expected \ud83d\udd17 expected ( expected && rhs ) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected function ~expected \ud83d\udd17 ~ expected () = default calls the destructor of the success value or error value - depending on what is stored in the expected function operator= \ud83d\udd17 expected & operator = ( const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected function operator= \ud83d\udd17 expected & operator = ( expected && rhs ) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected function expected \ud83d\udd17 expected ( const success < ValueType > & successValue ) constructs an expected which is signaling success and uses the value provided by successValue to copy construct its success value Parameters : successValue value which will be stored in the expected function expected \ud83d\udd17 expected ( success < ValueType > && successValue ) constructs an expected which is signaling success and uses the value provided by successValue to move construct its success value Parameters : successValue value which will be moved into the expected function expected \ud83d\udd17 expected ( const error < ErrorType > & errorValue ) constructs an expected which is signaling an error and stores the error value provided by errorValue Parameters : errorValue error value which will be stored in the expected function expected \ud83d\udd17 expected ( error < ErrorType > && errorValue ) constructs an expected which is signaling an error and stores the error value provided by errorValue Parameters : errorValue error value which will be moved into the expected function operator bool \ud83d\udd17 explicit operator bool () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error function has_error \ud83d\udd17 bool has_error () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error function get_error \ud83d\udd17 ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : reference to the internally contained error function get_error \ud83d\udd17 const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : const reference to the internally contained error function get_error \ud83d\udd17 ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : rvalue reference to the internally contained error function value \ud83d\udd17 ValueType & value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior Return : reference to the internally contained value function value \ud83d\udd17 const ValueType & value () const returns a const reference to the contained success value, if the expected does not contain a success value this is undefined behavior Return : const reference to the internally contained value function value \ud83d\udd17 ValueType && value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior Return : rvalue reference to the internally contained value function value_or \ud83d\udd17 ValueType value_or ( const ValueType & value ) const returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value Return : copy of the internally contained value or copy of value function value_or \ud83d\udd17 ValueType value_or ( const ValueType & value ) returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value Return : copy of the internally contained value or copy of value function operator* \ud83d\udd17 ValueType & operator * () dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. Return : reference to the contained value cxx :: expected < int , float > frodo ( success < int > ( 45 )); * frodo += 12 ; std :: cout << * frodo << std :: endl ; // prints 57 function operator* \ud83d\udd17 const ValueType & operator * () const dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. Return : const reference to the contained value cxx :: expected < int , float > frodo ( success < int > ( 45 )); * frodo += 12 ; std :: cout << * frodo << std :: endl ; // prints 57 function operator-> \ud83d\udd17 ValueType * operator -> () arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. Return : pointer of type ValueType to the contained value cxx :: expected < std :: vector < int > , int > holyPiotr ( success < std :: vector < int >> ({ 1 , 2 , 3 })); holyPiotr -> push_back ( 4 ); function operator-> \ud83d\udd17 const ValueType * operator -> () const arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. Return : pointer of type const ValueType to the contained value cxx :: expected < std :: vector < int > , int > holyPiotr ( success < std :: vector < int >> ({ 1 , 2 , 3 })); holyPiotr -> push_back ( 4 ); function operator expected< T > \ud83d\udd17 template < typename T > operator expected < T > () conversion operator to an error only expected which can be useful if you would like to return only the success of a function Return : converts an expected which can contain a value and an error to an expected which contains only an error cxx :: expected < int , int > someErrorProneFunction (){} cxx :: expected < int > isItSuccessful () { return someErrorProneFunction (); } function operator expected< T > \ud83d\udd17 template < typename T > operator expected < T > () const conversion operator to an error only expected which can be useful if you would like to return only the success of a function Return : converts an expected which can contain a value and an error to an expected which contains only an error cxx :: expected < int , int > someErrorProneFunction (){} cxx :: expected < int > isItSuccessful () { return someErrorProneFunction (); } function or_else \ud83d\udd17 const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : const reference to the expected itself someExpected . or_else ([]( float & result ){ std :: cout << \"error occured : \" << error << std :: endl ; }) function or_else \ud83d\udd17 expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : reference to the expected itself someExpected . or_else ([]( float & error ){ std :: cout << \"error occured : \" << error << std :: endl ; }) function and_then \ud83d\udd17 const expected & and_then ( const cxx :: function_ref < void ( ValueType & ) > & callable ) const if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : const reference to the expected someExpected . and_then ([]( int & result ){ std :: cout << \"we have a result : \" << result << std :: endl ; }) function and_then \ud83d\udd17 expected & and_then ( const cxx :: function_ref < void ( ValueType & ) > & callable ) if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : reference to the expected someExpected . and_then ([]( int & result ){ std :: cout << \"we have a result : \" << result << std :: endl ; }) function and_then \ud83d\udd17 template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > const expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) > & callable ) const if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable Parameters : callable the callable to be called with the contents of the optional Return : reference to the expected anExpectedOptional . and_then ([]( int & value ){ std :: cout << \"the optional contains the value: \" << result << std :: endl ; }) function and_then \ud83d\udd17 template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) > & callable ) if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable Parameters : callable the callable to be called with the contents of the optional Return : reference to the expected anExpectedOptional . and_then ([]( int & value ){ std :: cout << \"the optional contains the value: \" << result << std :: endl ; }) function if_empty \ud83d\udd17 template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > const expected & if_empty ( const cxx :: function_ref < void () > & callable ) const if the expected contains a success value and its type is an empty optional, calls the provided callable Parameters : callable the callable to be called if the contained optional is empty Return : reference to the expected anExpectedOptional . and_then ([]( SomeType & value ){ std :: cout << \"we got something in the optional: \" << value << std :: endl ; }) . if_empty ([](){ std :: cout << \"the optional was empty, but do something anyway!\" << result << std :: endl ; }) function if_empty \ud83d\udd17 template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > expected & if_empty ( const cxx :: function_ref < void () > & callable ) if the expected contains a success value and its type is an empty optional, calls the provided callable Parameters : callable the callable to be called if the contained optional is empty Return : reference to the expected anExpectedOptional . and_then ([]( SomeType & value ){ std :: cout << \"we got something in the optional: \" << value << std :: endl ; }) . if_empty ([](){ std :: cout << \"the optional was empty, but do something anyway!\" << result << std :: endl ; }) function to_optional \ud83d\udd17 optional < ValueType > to_optional () const function create_value \ud83d\udd17 template < typename ... Targs > static expected create_value ( Targs && ... args ) creates an expected which is signaling success and perfectly forwards the args to the constructor of ValueType Parameters : args... arguments which will be forwarded to the ValueType constructor Return : expected signalling success function create_error \ud83d\udd17 template < typename ... Targs > static expected create_error ( Targs && ... args ) creates an expected which is signaling an error and perfectly forwards the args to the constructor of ErrorType Parameters : args... arguments which will be forwarded to the ErrorType constructor Return : expected signalling error Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::expected< ValueType, ErrorType >"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#ioxcxxexpected-valuetype-errortype","text":"specialization of the expected class which can contain an error as well as a success value More... #include <iceoryx_hoofs/cxx/expected.hpp>","title":"iox::cxx::expected&lt; ValueType, ErrorType &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#public-functions","text":"Name expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value expected (const expected & ) =default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected expected (expected && rhs) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected ~expected () =default calls the destructor of the success value or error value - depending on what is stored in the expected expected & operator= (const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected expected & operator= ( expected && rhs) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected expected (const success < ValueType > & successValue) constructs an expected which is signaling success and uses the value provided by successValue to copy construct its success value expected ( success < ValueType > && successValue) constructs an expected which is signaling success and uses the value provided by successValue to move construct its success value expected (const error < ErrorType > & errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue expected ( error < ErrorType > && errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue operator bool () const returns true if the expected contains an error otherwise false bool has_error () const returns true if the expected contains an error otherwise false ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior ValueType & value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior const ValueType & value () const returns a const reference to the contained success value, if the expected does not contain a success value this is undefined behavior ValueType && value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior ValueType value_or (const ValueType & value) const returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value ValueType value_or (const ValueType & value) returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value ValueType & operator* () dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. const ValueType & operator* () const dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. ValueType * operator-> () arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. const ValueType * operator-> () const arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. template <typename T > operator expected< T > () conversion operator to an error only expected which can be useful if you would like to return only the success of a function template <typename T > operator expected< T > () const conversion operator to an error only expected which can be useful if you would like to return only the success of a function const expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable const expected & and_then (const cxx::function_ref < void(ValueType &)> & callable) const if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable expected & and_then (const cxx::function_ref < void(ValueType &)> & callable) if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> const expected & and_then (const cxx::function_ref < void(typename Optional::type &)> & callable) const if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> expected & and_then (const cxx::function_ref < void(typename Optional::type &)> & callable) if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> const expected & if_empty (const cxx::function_ref < void()> & callable) const if the expected contains a success value and its type is an empty optional, calls the provided callable template <typename Optional =ValueType,typename std::enable_if< internal::IsOptional< Optional >::value, int >::type =0> expected & if_empty (const cxx::function_ref < void()> & callable) if the expected contains a success value and its type is an empty optional, calls the provided callable optional < ValueType > to_optional () const template <typename... Targs> expected create_value (Targs &&... args) creates an expected which is signaling success and perfectly forwards the args to the constructor of ValueType template <typename... Targs> expected create_error (Targs &&... args) creates an expected which is signaling an error and perfectly forwards the args to the constructor of ErrorType","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#detailed-description","text":"template < typename ValueType , typename ErrorType > class iox :: cxx :: expected < ValueType , ErrorType > ; specialization of the expected class which can contain an error as well as a success value Parameters : ValueType type of the value which can be stored in the expected ErrorType type of the error which can be stored in the expected","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected","text":"expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_1","text":"expected ( const expected & ) = default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_2","text":"expected ( expected && rhs ) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_3","text":"~ expected () = default calls the destructor of the success value or error value - depending on what is stored in the expected","title":"function ~expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator","text":"expected & operator = ( const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator_1","text":"expected & operator = ( expected && rhs ) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_4","text":"expected ( const success < ValueType > & successValue ) constructs an expected which is signaling success and uses the value provided by successValue to copy construct its success value Parameters : successValue value which will be stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_5","text":"expected ( success < ValueType > && successValue ) constructs an expected which is signaling success and uses the value provided by successValue to move construct its success value Parameters : successValue value which will be moved into the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_6","text":"expected ( const error < ErrorType > & errorValue ) constructs an expected which is signaling an error and stores the error value provided by errorValue Parameters : errorValue error value which will be stored in the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-expected_7","text":"expected ( error < ErrorType > && errorValue ) constructs an expected which is signaling an error and stores the error value provided by errorValue Parameters : errorValue error value which will be moved into the expected","title":"function expected"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-bool","text":"explicit operator bool () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-has_error","text":"bool has_error () const returns true if the expected contains an error otherwise false Return : bool which contains true if the expected contains an error","title":"function has_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-get_error","text":"ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : reference to the internally contained error","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-get_error_1","text":"const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : const reference to the internally contained error","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-get_error_2","text":"ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior Return : rvalue reference to the internally contained error","title":"function get_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value","text":"ValueType & value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior Return : reference to the internally contained value","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_1","text":"const ValueType & value () const returns a const reference to the contained success value, if the expected does not contain a success value this is undefined behavior Return : const reference to the internally contained value","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_2","text":"ValueType && value () returns a reference to the contained success value, if the expected does not contain a success value this is undefined behavior Return : rvalue reference to the internally contained value","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_or","text":"ValueType value_or ( const ValueType & value ) const returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value Return : copy of the internally contained value or copy of value","title":"function value_or"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-value_or_1","text":"ValueType value_or ( const ValueType & value ) returns a copy of the contained success value if the expected does contain a success value, otherwise it returns a copy of value Return : copy of the internally contained value or copy of value","title":"function value_or"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator_2","text":"ValueType & operator * () dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. Return : reference to the contained value cxx :: expected < int , float > frodo ( success < int > ( 45 )); * frodo += 12 ; std :: cout << * frodo << std :: endl ; // prints 57","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator_3","text":"const ValueType & operator * () const dereferencing operator which returns a reference to the contained success value. if the expected contains an error the behavior is undefined. Return : const reference to the contained value cxx :: expected < int , float > frodo ( success < int > ( 45 )); * frodo += 12 ; std :: cout << * frodo << std :: endl ; // prints 57","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-","text":"ValueType * operator -> () arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. Return : pointer of type ValueType to the contained value cxx :: expected < std :: vector < int > , int > holyPiotr ( success < std :: vector < int >> ({ 1 , 2 , 3 })); holyPiotr -> push_back ( 4 );","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-_1","text":"const ValueType * operator -> () const arrow operator which returns the pointer to the contained success value. if the expected contains an error the behavior is undefined. Return : pointer of type const ValueType to the contained value cxx :: expected < std :: vector < int > , int > holyPiotr ( success < std :: vector < int >> ({ 1 , 2 , 3 })); holyPiotr -> push_back ( 4 );","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-expected-t","text":"template < typename T > operator expected < T > () conversion operator to an error only expected which can be useful if you would like to return only the success of a function Return : converts an expected which can contain a value and an error to an expected which contains only an error cxx :: expected < int , int > someErrorProneFunction (){} cxx :: expected < int > isItSuccessful () { return someErrorProneFunction (); }","title":"function operator expected&lt; T &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-operator-expected-t_1","text":"template < typename T > operator expected < T > () const conversion operator to an error only expected which can be useful if you would like to return only the success of a function Return : converts an expected which can contain a value and an error to an expected which contains only an error cxx :: expected < int , int > someErrorProneFunction (){} cxx :: expected < int > isItSuccessful () { return someErrorProneFunction (); }","title":"function operator expected&lt; T &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-or_else","text":"const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : const reference to the expected itself someExpected . or_else ([]( float & result ){ std :: cout << \"error occured : \" << error << std :: endl ; })","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-or_else_1","text":"expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) > & callable ) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable Parameters : callable callable which will be called if the expected contains an error Return : reference to the expected itself someExpected . or_else ([]( float & error ){ std :: cout << \"error occured : \" << error << std :: endl ; })","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then","text":"const expected & and_then ( const cxx :: function_ref < void ( ValueType & ) > & callable ) const if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : const reference to the expected someExpected . and_then ([]( int & result ){ std :: cout << \"we have a result : \" << result << std :: endl ; })","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then_1","text":"expected & and_then ( const cxx :: function_ref < void ( ValueType & ) > & callable ) if the expected does contain a success value the given callable is called and a reference to the result is given as an argument to the callable Parameters : callable callable which will be called if the expected contains a success value Return : reference to the expected someExpected . and_then ([]( int & result ){ std :: cout << \"we have a result : \" << result << std :: endl ; })","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then_2","text":"template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > const expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) > & callable ) const if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable Parameters : callable the callable to be called with the contents of the optional Return : reference to the expected anExpectedOptional . and_then ([]( int & value ){ std :: cout << \"the optional contains the value: \" << result << std :: endl ; })","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-and_then_3","text":"template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) > & callable ) if the expected contains a success value and its type is a non-empty optional, retrieve the value from the optional and provide it as the argument to the provided callable Parameters : callable the callable to be called with the contents of the optional Return : reference to the expected anExpectedOptional . and_then ([]( int & value ){ std :: cout << \"the optional contains the value: \" << result << std :: endl ; })","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-if_empty","text":"template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > const expected & if_empty ( const cxx :: function_ref < void () > & callable ) const if the expected contains a success value and its type is an empty optional, calls the provided callable Parameters : callable the callable to be called if the contained optional is empty Return : reference to the expected anExpectedOptional . and_then ([]( SomeType & value ){ std :: cout << \"we got something in the optional: \" << value << std :: endl ; }) . if_empty ([](){ std :: cout << \"the optional was empty, but do something anyway!\" << result << std :: endl ; })","title":"function if_empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-if_empty_1","text":"template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > expected & if_empty ( const cxx :: function_ref < void () > & callable ) if the expected contains a success value and its type is an empty optional, calls the provided callable Parameters : callable the callable to be called if the contained optional is empty Return : reference to the expected anExpectedOptional . and_then ([]( SomeType & value ){ std :: cout << \"we got something in the optional: \" << value << std :: endl ; }) . if_empty ([](){ std :: cout << \"the optional was empty, but do something anyway!\" << result << std :: endl ; })","title":"function if_empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-to_optional","text":"optional < ValueType > to_optional () const","title":"function to_optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-create_value","text":"template < typename ... Targs > static expected create_value ( Targs && ... args ) creates an expected which is signaling success and perfectly forwards the args to the constructor of ValueType Parameters : args... arguments which will be forwarded to the ValueType constructor Return : expected signalling success","title":"function create_value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01ValueType_00_01ErrorType_01_4/#function-create_error","text":"template < typename ... Targs > static expected create_error ( Targs && ... args ) creates an expected which is signaling an error and perfectly forwards the args to the constructor of ErrorType Parameters : args... arguments which will be forwarded to the ErrorType constructor Return : expected signalling error Updated on 18 December 2023 at 13:11:42 CET","title":"function create_error"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/","text":"iox::cxx::expected< void, ErrorType > \ud83d\udd17 More... Inherits from iox::cxx::expected< ErrorType > Additional inherited members \ud83d\udd17 Public Functions inherited from iox::cxx::expected< ErrorType > Name expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value expected (const expected & ) =default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected expected (expected && rhs) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected ~expected () =default calls the destructor of the success value or error value - depending on what is stored in the expected expected & operator= (const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected expected & operator= ( expected && rhs) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected expected (const success < void > & successValue) constructs an expected which is signaling success expected (const error < ErrorType > & errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue expected ( error < ErrorType > && errorValue) constructs an expected which is signaling an error and stores the error value provided by value operator bool () const returns true if the expected contains an error otherwise false bool has_error () const returns true if the expected contains an error otherwise false ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior const expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable const expected & and_then (const cxx::function_ref < void()> & callable) const if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected & and_then (const cxx::function_ref < void()> & callable) if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected create_value () creates an expected which is signaling success template <typename... Targs> expected create_error (Targs &&... args) creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType Detailed Description \ud83d\udd17 template < typename ErrorType > class iox :: cxx :: expected < void , ErrorType > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::expected< void, ErrorType >"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/#ioxcxxexpected-void-errortype","text":"More... Inherits from iox::cxx::expected< ErrorType >","title":"iox::cxx::expected&lt; void, ErrorType &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/#additional-inherited-members","text":"Public Functions inherited from iox::cxx::expected< ErrorType > Name expected () default ctor is deleted since you have to clearly state if the expected contains a success value or an error value expected (const expected & ) =default the copy constructor calls the copy constructor of the contained success value or the error value - depending on what is stored in the expected expected (expected && rhs) the move constructor calls the move constructor of the contained success value or the error value - depending on what is stored in the expected ~expected () =default calls the destructor of the success value or error value - depending on what is stored in the expected expected & operator= (const expected & ) calls the copy assignment operator of the contained success value or the error value - depending on what is stored in the expected expected & operator= ( expected && rhs) calls the move assignment operator of the contained success value or the error value - depending on what is stored in the expected expected (const success < void > & successValue) constructs an expected which is signaling success expected (const error < ErrorType > & errorValue) constructs an expected which is signaling an error and stores the error value provided by errorValue expected ( error < ErrorType > && errorValue) constructs an expected which is signaling an error and stores the error value provided by value operator bool () const returns true if the expected contains an error otherwise false bool has_error () const returns true if the expected contains an error otherwise false ErrorType & get_error () returns a reference to the contained error value, if the expected does not contain an error this is undefined behavior const ErrorType & get_error () const returns a const reference to the contained error value, if the expected does not contain an error this is undefined behavior ErrorType && get_error () returns a rvalue reference to the contained error value, if the expected does not contain an error this is undefined behavior const expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) const if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable expected & or_else (const cxx::function_ref < void(ErrorType &)> & callable) if the expected does contain an error the given callable is called and a reference to the ErrorType is given as an argument to the callable const expected & and_then (const cxx::function_ref < void()> & callable) const if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected & and_then (const cxx::function_ref < void()> & callable) if the expected does contain a success value the given callable is called and a reference to the expected is given as an argument to the callable expected create_value () creates an expected which is signaling success template <typename... Targs> expected create_error (Targs &&... args) creates an expected which is signaling an error and perfectly forwards the args to the constructor of lErrorType","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1expected_3_01void_00_01ErrorType_01_4/#detailed-description","text":"template < typename ErrorType > class iox :: cxx :: expected < void , ErrorType > ; Updated on 18 December 2023 at 13:11:42 CET","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/","text":"iox::cxx::forward_list \ud83d\udd17 C++11 compatible uni-directional forward list implementation. More... #include <iceoryx_hoofs/cxx/forward_list.hpp> Public Types \ud83d\udd17 Name using IteratorBase< false > iterator using IteratorBase< true > const_iterator using T value_type using decltype(Capacity) size_type Public Functions \ud83d\udd17 Name forward_list () constructor for an empty list (of T-types elements) ~forward_list () destructs the list and also calls the destructor of all contained elements forward_list (const forward_list & rhs) copy constructor list including elements forward_list ( forward_list && rhs) move constructor list including elements forward_list & operator= (const forward_list & rhs) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) forward_list & operator= ( forward_list && rhs) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) iterator before_begin () retrieve an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Terminated when content is attemted to read (operator*, operator->) const_iterator before_begin () const retrieve a const_iterator before first element only allowed for usage in erase_after, insert_after, emplace_after const_iterator cbefore_begin () const const_iterator an interator before first element only allowed for usage in erase_after, insert_after, emplace_after iterator begin () default list operation to retrieve an interator to first list element const_iterator begin () const default list operation to retrieve an const_iterator to first list element const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) bool empty () const list meta information on filling bool full () const list meta information on filling size_type size () const list meta information on filling size_type capacity () const list meta information, maximum number of elements the list can contain size_type max_size () const list meta information, maximum number of elements the list can contain T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. bool push_front (const T & data) add element to the beginning of the list bool push_front (T && data) add element to the beginning of the list via move bool pop_front () remove the first element from the begining of the list element destructor will be invoked void clear () remove all elements from the list, list will be empty element destructors will be invoked iterator erase_after (const_iterator beforeToBeErasedIter) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element size_type remove (const T & data) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. template <typename UnaryPredicate > size_type remove_if (UnaryPredicate pred) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. template <typename... ConstructorArgs> T & emplace_front (ConstructorArgs &&... args) construct element inplace at begining of list template <typename... ConstructorArgs> iterator emplace_after (const_iterator afterToBeEmplacedIter, ConstructorArgs &&... args) construct element inplace after the pointed-to element iterator insert_after (const_iterator citer, const T & data) insert element after iterator position iterator insert_after (const_iterator citer, T && data) add element after the pointed-to element via move Detailed Description \ud83d\udd17 template < typename T , uint64_t Capacity > class iox :: cxx :: forward_list ; C++11 compatible uni-directional forward list implementation. Adjustments in the API were done to not use exceptions and serve the requirement of a data structure movable over shared memory. attempt to add elements to a full list will be ignored. Capacity must at least be 1, (unintended) negative initialization is rejected with compile assertion limitation: concurrency concerns have to be handled by client side. overview of cxx::forward_list deviations to std::forward_list(C++11) list declaration with mandatory max list size argument member functions don't throw exception but will trigger different failure handling push_front returns a bool (instead of void) informing on successful insertion (true) pop_front returns a bool (instead of void) informing on successful removal (true), otherwise empty (false) emplace_front returns a reference to the inserted element (instead of void), this is C++17-conform remove / remove_if returns a the number of removed elements (instead of void), this is C++20-conform (yet) missing implementations \ud83d\udd17 allocator, difference_type based operations assign, resize, swap, merge, splice_after, reverse, unique, sort list operator==, operator!=, operator<, operator<=, operator>, operator>= Ttype user data to be managed within list Capacitynumber of maximum list elements a client can push to the list. minimum value is '1' Public Types Documentation \ud83d\udd17 using iterator \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: iterator = IteratorBase < false > ; using const_iterator \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: const_iterator = IteratorBase < true > ; using value_type \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: value_type = T ; using size_type \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: size_type = decltype ( Capacity ); Public Functions Documentation \ud83d\udd17 function forward_list \ud83d\udd17 forward_list () constructor for an empty list (of T-types elements) function ~forward_list \ud83d\udd17 ~ forward_list () destructs the list and also calls the destructor of all contained elements function forward_list \ud83d\udd17 forward_list ( const forward_list & rhs ) copy constructor list including elements Parameters : rhs is the list to copy from (same capacity) function forward_list \ud83d\udd17 forward_list ( forward_list && rhs ) move constructor list including elements Parameters : rhs is the list to move-construct elements from (same capacity) function operator= \ud83d\udd17 forward_list & operator = ( const forward_list & rhs ) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to copy from (same capacity) Return : reference to created list function operator= \ud83d\udd17 forward_list & operator = ( forward_list && rhs ) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to move from ('source', same capacity) Return : reference to created list function before_begin \ud83d\udd17 iterator before_begin () retrieve an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Terminated when content is attemted to read (operator*, operator->) Return : iterator to fictional element before first data element function before_begin \ud83d\udd17 const_iterator before_begin () const retrieve a const_iterator before first element only allowed for usage in erase_after, insert_after, emplace_after Return : iterator to fictional element before first data element function cbefore_begin \ud83d\udd17 const_iterator cbefore_begin () const const_iterator an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Return : iterator to fictional element before first data element function begin \ud83d\udd17 iterator begin () default list operation to retrieve an interator to first list element Return : iterator to first list element, returns iterator to end() when list is empty function begin \ud83d\udd17 const_iterator begin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty function cbegin \ud83d\udd17 const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty function end \ud83d\udd17 iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data. function end \ud83d\udd17 const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data. function cend \ud83d\udd17 const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data. function empty \ud83d\udd17 bool empty () const list meta information on filling Return : no elements in list (true), otherwise (false) function full \ud83d\udd17 bool full () const list meta information on filling Return : whether list is full (filled with 'capacity' / 'max_size' elements) (true), otherwise (false) function size \ud83d\udd17 size_type size () const list meta information on filling Return : current number of elements in list @min returns min 0 @max returns max capacity function capacity \ud83d\udd17 size_type capacity () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements. function max_size \ud83d\udd17 size_type max_size () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements, same as capacity() function front \ud83d\udd17 T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : reference to the first element function front \ud83d\udd17 const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : const reference to the first element function push_front \ud83d\udd17 bool push_front ( const T & data ) add element to the beginning of the list Parameters : data reference to data element Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false) function push_front \ud83d\udd17 bool push_front ( T && data ) add element to the beginning of the list via move Parameters : data universal reference perfectly forwarded to client class Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false) function pop_front \ud83d\udd17 bool pop_front () remove the first element from the begining of the list element destructor will be invoked Return : successful removal (true), otherwise no element could be taken from list (e.g. empty -> false) function clear \ud83d\udd17 void clear () remove all elements from the list, list will be empty element destructors will be invoked function erase_after \ud83d\udd17 iterator erase_after ( const_iterator beforeToBeErasedIter ) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element Parameters : beforeToBeErasedIter iterator linking the element before the to-be-removed element Return : an (non-const_) iterator to the element after the removed element, returns end() element when reached end of list function remove \ud83d\udd17 size_type remove ( const T & data ) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. Parameters : data value to compare to Return : the number of elements removed, return is C++20-conform function remove_if \ud83d\udd17 template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. Parameters : pred unary predicate which returns true if the element should be removed Return : the number of elements removed, return is C++20-conform function emplace_front \ud83d\udd17 template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) construct element inplace at begining of list Parameters : args T-typed construction parameters (initializer list) Return : referene to generated element, return is C++17-conform function emplace_after \ud83d\udd17 template < typename ... ConstructorArgs > iterator emplace_after ( const_iterator afterToBeEmplacedIter , ConstructorArgs && ... args ) construct element inplace after the pointed-to element Parameters : args T-typed construction parameters (initializer list) afterToBeEmplacedIter position in list to (construct)insert after Return : iterator to the newly added element function insert_after \ud83d\udd17 iterator insert_after ( const_iterator citer , const T & data ) insert element after iterator position Parameters : citer iterator with the position to insert after data reference to element to add Return : iterator to the newly added element function insert_after \ud83d\udd17 iterator insert_after ( const_iterator citer , T && data ) add element after the pointed-to element via move Parameters : citer iterator with the position to insert after data universal reference perfectly forwarded to client class Return : iterator to the newly added element Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#ioxcxxforward_list","text":"C++11 compatible uni-directional forward list implementation. More... #include <iceoryx_hoofs/cxx/forward_list.hpp>","title":"iox::cxx::forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-types","text":"Name using IteratorBase< false > iterator using IteratorBase< true > const_iterator using T value_type using decltype(Capacity) size_type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-functions","text":"Name forward_list () constructor for an empty list (of T-types elements) ~forward_list () destructs the list and also calls the destructor of all contained elements forward_list (const forward_list & rhs) copy constructor list including elements forward_list ( forward_list && rhs) move constructor list including elements forward_list & operator= (const forward_list & rhs) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) forward_list & operator= ( forward_list && rhs) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) iterator before_begin () retrieve an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Terminated when content is attemted to read (operator*, operator->) const_iterator before_begin () const retrieve a const_iterator before first element only allowed for usage in erase_after, insert_after, emplace_after const_iterator cbefore_begin () const const_iterator an interator before first element only allowed for usage in erase_after, insert_after, emplace_after iterator begin () default list operation to retrieve an interator to first list element const_iterator begin () const default list operation to retrieve an const_iterator to first list element const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) bool empty () const list meta information on filling bool full () const list meta information on filling size_type size () const list meta information on filling size_type capacity () const list meta information, maximum number of elements the list can contain size_type max_size () const list meta information, maximum number of elements the list can contain T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. bool push_front (const T & data) add element to the beginning of the list bool push_front (T && data) add element to the beginning of the list via move bool pop_front () remove the first element from the begining of the list element destructor will be invoked void clear () remove all elements from the list, list will be empty element destructors will be invoked iterator erase_after (const_iterator beforeToBeErasedIter) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element size_type remove (const T & data) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. template <typename UnaryPredicate > size_type remove_if (UnaryPredicate pred) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. template <typename... ConstructorArgs> T & emplace_front (ConstructorArgs &&... args) construct element inplace at begining of list template <typename... ConstructorArgs> iterator emplace_after (const_iterator afterToBeEmplacedIter, ConstructorArgs &&... args) construct element inplace after the pointed-to element iterator insert_after (const_iterator citer, const T & data) insert element after iterator position iterator insert_after (const_iterator citer, T && data) add element after the pointed-to element via move","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#detailed-description","text":"template < typename T , uint64_t Capacity > class iox :: cxx :: forward_list ; C++11 compatible uni-directional forward list implementation. Adjustments in the API were done to not use exceptions and serve the requirement of a data structure movable over shared memory. attempt to add elements to a full list will be ignored. Capacity must at least be 1, (unintended) negative initialization is rejected with compile assertion limitation: concurrency concerns have to be handled by client side. overview of cxx::forward_list deviations to std::forward_list(C++11) list declaration with mandatory max list size argument member functions don't throw exception but will trigger different failure handling push_front returns a bool (instead of void) informing on successful insertion (true) pop_front returns a bool (instead of void) informing on successful removal (true), otherwise empty (false) emplace_front returns a reference to the inserted element (instead of void), this is C++17-conform remove / remove_if returns a the number of removed elements (instead of void), this is C++20-conform","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#yet-missing-implementations","text":"allocator, difference_type based operations assign, resize, swap, merge, splice_after, reverse, unique, sort list operator==, operator!=, operator<, operator<=, operator>, operator>= Ttype user data to be managed within list Capacitynumber of maximum list elements a client can push to the list. minimum value is '1'","title":"(yet) missing implementations"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-iterator","text":"using iox :: cxx :: forward_list < T , Capacity >:: iterator = IteratorBase < false > ;","title":"using iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-const_iterator","text":"using iox :: cxx :: forward_list < T , Capacity >:: const_iterator = IteratorBase < true > ;","title":"using const_iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-value_type","text":"using iox :: cxx :: forward_list < T , Capacity >:: value_type = T ;","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#using-size_type","text":"using iox :: cxx :: forward_list < T , Capacity >:: size_type = decltype ( Capacity );","title":"using size_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list","text":"forward_list () constructor for an empty list (of T-types elements)","title":"function forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list_1","text":"~ forward_list () destructs the list and also calls the destructor of all contained elements","title":"function ~forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list_2","text":"forward_list ( const forward_list & rhs ) copy constructor list including elements Parameters : rhs is the list to copy from (same capacity)","title":"function forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-forward_list_3","text":"forward_list ( forward_list && rhs ) move constructor list including elements Parameters : rhs is the list to move-construct elements from (same capacity)","title":"function forward_list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-operator","text":"forward_list & operator = ( const forward_list & rhs ) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to copy from (same capacity) Return : reference to created list","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-operator_1","text":"forward_list & operator = ( forward_list && rhs ) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to move from ('source', same capacity) Return : reference to created list","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-before_begin","text":"iterator before_begin () retrieve an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Terminated when content is attemted to read (operator*, operator->) Return : iterator to fictional element before first data element","title":"function before_begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-before_begin_1","text":"const_iterator before_begin () const retrieve a const_iterator before first element only allowed for usage in erase_after, insert_after, emplace_after Return : iterator to fictional element before first data element","title":"function before_begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-cbefore_begin","text":"const_iterator cbefore_begin () const const_iterator an interator before first element only allowed for usage in erase_after, insert_after, emplace_after Return : iterator to fictional element before first data element","title":"function cbefore_begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-begin","text":"iterator begin () default list operation to retrieve an interator to first list element Return : iterator to first list element, returns iterator to end() when list is empty","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-begin_1","text":"const_iterator begin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-cbegin","text":"const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty","title":"function cbegin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-end","text":"iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data.","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-end_1","text":"const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data.","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-cend","text":"const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data.","title":"function cend"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-empty","text":"bool empty () const list meta information on filling Return : no elements in list (true), otherwise (false)","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-full","text":"bool full () const list meta information on filling Return : whether list is full (filled with 'capacity' / 'max_size' elements) (true), otherwise (false)","title":"function full"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-size","text":"size_type size () const list meta information on filling Return : current number of elements in list @min returns min 0 @max returns max capacity","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-capacity","text":"size_type capacity () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements.","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-max_size","text":"size_type max_size () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements, same as capacity()","title":"function max_size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-front","text":"T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : reference to the first element","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-front_1","text":"const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : const reference to the first element","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-push_front","text":"bool push_front ( const T & data ) add element to the beginning of the list Parameters : data reference to data element Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false)","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-push_front_1","text":"bool push_front ( T && data ) add element to the beginning of the list via move Parameters : data universal reference perfectly forwarded to client class Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false)","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-pop_front","text":"bool pop_front () remove the first element from the begining of the list element destructor will be invoked Return : successful removal (true), otherwise no element could be taken from list (e.g. empty -> false)","title":"function pop_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-clear","text":"void clear () remove all elements from the list, list will be empty element destructors will be invoked","title":"function clear"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-erase_after","text":"iterator erase_after ( const_iterator beforeToBeErasedIter ) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element Parameters : beforeToBeErasedIter iterator linking the element before the to-be-removed element Return : an (non-const_) iterator to the element after the removed element, returns end() element when reached end of list","title":"function erase_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-remove","text":"size_type remove ( const T & data ) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. Parameters : data value to compare to Return : the number of elements removed, return is C++20-conform","title":"function remove"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-remove_if","text":"template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. Parameters : pred unary predicate which returns true if the element should be removed Return : the number of elements removed, return is C++20-conform","title":"function remove_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-emplace_front","text":"template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) construct element inplace at begining of list Parameters : args T-typed construction parameters (initializer list) Return : referene to generated element, return is C++17-conform","title":"function emplace_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-emplace_after","text":"template < typename ... ConstructorArgs > iterator emplace_after ( const_iterator afterToBeEmplacedIter , ConstructorArgs && ... args ) construct element inplace after the pointed-to element Parameters : args T-typed construction parameters (initializer list) afterToBeEmplacedIter position in list to (construct)insert after Return : iterator to the newly added element","title":"function emplace_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-insert_after","text":"iterator insert_after ( const_iterator citer , const T & data ) insert element after iterator position Parameters : citer iterator with the position to insert after data reference to element to add Return : iterator to the newly added element","title":"function insert_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list/#function-insert_after_1","text":"iterator insert_after ( const_iterator citer , T && data ) add element after the pointed-to element via move Parameters : citer iterator with the position to insert after data universal reference perfectly forwarded to client class Return : iterator to the newly added element Updated on 18 December 2023 at 13:11:42 CET","title":"function insert_after"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/","text":"iox::cxx::forward_list::IteratorBase \ud83d\udd17 nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() More... Public Types \ud83d\udd17 Name using std::forward_iterator_tag iterator_category using typename std::conditional< IsConstIterator, const T, T >::type value_type using void difference_type using typename std::conditional< IsConstIterator, const T *, T * >::type pointer using typename std::conditional< IsConstIterator, const T &, T & >::type reference Public Functions \ud83d\udd17 Name IteratorBase (const IteratorBase< false > & iter) construct a const_iterator from an iterator IteratorBase & operator= (const IteratorBase< false > & rhs) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented IteratorBase & operator++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end template <bool IsConstIteratorOther> bool operator== (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked template <bool IsConstIteratorOther> bool operator!= (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked reference operator* () const dereferencing element content via iterator-position element pointer operator-> () const dereferencing element content via iterator-position element Friends \ud83d\udd17 Name class IteratorBase< true > class forward_list< T, Capacity > Detailed Description \ud83d\udd17 template < bool IsConstIterator = true > class iox :: cxx :: forward_list :: IteratorBase ; nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() Public Types Documentation \ud83d\udd17 using iterator_category \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: iterator_category = std :: forward_iterator_tag ; using value_type \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ; using difference_type \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: difference_type = void ; using pointer \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ; using reference \ud83d\udd17 using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ; Public Functions Documentation \ud83d\udd17 function IteratorBase \ud83d\udd17 IteratorBase ( const IteratorBase < false > & iter ) construct a const_iterator from an iterator Parameters : iter is the iterator which will deliver list and index info for the const_iterator function operator= \ud83d\udd17 IteratorBase & operator = ( const IteratorBase < false > & rhs ) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented Parameters : rhs is the iterator which will deliver list and index info for the const_iterator Return : reference to this iterator object function operator++ \ud83d\udd17 IteratorBase & operator ++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end Return : reference to this iterator object function operator== \ud83d\udd17 template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false) function operator!= \ud83d\udd17 template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false) function operator* \ud83d\udd17 reference operator * () const dereferencing element content via iterator-position element Return : reference to list element data function operator-> \ud83d\udd17 pointer operator -> () const dereferencing element content via iterator-position element Return : pointer to const list data element Friends \ud83d\udd17 friend IteratorBase< true > \ud83d\udd17 friend class IteratorBase < true > ; friend forward_list< T, Capacity > \ud83d\udd17 friend class forward_list < T , Capacity > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::forward_list::IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#ioxcxxforward_listiteratorbase","text":"nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() More...","title":"iox::cxx::forward_list::IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-types","text":"Name using std::forward_iterator_tag iterator_category using typename std::conditional< IsConstIterator, const T, T >::type value_type using void difference_type using typename std::conditional< IsConstIterator, const T *, T * >::type pointer using typename std::conditional< IsConstIterator, const T &, T & >::type reference","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-functions","text":"Name IteratorBase (const IteratorBase< false > & iter) construct a const_iterator from an iterator IteratorBase & operator= (const IteratorBase< false > & rhs) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented IteratorBase & operator++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end template <bool IsConstIteratorOther> bool operator== (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked template <bool IsConstIteratorOther> bool operator!= (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked reference operator* () const dereferencing element content via iterator-position element pointer operator-> () const dereferencing element content via iterator-position element","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friends","text":"Name class IteratorBase< true > class forward_list< T, Capacity >","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#detailed-description","text":"template < bool IsConstIterator = true > class iox :: cxx :: forward_list :: IteratorBase ; nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate()","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-iterator_category","text":"using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: iterator_category = std :: forward_iterator_tag ;","title":"using iterator_category"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-value_type","text":"using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ;","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-difference_type","text":"using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: difference_type = void ;","title":"using difference_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-pointer","text":"using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ;","title":"using pointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#using-reference","text":"using iox :: cxx :: forward_list < T , Capacity >:: IteratorBase < IsConstIterator >:: reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ;","title":"using reference"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-iteratorbase","text":"IteratorBase ( const IteratorBase < false > & iter ) construct a const_iterator from an iterator Parameters : iter is the iterator which will deliver list and index info for the const_iterator","title":"function IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator","text":"IteratorBase & operator = ( const IteratorBase < false > & rhs ) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented Parameters : rhs is the iterator which will deliver list and index info for the const_iterator Return : reference to this iterator object","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_1","text":"IteratorBase & operator ++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end Return : reference to this iterator object","title":"function operator++"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_2","text":"template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false)","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_3","text":"template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements like before_begin() and end() only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false)","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator_4","text":"reference operator * () const dereferencing element content via iterator-position element Return : reference to list element data","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#function-operator-","text":"pointer operator -> () const dereferencing element content via iterator-position element Return : pointer to const list data element","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friend-iteratorbase-true","text":"friend class IteratorBase < true > ;","title":"friend IteratorBase&lt; true &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1forward__list_1_1IteratorBase/#friend-forward_list-t-capacity","text":"friend class forward_list < T , Capacity > ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend forward_list&lt; T, Capacity &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref/","text":"iox::cxx::function_ref \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename SignatureType > class iox :: cxx :: function_ref ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref/#ioxcxxfunction_ref","text":"More...","title":"iox::cxx::function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref/#detailed-description","text":"template < typename SignatureType > class iox :: cxx :: function_ref ; Updated on 18 December 2023 at 13:11:42 CET","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/","text":"iox::cxx::function_ref< ReturnType(ArgTypes...)> \ud83d\udd17 cxx::function_ref is a non-owning reference to a callable. More... #include <iceoryx_hoofs/cxx/function_ref.hpp> Public Functions \ud83d\udd17 Name function_ref () Creates an empty function_ref in an invalid state. ~function_ref () =default function_ref (const function_ref & ) =default function_ref & operator= (const function_ref & ) =default template <typename CallableType ,typename =std::enable_if_t<!is_function_pointer ::value && !has_same_decayed_type ::value && is_invocable ::value>> function_ref (CallableType && callable) Creates a function_ref with a callable whose lifetime has to be longer than function_ref . function_ref (ReturnType(*)(ArgTypes...) function) Creates a function_ref from a function pointer. function_ref ( function_ref && rhs) function_ref & operator= ( function_ref && rhs) ReturnType operator() (ArgTypes... args) const Calls the provided callable. operator bool () const Checks whether a valid target is contained. void swap ( function_ref & rhs) Swaps the contents of two function_ref 's. Detailed Description \ud83d\udd17 template < class ReturnType , class ... ArgTypes > class iox :: cxx :: function_ref < ReturnType ( ArgTypes ...) > ; cxx::function_ref is a non-owning reference to a callable. Attention : Invoking an empty function_ref can lead to a program termination! It has these features: * No heap usage * No exceptions * Stateful lambda support * C++11/14 support // Usage as function parameter void fuu ( cxx :: function_ref < void () > callback ) { callback (); } // Call the lambda fuu ([]{ doSomething (); }); // Usage with l-values // Pitfall: Ensure that lifetime of callable suits the point in time of calling callback() auto callable = [ & ]{ doSomething (); }; cxx :: function_ref < void () > callback ( callable ); // Call the callback callback (); Public Functions Documentation \ud83d\udd17 function function_ref \ud83d\udd17 function_ref () Creates an empty function_ref in an invalid state. Note : Handle with care, program will terminate when calling an invalid function_ref function ~function_ref \ud83d\udd17 ~ function_ref () = default function function_ref \ud83d\udd17 function_ref ( const function_ref & ) = default function operator= \ud83d\udd17 function_ref & operator = ( const function_ref & ) = default function function_ref \ud83d\udd17 template < typename CallableType , typename = std :: enable_if_t <! is_function_pointer < CallableType >:: value && ! has_same_decayed_type < CallableType , function_ref >:: value && is_invocable < CallableType , ArgTypes ... >:: value >> function_ref ( CallableType && callable ) Creates a function_ref with a callable whose lifetime has to be longer than function_ref . Parameters : callable that is not a function_ref function function_ref \ud83d\udd17 function_ref ( ReturnType ( * )( ArgTypes ...) function ) Creates a function_ref from a function pointer. Parameters : function function pointer to function we want to reference Note : This overload is needed, as the general implementation will not work properly for function pointers. This ctor is not needed anymore once we can use user-defined-deduction guides (C++17) function function_ref \ud83d\udd17 function_ref ( function_ref && rhs ) function operator= \ud83d\udd17 function_ref & operator = ( function_ref && rhs ) function operator() \ud83d\udd17 ReturnType operator ()( ArgTypes ... args ) const Calls the provided callable. Parameters : Arguments are forwarded to the underlying function pointer Return : Returns the data type of the underlying function pointer Attention : Invoking an empty function_ref can lead to a program termination! function operator bool \ud83d\udd17 explicit operator bool () const Checks whether a valid target is contained. Return : True if valid target is contained, otherwise false function swap \ud83d\udd17 void swap ( function_ref & rhs ) Swaps the contents of two function_ref 's. Parameters : Reference to another function_ref Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::function_ref< ReturnType(ArgTypes...)>"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#ioxcxxfunction_ref-returntypeargtypes","text":"cxx::function_ref is a non-owning reference to a callable. More... #include <iceoryx_hoofs/cxx/function_ref.hpp>","title":"iox::cxx::function_ref&lt; ReturnType(ArgTypes...)&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#public-functions","text":"Name function_ref () Creates an empty function_ref in an invalid state. ~function_ref () =default function_ref (const function_ref & ) =default function_ref & operator= (const function_ref & ) =default template <typename CallableType ,typename =std::enable_if_t<!is_function_pointer ::value && !has_same_decayed_type ::value && is_invocable ::value>> function_ref (CallableType && callable) Creates a function_ref with a callable whose lifetime has to be longer than function_ref . function_ref (ReturnType(*)(ArgTypes...) function) Creates a function_ref from a function pointer. function_ref ( function_ref && rhs) function_ref & operator= ( function_ref && rhs) ReturnType operator() (ArgTypes... args) const Calls the provided callable. operator bool () const Checks whether a valid target is contained. void swap ( function_ref & rhs) Swaps the contents of two function_ref 's.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#detailed-description","text":"template < class ReturnType , class ... ArgTypes > class iox :: cxx :: function_ref < ReturnType ( ArgTypes ...) > ; cxx::function_ref is a non-owning reference to a callable. Attention : Invoking an empty function_ref can lead to a program termination! It has these features: * No heap usage * No exceptions * Stateful lambda support * C++11/14 support // Usage as function parameter void fuu ( cxx :: function_ref < void () > callback ) { callback (); } // Call the lambda fuu ([]{ doSomething (); }); // Usage with l-values // Pitfall: Ensure that lifetime of callable suits the point in time of calling callback() auto callable = [ & ]{ doSomething (); }; cxx :: function_ref < void () > callback ( callable ); // Call the callback callback ();","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref","text":"function_ref () Creates an empty function_ref in an invalid state. Note : Handle with care, program will terminate when calling an invalid function_ref","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_1","text":"~ function_ref () = default","title":"function ~function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_2","text":"function_ref ( const function_ref & ) = default","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator","text":"function_ref & operator = ( const function_ref & ) = default","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_3","text":"template < typename CallableType , typename = std :: enable_if_t <! is_function_pointer < CallableType >:: value && ! has_same_decayed_type < CallableType , function_ref >:: value && is_invocable < CallableType , ArgTypes ... >:: value >> function_ref ( CallableType && callable ) Creates a function_ref with a callable whose lifetime has to be longer than function_ref . Parameters : callable that is not a function_ref","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_4","text":"function_ref ( ReturnType ( * )( ArgTypes ...) function ) Creates a function_ref from a function pointer. Parameters : function function pointer to function we want to reference Note : This overload is needed, as the general implementation will not work properly for function pointers. This ctor is not needed anymore once we can use user-defined-deduction guides (C++17)","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-function_ref_5","text":"function_ref ( function_ref && rhs )","title":"function function_ref"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator_1","text":"function_ref & operator = ( function_ref && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator_2","text":"ReturnType operator ()( ArgTypes ... args ) const Calls the provided callable. Parameters : Arguments are forwarded to the underlying function pointer Return : Returns the data type of the underlying function pointer Attention : Invoking an empty function_ref can lead to a program termination!","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-operator-bool","text":"explicit operator bool () const Checks whether a valid target is contained. Return : True if valid target is contained, otherwise false","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1function__ref_3_01ReturnType_07ArgTypes_8_8_8_08_4/#function-swap","text":"void swap ( function_ref & rhs ) Swaps the contents of two function_ref 's. Parameters : Reference to another function_ref Updated on 18 December 2023 at 13:11:42 CET","title":"function swap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/","text":"iox::cxx::list \ud83d\udd17 C++11 compatible bi-directional list implementation. More... #include <iceoryx_hoofs/cxx/list.hpp> Public Types \ud83d\udd17 Name using IteratorBase< false > iterator using IteratorBase< true > const_iterator using T value_type using decltype(Capacity) size_type Public Functions \ud83d\udd17 Name list () constructor for an empty list (of T-types elements) ~list () destructs the list and also calls the destructor of all contained elements list (const list & rhs) copy constructor list including elements list ( list && rhs) move constructor list including elements list & operator= (const list & rhs) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) list & operator= ( list && rhs) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) iterator begin () default list operation to retrieve an interator to first list element const_iterator begin () const default list operation to retrieve an const_iterator to first list element const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) bool empty () const list meta information on filling bool full () const list meta information on filling size_type size () const list meta information on filling size_type capacity () const list meta information, maximum number of elements the list can contain size_type max_size () const list meta information, maximum number of elements the list can contain T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. T & back () Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. const T & back () const Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. bool push_front (const T & data) add element to the beginning of the list bool push_front (T && data) add element to the beginning of the list via move bool push_back (const T & data) add element to the end of the list bool push_back (T && data) add element to the end of the list via move bool pop_front () remove the first element from the begining of the list element destructor will be invoked bool pop_back () remove the last element from the end of the list element destructor will be invoked void clear () remove all elements from the list, list will be empty element destructors will be invoked iterator erase (const_iterator iter) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element size_type remove (const T & data) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. template <typename UnaryPredicate > size_type remove_if (UnaryPredicate pred) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. template <typename... ConstructorArgs> T & emplace_front (ConstructorArgs &&... args) construct element inplace at begining of list template <typename... ConstructorArgs> T & emplace_back (ConstructorArgs &&... args) construct element inplace at end of list template <typename... ConstructorArgs> iterator emplace (const_iterator iter, ConstructorArgs &&... args) construct element inplace at iterator position iterator insert (const_iterator citer, const T & data) insert element before iterator position iterator insert (const_iterator citer, T && data) add element before the pointed-to element via move Detailed Description \ud83d\udd17 template < typename T , uint64_t Capacity > class iox :: cxx :: list ; C++11 compatible bi-directional list implementation. Adjustments in the API were done to not use exceptions and serve the requirement of a data structure movable over shared memory. attempt to add elements to a full list will be ignored. Capacity must at least be 1, (unintended) negative initialization is rejected with compile assertion limitation: concurrency concerns have to be handled by client side. overview of cxx::forward_list deviations to std::forward_list(C++11) list declaration with mandatory max list size argument member functions don't throw exception but will trigger different failure handling push_front/~_back returns a bool (instead of void) informing on successful insertion (true) pop_front/~_back returns a bool (instead of void) informing on successful removal (true), otherwise empty (false) emplace_front/~_back returns a reference to the inserted element (instead of void), this is C++17-conform remove / remove_if returns a the number of removed elements (instead of void), this is C++20-conform (yet) missing implementations \ud83d\udd17 allocator, difference_type / range operations assign, resize, swap, merge, splice_after, reverse, rbegin/crbegin, rend/crend, unique, sort list operator==, operator!=, operator<, operator<=, operator>, operator>= Ttype user data to be managed within list Capacitynumber of maximum list elements a client can push to the list. minimum value is '1' Public Types Documentation \ud83d\udd17 using iterator \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: iterator = IteratorBase < false > ; using const_iterator \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: const_iterator = IteratorBase < true > ; using value_type \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: value_type = T ; using size_type \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: size_type = decltype ( Capacity ); Public Functions Documentation \ud83d\udd17 function list \ud83d\udd17 list () constructor for an empty list (of T-types elements) function ~list \ud83d\udd17 ~ list () destructs the list and also calls the destructor of all contained elements function list \ud83d\udd17 list ( const list & rhs ) copy constructor list including elements Parameters : rhs is the list to copy from (same capacity) function list \ud83d\udd17 list ( list && rhs ) move constructor list including elements Parameters : rhs is the list to move-construct elements from (same capacity) function operator= \ud83d\udd17 list & operator = ( const list & rhs ) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to copy from (same capacity) Return : reference to created list function operator= \ud83d\udd17 list & operator = ( list && rhs ) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to move from ('source', same capacity) Return : reference to created list function begin \ud83d\udd17 iterator begin () default list operation to retrieve an interator to first list element Return : iterator to first list element, returns iterator to end() when list is empty function begin \ud83d\udd17 const_iterator begin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty function cbegin \ud83d\udd17 const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty function end \ud83d\udd17 iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data. function end \ud83d\udd17 const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data. function cend \ud83d\udd17 const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data. function empty \ud83d\udd17 bool empty () const list meta information on filling Return : no elements in list (true), otherwise (false) function full \ud83d\udd17 bool full () const list meta information on filling Return : whether list is full (filled with 'capacity' / 'max_size' elements) (true), otherwise (false) function size \ud83d\udd17 size_type size () const list meta information on filling Return : current number of elements in list @min returns min 0 @max returns max capacity function capacity \ud83d\udd17 size_type capacity () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements. function max_size \ud83d\udd17 size_type max_size () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements, same as capacity() function front \ud83d\udd17 T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : reference to the first element function front \ud83d\udd17 const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : const reference to the first element function back \ud83d\udd17 T & back () Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. Return : reference to the last element function back \ud83d\udd17 const T & back () const Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. Return : const reference to the last element function push_front \ud83d\udd17 bool push_front ( const T & data ) add element to the beginning of the list Parameters : data reference to data element Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false) function push_front \ud83d\udd17 bool push_front ( T && data ) add element to the beginning of the list via move Parameters : data universal reference perfectly forwarded to client class Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false) function push_back \ud83d\udd17 bool push_back ( const T & data ) add element to the end of the list Parameters : data reference to data element Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false) function push_back \ud83d\udd17 bool push_back ( T && data ) add element to the end of the list via move Parameters : data universal reference perfectly forwarded to client class Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false) function pop_front \ud83d\udd17 bool pop_front () remove the first element from the begining of the list element destructor will be invoked Return : successful removal (true), otherwise no element could be taken from list (e.g. empty -> false) function pop_back \ud83d\udd17 bool pop_back () remove the last element from the end of the list element destructor will be invoked Return : successful removal (true), otherwise no element could be taken from list (e.g. empty -> false) function clear \ud83d\udd17 void clear () remove all elements from the list, list will be empty element destructors will be invoked function erase \ud83d\udd17 iterator erase ( const_iterator iter ) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element Parameters : iter iterator linking the to-be-removed element Return : an (non-const_) iterator to the element after the removed element, returns end() element when reached end of list function remove \ud83d\udd17 size_type remove ( const T & data ) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. Parameters : data value to compare to Return : the number of elements removed, return is C++20-conform function remove_if \ud83d\udd17 template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. Parameters : pred unary predicate which returns true if the element should be removed Return : the number of elements removed, return is C++20-conform function emplace_front \ud83d\udd17 template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) construct element inplace at begining of list Parameters : args T-typed construction parameters (initializer list) Return : referene to generated element, return is C++17-conform function emplace_back \ud83d\udd17 template < typename ... ConstructorArgs > T & emplace_back ( ConstructorArgs && ... args ) construct element inplace at end of list Parameters : args T-typed construction parameters (initializer list) Return : referene to generated element, return is C++17-conform function emplace \ud83d\udd17 template < typename ... ConstructorArgs > iterator emplace ( const_iterator iter , ConstructorArgs && ... args ) construct element inplace at iterator position Parameters : args T-typed construction parameters (initializer list) iter position in list to (construct)insert after Return : iterator to the newly added element function insert \ud83d\udd17 iterator insert ( const_iterator citer , const T & data ) insert element before iterator position Parameters : citer iterator with the position to insert after data reference to element to add Return : iterator to the newly added element function insert \ud83d\udd17 iterator insert ( const_iterator citer , T && data ) add element before the pointed-to element via move Parameters : citer iterator with the position to insert after data universal reference perfectly forwarded to client class Return : iterator to the newly added element Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#ioxcxxlist","text":"C++11 compatible bi-directional list implementation. More... #include <iceoryx_hoofs/cxx/list.hpp>","title":"iox::cxx::list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-types","text":"Name using IteratorBase< false > iterator using IteratorBase< true > const_iterator using T value_type using decltype(Capacity) size_type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-functions","text":"Name list () constructor for an empty list (of T-types elements) ~list () destructs the list and also calls the destructor of all contained elements list (const list & rhs) copy constructor list including elements list ( list && rhs) move constructor list including elements list & operator= (const list & rhs) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) list & operator= ( list && rhs) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) iterator begin () default list operation to retrieve an interator to first list element const_iterator begin () const default list operation to retrieve an const_iterator to first list element const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) bool empty () const list meta information on filling bool full () const list meta information on filling size_type size () const list meta information on filling size_type capacity () const list meta information, maximum number of elements the list can contain size_type max_size () const list meta information, maximum number of elements the list can contain T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. T & back () Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. const T & back () const Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. bool push_front (const T & data) add element to the beginning of the list bool push_front (T && data) add element to the beginning of the list via move bool push_back (const T & data) add element to the end of the list bool push_back (T && data) add element to the end of the list via move bool pop_front () remove the first element from the begining of the list element destructor will be invoked bool pop_back () remove the last element from the end of the list element destructor will be invoked void clear () remove all elements from the list, list will be empty element destructors will be invoked iterator erase (const_iterator iter) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element size_type remove (const T & data) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. template <typename UnaryPredicate > size_type remove_if (UnaryPredicate pred) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. template <typename... ConstructorArgs> T & emplace_front (ConstructorArgs &&... args) construct element inplace at begining of list template <typename... ConstructorArgs> T & emplace_back (ConstructorArgs &&... args) construct element inplace at end of list template <typename... ConstructorArgs> iterator emplace (const_iterator iter, ConstructorArgs &&... args) construct element inplace at iterator position iterator insert (const_iterator citer, const T & data) insert element before iterator position iterator insert (const_iterator citer, T && data) add element before the pointed-to element via move","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#detailed-description","text":"template < typename T , uint64_t Capacity > class iox :: cxx :: list ; C++11 compatible bi-directional list implementation. Adjustments in the API were done to not use exceptions and serve the requirement of a data structure movable over shared memory. attempt to add elements to a full list will be ignored. Capacity must at least be 1, (unintended) negative initialization is rejected with compile assertion limitation: concurrency concerns have to be handled by client side. overview of cxx::forward_list deviations to std::forward_list(C++11) list declaration with mandatory max list size argument member functions don't throw exception but will trigger different failure handling push_front/~_back returns a bool (instead of void) informing on successful insertion (true) pop_front/~_back returns a bool (instead of void) informing on successful removal (true), otherwise empty (false) emplace_front/~_back returns a reference to the inserted element (instead of void), this is C++17-conform remove / remove_if returns a the number of removed elements (instead of void), this is C++20-conform","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#yet-missing-implementations","text":"allocator, difference_type / range operations assign, resize, swap, merge, splice_after, reverse, rbegin/crbegin, rend/crend, unique, sort list operator==, operator!=, operator<, operator<=, operator>, operator>= Ttype user data to be managed within list Capacitynumber of maximum list elements a client can push to the list. minimum value is '1'","title":"(yet) missing implementations"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-iterator","text":"using iox :: cxx :: list < T , Capacity >:: iterator = IteratorBase < false > ;","title":"using iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-const_iterator","text":"using iox :: cxx :: list < T , Capacity >:: const_iterator = IteratorBase < true > ;","title":"using const_iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-value_type","text":"using iox :: cxx :: list < T , Capacity >:: value_type = T ;","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#using-size_type","text":"using iox :: cxx :: list < T , Capacity >:: size_type = decltype ( Capacity );","title":"using size_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list","text":"list () constructor for an empty list (of T-types elements)","title":"function list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list_1","text":"~ list () destructs the list and also calls the destructor of all contained elements","title":"function ~list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list_2","text":"list ( const list & rhs ) copy constructor list including elements Parameters : rhs is the list to copy from (same capacity)","title":"function list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-list_3","text":"list ( list && rhs ) move constructor list including elements Parameters : rhs is the list to move-construct elements from (same capacity)","title":"function list"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-operator","text":"list & operator = ( const list & rhs ) copy assignment, each element is copied (added) to the constructed list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to copy from (same capacity) Return : reference to created list","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-operator_1","text":"list & operator = ( list && rhs ) move assignment, list is cleared and initialized, elements are moved from source list any existing elements in 'this'/lhs are removed (same behaviour as std::list : Assigns new contents to the container, replacing its current contents, and modifying its size accordingly.) Parameters : rhs is the list to move from ('source', same capacity) Return : reference to created list","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-begin","text":"iterator begin () default list operation to retrieve an interator to first list element Return : iterator to first list element, returns iterator to end() when list is empty","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-begin_1","text":"const_iterator begin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-cbegin","text":"const_iterator cbegin () const default list operation to retrieve an const_iterator to first list element Return : iterator to first list element, returns iterator to end() when list is empty","title":"function cbegin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-end","text":"iterator end () default list operation to retrieve an interator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data.","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-end_1","text":"const_iterator end () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data.","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-cend","text":"const_iterator cend () const default list operation to retrieve an const_iterator to end of list (behind last valid element) Terminated when content is attemted to read (operator*, operator->) Return : iterator to end element, does not contain data.","title":"function cend"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-empty","text":"bool empty () const list meta information on filling Return : no elements in list (true), otherwise (false)","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-full","text":"bool full () const list meta information on filling Return : whether list is full (filled with 'capacity' / 'max_size' elements) (true), otherwise (false)","title":"function full"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-size","text":"size_type size () const list meta information on filling Return : current number of elements in list @min returns min 0 @max returns max capacity","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-capacity","text":"size_type capacity () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements.","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-max_size","text":"size_type max_size () const list meta information, maximum number of elements the list can contain Return : list has been initialized with the following number of elements, same as capacity()","title":"function max_size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-front","text":"T & front () Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : reference to the first element","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-front_1","text":"const T & front () const Returns a reference to the first element in the container. calling front() on an empty list will terminate() the processing. Return : const reference to the first element","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-back","text":"T & back () Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. Return : reference to the last element","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-back_1","text":"const T & back () const Returns a reference to the last element in the container. calling back() on an empty list will terminate() the processing. Return : const reference to the last element","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_front","text":"bool push_front ( const T & data ) add element to the beginning of the list Parameters : data reference to data element Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false)","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_front_1","text":"bool push_front ( T && data ) add element to the beginning of the list via move Parameters : data universal reference perfectly forwarded to client class Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false)","title":"function push_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_back","text":"bool push_back ( const T & data ) add element to the end of the list Parameters : data reference to data element Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false)","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-push_back_1","text":"bool push_back ( T && data ) add element to the end of the list via move Parameters : data universal reference perfectly forwarded to client class Return : successful insertion (true), otherwise no element could be added to list (e.g. full -> false)","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-pop_front","text":"bool pop_front () remove the first element from the begining of the list element destructor will be invoked Return : successful removal (true), otherwise no element could be taken from list (e.g. empty -> false)","title":"function pop_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-pop_back","text":"bool pop_back () remove the last element from the end of the list element destructor will be invoked Return : successful removal (true), otherwise no element could be taken from list (e.g. empty -> false)","title":"function pop_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-clear","text":"void clear () remove all elements from the list, list will be empty element destructors will be invoked","title":"function clear"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-erase","text":"iterator erase ( const_iterator iter ) remove next element from linked iterator position element destructors will be invoked recursive calls to erase_after only delete each 2nd element Parameters : iter iterator linking the to-be-removed element Return : an (non-const_) iterator to the element after the removed element, returns end() element when reached end of list","title":"function erase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-remove","text":"size_type remove ( const T & data ) remove all elements which matches the given comparing element (compare by value) requires a the template type T to have operator== defined. Parameters : data value to compare to Return : the number of elements removed, return is C++20-conform","title":"function remove"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-remove_if","text":"template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) remove all elements which matches the provided comparison function requires a the template type T to have a operator== defined. Parameters : pred unary predicate which returns true if the element should be removed Return : the number of elements removed, return is C++20-conform","title":"function remove_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-emplace_front","text":"template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) construct element inplace at begining of list Parameters : args T-typed construction parameters (initializer list) Return : referene to generated element, return is C++17-conform","title":"function emplace_front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-emplace_back","text":"template < typename ... ConstructorArgs > T & emplace_back ( ConstructorArgs && ... args ) construct element inplace at end of list Parameters : args T-typed construction parameters (initializer list) Return : referene to generated element, return is C++17-conform","title":"function emplace_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-emplace","text":"template < typename ... ConstructorArgs > iterator emplace ( const_iterator iter , ConstructorArgs && ... args ) construct element inplace at iterator position Parameters : args T-typed construction parameters (initializer list) iter position in list to (construct)insert after Return : iterator to the newly added element","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-insert","text":"iterator insert ( const_iterator citer , const T & data ) insert element before iterator position Parameters : citer iterator with the position to insert after data reference to element to add Return : iterator to the newly added element","title":"function insert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list/#function-insert_1","text":"iterator insert ( const_iterator citer , T && data ) add element before the pointed-to element via move Parameters : citer iterator with the position to insert after data universal reference perfectly forwarded to client class Return : iterator to the newly added element Updated on 18 December 2023 at 13:11:42 CET","title":"function insert"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/","text":"iox::cxx::list::IteratorBase \ud83d\udd17 nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() More... Public Types \ud83d\udd17 Name using std::bidirectional_iterator_tag iterator_category using typename std::conditional< IsConstIterator, const T, T >::type value_type using void difference_type using typename std::conditional< IsConstIterator, const T *, T * >::type pointer using typename std::conditional< IsConstIterator, const T &, T & >::type reference Public Functions \ud83d\udd17 Name IteratorBase (const IteratorBase< false > & iter) construct a const_iterator from an iterator IteratorBase & operator= (const IteratorBase< false > & rhs) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented IteratorBase & operator++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end IteratorBase & operator-- () prefix decrement iterator, so it points to the previous list element decrementing an iterator pointing already towards begin() has no effect (iterator stays at begin() ) template <bool IsConstIteratorOther> bool operator== (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked template <bool IsConstIteratorOther> bool operator!= (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked reference operator* () const dereferencing element content via iterator-position element pointer operator-> () const dereferencing element content via iterator-position element Friends \ud83d\udd17 Name class IteratorBase< true > class list< T, Capacity > Detailed Description \ud83d\udd17 template < bool IsConstIterator = true > class iox :: cxx :: list :: IteratorBase ; nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() Public Types Documentation \ud83d\udd17 using iterator_category \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: iterator_category = std :: bidirectional_iterator_tag ; using value_type \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ; using difference_type \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: difference_type = void ; using pointer \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ; using reference \ud83d\udd17 using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ; Public Functions Documentation \ud83d\udd17 function IteratorBase \ud83d\udd17 IteratorBase ( const IteratorBase < false > & iter ) construct a const_iterator from an iterator Parameters : iter is the iterator which will deliver list and index info for the const_iterator function operator= \ud83d\udd17 IteratorBase & operator = ( const IteratorBase < false > & rhs ) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented Parameters : rhs is the iterator which will deliver list and index info for the const_iterator Return : reference to this iterator object function operator++ \ud83d\udd17 IteratorBase & operator ++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end Return : reference to this iterator object function operator-- \ud83d\udd17 IteratorBase & operator -- () prefix decrement iterator, so it points to the previous list element decrementing an iterator pointing already towards begin() has no effect (iterator stays at begin() ) Return : reference to this iterator object function operator== \ud83d\udd17 template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false) function operator!= \ud83d\udd17 template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false) function operator* \ud83d\udd17 reference operator * () const dereferencing element content via iterator-position element Return : reference to list element data function operator-> \ud83d\udd17 pointer operator -> () const dereferencing element content via iterator-position element Return : pointer to const list data element Friends \ud83d\udd17 friend IteratorBase< true > \ud83d\udd17 friend class IteratorBase < true > ; friend list< T, Capacity > \ud83d\udd17 friend class list < T , Capacity > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::list::IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#ioxcxxlistiteratorbase","text":"nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate() More...","title":"iox::cxx::list::IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-types","text":"Name using std::bidirectional_iterator_tag iterator_category using typename std::conditional< IsConstIterator, const T, T >::type value_type using void difference_type using typename std::conditional< IsConstIterator, const T *, T * >::type pointer using typename std::conditional< IsConstIterator, const T &, T & >::type reference","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-functions","text":"Name IteratorBase (const IteratorBase< false > & iter) construct a const_iterator from an iterator IteratorBase & operator= (const IteratorBase< false > & rhs) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented IteratorBase & operator++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end IteratorBase & operator-- () prefix decrement iterator, so it points to the previous list element decrementing an iterator pointing already towards begin() has no effect (iterator stays at begin() ) template <bool IsConstIteratorOther> bool operator== (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked template <bool IsConstIteratorOther> bool operator!= (const IteratorBase< IsConstIteratorOther > & rhs) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked reference operator* () const dereferencing element content via iterator-position element pointer operator-> () const dereferencing element content via iterator-position element","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friends","text":"Name class IteratorBase< true > class list< T, Capacity >","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#detailed-description","text":"template < bool IsConstIterator = true > class iox :: cxx :: list :: IteratorBase ; nested iterator class for list element operations including element access comparison of iterator from different list is rejected by terminate()","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-iterator_category","text":"using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: iterator_category = std :: bidirectional_iterator_tag ;","title":"using iterator_category"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-value_type","text":"using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ;","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-difference_type","text":"using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: difference_type = void ;","title":"using difference_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-pointer","text":"using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ;","title":"using pointer"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#using-reference","text":"using iox :: cxx :: list < T , Capacity >:: IteratorBase < IsConstIterator >:: reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ;","title":"using reference"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-iteratorbase","text":"IteratorBase ( const IteratorBase < false > & iter ) construct a const_iterator from an iterator Parameters : iter is the iterator which will deliver list and index info for the const_iterator","title":"function IteratorBase"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator","text":"IteratorBase & operator = ( const IteratorBase < false > & rhs ) assigns a const_iterator from an iterator; needs to be implemented because the copy c'tor is also explicitly implemented Parameters : rhs is the iterator which will deliver list and index info for the const_iterator Return : reference to this iterator object","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_1","text":"IteratorBase & operator ++ () prefix increment iterator, so it points to the next list element when trying to increment beyond the end of the list, iterator stays pointing at the end Return : reference to this iterator object","title":"function operator++"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator-","text":"IteratorBase & operator -- () prefix decrement iterator, so it points to the previous list element decrementing an iterator pointing already towards begin() has no effect (iterator stays at begin() ) Return : reference to this iterator object","title":"function operator--"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_2","text":"template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false)","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_3","text":"template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther > & rhs ) const comparing list iterators for non-equality the referenced list position is compared, not the content of the list element (T-typed) -> there is no content for fictional elements at BEGIN_END_LINK_INDEX only iterators of the same parent list can be compared; in case of misuse, terminate() is invoked Parameters : rhs is the 2nd iterator to compare to Return : list position for two iterators is the same (true) or different (false)","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator_4","text":"reference operator * () const dereferencing element content via iterator-position element Return : reference to list element data","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#function-operator-_1","text":"pointer operator -> () const dereferencing element content via iterator-position element Return : pointer to const list data element","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friend-iteratorbase-true","text":"friend class IteratorBase < true > ;","title":"friend IteratorBase&lt; true &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1list_1_1IteratorBase/#friend-list-t-capacity","text":"friend class list < T , Capacity > ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend list&lt; T, Capacity &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/","text":"iox::cxx::optional \ud83d\udd17 Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. More... #include <iceoryx_hoofs/cxx/optional.hpp> Public Types \ud83d\udd17 Name using T type Public Functions \ud83d\udd17 Name optional () Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is undefined. optional (const nullopt_t & ) Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is defined in the cxx::Expects handling. optional (T && value) Creates an optional by forwarding value to the constructor of T. This optional has a value. optional (const T & value) Creates an optional by using the copy constructor of T. template <typename... Targs> optional ( in_place_t , Targs &&... args) Creates an optional and an object inside the optional on construction by perfectly forwarding args to the constructor of T. Could be used e.g. when T is not copyable/movable. ~optional () The destructor will call the destructor of T if a value is set. optional (const optional & rhs) Constructs a value with the copy constructor if rhs has a value. Otherwise it contains no value. optional ( optional && rhs) Constructs a value with the move constructor if rhs has a value. Otherwise it contains no value. optional & operator= (const optional & rhs) Copies an optional. If the optional has a value then the copy assignment of that value is called. If the optional has no value a new value is constructed with the copy constructor. optional & operator= ( optional && rhs) Moves an optional. If the optional has a value then the move assignment of that value is called. If the optional has no value a new value is constructed with the move constructor. constexpr bool operator== (const optional < T > & rhs) const If the optionals have values it compares these values by using their comparison operator. constexpr bool operator== (const nullopt_t & ) const Comparison with nullopt_t for easier unset optional comparison. constexpr bool operator!= (const optional < T > & rhs) const If the optionals have values it compares these values by using their comparison operator. constexpr bool operator!= (const nullopt_t & ) const Comparision with nullopt_t for easier unset optional comparison. template <typename U =T> std::enable_if<!std::is_same< U, optional < T > & >:: value , optional >::type & operator= (U && value) Direct assignment of the underlying value. If the optional has no value then a new T is constructed by forwarding the assignment to T's constructor. If the optional has a value the assignment operator of T is called. const T * operator-> () const Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. const T & operator* () const Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. T * operator-> () Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. T & operator* () Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. constexpr operator bool () const Will return true if the optional contains a value, otherwise false. constexpr bool has_value () const Will return true if the optional contains a value, otherwise false. template <typename... Targs> T & emplace (Targs &&... args) A new element is constructed by forwarding the arguments to the constructor of T. If the optional has a value then the destructor of T is called. void reset () Calls the destructor of T if the optional has a value. If the optional has no value, nothing happens. After that call the optional has no more value. T & value () Returns a reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. const T & value () const Returns a const reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. T && value () Returns a rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. const T && value () const Returns a const rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. template <typename U > constexpr T value_or (U && default_value) const If the optional contains a value a copy of that value is returned, otherwise the default_value is returned. optional & and_then (const cxx::function_ref < void(T &)> & callable) calls the provided callable with the optional value as arguments if the optional contains a value const optional & and_then (const cxx::function_ref < void(const T &)> & callable) const calls the provided callable with the optional value as arguments if the optional contains a value optional & or_else (const cxx::function_ref < void()> & callable) calls the provided callable if the optional does not contain a value const optional & or_else (const cxx::function_ref < void()> & callable) const calls the provided callable if the optional does not contain a value Detailed Description \ud83d\udd17 template < typename T > class iox :: cxx :: optional ; Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. #include \"iceoryx_hoofs/cxx/optional.hpp\" cxx :: optional < void *> SomeFactory () { void * memory = malloc ( 1234 ); if ( memory == nullptr ) return cxx :: nullopt_t (); else return cxx :: make_optional < void *> ( memory ); } int main () { auto var = SomeFactory (); // never forget the has_value call before working with an optional if ( var . has_value () ) { // do stuff with var } } Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 using iox :: cxx :: optional < T >:: type = T ; Public Functions Documentation \ud83d\udd17 function optional \ud83d\udd17 optional () Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is undefined. function optional \ud83d\udd17 optional ( const nullopt_t & ) Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is defined in the cxx::Expects handling. function optional \ud83d\udd17 optional ( T && value ) Creates an optional by forwarding value to the constructor of T. This optional has a value. Parameters : value rvalue of type T which will be moved into the optional function optional \ud83d\udd17 optional ( const T & value ) Creates an optional by using the copy constructor of T. Parameters : value lvalue of type T which will be copy constructed into the optional function optional \ud83d\udd17 template < typename ... Targs > optional ( in_place_t , Targs && ... args ) Creates an optional and an object inside the optional on construction by perfectly forwarding args to the constructor of T. Could be used e.g. when T is not copyable/movable. Parameters : in_place_t compile time variable to distinguish between constructors with certain behavior Template Parameters : Targs is the template parameter pack for the perfectly forwarded arguments function ~optional \ud83d\udd17 ~ optional () The destructor will call the destructor of T if a value is set. function optional \ud83d\udd17 optional ( const optional & rhs ) Constructs a value with the copy constructor if rhs has a value. Otherwise it contains no value. Parameters : rhs source of the copy function optional \ud83d\udd17 optional ( optional && rhs ) Constructs a value with the move constructor if rhs has a value. Otherwise it contains no value. Parameters : rhs source of the move function operator= \ud83d\udd17 optional & operator = ( const optional & rhs ) Copies an optional. If the optional has a value then the copy assignment of that value is called. If the optional has no value a new value is constructed with the copy constructor. Parameters : rhs source of the copy Return : reference to the current optional function operator= \ud83d\udd17 optional & operator = ( optional && rhs ) Moves an optional. If the optional has a value then the move assignment of that value is called. If the optional has no value a new value is constructed with the move constructor. Parameters : rhs source of the move Return : reference to the current optional function operator== \ud83d\udd17 constexpr bool operator == ( const optional < T > & rhs ) const If the optionals have values it compares these values by using their comparison operator. Parameters : rhs value to which this optional should be compared to Return : true if the contained values are equal, otherwise false function operator== \ud83d\udd17 constexpr bool operator == ( const nullopt_t & ) const Comparison with nullopt_t for easier unset optional comparison. Return : true if the optional is unset, otherwise false function operator!= \ud83d\udd17 constexpr bool operator != ( const optional < T > & rhs ) const If the optionals have values it compares these values by using their comparison operator. Parameters : rhs value to which this optional should be compared to Return : true if the contained values are not equal, otherwise false function operator!= \ud83d\udd17 constexpr bool operator != ( const nullopt_t & ) const Comparision with nullopt_t for easier unset optional comparison. Return : true if the optional is set, otherwise false function operator= \ud83d\udd17 template < typename U = T > std :: enable_if <! std :: is_same < U , optional < T > & >:: value , optional >:: type & operator = ( U && value ) Direct assignment of the underlying value. If the optional has no value then a new T is constructed by forwarding the assignment to T's constructor. If the optional has a value the assignment operator of T is called. Parameters : value value to assign to the underlying optional value Return : reference to the current optional function operator-> \ud83d\udd17 const T * operator -> () const Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : pointer of type const T to the underlying type function operator* \ud83d\udd17 const T & operator * () const Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : reference of type const T to the underlying type function operator-> \ud83d\udd17 T * operator -> () Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : pointer of type T to the underlying type function operator* \ud83d\udd17 T & operator * () Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : reference of type T to the underlying type function operator bool \ud83d\udd17 explicit constexpr operator bool () const Will return true if the optional contains a value, otherwise false. Return : true if optional contains a value, otherwise false function has_value \ud83d\udd17 constexpr bool has_value () const Will return true if the optional contains a value, otherwise false. Return : true if optional contains a value, otherwise false function emplace \ud83d\udd17 template < typename ... Targs > T & emplace ( Targs && ... args ) A new element is constructed by forwarding the arguments to the constructor of T. If the optional has a value then the destructor of T is called. Parameters : perfectly forwards args to the constructor of T to perform a placement new Return : reference to the underlying type function reset \ud83d\udd17 void reset () Calls the destructor of T if the optional has a value. If the optional has no value, nothing happens. After that call the optional has no more value. function value \ud83d\udd17 T & value () Returns a reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : reference to the underlying type function value \ud83d\udd17 const T & value () const Returns a const reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : const reference to the underlying type function value \ud83d\udd17 T && value () Returns a rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : rvalue reference to the underlying type function value \ud83d\udd17 const T && value () const Returns a const rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : const rvalue reference to the underlying type function value_or \ud83d\udd17 template < typename U > constexpr T value_or ( U && default_value ) const If the optional contains a value a copy of that value is returned, otherwise the default_value is returned. Return : copy of the underlying type if the optional has a value otherwise a copy of default_value function and_then \ud83d\udd17 optional & and_then ( const cxx :: function_ref < void ( T & ) > & callable ) calls the provided callable with the optional value as arguments if the optional contains a value Parameters : callable which has T as argument Return : reference to this function and_then \ud83d\udd17 const optional & and_then ( const cxx :: function_ref < void ( const T & ) > & callable ) const calls the provided callable with the optional value as arguments if the optional contains a value Parameters : callable which has T as argument Return : reference to this function or_else \ud83d\udd17 optional & or_else ( const cxx :: function_ref < void () > & callable ) calls the provided callable if the optional does not contain a value Parameters : callable Return : reference to this function or_else \ud83d\udd17 const optional & or_else ( const cxx :: function_ref < void () > & callable ) const calls the provided callable if the optional does not contain a value Parameters : callable Return : reference to this Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#ioxcxxoptional","text":"Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. More... #include <iceoryx_hoofs/cxx/optional.hpp>","title":"iox::cxx::optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-types","text":"Name using T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-functions","text":"Name optional () Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is undefined. optional (const nullopt_t & ) Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is defined in the cxx::Expects handling. optional (T && value) Creates an optional by forwarding value to the constructor of T. This optional has a value. optional (const T & value) Creates an optional by using the copy constructor of T. template <typename... Targs> optional ( in_place_t , Targs &&... args) Creates an optional and an object inside the optional on construction by perfectly forwarding args to the constructor of T. Could be used e.g. when T is not copyable/movable. ~optional () The destructor will call the destructor of T if a value is set. optional (const optional & rhs) Constructs a value with the copy constructor if rhs has a value. Otherwise it contains no value. optional ( optional && rhs) Constructs a value with the move constructor if rhs has a value. Otherwise it contains no value. optional & operator= (const optional & rhs) Copies an optional. If the optional has a value then the copy assignment of that value is called. If the optional has no value a new value is constructed with the copy constructor. optional & operator= ( optional && rhs) Moves an optional. If the optional has a value then the move assignment of that value is called. If the optional has no value a new value is constructed with the move constructor. constexpr bool operator== (const optional < T > & rhs) const If the optionals have values it compares these values by using their comparison operator. constexpr bool operator== (const nullopt_t & ) const Comparison with nullopt_t for easier unset optional comparison. constexpr bool operator!= (const optional < T > & rhs) const If the optionals have values it compares these values by using their comparison operator. constexpr bool operator!= (const nullopt_t & ) const Comparision with nullopt_t for easier unset optional comparison. template <typename U =T> std::enable_if<!std::is_same< U, optional < T > & >:: value , optional >::type & operator= (U && value) Direct assignment of the underlying value. If the optional has no value then a new T is constructed by forwarding the assignment to T's constructor. If the optional has a value the assignment operator of T is called. const T * operator-> () const Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. const T & operator* () const Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. T * operator-> () Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. T & operator* () Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. constexpr operator bool () const Will return true if the optional contains a value, otherwise false. constexpr bool has_value () const Will return true if the optional contains a value, otherwise false. template <typename... Targs> T & emplace (Targs &&... args) A new element is constructed by forwarding the arguments to the constructor of T. If the optional has a value then the destructor of T is called. void reset () Calls the destructor of T if the optional has a value. If the optional has no value, nothing happens. After that call the optional has no more value. T & value () Returns a reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. const T & value () const Returns a const reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. T && value () Returns a rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. const T && value () const Returns a const rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. template <typename U > constexpr T value_or (U && default_value) const If the optional contains a value a copy of that value is returned, otherwise the default_value is returned. optional & and_then (const cxx::function_ref < void(T &)> & callable) calls the provided callable with the optional value as arguments if the optional contains a value const optional & and_then (const cxx::function_ref < void(const T &)> & callable) const calls the provided callable with the optional value as arguments if the optional contains a value optional & or_else (const cxx::function_ref < void()> & callable) calls the provided callable if the optional does not contain a value const optional & or_else (const cxx::function_ref < void()> & callable) const calls the provided callable if the optional does not contain a value","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#detailed-description","text":"template < typename T > class iox :: cxx :: optional ; Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. #include \"iceoryx_hoofs/cxx/optional.hpp\" cxx :: optional < void *> SomeFactory () { void * memory = malloc ( 1234 ); if ( memory == nullptr ) return cxx :: nullopt_t (); else return cxx :: make_optional < void *> ( memory ); } int main () { auto var = SomeFactory (); // never forget the has_value call before working with an optional if ( var . has_value () ) { // do stuff with var } }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#using-type","text":"using iox :: cxx :: optional < T >:: type = T ;","title":"using type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional","text":"optional () Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is undefined.","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_1","text":"optional ( const nullopt_t & ) Creates an optional which has no value. If you access such an optional via . value() or the arrow operator the behavior is defined in the cxx::Expects handling.","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_2","text":"optional ( T && value ) Creates an optional by forwarding value to the constructor of T. This optional has a value. Parameters : value rvalue of type T which will be moved into the optional","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_3","text":"optional ( const T & value ) Creates an optional by using the copy constructor of T. Parameters : value lvalue of type T which will be copy constructed into the optional","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_4","text":"template < typename ... Targs > optional ( in_place_t , Targs && ... args ) Creates an optional and an object inside the optional on construction by perfectly forwarding args to the constructor of T. Could be used e.g. when T is not copyable/movable. Parameters : in_place_t compile time variable to distinguish between constructors with certain behavior Template Parameters : Targs is the template parameter pack for the perfectly forwarded arguments","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_5","text":"~ optional () The destructor will call the destructor of T if a value is set.","title":"function ~optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_6","text":"optional ( const optional & rhs ) Constructs a value with the copy constructor if rhs has a value. Otherwise it contains no value. Parameters : rhs source of the copy","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-optional_7","text":"optional ( optional && rhs ) Constructs a value with the move constructor if rhs has a value. Otherwise it contains no value. Parameters : rhs source of the move","title":"function optional"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator","text":"optional & operator = ( const optional & rhs ) Copies an optional. If the optional has a value then the copy assignment of that value is called. If the optional has no value a new value is constructed with the copy constructor. Parameters : rhs source of the copy Return : reference to the current optional","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_1","text":"optional & operator = ( optional && rhs ) Moves an optional. If the optional has a value then the move assignment of that value is called. If the optional has no value a new value is constructed with the move constructor. Parameters : rhs source of the move Return : reference to the current optional","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_2","text":"constexpr bool operator == ( const optional < T > & rhs ) const If the optionals have values it compares these values by using their comparison operator. Parameters : rhs value to which this optional should be compared to Return : true if the contained values are equal, otherwise false","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_3","text":"constexpr bool operator == ( const nullopt_t & ) const Comparison with nullopt_t for easier unset optional comparison. Return : true if the optional is unset, otherwise false","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_4","text":"constexpr bool operator != ( const optional < T > & rhs ) const If the optionals have values it compares these values by using their comparison operator. Parameters : rhs value to which this optional should be compared to Return : true if the contained values are not equal, otherwise false","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_5","text":"constexpr bool operator != ( const nullopt_t & ) const Comparision with nullopt_t for easier unset optional comparison. Return : true if the optional is set, otherwise false","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_6","text":"template < typename U = T > std :: enable_if <! std :: is_same < U , optional < T > & >:: value , optional >:: type & operator = ( U && value ) Direct assignment of the underlying value. If the optional has no value then a new T is constructed by forwarding the assignment to T's constructor. If the optional has a value the assignment operator of T is called. Parameters : value value to assign to the underlying optional value Return : reference to the current optional","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator-","text":"const T * operator -> () const Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : pointer of type const T to the underlying type","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_7","text":"const T & operator * () const Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : reference of type const T to the underlying type","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator-_1","text":"T * operator -> () Returns a pointer to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : pointer of type T to the underlying type","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator_8","text":"T & operator * () Returns a reference to the underlying value. If the optional has no value the behavior is undefined. You need to verify that the optional has a value by calling has_value() before using it. Return : reference of type T to the underlying type","title":"function operator*"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-operator-bool","text":"explicit constexpr operator bool () const Will return true if the optional contains a value, otherwise false. Return : true if optional contains a value, otherwise false","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-has_value","text":"constexpr bool has_value () const Will return true if the optional contains a value, otherwise false. Return : true if optional contains a value, otherwise false","title":"function has_value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-emplace","text":"template < typename ... Targs > T & emplace ( Targs && ... args ) A new element is constructed by forwarding the arguments to the constructor of T. If the optional has a value then the destructor of T is called. Parameters : perfectly forwards args to the constructor of T to perform a placement new Return : reference to the underlying type","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-reset","text":"void reset () Calls the destructor of T if the optional has a value. If the optional has no value, nothing happens. After that call the optional has no more value.","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value","text":"T & value () Returns a reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : reference to the underlying type","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_1","text":"const T & value () const Returns a const reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : const reference to the underlying type","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_2","text":"T && value () Returns a rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : rvalue reference to the underlying type","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_3","text":"const T && value () const Returns a const rvalue reference to the underlying value. If the optional has no value the application terminates. You need to verify that the optional has a value by calling has_value() before using it. Return : const rvalue reference to the underlying type","title":"function value"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-value_or","text":"template < typename U > constexpr T value_or ( U && default_value ) const If the optional contains a value a copy of that value is returned, otherwise the default_value is returned. Return : copy of the underlying type if the optional has a value otherwise a copy of default_value","title":"function value_or"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-and_then","text":"optional & and_then ( const cxx :: function_ref < void ( T & ) > & callable ) calls the provided callable with the optional value as arguments if the optional contains a value Parameters : callable which has T as argument Return : reference to this","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-and_then_1","text":"const optional & and_then ( const cxx :: function_ref < void ( const T & ) > & callable ) const calls the provided callable with the optional value as arguments if the optional contains a value Parameters : callable which has T as argument Return : reference to this","title":"function and_then"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-or_else","text":"optional & or_else ( const cxx :: function_ref < void () > & callable ) calls the provided callable if the optional does not contain a value Parameters : callable Return : reference to this","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1optional/#function-or_else_1","text":"const optional & or_else ( const cxx :: function_ref < void () > & callable ) const calls the provided callable if the optional does not contain a value Parameters : callable Return : reference to this Updated on 18 December 2023 at 13:11:42 CET","title":"function or_else"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/","text":"iox::cxx::stack \ud83d\udd17 stack implementation with a simple push pop interface More... #include <iceoryx_hoofs/cxx/stack.hpp> Public Functions \ud83d\udd17 Name cxx::optional < T > pop () returns the last pushed element when the stack contains elements otherwise a cxx::nullopt template <typename... Targs> bool push (Targs &&... args) pushed an element into the stack by forwarding all arguments to the constructor of T uint64_t size () const returns the stack size constexpr uint64_t capacity () returns the stack capacity Detailed Description \ud83d\udd17 template < typename T , uint64_t Capacity > class iox :: cxx :: stack ; stack implementation with a simple push pop interface Template Parameters : T type which the stack contains Capacity the capacity of the stack Public Functions Documentation \ud83d\udd17 function pop \ud83d\udd17 cxx :: optional < T > pop () returns the last pushed element when the stack contains elements otherwise a cxx::nullopt function push \ud83d\udd17 template < typename ... Targs > bool push ( Targs && ... args ) pushed an element into the stack by forwarding all arguments to the constructor of T Parameters : args arguments which will be perfectly forwarded to the constructor of T Return : true if the push was successful, otherwise false function size \ud83d\udd17 uint64_t size () const returns the stack size function capacity \ud83d\udd17 static constexpr uint64_t capacity () returns the stack capacity Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::stack"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#ioxcxxstack","text":"stack implementation with a simple push pop interface More... #include <iceoryx_hoofs/cxx/stack.hpp>","title":"iox::cxx::stack"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#public-functions","text":"Name cxx::optional < T > pop () returns the last pushed element when the stack contains elements otherwise a cxx::nullopt template <typename... Targs> bool push (Targs &&... args) pushed an element into the stack by forwarding all arguments to the constructor of T uint64_t size () const returns the stack size constexpr uint64_t capacity () returns the stack capacity","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#detailed-description","text":"template < typename T , uint64_t Capacity > class iox :: cxx :: stack ; stack implementation with a simple push pop interface Template Parameters : T type which the stack contains Capacity the capacity of the stack","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-pop","text":"cxx :: optional < T > pop () returns the last pushed element when the stack contains elements otherwise a cxx::nullopt","title":"function pop"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-push","text":"template < typename ... Targs > bool push ( Targs && ... args ) pushed an element into the stack by forwarding all arguments to the constructor of T Parameters : args arguments which will be perfectly forwarded to the constructor of T Return : true if the push was successful, otherwise false","title":"function push"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-size","text":"uint64_t size () const returns the stack size","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1stack/#function-capacity","text":"static constexpr uint64_t capacity () returns the stack capacity Updated on 18 December 2023 at 13:11:42 CET","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/","text":"iox::cxx::string \ud83d\udd17 string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. More... #include <iceoryx_hoofs/cxx/string.hpp> Public Functions \ud83d\udd17 Name constexpr string () =default creates an empty string with size 0 string (const string & other) copy constructor string ( string && other) move constructor string & operator= (const string & rhs) copy assignment string & operator= ( string && rhs) move assignment template <uint64_t N> string (const string < N > & other) creates a new string of given capacity as a copy of other with compile time check whether the capacity of other is less than or equal to this' capacity template <uint64_t N> string ( string < N > && other) moves other to this with compile time check whether the capacity of other is less than or equal to this' capacity template <uint64_t N> string & operator= (const string < N > & rhs) assigns rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity template <uint64_t N> string & operator= ( string < N > && rhs) moves rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity template <uint64_t N> string (const char(&) other[N]) conversion constructor for char array with compile time check if the array size is less than or equal to the string capacity string ( TruncateToCapacity_t , const char *const other) conversion constructor for cstring to string which truncates characters if the size is greater than the string capacity string ( TruncateToCapacity_t , const std::string & other) conversion constructor for std::string to string which truncates characters if the std::string size is greater than the string capacity string ( TruncateToCapacity_t , const char *const other, const uint64_t count) constructor from cstring to string. Constructs the string with the first count characters of the cstring including null characters. If count is greater than the string capacity the remainder of the characters are truncated. template <uint64_t N> string & operator= (const char(&) rhs[N]) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity template <uint64_t N> string & assign (const string < N > & str) fixed string assignment with compile time check if capacity of str is less than or equal to this' capacity template <uint64_t N> string & assign (const char(&) str[N]) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity bool unsafe_assign (const char *const str) assigns a cstring to string. The assignment fails if the cstring size is greater than the string capacity. bool unsafe_assign (const std::string & str) assigns a std::string to string. The assignment fails if the std::string size is greater than the string capacity. template <uint64_t N> int64_t compare (const string < N > & other) const compares two strings template <uint64_t N> bool operator== (const string < N > & rhs) const checks if self is equal to rhs template <uint64_t N> bool operator!= (const string < N > & rhs) const checks if self is not equal to rhs template <uint64_t N> bool operator< (const string < N > & rhs) const checks if self is less than rhs, in lexicographical order template <uint64_t N> bool operator<= (const string < N > & rhs) const checks if self is less than or equal to rhs, in lexicographical order template <uint64_t N> bool operator> (const string < N > & rhs) const checks if self is greater than rhs, in lexicographical order template <uint64_t N> bool operator>= (const string < N > & rhs) const checks if self is greater than or equal to rhs, in lexicographical order bool operator== (const char *const rhs) const The equality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. bool operator!= (const char *const rhs) const The inequality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. const char * c_str () const returns a pointer to the char array of self constexpr uint64_t size () const returns the number of characters stored in the string constexpr bool empty () const returns if the string is empty or not operator std::string () const converts the string to a std::string template <typename T > string & operator+= (const T & ) since there are two valid options for what should happen when appending a string larger than this' capacity (failing or truncating), the fixed string does not support operator+=; use append for truncating or unsafe_append for failing in that case template <typename T > std::enable_if< internal::IsCharArray< T >::value template <typename T > std::enable_if< internal::IsCharArray< T >::value iox::cxx::optional < string < Capacity > > substr (const uint64_t pos, const uint64_t count) const creates a substring containing the characters from pos until count; if pos+count is greater than the size of the original string the returned substring only contains the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string; iox::cxx::optional < string < Capacity > > substr (const uint64_t pos =0U) const creates a substring containing the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string template <typename T > std::enable_if< std::is_same< T, std::string >::value template <typename T > std::enable_if< std::is_same< T, std::string >::value template <typename T > std::enable_if< std::is_same< T, std::string >::value constexpr uint64_t capacity () returns the maximum number of characters that can be stored in the string Friends \ud83d\udd17 Name class string std::enable_if<(internal::IsCharArray< T1 >::value Detailed Description \ud83d\udd17 template < uint64_t Capacity > class iox :: cxx :: string ; string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. Public Functions Documentation \ud83d\udd17 function string \ud83d\udd17 constexpr string () = default creates an empty string with size 0 function string \ud83d\udd17 string ( const string & other ) copy constructor Parameters : other is the copy origin function string \ud83d\udd17 string ( string && other ) move constructor Parameters : other is the move origin function operator= \ud83d\udd17 string & operator = ( const string & rhs ) copy assignment Parameters : rhs is the copy origin Return : reference to self function operator= \ud83d\udd17 string & operator = ( string && rhs ) move assignment Parameters : rhs is the move origin Return : reference to self function string \ud83d\udd17 template < uint64_t N > string ( const string < N > & other ) creates a new string of given capacity as a copy of other with compile time check whether the capacity of other is less than or equal to this' capacity Parameters : other is the copy origin function string \ud83d\udd17 template < uint64_t N > string ( string < N > && other ) moves other to this with compile time check whether the capacity of other is less than or equal to this' capacity Parameters : other is the move origin function operator= \ud83d\udd17 template < uint64_t N > string & operator = ( const string < N > & rhs ) assigns rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity Parameters : rhs is the copy origin Return : reference to self function operator= \ud83d\udd17 template < uint64_t N > string & operator = ( string < N > && rhs ) moves rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity Parameters : rhs is the move origin Return : reference to self function string \ud83d\udd17 template < uint64_t N > string ( const char ( & ) other [ N ] ) conversion constructor for char array with compile time check if the array size is less than or equal to the string capacity Parameters : other is the char array Template Parameters : N is the implicit template parameter for the char array size Note : if the array is not zero-terminated, the last value will be overwritten with 0 #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ( \"abcd\" ); } function string \ud83d\udd17 string ( TruncateToCapacity_t , const char * const other ) conversion constructor for cstring to string which truncates characters if the size is greater than the string capacity Parameters : TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior other is the cstring to convert Attention : truncates characters if the size is greater than the string capacity #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ( TruncateToCapacity , \"abcd\" ); } function string \ud83d\udd17 string ( TruncateToCapacity_t , const std :: string & other ) conversion constructor for std::string to string which truncates characters if the std::string size is greater than the string capacity Parameters : TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior other is the std::string to convert Attention : truncates characters if the std::string size is greater than the string capacity #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { std :: string bar = \"bar\" ; string < 4 > fuu ( TruncateToCapacity , bar ); } function string \ud83d\udd17 string ( TruncateToCapacity_t , const char * const other , const uint64_t count ) constructor from cstring to string. Constructs the string with the first count characters of the cstring including null characters. If count is greater than the string capacity the remainder of the characters are truncated. Parameters : TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior other is the cstring to convert count is the number of characters for constructing the string #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ( TruncateToCapacity , \"abcd\" , 2 ); } function operator= \ud83d\udd17 template < uint64_t N > string & operator = ( const char ( & ) rhs [ N ] ) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity Parameters : rhs is the char array Template Parameters : [in] N is the implicit template parameter for the char array size Return : reference to self Note : if the array is not zero-terminated, the last value will be overwritten with 0 #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu = \"abcd\" ; } function assign \ud83d\udd17 template < uint64_t N > string & assign ( const string < N > & str ) fixed string assignment with compile time check if capacity of str is less than or equal to this' capacity Parameters : str is the fixed string object to assign Return : reference to self function assign \ud83d\udd17 template < uint64_t N > string & assign ( const char ( & ) str [ N ] ) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity Parameters : str is the char array Template Parameters : [in] N is the implicit template parameter for the char array size Return : reference to self Note : if the array is not zero-terminated, the last value will be overwritten with 0 #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ; char bar [] = \"abcd\" ; fuu . assign ( bar ); } function unsafe_assign \ud83d\udd17 bool unsafe_assign ( const char * const str ) assigns a cstring to string. The assignment fails if the cstring size is greater than the string capacity. Parameters : str is the cstring to assign Return : true if the assignment succeeds, otherwise false function unsafe_assign \ud83d\udd17 bool unsafe_assign ( const std :: string & str ) assigns a std::string to string. The assignment fails if the std::string size is greater than the string capacity. Parameters : str is the std::string to assign Return : true if the assignment succeeds, otherwise false function compare \ud83d\udd17 template < uint64_t N > int64_t compare ( const string < N > & other ) const compares two strings Parameters : other is the string to compare with self Return : an integer < 0 if the first character that does not match has a lower value in self than in other, 0 if the contents of both strings are equal, an integer > 0 if the first character that does not match has a greater value in self than in other function operator== \ud83d\udd17 template < uint64_t N > bool operator == ( const string < N > & rhs ) const checks if self is equal to rhs Parameters : rhs is the string to compare with self Return : true if both strings are equal, otherwise false function operator!= \ud83d\udd17 template < uint64_t N > bool operator != ( const string < N > & rhs ) const checks if self is not equal to rhs Parameters : rhs is the string to compare with self Return : true if both strings are not equal, otherwise false function operator< \ud83d\udd17 template < uint64_t N > bool operator < ( const string < N > & rhs ) const checks if self is less than rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is less than rhs, otherwise false function operator<= \ud83d\udd17 template < uint64_t N > bool operator <= ( const string < N > & rhs ) const checks if self is less than or equal to rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is less than or equal to rhs, otherwise false function operator> \ud83d\udd17 template < uint64_t N > bool operator > ( const string < N > & rhs ) const checks if self is greater than rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is greater than rhs, otherwise false function operator>= \ud83d\udd17 template < uint64_t N > bool operator >= ( const string < N > & rhs ) const checks if self is greater than or equal to rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is greater than or equal to rhs, otherwise false function operator== \ud83d\udd17 bool operator == ( const char * const rhs ) const The equality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : rhs is the char pointer to the array to compare Return : false Todo : consider implementing the equality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator==(const char (&rhs)[N]) const noexcept function operator!= \ud83d\udd17 bool operator != ( const char * const rhs ) const The inequality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : rhs is the char pointer to the array to compare Return : false Todo : consider implementing the inequality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator!=(const char (&rhs)[N]) const noexcept function c_str \ud83d\udd17 const char * c_str () const returns a pointer to the char array of self Return : a pointer to the char array of self function size \ud83d\udd17 constexpr uint64_t size () const returns the number of characters stored in the string Return : the number of characters stored in the string function empty \ud83d\udd17 constexpr bool empty () const returns if the string is empty or not Return : true if size() == 0 otherwise false function operator std::string \ud83d\udd17 operator std :: string () const converts the string to a std::string Return : a std::string with data equivalent to those stored in the string function operator+= \ud83d\udd17 template < typename T > string & operator += ( const T & ) since there are two valid options for what should happen when appending a string larger than this' capacity (failing or truncating), the fixed string does not support operator+=; use append for truncating or unsafe_append for failing in that case function append \ud83d\udd17 template < typename T > std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , string & >:: type append ( TruncateToCapacity_t , const T & t ) appends a fixed string or string literal to the end of this. If this' capacity is too small for appending the whole string (literal) the remainder of the characters are truncated. Parameters : TruncateToCapacity_t is a compile time variable which is used to make the user aware of the possible truncation t is the fixed string/string literal to append Return : reference to self string < 5 > fuu ( \"cde\" ); fuu . append ( TruncateToCapacity , \"fgahc\" ); function unsafe_append \ud83d\udd17 template < typename T > std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , bool >:: type unsafe_append ( const T & t ) appends a fixed string or string literal to the end of this. The appending fails if the sum of both sizes is greater than this' capacity. Parameters : fixed string/string literal to append Return : true if the appending succeeds, otherwise false function substr \ud83d\udd17 iox :: cxx :: optional < string < Capacity > > substr ( const uint64_t pos , const uint64_t count ) const creates a substring containing the characters from pos until count; if pos+count is greater than the size of the original string the returned substring only contains the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string; Parameters : pos is the position of the first character used for the substring count is the requested length of the substring Return : an optional containing the substring, iox::cxx::nullopt if pos is greater than the size of the original string function substr \ud83d\udd17 iox :: cxx :: optional < string < Capacity > > substr ( const uint64_t pos = 0U ) const creates a substring containing the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string Parameters : pos is the position of the first character used for the substring Return : an optional containing the substring, iox::cxx::nullopt if pos is greater than the size of the original string function find \ud83d\udd17 template < typename T > std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t > >:: type find ( const T & t , const uint64_t pos = 0U ) const finds the first occurence of the given character sequence; returns the position of the first character of the found substring, returns iox::cxx::nullopt if no substring is found or if pos is greater than this' size Parameters : t is the character sequence to search for; must be a cxx::string , string literal or std::string pos is the position at which to start the search Return : an optional containing the position of the first character of the found substring, iox::cxx::nullopt if no substring is found function find_first_of \ud83d\udd17 template < typename T > std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t > >:: type find_first_of ( const T & t , const uint64_t pos = 0U ) const finds the first occurence of a character equal to one of the characters of the given character sequence and returns its position; returns iox::cxx::nullopt if no character is found or if pos is greater than this' size Parameters : t is the character sequence to search for; must be a cxx::string , string literal or std::string pos is the position at which to start the search Return : an optional containing the position of the first character equal to one of the characters of the given character sequence, iox::cxx::nullopt if no character is found function find_last_of \ud83d\udd17 template < typename T > std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t > >:: type find_last_of ( const T & t , const uint64_t pos = Capacity ) const finds the last occurence of a character equal to one of the characters of the given character sequence and returns its position; returns iox::cxx::nullopt if no character is found Parameters : t is the character sequence to search for; must be a cxx::string , string literal or std::string pos is the position at which to finish the search Return : an optional containing the position of the last character equal to one of the characters of the given character sequence, iox::cxx::nullopt if no character is found function capacity \ud83d\udd17 static constexpr uint64_t capacity () returns the maximum number of characters that can be stored in the string Return : the maximum number of characters that can be stored in the string Friends \ud83d\udd17 friend string \ud83d\udd17 friend class string ; friend concatenate \ud83d\udd17 friend std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa > >:: type concatenate ( const T1 & t1 , const T2 & t2 ); concatenates two fixed strings/string literals Parameters : fixed strings/string literals to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings string < 5 > fuu ( \"cdefg\" ); auto bar = iox :: cxx :: concatenate ( fuu , \"ahc\" ); Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#ioxcxxstring","text":"string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. More... #include <iceoryx_hoofs/cxx/string.hpp>","title":"iox::cxx::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#public-functions","text":"Name constexpr string () =default creates an empty string with size 0 string (const string & other) copy constructor string ( string && other) move constructor string & operator= (const string & rhs) copy assignment string & operator= ( string && rhs) move assignment template <uint64_t N> string (const string < N > & other) creates a new string of given capacity as a copy of other with compile time check whether the capacity of other is less than or equal to this' capacity template <uint64_t N> string ( string < N > && other) moves other to this with compile time check whether the capacity of other is less than or equal to this' capacity template <uint64_t N> string & operator= (const string < N > & rhs) assigns rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity template <uint64_t N> string & operator= ( string < N > && rhs) moves rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity template <uint64_t N> string (const char(&) other[N]) conversion constructor for char array with compile time check if the array size is less than or equal to the string capacity string ( TruncateToCapacity_t , const char *const other) conversion constructor for cstring to string which truncates characters if the size is greater than the string capacity string ( TruncateToCapacity_t , const std::string & other) conversion constructor for std::string to string which truncates characters if the std::string size is greater than the string capacity string ( TruncateToCapacity_t , const char *const other, const uint64_t count) constructor from cstring to string. Constructs the string with the first count characters of the cstring including null characters. If count is greater than the string capacity the remainder of the characters are truncated. template <uint64_t N> string & operator= (const char(&) rhs[N]) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity template <uint64_t N> string & assign (const string < N > & str) fixed string assignment with compile time check if capacity of str is less than or equal to this' capacity template <uint64_t N> string & assign (const char(&) str[N]) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity bool unsafe_assign (const char *const str) assigns a cstring to string. The assignment fails if the cstring size is greater than the string capacity. bool unsafe_assign (const std::string & str) assigns a std::string to string. The assignment fails if the std::string size is greater than the string capacity. template <uint64_t N> int64_t compare (const string < N > & other) const compares two strings template <uint64_t N> bool operator== (const string < N > & rhs) const checks if self is equal to rhs template <uint64_t N> bool operator!= (const string < N > & rhs) const checks if self is not equal to rhs template <uint64_t N> bool operator< (const string < N > & rhs) const checks if self is less than rhs, in lexicographical order template <uint64_t N> bool operator<= (const string < N > & rhs) const checks if self is less than or equal to rhs, in lexicographical order template <uint64_t N> bool operator> (const string < N > & rhs) const checks if self is greater than rhs, in lexicographical order template <uint64_t N> bool operator>= (const string < N > & rhs) const checks if self is greater than or equal to rhs, in lexicographical order bool operator== (const char *const rhs) const The equality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. bool operator!= (const char *const rhs) const The inequality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. const char * c_str () const returns a pointer to the char array of self constexpr uint64_t size () const returns the number of characters stored in the string constexpr bool empty () const returns if the string is empty or not operator std::string () const converts the string to a std::string template <typename T > string & operator+= (const T & ) since there are two valid options for what should happen when appending a string larger than this' capacity (failing or truncating), the fixed string does not support operator+=; use append for truncating or unsafe_append for failing in that case template <typename T > std::enable_if< internal::IsCharArray< T >::value template <typename T > std::enable_if< internal::IsCharArray< T >::value iox::cxx::optional < string < Capacity > > substr (const uint64_t pos, const uint64_t count) const creates a substring containing the characters from pos until count; if pos+count is greater than the size of the original string the returned substring only contains the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string; iox::cxx::optional < string < Capacity > > substr (const uint64_t pos =0U) const creates a substring containing the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string template <typename T > std::enable_if< std::is_same< T, std::string >::value template <typename T > std::enable_if< std::is_same< T, std::string >::value template <typename T > std::enable_if< std::is_same< T, std::string >::value constexpr uint64_t capacity () returns the maximum number of characters that can be stored in the string","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friends","text":"Name class string std::enable_if<(internal::IsCharArray< T1 >::value","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#detailed-description","text":"template < uint64_t Capacity > class iox :: cxx :: string ; string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap.","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string","text":"constexpr string () = default creates an empty string with size 0","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_1","text":"string ( const string & other ) copy constructor Parameters : other is the copy origin","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_2","text":"string ( string && other ) move constructor Parameters : other is the move origin","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator","text":"string & operator = ( const string & rhs ) copy assignment Parameters : rhs is the copy origin Return : reference to self","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_1","text":"string & operator = ( string && rhs ) move assignment Parameters : rhs is the move origin Return : reference to self","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_3","text":"template < uint64_t N > string ( const string < N > & other ) creates a new string of given capacity as a copy of other with compile time check whether the capacity of other is less than or equal to this' capacity Parameters : other is the copy origin","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_4","text":"template < uint64_t N > string ( string < N > && other ) moves other to this with compile time check whether the capacity of other is less than or equal to this' capacity Parameters : other is the move origin","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_2","text":"template < uint64_t N > string & operator = ( const string < N > & rhs ) assigns rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity Parameters : rhs is the copy origin Return : reference to self","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_3","text":"template < uint64_t N > string & operator = ( string < N > && rhs ) moves rhs fixed string to this with compile time check whether the capacity of rhs is less than or equal to this' capacity Parameters : rhs is the move origin Return : reference to self","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_5","text":"template < uint64_t N > string ( const char ( & ) other [ N ] ) conversion constructor for char array with compile time check if the array size is less than or equal to the string capacity Parameters : other is the char array Template Parameters : N is the implicit template parameter for the char array size Note : if the array is not zero-terminated, the last value will be overwritten with 0 #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ( \"abcd\" ); }","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_6","text":"string ( TruncateToCapacity_t , const char * const other ) conversion constructor for cstring to string which truncates characters if the size is greater than the string capacity Parameters : TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior other is the cstring to convert Attention : truncates characters if the size is greater than the string capacity #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ( TruncateToCapacity , \"abcd\" ); }","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_7","text":"string ( TruncateToCapacity_t , const std :: string & other ) conversion constructor for std::string to string which truncates characters if the std::string size is greater than the string capacity Parameters : TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior other is the std::string to convert Attention : truncates characters if the std::string size is greater than the string capacity #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { std :: string bar = \"bar\" ; string < 4 > fuu ( TruncateToCapacity , bar ); }","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-string_8","text":"string ( TruncateToCapacity_t , const char * const other , const uint64_t count ) constructor from cstring to string. Constructs the string with the first count characters of the cstring including null characters. If count is greater than the string capacity the remainder of the characters are truncated. Parameters : TruncateToCapacity_t is a compile time variable which is used to distinguish between constructors with certain behavior other is the cstring to convert count is the number of characters for constructing the string #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ( TruncateToCapacity , \"abcd\" , 2 ); }","title":"function string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_4","text":"template < uint64_t N > string & operator = ( const char ( & ) rhs [ N ] ) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity Parameters : rhs is the char array Template Parameters : [in] N is the implicit template parameter for the char array size Return : reference to self Note : if the array is not zero-terminated, the last value will be overwritten with 0 #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu = \"abcd\" ; }","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-assign","text":"template < uint64_t N > string & assign ( const string < N > & str ) fixed string assignment with compile time check if capacity of str is less than or equal to this' capacity Parameters : str is the fixed string object to assign Return : reference to self","title":"function assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-assign_1","text":"template < uint64_t N > string & assign ( const char ( & ) str [ N ] ) assigns a char array to string with compile time check if the array size is less than or equal to the string capacity Parameters : str is the char array Template Parameters : [in] N is the implicit template parameter for the char array size Return : reference to self Note : if the array is not zero-terminated, the last value will be overwritten with 0 #include \"iceoryx_hoofs/cxx/string.hpp\" using namespace iox :: cxx ; int main () { string < 4 > fuu ; char bar [] = \"abcd\" ; fuu . assign ( bar ); }","title":"function assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-unsafe_assign","text":"bool unsafe_assign ( const char * const str ) assigns a cstring to string. The assignment fails if the cstring size is greater than the string capacity. Parameters : str is the cstring to assign Return : true if the assignment succeeds, otherwise false","title":"function unsafe_assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-unsafe_assign_1","text":"bool unsafe_assign ( const std :: string & str ) assigns a std::string to string. The assignment fails if the std::string size is greater than the string capacity. Parameters : str is the std::string to assign Return : true if the assignment succeeds, otherwise false","title":"function unsafe_assign"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-compare","text":"template < uint64_t N > int64_t compare ( const string < N > & other ) const compares two strings Parameters : other is the string to compare with self Return : an integer < 0 if the first character that does not match has a lower value in self than in other, 0 if the contents of both strings are equal, an integer > 0 if the first character that does not match has a greater value in self than in other","title":"function compare"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_5","text":"template < uint64_t N > bool operator == ( const string < N > & rhs ) const checks if self is equal to rhs Parameters : rhs is the string to compare with self Return : true if both strings are equal, otherwise false","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_6","text":"template < uint64_t N > bool operator != ( const string < N > & rhs ) const checks if self is not equal to rhs Parameters : rhs is the string to compare with self Return : true if both strings are not equal, otherwise false","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_7","text":"template < uint64_t N > bool operator < ( const string < N > & rhs ) const checks if self is less than rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is less than rhs, otherwise false","title":"function operator&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_8","text":"template < uint64_t N > bool operator <= ( const string < N > & rhs ) const checks if self is less than or equal to rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is less than or equal to rhs, otherwise false","title":"function operator&lt;="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_9","text":"template < uint64_t N > bool operator > ( const string < N > & rhs ) const checks if self is greater than rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is greater than rhs, otherwise false","title":"function operator&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_10","text":"template < uint64_t N > bool operator >= ( const string < N > & rhs ) const checks if self is greater than or equal to rhs, in lexicographical order Parameters : rhs is the string to compare with self Return : true if self is greater than or equal to rhs, otherwise false","title":"function operator&gt;="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_11","text":"bool operator == ( const char * const rhs ) const The equality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : rhs is the char pointer to the array to compare Return : false Todo : consider implementing the equality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator==(const char (&rhs)[N]) const noexcept","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_12","text":"bool operator != ( const char * const rhs ) const The inequality operator for fixed string and char pointer is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : rhs is the char pointer to the array to compare Return : false Todo : consider implementing the inequality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator!=(const char (&rhs)[N]) const noexcept","title":"function operator!="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-c_str","text":"const char * c_str () const returns a pointer to the char array of self Return : a pointer to the char array of self","title":"function c_str"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-size","text":"constexpr uint64_t size () const returns the number of characters stored in the string Return : the number of characters stored in the string","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-empty","text":"constexpr bool empty () const returns if the string is empty or not Return : true if size() == 0 otherwise false","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator-stdstring","text":"operator std :: string () const converts the string to a std::string Return : a std::string with data equivalent to those stored in the string","title":"function operator std::string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-operator_13","text":"template < typename T > string & operator += ( const T & ) since there are two valid options for what should happen when appending a string larger than this' capacity (failing or truncating), the fixed string does not support operator+=; use append for truncating or unsafe_append for failing in that case","title":"function operator+="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-append","text":"template < typename T > std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , string & >:: type append ( TruncateToCapacity_t , const T & t ) appends a fixed string or string literal to the end of this. If this' capacity is too small for appending the whole string (literal) the remainder of the characters are truncated. Parameters : TruncateToCapacity_t is a compile time variable which is used to make the user aware of the possible truncation t is the fixed string/string literal to append Return : reference to self string < 5 > fuu ( \"cde\" ); fuu . append ( TruncateToCapacity , \"fgahc\" );","title":"function append"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-unsafe_append","text":"template < typename T > std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , bool >:: type unsafe_append ( const T & t ) appends a fixed string or string literal to the end of this. The appending fails if the sum of both sizes is greater than this' capacity. Parameters : fixed string/string literal to append Return : true if the appending succeeds, otherwise false","title":"function unsafe_append"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-substr","text":"iox :: cxx :: optional < string < Capacity > > substr ( const uint64_t pos , const uint64_t count ) const creates a substring containing the characters from pos until count; if pos+count is greater than the size of the original string the returned substring only contains the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string; Parameters : pos is the position of the first character used for the substring count is the requested length of the substring Return : an optional containing the substring, iox::cxx::nullopt if pos is greater than the size of the original string","title":"function substr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-substr_1","text":"iox :: cxx :: optional < string < Capacity > > substr ( const uint64_t pos = 0U ) const creates a substring containing the characters from pos until size() ; iox::cxx::nullopt is returned if pos is greater than the size of the original string Parameters : pos is the position of the first character used for the substring Return : an optional containing the substring, iox::cxx::nullopt if pos is greater than the size of the original string","title":"function substr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-find","text":"template < typename T > std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t > >:: type find ( const T & t , const uint64_t pos = 0U ) const finds the first occurence of the given character sequence; returns the position of the first character of the found substring, returns iox::cxx::nullopt if no substring is found or if pos is greater than this' size Parameters : t is the character sequence to search for; must be a cxx::string , string literal or std::string pos is the position at which to start the search Return : an optional containing the position of the first character of the found substring, iox::cxx::nullopt if no substring is found","title":"function find"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-find_first_of","text":"template < typename T > std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t > >:: type find_first_of ( const T & t , const uint64_t pos = 0U ) const finds the first occurence of a character equal to one of the characters of the given character sequence and returns its position; returns iox::cxx::nullopt if no character is found or if pos is greater than this' size Parameters : t is the character sequence to search for; must be a cxx::string , string literal or std::string pos is the position at which to start the search Return : an optional containing the position of the first character equal to one of the characters of the given character sequence, iox::cxx::nullopt if no character is found","title":"function find_first_of"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-find_last_of","text":"template < typename T > std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t > >:: type find_last_of ( const T & t , const uint64_t pos = Capacity ) const finds the last occurence of a character equal to one of the characters of the given character sequence and returns its position; returns iox::cxx::nullopt if no character is found Parameters : t is the character sequence to search for; must be a cxx::string , string literal or std::string pos is the position at which to finish the search Return : an optional containing the position of the last character equal to one of the characters of the given character sequence, iox::cxx::nullopt if no character is found","title":"function find_last_of"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#function-capacity","text":"static constexpr uint64_t capacity () returns the maximum number of characters that can be stored in the string Return : the maximum number of characters that can be stored in the string","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friend-string","text":"friend class string ;","title":"friend string"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1string/#friend-concatenate","text":"friend std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa > >:: type concatenate ( const T1 & t1 , const T2 & t2 ); concatenates two fixed strings/string literals Parameters : fixed strings/string literals to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings string < 5 > fuu ( \"cdefg\" ); auto bar = iox :: cxx :: concatenate ( fuu , \"ahc\" ); Updated on 18 December 2023 at 13:11:42 CET","title":"friend concatenate"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/","text":"iox::cxx::unique_ptr \ud83d\udd17 The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. More... #include <iceoryx_hoofs/cxx/unique_ptr.hpp> Public Functions \ud83d\udd17 Name unique_ptr () unique_ptr ( function_ref < void(T *)> && deleter) unique_ptr Creates an empty unique ptr that owns nothing. Can be passed ownership later via reset. unique_ptr (T const ptr, function_ref < void(T )> && deleter) unique_ptr Creates a unique pointer that takes ownership of an object. unique_ptr (const unique_ptr & other) unique_ptr & operator= (const unique_ptr & ) unique_ptr ( unique_ptr && rhs) unique_ptr & operator= ( unique_ptr && rhs) ~unique_ptr () unique_ptr < T > & operator= (std::nullptr_t ) T * operator-> () operator -> Transparent access to the managed object. const T * operator-> () const operator -> Transparent access to the managed object. operator bool () const operator bool Returns true if it points to something. T * get () get Retrieve the underlying raw pointer. const T * get () const get Retrieve the underlying raw pointer. T * release () release Release ownership of the underlying pointer. void reset (T *const ptr =nullptr) reset Reset the unique pointer to take ownership of the given pointer. void swap ( unique_ptr & other) swap Swaps object ownership with another unique_ptr (incl. deleters) Detailed Description \ud83d\udd17 template < typename T > class iox :: cxx :: unique_ptr ; The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. To avoid using the heap, deleters are not managed by the pointer itself, and instead must be provided as function references ('cxx: function_ref '). The functions must exist at least as long as the pointers that use them. Also unlike the STL implementation, the deleters are not encoded in the unique_ptr type, allowing unique_ptr instances with different deleters to be stored in the same containers. Public Functions Documentation \ud83d\udd17 function unique_ptr \ud83d\udd17 unique_ptr () function unique_ptr \ud83d\udd17 unique_ptr ( function_ref < void ( T * ) > && deleter ) unique_ptr Creates an empty unique ptr that owns nothing. Can be passed ownership later via reset. function unique_ptr \ud83d\udd17 unique_ptr ( T * const ptr , function_ref < void ( T * ) > && deleter ) unique_ptr Creates a unique pointer that takes ownership of an object. Parameters : ptr The raw pointer to the object to be managed. deleter The deleter function for cleaning up the managed object. As cxx: function_ref used for the deleter is non-owning the user needs to care about the lifetime of the callable! A deleter must always be provided as no default can be provided given that no heap is used. The unique_ptr must know how to delete the managed object when the pointer goes out of scope. function unique_ptr \ud83d\udd17 unique_ptr ( const unique_ptr & other ) function operator= \ud83d\udd17 unique_ptr & operator = ( const unique_ptr & ) function unique_ptr \ud83d\udd17 unique_ptr ( unique_ptr && rhs ) function operator= \ud83d\udd17 unique_ptr & operator = ( unique_ptr && rhs ) function ~unique_ptr \ud83d\udd17 ~ unique_ptr () Automatically deletes the managed object on destruction. function operator= \ud83d\udd17 unique_ptr < T > & operator = ( std :: nullptr_t ) function operator-> \ud83d\udd17 T * operator -> () operator -> Transparent access to the managed object. Return : function operator-> \ud83d\udd17 const T * operator -> () const operator -> Transparent access to the managed object. Return : function operator bool \ud83d\udd17 explicit operator bool () const operator bool Returns true if it points to something. function get \ud83d\udd17 T * get () get Retrieve the underlying raw pointer. Return : Pointer to managed object or nullptr if none owned. The unique_ptr retains ownership, therefore the \"borrowed\" pointer must not be deleted. function get \ud83d\udd17 const T * get () const get Retrieve the underlying raw pointer. Return : Pointer to managed object or nullptr if none owned. The unique_ptr retains ownership, therefore the \"borrowed\" pointer must not be deleted. function release \ud83d\udd17 T * release () release Release ownership of the underlying pointer. Return : Pointer to the managed object or nullptr if none owned. function reset \ud83d\udd17 void reset ( T * const ptr = nullptr ) reset Reset the unique pointer to take ownership of the given pointer. Parameters : ptr Pointer to object to take ownership on. Any previously owned objects will be deleted. If no pointer given then points to nullptr. function swap \ud83d\udd17 void swap ( unique_ptr & other ) swap Swaps object ownership with another unique_ptr (incl. deleters) Parameters : other The unique_ptr with which to swap owned objects. Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#ioxcxxunique_ptr","text":"The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. More... #include <iceoryx_hoofs/cxx/unique_ptr.hpp>","title":"iox::cxx::unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#public-functions","text":"Name unique_ptr () unique_ptr ( function_ref < void(T *)> && deleter) unique_ptr Creates an empty unique ptr that owns nothing. Can be passed ownership later via reset. unique_ptr (T const ptr, function_ref < void(T )> && deleter) unique_ptr Creates a unique pointer that takes ownership of an object. unique_ptr (const unique_ptr & other) unique_ptr & operator= (const unique_ptr & ) unique_ptr ( unique_ptr && rhs) unique_ptr & operator= ( unique_ptr && rhs) ~unique_ptr () unique_ptr < T > & operator= (std::nullptr_t ) T * operator-> () operator -> Transparent access to the managed object. const T * operator-> () const operator -> Transparent access to the managed object. operator bool () const operator bool Returns true if it points to something. T * get () get Retrieve the underlying raw pointer. const T * get () const get Retrieve the underlying raw pointer. T * release () release Release ownership of the underlying pointer. void reset (T *const ptr =nullptr) reset Reset the unique pointer to take ownership of the given pointer. void swap ( unique_ptr & other) swap Swaps object ownership with another unique_ptr (incl. deleters)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#detailed-description","text":"template < typename T > class iox :: cxx :: unique_ptr ; The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. To avoid using the heap, deleters are not managed by the pointer itself, and instead must be provided as function references ('cxx: function_ref '). The functions must exist at least as long as the pointers that use them. Also unlike the STL implementation, the deleters are not encoded in the unique_ptr type, allowing unique_ptr instances with different deleters to be stored in the same containers.","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr","text":"unique_ptr ()","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_1","text":"unique_ptr ( function_ref < void ( T * ) > && deleter ) unique_ptr Creates an empty unique ptr that owns nothing. Can be passed ownership later via reset.","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_2","text":"unique_ptr ( T * const ptr , function_ref < void ( T * ) > && deleter ) unique_ptr Creates a unique pointer that takes ownership of an object. Parameters : ptr The raw pointer to the object to be managed. deleter The deleter function for cleaning up the managed object. As cxx: function_ref used for the deleter is non-owning the user needs to care about the lifetime of the callable! A deleter must always be provided as no default can be provided given that no heap is used. The unique_ptr must know how to delete the managed object when the pointer goes out of scope.","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_3","text":"unique_ptr ( const unique_ptr & other )","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator","text":"unique_ptr & operator = ( const unique_ptr & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_4","text":"unique_ptr ( unique_ptr && rhs )","title":"function unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator_1","text":"unique_ptr & operator = ( unique_ptr && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-unique_ptr_5","text":"~ unique_ptr () Automatically deletes the managed object on destruction.","title":"function ~unique_ptr"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator_2","text":"unique_ptr < T > & operator = ( std :: nullptr_t )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator-","text":"T * operator -> () operator -> Transparent access to the managed object. Return :","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator-_1","text":"const T * operator -> () const operator -> Transparent access to the managed object. Return :","title":"function operator-&gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-operator-bool","text":"explicit operator bool () const operator bool Returns true if it points to something.","title":"function operator bool"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-get","text":"T * get () get Retrieve the underlying raw pointer. Return : Pointer to managed object or nullptr if none owned. The unique_ptr retains ownership, therefore the \"borrowed\" pointer must not be deleted.","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-get_1","text":"const T * get () const get Retrieve the underlying raw pointer. Return : Pointer to managed object or nullptr if none owned. The unique_ptr retains ownership, therefore the \"borrowed\" pointer must not be deleted.","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-release","text":"T * release () release Release ownership of the underlying pointer. Return : Pointer to the managed object or nullptr if none owned.","title":"function release"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-reset","text":"void reset ( T * const ptr = nullptr ) reset Reset the unique pointer to take ownership of the given pointer. Parameters : ptr Pointer to object to take ownership on. Any previously owned objects will be deleted. If no pointer given then points to nullptr.","title":"function reset"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1unique__ptr/#function-swap","text":"void swap ( unique_ptr & other ) swap Swaps object ownership with another unique_ptr (incl. deleters) Parameters : other The unique_ptr with which to swap owned objects. Updated on 18 December 2023 at 13:11:42 CET","title":"function swap"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/","text":"iox::cxx::variant \ud83d\udd17 Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. More... #include <iceoryx_hoofs/cxx/variant.hpp> Public Functions \ud83d\udd17 Name constexpr variant () =default the default constructor constructs a variant which does not contain an element and returns INVALID_VARIANT_INDEX when . index() is called template <uint64_t N,typename... CTorArguments> constexpr variant (const in_place_index < N > & index, CTorArguments &&... args) creates a variant and perform an in place construction of the type stored at index N. If the index N is out of bounds you get a compiler error. template <typename T ,typename... CTorArguments> constexpr variant (const in_place_type < T > & type, CTorArguments &&... args) creates a variant and perform an in place construction of the type T. If T is not part of the variant you get a compiler error. template <typename T ,typename =std::enable_if_t<!std::is_same , variant>::value>,typename std::enable_if_t<!internal::is_in_place_index< std::decay_t< T >>::value, bool > =false,typename std::enable_if_t<!internal::is_in_place_type< std::decay_t< T >>::value, bool > =false> constexpr variant (T && arg) creates a variant from a user supplied value constexpr variant (const variant & rhs) if the variant contains an element the elements copy constructor is called otherwise an empty variant is copied constexpr variant & operator= (const variant & rhs) if the variant contains an element the elements copy assignment operator is called otherwise an empty variant is copied constexpr variant ( variant && rhs) if the variant contains an element the elements move constructor is called otherwise an empty variant is moved constexpr variant & operator= ( variant && rhs) if the variant contains an element the elements move assignment operator is called otherwise an empty variant is moved ~variant () if the variant contains an element the elements destructor is called otherwise nothing happens template <typename T > std::enable_if<!std::is_same< T, variant < Types... > & >::value, variant < Types... > >::type & operator= (T && rhs) if the variant contains an element the elements assignment operator is called otherwise we have undefined behavior. It is important that you make sure that the variant really contains that type T. template <uint64_t TypeIndex,typename... CTorArguments> bool emplace_at_index (CTorArguments &&... args) calls the constructor of the type at index TypeIndex and perfectly forwards the arguments to this constructor. (not stl compliant) template <typename T ,typename... CTorArguments> bool emplace (CTorArguments &&... args) calls the constructor of the type T and perfectly forwards the arguments to the constructor of T. template <uint64_t TypeIndex> internal::get_type_at_index< 0, TypeIndex, Types... >::type * get_at_index () returns a pointer to the type stored at index TypeIndex. (not stl compliant) template <uint64_t TypeIndex> const internal::get_type_at_index< 0, TypeIndex, Types... >::type * get_at_index () const returns a pointer to the type stored at index TypeIndex. (not stl compliant) template <typename T > const T * get () const returns a pointer to the type T stored in the variant. (not stl compliant) template <typename T > T * get () returns a pointer to the type T stored in the variant. (not stl compliant) template <typename T > T * get_if (T * defaultValue) returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue template <typename T > const T * get_if (const T * defaultValue) const returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue constexpr uint64_t index () const returns the index of the stored type in the variant. if the variant does not contain any type it returns INVALID_VARIANT_INDEX Detailed Description \ud83d\udd17 template < typename ... Types > class iox :: cxx :: variant ; Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. Parameters : Types... variadic list of types which the variant should be able to store #include \"iceoryx_hoofs/cxx/variant.hpp\" #include <iostream> cxx :: variant < int , float , double > someVariant ; // ... do stuff if ( someVariant . index () == INVALID_VARIANT_INDEX ) { someVariant . emplace < float > ( 123.456f ); } else if ( someVariant . index () == 1 ) { auto blubb = someVariant . template get_at_index < 1 > (); std :: cout << * blubb << std :: endl ; auto sameAsBlubb = someVariant . get < float > (); std :: cout << * sameAsBlubb << std :: endl ; } // .. do stuff int defaultValue = 123 ; int * fuu = someVariant . get_if < int > ( & defaultValue ); std :: cout << * fuu << std :: endl ; Public Functions Documentation \ud83d\udd17 function variant \ud83d\udd17 constexpr variant () = default the default constructor constructs a variant which does not contain an element and returns INVALID_VARIANT_INDEX when . index() is called function variant \ud83d\udd17 template < uint64_t N , typename ... CTorArguments > constexpr variant ( const in_place_index < N > & index , CTorArguments && ... args ) creates a variant and perform an in place construction of the type stored at index N. If the index N is out of bounds you get a compiler error. Template Parameters : function variant \ud83d\udd17 template < typename T , typename ... CTorArguments > constexpr variant ( const in_place_type < T > & type , CTorArguments && ... args ) creates a variant and perform an in place construction of the type T. If T is not part of the variant you get a compiler error. Template Parameters : function variant \ud83d\udd17 template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , variant >:: value > , typename std :: enable_if_t <! internal :: is_in_place_index < std :: decay_t < T >>:: value , bool > = false , typename std :: enable_if_t <! internal :: is_in_place_type < std :: decay_t < T >>:: value , bool > = false > constexpr variant ( T && arg ) creates a variant from a user supplied value Template Parameters : function variant \ud83d\udd17 constexpr variant ( const variant & rhs ) if the variant contains an element the elements copy constructor is called otherwise an empty variant is copied Parameters : rhs source of the copy function operator= \ud83d\udd17 constexpr variant & operator = ( const variant & rhs ) if the variant contains an element the elements copy assignment operator is called otherwise an empty variant is copied Parameters : rhs source of the copy assignment Return : reference to the variant itself function variant \ud83d\udd17 constexpr variant ( variant && rhs ) if the variant contains an element the elements move constructor is called otherwise an empty variant is moved Parameters : rhs source of the move function operator= \ud83d\udd17 constexpr variant & operator = ( variant && rhs ) if the variant contains an element the elements move assignment operator is called otherwise an empty variant is moved Parameters : rhs source of the move assignment Return : reference to the variant itself function ~variant \ud83d\udd17 ~ variant () if the variant contains an element the elements destructor is called otherwise nothing happens function operator= \ud83d\udd17 template < typename T > std :: enable_if <! std :: is_same < T , variant < Types ... > & >:: value , variant < Types ... > >:: type & operator = ( T && rhs ) if the variant contains an element the elements assignment operator is called otherwise we have undefined behavior. It is important that you make sure that the variant really contains that type T. Template Parameters : function emplace_at_index \ud83d\udd17 template < uint64_t TypeIndex , typename ... CTorArguments > bool emplace_at_index ( CTorArguments && ... args ) calls the constructor of the type at index TypeIndex and perfectly forwards the arguments to this constructor. (not stl compliant) Parameters : args arguments which will be forwarded to the constructor to the type at TypeIndex Template Parameters : TypeIndex index of the type which will be created CTorArguments variadic types of the c'tor arguments Return : if the variant already contains a different type it returns false, if the construction was successful it returns true function emplace \ud83d\udd17 template < typename T , typename ... CTorArguments > bool emplace ( CTorArguments && ... args ) calls the constructor of the type T and perfectly forwards the arguments to the constructor of T. Template Parameters : function get_at_index \ud83d\udd17 template < uint64_t TypeIndex > internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () returns a pointer to the type stored at index TypeIndex. (not stl compliant) Template Parameters : function get_at_index \ud83d\udd17 template < uint64_t TypeIndex > const internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () const returns a pointer to the type stored at index TypeIndex. (not stl compliant) Template Parameters : function get \ud83d\udd17 template < typename T > const T * get () const returns a pointer to the type T stored in the variant. (not stl compliant) Template Parameters : function get \ud83d\udd17 template < typename T > T * get () returns a pointer to the type T stored in the variant. (not stl compliant) Template Parameters : function get_if \ud83d\udd17 template < typename T > T * get_if ( T * defaultValue ) returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue Return : pointer to the stored value if it is of type T, otherwise defaultValue function get_if \ud83d\udd17 template < typename T > const T * get_if ( const T * defaultValue ) const returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue Template Parameters : function index \ud83d\udd17 constexpr uint64_t index () const returns the index of the stored type in the variant. if the variant does not contain any type it returns INVALID_VARIANT_INDEX Return : index of the stored type Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#ioxcxxvariant","text":"Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. More... #include <iceoryx_hoofs/cxx/variant.hpp>","title":"iox::cxx::variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#public-functions","text":"Name constexpr variant () =default the default constructor constructs a variant which does not contain an element and returns INVALID_VARIANT_INDEX when . index() is called template <uint64_t N,typename... CTorArguments> constexpr variant (const in_place_index < N > & index, CTorArguments &&... args) creates a variant and perform an in place construction of the type stored at index N. If the index N is out of bounds you get a compiler error. template <typename T ,typename... CTorArguments> constexpr variant (const in_place_type < T > & type, CTorArguments &&... args) creates a variant and perform an in place construction of the type T. If T is not part of the variant you get a compiler error. template <typename T ,typename =std::enable_if_t<!std::is_same , variant>::value>,typename std::enable_if_t<!internal::is_in_place_index< std::decay_t< T >>::value, bool > =false,typename std::enable_if_t<!internal::is_in_place_type< std::decay_t< T >>::value, bool > =false> constexpr variant (T && arg) creates a variant from a user supplied value constexpr variant (const variant & rhs) if the variant contains an element the elements copy constructor is called otherwise an empty variant is copied constexpr variant & operator= (const variant & rhs) if the variant contains an element the elements copy assignment operator is called otherwise an empty variant is copied constexpr variant ( variant && rhs) if the variant contains an element the elements move constructor is called otherwise an empty variant is moved constexpr variant & operator= ( variant && rhs) if the variant contains an element the elements move assignment operator is called otherwise an empty variant is moved ~variant () if the variant contains an element the elements destructor is called otherwise nothing happens template <typename T > std::enable_if<!std::is_same< T, variant < Types... > & >::value, variant < Types... > >::type & operator= (T && rhs) if the variant contains an element the elements assignment operator is called otherwise we have undefined behavior. It is important that you make sure that the variant really contains that type T. template <uint64_t TypeIndex,typename... CTorArguments> bool emplace_at_index (CTorArguments &&... args) calls the constructor of the type at index TypeIndex and perfectly forwards the arguments to this constructor. (not stl compliant) template <typename T ,typename... CTorArguments> bool emplace (CTorArguments &&... args) calls the constructor of the type T and perfectly forwards the arguments to the constructor of T. template <uint64_t TypeIndex> internal::get_type_at_index< 0, TypeIndex, Types... >::type * get_at_index () returns a pointer to the type stored at index TypeIndex. (not stl compliant) template <uint64_t TypeIndex> const internal::get_type_at_index< 0, TypeIndex, Types... >::type * get_at_index () const returns a pointer to the type stored at index TypeIndex. (not stl compliant) template <typename T > const T * get () const returns a pointer to the type T stored in the variant. (not stl compliant) template <typename T > T * get () returns a pointer to the type T stored in the variant. (not stl compliant) template <typename T > T * get_if (T * defaultValue) returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue template <typename T > const T * get_if (const T * defaultValue) const returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue constexpr uint64_t index () const returns the index of the stored type in the variant. if the variant does not contain any type it returns INVALID_VARIANT_INDEX","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#detailed-description","text":"template < typename ... Types > class iox :: cxx :: variant ; Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. Parameters : Types... variadic list of types which the variant should be able to store #include \"iceoryx_hoofs/cxx/variant.hpp\" #include <iostream> cxx :: variant < int , float , double > someVariant ; // ... do stuff if ( someVariant . index () == INVALID_VARIANT_INDEX ) { someVariant . emplace < float > ( 123.456f ); } else if ( someVariant . index () == 1 ) { auto blubb = someVariant . template get_at_index < 1 > (); std :: cout << * blubb << std :: endl ; auto sameAsBlubb = someVariant . get < float > (); std :: cout << * sameAsBlubb << std :: endl ; } // .. do stuff int defaultValue = 123 ; int * fuu = someVariant . get_if < int > ( & defaultValue ); std :: cout << * fuu << std :: endl ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant","text":"constexpr variant () = default the default constructor constructs a variant which does not contain an element and returns INVALID_VARIANT_INDEX when . index() is called","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_1","text":"template < uint64_t N , typename ... CTorArguments > constexpr variant ( const in_place_index < N > & index , CTorArguments && ... args ) creates a variant and perform an in place construction of the type stored at index N. If the index N is out of bounds you get a compiler error. Template Parameters :","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_2","text":"template < typename T , typename ... CTorArguments > constexpr variant ( const in_place_type < T > & type , CTorArguments && ... args ) creates a variant and perform an in place construction of the type T. If T is not part of the variant you get a compiler error. Template Parameters :","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_3","text":"template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , variant >:: value > , typename std :: enable_if_t <! internal :: is_in_place_index < std :: decay_t < T >>:: value , bool > = false , typename std :: enable_if_t <! internal :: is_in_place_type < std :: decay_t < T >>:: value , bool > = false > constexpr variant ( T && arg ) creates a variant from a user supplied value Template Parameters :","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_4","text":"constexpr variant ( const variant & rhs ) if the variant contains an element the elements copy constructor is called otherwise an empty variant is copied Parameters : rhs source of the copy","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-operator","text":"constexpr variant & operator = ( const variant & rhs ) if the variant contains an element the elements copy assignment operator is called otherwise an empty variant is copied Parameters : rhs source of the copy assignment Return : reference to the variant itself","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_5","text":"constexpr variant ( variant && rhs ) if the variant contains an element the elements move constructor is called otherwise an empty variant is moved Parameters : rhs source of the move","title":"function variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-operator_1","text":"constexpr variant & operator = ( variant && rhs ) if the variant contains an element the elements move assignment operator is called otherwise an empty variant is moved Parameters : rhs source of the move assignment Return : reference to the variant itself","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-variant_6","text":"~ variant () if the variant contains an element the elements destructor is called otherwise nothing happens","title":"function ~variant"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-operator_2","text":"template < typename T > std :: enable_if <! std :: is_same < T , variant < Types ... > & >:: value , variant < Types ... > >:: type & operator = ( T && rhs ) if the variant contains an element the elements assignment operator is called otherwise we have undefined behavior. It is important that you make sure that the variant really contains that type T. Template Parameters :","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-emplace_at_index","text":"template < uint64_t TypeIndex , typename ... CTorArguments > bool emplace_at_index ( CTorArguments && ... args ) calls the constructor of the type at index TypeIndex and perfectly forwards the arguments to this constructor. (not stl compliant) Parameters : args arguments which will be forwarded to the constructor to the type at TypeIndex Template Parameters : TypeIndex index of the type which will be created CTorArguments variadic types of the c'tor arguments Return : if the variant already contains a different type it returns false, if the construction was successful it returns true","title":"function emplace_at_index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-emplace","text":"template < typename T , typename ... CTorArguments > bool emplace ( CTorArguments && ... args ) calls the constructor of the type T and perfectly forwards the arguments to the constructor of T. Template Parameters :","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_at_index","text":"template < uint64_t TypeIndex > internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () returns a pointer to the type stored at index TypeIndex. (not stl compliant) Template Parameters :","title":"function get_at_index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_at_index_1","text":"template < uint64_t TypeIndex > const internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () const returns a pointer to the type stored at index TypeIndex. (not stl compliant) Template Parameters :","title":"function get_at_index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get","text":"template < typename T > const T * get () const returns a pointer to the type T stored in the variant. (not stl compliant) Template Parameters :","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_1","text":"template < typename T > T * get () returns a pointer to the type T stored in the variant. (not stl compliant) Template Parameters :","title":"function get"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_if","text":"template < typename T > T * get_if ( T * defaultValue ) returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue Return : pointer to the stored value if it is of type T, otherwise defaultValue","title":"function get_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-get_if_1","text":"template < typename T > const T * get_if ( const T * defaultValue ) const returns a pointer to the type T if its stored in the variant otherwise it returns the provided defaultValue Template Parameters :","title":"function get_if"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1variant/#function-index","text":"constexpr uint64_t index () const returns the index of the stored type in the variant. if the variant does not contain any type it returns INVALID_VARIANT_INDEX Return : index of the stored type Updated on 18 December 2023 at 13:11:42 CET","title":"function index"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/","text":"iox::cxx::vector \ud83d\udd17 C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. More... #include <iceoryx_hoofs/cxx/vector.hpp> Public Types \ud83d\udd17 Name using T value_type using T * iterator using const T * const_iterator Public Functions \ud83d\udd17 Name vector () =default creates an empty vector vector (const uint64_t count, const T & value) creates a vector with count copies of elements with value value vector (const uint64_t count) creates a vector with count copies of elements constructed with the default constructor of T vector (const vector & rhs) copy constructor to copy a vector of the same capacity vector ( vector && rhs) move constructor to move a vector of the same capacity ~vector () destructs the vector and also calls the destructor of all contained elements vector & operator= (const vector & rhs) copy assignment. if the destination vector contains more elements than the source the remaining elements will be destructed vector & operator= ( vector && rhs) move assignment. if the destination vector contains more elements than the source the remaining elements will be destructed iterator begin () returns an iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) const_iterator begin () const returns a const iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) iterator end () returns an iterator to the element which comes after the last element (the first element which is outside of the vector) const_iterator end () const returns a const iterator to the element which comes after the last element (the first element which is outside of the vector) T * data () return the pointer to the underlying array const T * data () const return the const pointer to the underlying array T & at (const uint64_t index) returns a reference to the element stored at index. the behavior const T & at (const uint64_t index) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. T & operator[] (const uint64_t index) returns a reference to the element stored at index. the behavior const T & operator[] (const uint64_t index) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. T & front () returns a reference to the first element; terminates if the vector is empty const T & front () const returns a const reference to the first element; terminates if the vector is empty T & back () returns a reference to the last element; terminates if the vector is empty const T & back () const returns a const reference to the last element; terminates if the vector is empty uint64_t capacity () const returns the capacity of the vector which was given via the template argument uint64_t size () const returns the number of elements which are currently stored in the vector bool empty () const returns true if the vector is emtpy, otherwise false void clear () calls the destructor of all contained elements and removes them template <typename... Targs> bool resize (const uint64_t count, const Targs &... args) resizes the vector. If the vector size increases new elements will be constructed with the given arguments. If count is greater than the capacity the vector will stay unchanged. template <typename... Targs> bool emplace (const uint64_t position, Targs &&... args) forwards all arguments to the constructor of the contained element and performs a placement new at the provided position template <typename... Targs> bool emplace_back (Targs &&... args) forwards all arguments to the constructor of the contained element and performs a placement new at the end bool push_back (const T & value) appends the given element at the end of the vector bool push_back (T && value) appends the given element at the end of the vector bool pop_back () removes the last element of the vector; calling pop_back on an empty container does nothing iterator erase (iterator position) removes an element at the given position. if this element is in the middle of the vector every element is moved one place to the left to ensure that the elements are stored contiguously Detailed Description \ud83d\udd17 template < typename T , uint64_t Capacity > class iox :: cxx :: vector ; C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. Attention : Out of bounds access or accessing an empty vector can lead to a program termination! Public Types Documentation \ud83d\udd17 using value_type \ud83d\udd17 using iox :: cxx :: vector < T , Capacity >:: value_type = T ; using iterator \ud83d\udd17 using iox :: cxx :: vector < T , Capacity >:: iterator = T * ; using const_iterator \ud83d\udd17 using iox :: cxx :: vector < T , Capacity >:: const_iterator = const T * ; Public Functions Documentation \ud83d\udd17 function vector \ud83d\udd17 vector () = default creates an empty vector function vector \ud83d\udd17 vector ( const uint64_t count , const T & value ) creates a vector with count copies of elements with value value Parameters : count is the number copies which are inserted into the vector value is the value which is inserted into the vector function vector \ud83d\udd17 vector ( const uint64_t count ) creates a vector with count copies of elements constructed with the default constructor of T Parameters : count is the number copies which are inserted into the vector function vector \ud83d\udd17 vector ( const vector & rhs ) copy constructor to copy a vector of the same capacity function vector \ud83d\udd17 vector ( vector && rhs ) move constructor to move a vector of the same capacity function ~vector \ud83d\udd17 ~ vector () destructs the vector and also calls the destructor of all contained elements function operator= \ud83d\udd17 vector & operator = ( const vector & rhs ) copy assignment. if the destination vector contains more elements than the source the remaining elements will be destructed function operator= \ud83d\udd17 vector & operator = ( vector && rhs ) move assignment. if the destination vector contains more elements than the source the remaining elements will be destructed function begin \ud83d\udd17 iterator begin () returns an iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) function begin \ud83d\udd17 const_iterator begin () const returns a const iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) function end \ud83d\udd17 iterator end () returns an iterator to the element which comes after the last element (the first element which is outside of the vector) function end \ud83d\udd17 const_iterator end () const returns a const iterator to the element which comes after the last element (the first element which is outside of the vector) function data \ud83d\udd17 T * data () return the pointer to the underlying array Return : pointer to underlying array function data \ud83d\udd17 const T * data () const return the const pointer to the underlying array Return : const pointer to underlying array function at \ud83d\udd17 T & at ( const uint64_t index ) returns a reference to the element stored at index. the behavior Attention : Out of bounds access can lead to a program termination! function at \ud83d\udd17 const T & at ( const uint64_t index ) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. Attention : Out of bounds access can lead to a program termination! function operator[] \ud83d\udd17 T & operator []( const uint64_t index ) returns a reference to the element stored at index. the behavior Attention : Out of bounds access can lead to a program termination! function operator[] \ud83d\udd17 const T & operator []( const uint64_t index ) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. Attention : Out of bounds access can lead to a program termination! function front \ud83d\udd17 T & front () returns a reference to the first element; terminates if the vector is empty Return : reference to the first element Attention : Accessing an empty vector can lead to a program termination! function front \ud83d\udd17 const T & front () const returns a const reference to the first element; terminates if the vector is empty Return : const reference to the first element Attention : Accessing an empty vector can lead to a program termination! function back \ud83d\udd17 T & back () returns a reference to the last element; terminates if the vector is empty Return : reference to the last element Attention : Accessing an empty vector can lead to a program termination! function back \ud83d\udd17 const T & back () const returns a const reference to the last element; terminates if the vector is empty Return : const reference to the last element Attention : Accessing an empty vector can lead to a program termination! function capacity \ud83d\udd17 uint64_t capacity () const returns the capacity of the vector which was given via the template argument function size \ud83d\udd17 uint64_t size () const returns the number of elements which are currently stored in the vector function empty \ud83d\udd17 bool empty () const returns true if the vector is emtpy, otherwise false function clear \ud83d\udd17 void clear () calls the destructor of all contained elements and removes them function resize \ud83d\udd17 template < typename ... Targs > bool resize ( const uint64_t count , const Targs & ... args ) resizes the vector. If the vector size increases new elements will be constructed with the given arguments. If count is greater than the capacity the vector will stay unchanged. Parameters : count new size of the vector args arguments which are used by the constructor of newly created elements Return : true if the resize was successful, false if count is greater than the capacity. Note : perfect forwarded arguments are explicitly not wanted here. think of what happens if resize creates two new elements via move construction. The first one has a valid source but the second gets an already moved parameter. function emplace \ud83d\udd17 template < typename ... Targs > bool emplace ( const uint64_t position , Targs && ... args ) forwards all arguments to the constructor of the contained element and performs a placement new at the provided position Parameters : position the position where the element should be created function emplace_back \ud83d\udd17 template < typename ... Targs > bool emplace_back ( Targs && ... args ) forwards all arguments to the constructor of the contained element and performs a placement new at the end function push_back \ud83d\udd17 bool push_back ( const T & value ) appends the given element at the end of the vector Return : true if successful, false if vector already full function push_back \ud83d\udd17 bool push_back ( T && value ) appends the given element at the end of the vector Return : true if successful, false if vector already full function pop_back \ud83d\udd17 bool pop_back () removes the last element of the vector; calling pop_back on an empty container does nothing Return : true if the last element was removed. If the vector is empty it returns false. function erase \ud83d\udd17 iterator erase ( iterator position ) removes an element at the given position. if this element is in the middle of the vector every element is moved one place to the left to ensure that the elements are stored contiguously Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#ioxcxxvector","text":"C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. More... #include <iceoryx_hoofs/cxx/vector.hpp>","title":"iox::cxx::vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-types","text":"Name using T value_type using T * iterator using const T * const_iterator","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-functions","text":"Name vector () =default creates an empty vector vector (const uint64_t count, const T & value) creates a vector with count copies of elements with value value vector (const uint64_t count) creates a vector with count copies of elements constructed with the default constructor of T vector (const vector & rhs) copy constructor to copy a vector of the same capacity vector ( vector && rhs) move constructor to move a vector of the same capacity ~vector () destructs the vector and also calls the destructor of all contained elements vector & operator= (const vector & rhs) copy assignment. if the destination vector contains more elements than the source the remaining elements will be destructed vector & operator= ( vector && rhs) move assignment. if the destination vector contains more elements than the source the remaining elements will be destructed iterator begin () returns an iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) const_iterator begin () const returns a const iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector) iterator end () returns an iterator to the element which comes after the last element (the first element which is outside of the vector) const_iterator end () const returns a const iterator to the element which comes after the last element (the first element which is outside of the vector) T * data () return the pointer to the underlying array const T * data () const return the const pointer to the underlying array T & at (const uint64_t index) returns a reference to the element stored at index. the behavior const T & at (const uint64_t index) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. T & operator[] (const uint64_t index) returns a reference to the element stored at index. the behavior const T & operator[] (const uint64_t index) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. T & front () returns a reference to the first element; terminates if the vector is empty const T & front () const returns a const reference to the first element; terminates if the vector is empty T & back () returns a reference to the last element; terminates if the vector is empty const T & back () const returns a const reference to the last element; terminates if the vector is empty uint64_t capacity () const returns the capacity of the vector which was given via the template argument uint64_t size () const returns the number of elements which are currently stored in the vector bool empty () const returns true if the vector is emtpy, otherwise false void clear () calls the destructor of all contained elements and removes them template <typename... Targs> bool resize (const uint64_t count, const Targs &... args) resizes the vector. If the vector size increases new elements will be constructed with the given arguments. If count is greater than the capacity the vector will stay unchanged. template <typename... Targs> bool emplace (const uint64_t position, Targs &&... args) forwards all arguments to the constructor of the contained element and performs a placement new at the provided position template <typename... Targs> bool emplace_back (Targs &&... args) forwards all arguments to the constructor of the contained element and performs a placement new at the end bool push_back (const T & value) appends the given element at the end of the vector bool push_back (T && value) appends the given element at the end of the vector bool pop_back () removes the last element of the vector; calling pop_back on an empty container does nothing iterator erase (iterator position) removes an element at the given position. if this element is in the middle of the vector every element is moved one place to the left to ensure that the elements are stored contiguously","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#detailed-description","text":"template < typename T , uint64_t Capacity > class iox :: cxx :: vector ; C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. Attention : Out of bounds access or accessing an empty vector can lead to a program termination!","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#using-value_type","text":"using iox :: cxx :: vector < T , Capacity >:: value_type = T ;","title":"using value_type"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#using-iterator","text":"using iox :: cxx :: vector < T , Capacity >:: iterator = T * ;","title":"using iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#using-const_iterator","text":"using iox :: cxx :: vector < T , Capacity >:: const_iterator = const T * ;","title":"using const_iterator"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector","text":"vector () = default creates an empty vector","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_1","text":"vector ( const uint64_t count , const T & value ) creates a vector with count copies of elements with value value Parameters : count is the number copies which are inserted into the vector value is the value which is inserted into the vector","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_2","text":"vector ( const uint64_t count ) creates a vector with count copies of elements constructed with the default constructor of T Parameters : count is the number copies which are inserted into the vector","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_3","text":"vector ( const vector & rhs ) copy constructor to copy a vector of the same capacity","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_4","text":"vector ( vector && rhs ) move constructor to move a vector of the same capacity","title":"function vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-vector_5","text":"~ vector () destructs the vector and also calls the destructor of all contained elements","title":"function ~vector"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator","text":"vector & operator = ( const vector & rhs ) copy assignment. if the destination vector contains more elements than the source the remaining elements will be destructed","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator_1","text":"vector & operator = ( vector && rhs ) move assignment. if the destination vector contains more elements than the source the remaining elements will be destructed","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-begin","text":"iterator begin () returns an iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector)","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-begin_1","text":"const_iterator begin () const returns a const iterator to the first element of the vector, if the vector is empty it returns the same iterator as end (the first iterator which is outside of the vector)","title":"function begin"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-end","text":"iterator end () returns an iterator to the element which comes after the last element (the first element which is outside of the vector)","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-end_1","text":"const_iterator end () const returns a const iterator to the element which comes after the last element (the first element which is outside of the vector)","title":"function end"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-data","text":"T * data () return the pointer to the underlying array Return : pointer to underlying array","title":"function data"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-data_1","text":"const T * data () const return the const pointer to the underlying array Return : const pointer to underlying array","title":"function data"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-at","text":"T & at ( const uint64_t index ) returns a reference to the element stored at index. the behavior Attention : Out of bounds access can lead to a program termination!","title":"function at"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-at_1","text":"const T & at ( const uint64_t index ) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. Attention : Out of bounds access can lead to a program termination!","title":"function at"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator_2","text":"T & operator []( const uint64_t index ) returns a reference to the element stored at index. the behavior Attention : Out of bounds access can lead to a program termination!","title":"function operator[]"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-operator_3","text":"const T & operator []( const uint64_t index ) const returns a const reference to the element stored at index. the behavior is undefined if the element at index does not exist. Attention : Out of bounds access can lead to a program termination!","title":"function operator[]"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-front","text":"T & front () returns a reference to the first element; terminates if the vector is empty Return : reference to the first element Attention : Accessing an empty vector can lead to a program termination!","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-front_1","text":"const T & front () const returns a const reference to the first element; terminates if the vector is empty Return : const reference to the first element Attention : Accessing an empty vector can lead to a program termination!","title":"function front"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-back","text":"T & back () returns a reference to the last element; terminates if the vector is empty Return : reference to the last element Attention : Accessing an empty vector can lead to a program termination!","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-back_1","text":"const T & back () const returns a const reference to the last element; terminates if the vector is empty Return : const reference to the last element Attention : Accessing an empty vector can lead to a program termination!","title":"function back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-capacity","text":"uint64_t capacity () const returns the capacity of the vector which was given via the template argument","title":"function capacity"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-size","text":"uint64_t size () const returns the number of elements which are currently stored in the vector","title":"function size"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-empty","text":"bool empty () const returns true if the vector is emtpy, otherwise false","title":"function empty"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-clear","text":"void clear () calls the destructor of all contained elements and removes them","title":"function clear"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-resize","text":"template < typename ... Targs > bool resize ( const uint64_t count , const Targs & ... args ) resizes the vector. If the vector size increases new elements will be constructed with the given arguments. If count is greater than the capacity the vector will stay unchanged. Parameters : count new size of the vector args arguments which are used by the constructor of newly created elements Return : true if the resize was successful, false if count is greater than the capacity. Note : perfect forwarded arguments are explicitly not wanted here. think of what happens if resize creates two new elements via move construction. The first one has a valid source but the second gets an already moved parameter.","title":"function resize"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-emplace","text":"template < typename ... Targs > bool emplace ( const uint64_t position , Targs && ... args ) forwards all arguments to the constructor of the contained element and performs a placement new at the provided position Parameters : position the position where the element should be created","title":"function emplace"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-emplace_back","text":"template < typename ... Targs > bool emplace_back ( Targs && ... args ) forwards all arguments to the constructor of the contained element and performs a placement new at the end","title":"function emplace_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-push_back","text":"bool push_back ( const T & value ) appends the given element at the end of the vector Return : true if successful, false if vector already full","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-push_back_1","text":"bool push_back ( T && value ) appends the given element at the end of the vector Return : true if successful, false if vector already full","title":"function push_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-pop_back","text":"bool pop_back () removes the last element of the vector; calling pop_back on an empty container does nothing Return : true if the last element was removed. If the vector is empty it returns false.","title":"function pop_back"},{"location":"API-reference/hoofs/Classes/classiox_1_1cxx_1_1vector/#function-erase","text":"iterator erase ( iterator position ) removes an element at the given position. if this element is in the middle of the vector every element is moved one place to the left to ensure that the elements are stored contiguously Updated on 18 December 2023 at 13:11:42 CET","title":"function erase"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/","text":"iox::log::LogManager \ud83d\udd17 Public Functions \ud83d\udd17 Name LogManager & GetLogManager () Logger & CreateLogContext (const std::string & ctxId, const std::string & ctxDescription, const LogLevel appDefLogLevel) ~LogManager () =default LogManager (const LogManager & ) LogManager ( LogManager && ) LogManager & operator= (const LogManager & ) LogManager & operator= ( LogManager && ) LogLevel DefaultLogLevel () const void SetDefaultLogLevel (const LogLevel logLevel, const LogLevelOutput logLevelOutput =LogLevelOutput::kDisplayLogLevel) LogMode DefaultLogMode () const void SetDefaultLogMode (const LogMode logMode) Protected Functions \ud83d\udd17 Name LogManager () =default Public Functions Documentation \ud83d\udd17 function GetLogManager \ud83d\udd17 static LogManager & GetLogManager () function CreateLogContext \ud83d\udd17 static Logger & CreateLogContext ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel ) function ~LogManager \ud83d\udd17 ~ LogManager () = default function LogManager \ud83d\udd17 LogManager ( const LogManager & ) function LogManager \ud83d\udd17 LogManager ( LogManager && ) function operator= \ud83d\udd17 LogManager & operator = ( const LogManager & ) function operator= \ud83d\udd17 LogManager & operator = ( LogManager && ) function DefaultLogLevel \ud83d\udd17 LogLevel DefaultLogLevel () const function SetDefaultLogLevel \ud83d\udd17 void SetDefaultLogLevel ( const LogLevel logLevel , const LogLevelOutput logLevelOutput = LogLevelOutput :: kDisplayLogLevel ) function DefaultLogMode \ud83d\udd17 LogMode DefaultLogMode () const function SetDefaultLogMode \ud83d\udd17 void SetDefaultLogMode ( const LogMode logMode ) Protected Functions Documentation \ud83d\udd17 function LogManager \ud83d\udd17 LogManager () = default Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#ioxloglogmanager","text":"","title":"iox::log::LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#public-functions","text":"Name LogManager & GetLogManager () Logger & CreateLogContext (const std::string & ctxId, const std::string & ctxDescription, const LogLevel appDefLogLevel) ~LogManager () =default LogManager (const LogManager & ) LogManager ( LogManager && ) LogManager & operator= (const LogManager & ) LogManager & operator= ( LogManager && ) LogLevel DefaultLogLevel () const void SetDefaultLogLevel (const LogLevel logLevel, const LogLevelOutput logLevelOutput =LogLevelOutput::kDisplayLogLevel) LogMode DefaultLogMode () const void SetDefaultLogMode (const LogMode logMode)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#protected-functions","text":"Name LogManager () =default","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-getlogmanager","text":"static LogManager & GetLogManager ()","title":"function GetLogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-createlogcontext","text":"static Logger & CreateLogContext ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel )","title":"function CreateLogContext"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager","text":"~ LogManager () = default","title":"function ~LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager_1","text":"LogManager ( const LogManager & )","title":"function LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager_2","text":"LogManager ( LogManager && )","title":"function LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-operator","text":"LogManager & operator = ( const LogManager & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-operator_1","text":"LogManager & operator = ( LogManager && )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-defaultloglevel","text":"LogLevel DefaultLogLevel () const","title":"function DefaultLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-setdefaultloglevel","text":"void SetDefaultLogLevel ( const LogLevel logLevel , const LogLevelOutput logLevelOutput = LogLevelOutput :: kDisplayLogLevel )","title":"function SetDefaultLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-defaultlogmode","text":"LogMode DefaultLogMode () const","title":"function DefaultLogMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-setdefaultlogmode","text":"void SetDefaultLogMode ( const LogMode logMode )","title":"function SetDefaultLogMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogManager/#function-logmanager_3","text":"LogManager () = default Updated on 18 December 2023 at 13:11:42 CET","title":"function LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/","text":"iox::log::LogStream \ud83d\udd17 Public Functions \ud83d\udd17 Name LogStream ( Logger & logger, LogLevel logLevel =LogLevel::kWarn) virtual ~LogStream () void Flush () LogStream & operator<< (const char * cstr) LogStream & operator<< (const std::string & str) template <typename T ,typename std::enable_if< std::is_arithmetic< T >::value, int >::type =0> LogStream & operator<< (const T val) template <typename T ,typename std::enable_if< std::is_arithmetic< T >::value, int >::type =0> LogStream & operator<< (const T val) template <typename T ,typename std::enable_if< std::is_arithmetic< T >::value, int >::type =0> LogStream & operator<< (const T val) LogStream & operator<< (const LogRawBuffer & value) Public Functions Documentation \ud83d\udd17 function LogStream \ud83d\udd17 LogStream ( Logger & logger , LogLevel logLevel = LogLevel :: kWarn ) function ~LogStream \ud83d\udd17 virtual ~ LogStream () function Flush \ud83d\udd17 void Flush () function operator<< \ud83d\udd17 LogStream & operator << ( const char * cstr ) function operator<< \ud83d\udd17 LogStream & operator << ( const std :: string & str ) function operator<< \ud83d\udd17 template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > inline LogStream & operator << ( const T val ) function operator<< \ud83d\udd17 template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > inline LogStream & operator << ( const T val ) function operator<< \ud83d\udd17 template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > inline LogStream & operator << ( const T val ) function operator<< \ud83d\udd17 LogStream & operator << ( const LogRawBuffer & value ) Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#ioxloglogstream","text":"","title":"iox::log::LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#public-functions","text":"Name LogStream ( Logger & logger, LogLevel logLevel =LogLevel::kWarn) virtual ~LogStream () void Flush () LogStream & operator<< (const char * cstr) LogStream & operator<< (const std::string & str) template <typename T ,typename std::enable_if< std::is_arithmetic< T >::value, int >::type =0> LogStream & operator<< (const T val) template <typename T ,typename std::enable_if< std::is_arithmetic< T >::value, int >::type =0> LogStream & operator<< (const T val) template <typename T ,typename std::enable_if< std::is_arithmetic< T >::value, int >::type =0> LogStream & operator<< (const T val) LogStream & operator<< (const LogRawBuffer & value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-logstream","text":"LogStream ( Logger & logger , LogLevel logLevel = LogLevel :: kWarn )","title":"function LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-logstream_1","text":"virtual ~ LogStream ()","title":"function ~LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-flush","text":"void Flush ()","title":"function Flush"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator","text":"LogStream & operator << ( const char * cstr )","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_1","text":"LogStream & operator << ( const std :: string & str )","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_2","text":"template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > inline LogStream & operator << ( const T val )","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_3","text":"template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > inline LogStream & operator << ( const T val )","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_4","text":"template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > inline LogStream & operator << ( const T val )","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1LogStream/#function-operator_5","text":"LogStream & operator << ( const LogRawBuffer & value ) Updated on 18 December 2023 at 13:11:42 CET","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/","text":"iox::log::Logger \ud83d\udd17 More... #include <iceoryx_hoofs/log/logger.hpp> Public Functions \ud83d\udd17 Name Logger ( Logger && other) Logger & operator= ( Logger && rhs) Logger (const Logger & other) Logger & operator= (const Logger & rhs) LogLevel GetLogLevel () const Getter method for the current LogLevel. void SetLogLevel (const LogLevel logLevel) Sets the LogLevel for the Logger . cxx::GenericRAII SetLogLevelForScope (const LogLevel logLevel) Sets the LogLevel to the given level for the lifetime of the GenericRAII object and then sets it back to the previous one. void SetLogMode (const LogMode logMode) bool IsEnabled (const LogLevel logLevel) const LogStream LogFatal () LogStream LogError () LogStream LogWarn () LogStream LogInfo () LogStream LogDebug () LogStream LogVerbose () Protected Functions \ud83d\udd17 Name Logger (const std::string & ctxId, const std::string & ctxDescription, const LogLevel appLogLevel) virtual void Log (const LogEntry & entry) const Friends \ud83d\udd17 Name class LogManager class LogStream Detailed Description \ud83d\udd17 class iox :: log :: Logger ; Todo : for asynchronous logging, make the logger an active object according to Herb Sutter https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/ Public Functions Documentation \ud83d\udd17 function Logger \ud83d\udd17 Logger ( Logger && other ) function operator= \ud83d\udd17 Logger & operator = ( Logger && rhs ) function Logger \ud83d\udd17 Logger ( const Logger & other ) function operator= \ud83d\udd17 Logger & operator = ( const Logger & rhs ) function GetLogLevel \ud83d\udd17 LogLevel GetLogLevel () const Getter method for the current LogLevel. Return : the current LogLevel function SetLogLevel \ud83d\udd17 void SetLogLevel ( const LogLevel logLevel ) Sets the LogLevel for the Logger . Parameters : logLevel to be set function SetLogLevelForScope \ud83d\udd17 cxx :: GenericRAII SetLogLevelForScope ( const LogLevel logLevel ) Sets the LogLevel to the given level for the lifetime of the GenericRAII object and then sets it back to the previous one. Parameters : logLevel to be set temporarily Return : a scope guard which resets the LogLevel to the value at the time when this method was called function SetLogMode \ud83d\udd17 void SetLogMode ( const LogMode logMode ) function IsEnabled \ud83d\udd17 bool IsEnabled ( const LogLevel logLevel ) const function LogFatal \ud83d\udd17 LogStream LogFatal () function LogError \ud83d\udd17 LogStream LogError () function LogWarn \ud83d\udd17 LogStream LogWarn () function LogInfo \ud83d\udd17 LogStream LogInfo () function LogDebug \ud83d\udd17 LogStream LogDebug () function LogVerbose \ud83d\udd17 LogStream LogVerbose () Protected Functions Documentation \ud83d\udd17 function Logger \ud83d\udd17 Logger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appLogLevel ) function Log \ud83d\udd17 virtual void Log ( const LogEntry & entry ) const Friends \ud83d\udd17 friend LogManager \ud83d\udd17 friend class LogManager ; friend LogStream \ud83d\udd17 friend class LogStream ; Todo : LogStream needs to call Log(); do we want to make Log() public? Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#ioxloglogger","text":"More... #include <iceoryx_hoofs/log/logger.hpp>","title":"iox::log::Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#public-functions","text":"Name Logger ( Logger && other) Logger & operator= ( Logger && rhs) Logger (const Logger & other) Logger & operator= (const Logger & rhs) LogLevel GetLogLevel () const Getter method for the current LogLevel. void SetLogLevel (const LogLevel logLevel) Sets the LogLevel for the Logger . cxx::GenericRAII SetLogLevelForScope (const LogLevel logLevel) Sets the LogLevel to the given level for the lifetime of the GenericRAII object and then sets it back to the previous one. void SetLogMode (const LogMode logMode) bool IsEnabled (const LogLevel logLevel) const LogStream LogFatal () LogStream LogError () LogStream LogWarn () LogStream LogInfo () LogStream LogDebug () LogStream LogVerbose ()","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#protected-functions","text":"Name Logger (const std::string & ctxId, const std::string & ctxDescription, const LogLevel appLogLevel) virtual void Log (const LogEntry & entry) const","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friends","text":"Name class LogManager class LogStream","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#detailed-description","text":"class iox :: log :: Logger ; Todo : for asynchronous logging, make the logger an active object according to Herb Sutter https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logger","text":"Logger ( Logger && other )","title":"function Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-operator","text":"Logger & operator = ( Logger && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logger_1","text":"Logger ( const Logger & other )","title":"function Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-operator_1","text":"Logger & operator = ( const Logger & rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-getloglevel","text":"LogLevel GetLogLevel () const Getter method for the current LogLevel. Return : the current LogLevel","title":"function GetLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-setloglevel","text":"void SetLogLevel ( const LogLevel logLevel ) Sets the LogLevel for the Logger . Parameters : logLevel to be set","title":"function SetLogLevel"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-setloglevelforscope","text":"cxx :: GenericRAII SetLogLevelForScope ( const LogLevel logLevel ) Sets the LogLevel to the given level for the lifetime of the GenericRAII object and then sets it back to the previous one. Parameters : logLevel to be set temporarily Return : a scope guard which resets the LogLevel to the value at the time when this method was called","title":"function SetLogLevelForScope"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-setlogmode","text":"void SetLogMode ( const LogMode logMode )","title":"function SetLogMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-isenabled","text":"bool IsEnabled ( const LogLevel logLevel ) const","title":"function IsEnabled"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logfatal","text":"LogStream LogFatal ()","title":"function LogFatal"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logerror","text":"LogStream LogError ()","title":"function LogError"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logwarn","text":"LogStream LogWarn ()","title":"function LogWarn"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-loginfo","text":"LogStream LogInfo ()","title":"function LogInfo"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logdebug","text":"LogStream LogDebug ()","title":"function LogDebug"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logverbose","text":"LogStream LogVerbose ()","title":"function LogVerbose"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-logger_2","text":"Logger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appLogLevel )","title":"function Logger"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#function-log","text":"virtual void Log ( const LogEntry & entry ) const","title":"function Log"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friend-logmanager","text":"friend class LogManager ;","title":"friend LogManager"},{"location":"API-reference/hoofs/Classes/classiox_1_1log_1_1Logger/#friend-logstream","text":"friend class LogStream ; Todo : LogStream needs to call Log(); do we want to make Log() public? Updated on 18 December 2023 at 13:11:42 CET","title":"friend LogStream"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/","text":"iox::posix::FileLock \ud83d\udd17 Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) More... #include <iceoryx_hoofs/posix_wrapper/file_lock.hpp> Inherits from DesignPattern::Creation< FileLock, FileLockError > Public Types \ud83d\udd17 Name using cxx::string < FILENAME_LENGTH > FileName_t using cxx::string < platform::IOX_MAX_PATH_LENGTH > PathName_t Public Functions \ud83d\udd17 Name FileLock (const FileLock & ) FileLock & operator= (const FileLock & ) FileLock ( FileLock && rhs) FileLock & operator= ( FileLock && rhs) ~FileLock () Public Attributes \ud83d\udd17 Name constexpr int32_t ERROR_CODE constexpr int32_t INVALID_FD constexpr const char LOCK_FILE_SUFFIX constexpr uint64_t FILENAME_LENGTH Friends \ud83d\udd17 Name class DesignPattern::Creation< FileLock, FileLockError > Additional inherited members \ud83d\udd17 Public Types inherited from DesignPattern::Creation< FileLock, FileLockError > Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions inherited from DesignPattern::Creation< FileLock, FileLockError > Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes inherited from DesignPattern::Creation< FileLock, FileLockError > Name bool m_isInitialized ErrorType m_errorValue Detailed Description \ud83d\udd17 class iox :: posix :: FileLock ; Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) iox :: posix :: FileLock :: create ( nameOfmyLock ) . and_then ([] { std :: cout << \"We aquired the lock!\" << std :: endl ; }) . or_else ([]( auto & error ) { if ( error == FileLockError :: LOCKED_BY_OTHER_PROCESS ) { std :: cout << \"Some other process is running and holds the lock!\" << std :: endl ; } }); Public Types Documentation \ud83d\udd17 using FileName_t \ud83d\udd17 using iox :: posix :: FileLock :: FileName_t = cxx :: string < FILENAME_LENGTH > ; using PathName_t \ud83d\udd17 using iox :: posix :: FileLock :: PathName_t = cxx :: string < platform :: IOX_MAX_PATH_LENGTH > ; Public Functions Documentation \ud83d\udd17 function FileLock \ud83d\udd17 FileLock ( const FileLock & ) function operator= \ud83d\udd17 FileLock & operator = ( const FileLock & ) function FileLock \ud83d\udd17 FileLock ( FileLock && rhs ) function operator= \ud83d\udd17 FileLock & operator = ( FileLock && rhs ) function ~FileLock \ud83d\udd17 ~ FileLock () Public Attributes Documentation \ud83d\udd17 variable ERROR_CODE \ud83d\udd17 static constexpr int32_t ERROR_CODE = -1 ; variable INVALID_FD \ud83d\udd17 static constexpr int32_t INVALID_FD = -1 ; variable LOCK_FILE_SUFFIX \ud83d\udd17 static constexpr const char LOCK_FILE_SUFFIX = \".lock\" ; variable FILENAME_LENGTH \ud83d\udd17 static constexpr uint64_t FILENAME_LENGTH = platform :: IOX_MAX_FILENAME_LENGTH - sizeof ( platform :: IOX_LOCK_FILE_PATH_PREFIX ) / sizeof ( char ) - sizeof ( LOCK_FILE_SUFFIX ) / sizeof ( char ); Friends \ud83d\udd17 friend DesignPattern::Creation< FileLock, FileLockError > \ud83d\udd17 friend class DesignPattern :: Creation < FileLock , FileLockError > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#ioxposixfilelock","text":"Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) More... #include <iceoryx_hoofs/posix_wrapper/file_lock.hpp> Inherits from DesignPattern::Creation< FileLock, FileLockError >","title":"iox::posix::FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-types","text":"Name using cxx::string < FILENAME_LENGTH > FileName_t using cxx::string < platform::IOX_MAX_PATH_LENGTH > PathName_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-functions","text":"Name FileLock (const FileLock & ) FileLock & operator= (const FileLock & ) FileLock ( FileLock && rhs) FileLock & operator= ( FileLock && rhs) ~FileLock ()","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-attributes","text":"Name constexpr int32_t ERROR_CODE constexpr int32_t INVALID_FD constexpr const char LOCK_FILE_SUFFIX constexpr uint64_t FILENAME_LENGTH","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#friends","text":"Name class DesignPattern::Creation< FileLock, FileLockError >","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#additional-inherited-members","text":"Public Types inherited from DesignPattern::Creation< FileLock, FileLockError > Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions inherited from DesignPattern::Creation< FileLock, FileLockError > Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes inherited from DesignPattern::Creation< FileLock, FileLockError > Name bool m_isInitialized ErrorType m_errorValue","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#detailed-description","text":"class iox :: posix :: FileLock ; Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) iox :: posix :: FileLock :: create ( nameOfmyLock ) . and_then ([] { std :: cout << \"We aquired the lock!\" << std :: endl ; }) . or_else ([]( auto & error ) { if ( error == FileLockError :: LOCKED_BY_OTHER_PROCESS ) { std :: cout << \"Some other process is running and holds the lock!\" << std :: endl ; } });","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#using-filename_t","text":"using iox :: posix :: FileLock :: FileName_t = cxx :: string < FILENAME_LENGTH > ;","title":"using FileName_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#using-pathname_t","text":"using iox :: posix :: FileLock :: PathName_t = cxx :: string < platform :: IOX_MAX_PATH_LENGTH > ;","title":"using PathName_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-filelock","text":"FileLock ( const FileLock & )","title":"function FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-operator","text":"FileLock & operator = ( const FileLock & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-filelock_1","text":"FileLock ( FileLock && rhs )","title":"function FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-operator_1","text":"FileLock & operator = ( FileLock && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#function-filelock_2","text":"~ FileLock ()","title":"function ~FileLock"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-error_code","text":"static constexpr int32_t ERROR_CODE = -1 ;","title":"variable ERROR_CODE"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-invalid_fd","text":"static constexpr int32_t INVALID_FD = -1 ;","title":"variable INVALID_FD"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-lock_file_suffix","text":"static constexpr const char LOCK_FILE_SUFFIX = \".lock\" ;","title":"variable LOCK_FILE_SUFFIX"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#variable-filename_length","text":"static constexpr uint64_t FILENAME_LENGTH = platform :: IOX_MAX_FILENAME_LENGTH - sizeof ( platform :: IOX_LOCK_FILE_PATH_PREFIX ) / sizeof ( char ) - sizeof ( LOCK_FILE_SUFFIX ) / sizeof ( char );","title":"variable FILENAME_LENGTH"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1FileLock/#friend-designpatterncreation-filelock-filelockerror","text":"friend class DesignPattern :: Creation < FileLock , FileLockError > ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend DesignPattern::Creation&lt; FileLock, FileLockError &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/","text":"iox::posix::NamedPipe \ud83d\udd17 Inherits from DesignPattern::Creation< NamedPipe, IpcChannelError > Public Types \ud83d\udd17 Name using cxx::string < MAX_MESSAGE_SIZE > Message_t using concurrent::LockFreeQueue < Message_t , MAX_NUMBER_OF_MESSAGES > MessageQueue_t Public Functions \ud83d\udd17 Name NamedPipe (const NamedPipe & ) NamedPipe & operator= (const NamedPipe & ) NamedPipe () For compatibility with IpcChannel alias, default ctor which creates an uninitialized NamedPipe . NamedPipe ( NamedPipe && rhs) NamedPipe & operator= ( NamedPipe && rhs) ~NamedPipe () cxx::expected< IpcChannelError > destroy () destroys an initialized named pipe. cxx::expected< bool, IpcChannelError > isOutdated () for compatibility with IpcChannelError cxx::expected< IpcChannelError > trySend (const std::string & message) const tries to send a message via the named pipe. if the pipe is full IpcChannelError::TIMEOUT is returned cxx::expected< IpcChannelError > send (const std::string & message) const sends a message via the named pipe. if the pipe is full this call is blocking until the message could be delivered cxx::expected< IpcChannelError > timedSend (const std::string & message, const units::Duration & timeout) const sends a message via the named pipe. cxx::expected< std::string, IpcChannelError > tryReceive () const tries to receive a message via the named pipe. if the pipe is empty IpcChannelError::TIMEOUT is returned cxx::expected< std::string, IpcChannelError > receive () const receives a message via the named pipe. if the pipe is empty this call is blocking until a message was received cxx::expected< std::string, IpcChannelError > timedReceive (const units::Duration & timeout) const receives a message via the named pipe. cxx::expected< bool, IpcChannelError > unlinkIfExists (const IpcChannelName_t & name) removes a named pipe artifact from the system Public Attributes \ud83d\udd17 Name constexpr uint64_t MAX_MESSAGE_SIZE constexpr uint64_t MAX_NUMBER_OF_MESSAGES constexpr uint64_t NULL_TERMINATOR_SIZE constexpr units::Duration CYCLE_TIME constexpr const char NAMED_PIPE_PREFIX Friends \ud83d\udd17 Name class DesignPattern::Creation< NamedPipe, IpcChannelError > Additional inherited members \ud83d\udd17 Public Types inherited from DesignPattern::Creation< NamedPipe, IpcChannelError > Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions inherited from DesignPattern::Creation< NamedPipe, IpcChannelError > Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes inherited from DesignPattern::Creation< NamedPipe, IpcChannelError > Name bool m_isInitialized ErrorType m_errorValue Public Types Documentation \ud83d\udd17 using Message_t \ud83d\udd17 using iox :: posix :: NamedPipe :: Message_t = cxx :: string < MAX_MESSAGE_SIZE > ; using MessageQueue_t \ud83d\udd17 using iox :: posix :: NamedPipe :: MessageQueue_t = concurrent :: LockFreeQueue < Message_t , MAX_NUMBER_OF_MESSAGES > ; Public Functions Documentation \ud83d\udd17 function NamedPipe \ud83d\udd17 NamedPipe ( const NamedPipe & ) function operator= \ud83d\udd17 NamedPipe & operator = ( const NamedPipe & ) function NamedPipe \ud83d\udd17 NamedPipe () For compatibility with IpcChannel alias, default ctor which creates an uninitialized NamedPipe . function NamedPipe \ud83d\udd17 NamedPipe ( NamedPipe && rhs ) function operator= \ud83d\udd17 NamedPipe & operator = ( NamedPipe && rhs ) function ~NamedPipe \ud83d\udd17 ~ NamedPipe () function destroy \ud83d\udd17 cxx :: expected < IpcChannelError > destroy () destroys an initialized named pipe. Return : is always successful function isOutdated \ud83d\udd17 cxx :: expected < bool , IpcChannelError > isOutdated () for compatibility with IpcChannelError Return : always false function trySend \ud83d\udd17 cxx :: expected < IpcChannelError > trySend ( const std :: string & message ) const tries to send a message via the named pipe. if the pipe is full IpcChannelError::TIMEOUT is returned Return : on failure an error which describes the failure function send \ud83d\udd17 cxx :: expected < IpcChannelError > send ( const std :: string & message ) const sends a message via the named pipe. if the pipe is full this call is blocking until the message could be delivered Parameters : message the message which should be sent, is not allowed to be longer then MAX_MESSAGE_SIZE Return : success when message was sent otherwise an error which describes the failure function timedSend \ud83d\udd17 cxx :: expected < IpcChannelError > timedSend ( const std :: string & message , const units :: Duration & timeout ) const sends a message via the named pipe. Parameters : message the message which should be sent, is not allowed to be longer then MAX_MESSAGE_SIZE timeout the timeout on how long this method should retry to send the message Return : success when message was sent otherwise an error which describes the failure function tryReceive \ud83d\udd17 cxx :: expected < std :: string , IpcChannelError > tryReceive () const tries to receive a message via the named pipe. if the pipe is empty IpcChannelError::TIMEOUT is returned Return : on success a string containing the message, otherwise an error which describes the failure function receive \ud83d\udd17 cxx :: expected < std :: string , IpcChannelError > receive () const receives a message via the named pipe. if the pipe is empty this call is blocking until a message was received Return : on success a string containing the message, otherwise an error which describes the failure function timedReceive \ud83d\udd17 cxx :: expected < std :: string , IpcChannelError > timedReceive ( const units :: Duration & timeout ) const receives a message via the named pipe. Parameters : timeout the timeout on how long this method should retry to receive a message Return : on success a string containing the message, otherwise an error which describes the failure function unlinkIfExists \ud83d\udd17 static cxx :: expected < bool , IpcChannelError > unlinkIfExists ( const IpcChannelName_t & name ) removes a named pipe artifact from the system Return : true if the artifact was removed, false when no artifact was found and IpcChannelError::INTERNAL_LOGIC_ERROR when shm_unlink failed Public Attributes Documentation \ud83d\udd17 variable MAX_MESSAGE_SIZE \ud83d\udd17 static constexpr uint64_t MAX_MESSAGE_SIZE = 4U * 1024U ; variable MAX_NUMBER_OF_MESSAGES \ud83d\udd17 static constexpr uint64_t MAX_NUMBER_OF_MESSAGES = 10U ; variable NULL_TERMINATOR_SIZE \ud83d\udd17 static constexpr uint64_t NULL_TERMINATOR_SIZE = 0U ; variable CYCLE_TIME \ud83d\udd17 static constexpr units :: Duration CYCLE_TIME = units :: Duration :: fromMilliseconds ( 10 ); variable NAMED_PIPE_PREFIX \ud83d\udd17 static constexpr const char NAMED_PIPE_PREFIX = \"iox_np_\" ; Friends \ud83d\udd17 friend DesignPattern::Creation< NamedPipe, IpcChannelError > \ud83d\udd17 friend class DesignPattern :: Creation < NamedPipe , IpcChannelError > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#ioxposixnamedpipe","text":"Inherits from DesignPattern::Creation< NamedPipe, IpcChannelError >","title":"iox::posix::NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-types","text":"Name using cxx::string < MAX_MESSAGE_SIZE > Message_t using concurrent::LockFreeQueue < Message_t , MAX_NUMBER_OF_MESSAGES > MessageQueue_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-functions","text":"Name NamedPipe (const NamedPipe & ) NamedPipe & operator= (const NamedPipe & ) NamedPipe () For compatibility with IpcChannel alias, default ctor which creates an uninitialized NamedPipe . NamedPipe ( NamedPipe && rhs) NamedPipe & operator= ( NamedPipe && rhs) ~NamedPipe () cxx::expected< IpcChannelError > destroy () destroys an initialized named pipe. cxx::expected< bool, IpcChannelError > isOutdated () for compatibility with IpcChannelError cxx::expected< IpcChannelError > trySend (const std::string & message) const tries to send a message via the named pipe. if the pipe is full IpcChannelError::TIMEOUT is returned cxx::expected< IpcChannelError > send (const std::string & message) const sends a message via the named pipe. if the pipe is full this call is blocking until the message could be delivered cxx::expected< IpcChannelError > timedSend (const std::string & message, const units::Duration & timeout) const sends a message via the named pipe. cxx::expected< std::string, IpcChannelError > tryReceive () const tries to receive a message via the named pipe. if the pipe is empty IpcChannelError::TIMEOUT is returned cxx::expected< std::string, IpcChannelError > receive () const receives a message via the named pipe. if the pipe is empty this call is blocking until a message was received cxx::expected< std::string, IpcChannelError > timedReceive (const units::Duration & timeout) const receives a message via the named pipe. cxx::expected< bool, IpcChannelError > unlinkIfExists (const IpcChannelName_t & name) removes a named pipe artifact from the system","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-attributes","text":"Name constexpr uint64_t MAX_MESSAGE_SIZE constexpr uint64_t MAX_NUMBER_OF_MESSAGES constexpr uint64_t NULL_TERMINATOR_SIZE constexpr units::Duration CYCLE_TIME constexpr const char NAMED_PIPE_PREFIX","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#friends","text":"Name class DesignPattern::Creation< NamedPipe, IpcChannelError >","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#additional-inherited-members","text":"Public Types inherited from DesignPattern::Creation< NamedPipe, IpcChannelError > Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions inherited from DesignPattern::Creation< NamedPipe, IpcChannelError > Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes inherited from DesignPattern::Creation< NamedPipe, IpcChannelError > Name bool m_isInitialized ErrorType m_errorValue","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#using-message_t","text":"using iox :: posix :: NamedPipe :: Message_t = cxx :: string < MAX_MESSAGE_SIZE > ;","title":"using Message_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#using-messagequeue_t","text":"using iox :: posix :: NamedPipe :: MessageQueue_t = concurrent :: LockFreeQueue < Message_t , MAX_NUMBER_OF_MESSAGES > ;","title":"using MessageQueue_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe","text":"NamedPipe ( const NamedPipe & )","title":"function NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-operator","text":"NamedPipe & operator = ( const NamedPipe & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe_1","text":"NamedPipe () For compatibility with IpcChannel alias, default ctor which creates an uninitialized NamedPipe .","title":"function NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe_2","text":"NamedPipe ( NamedPipe && rhs )","title":"function NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-operator_1","text":"NamedPipe & operator = ( NamedPipe && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-namedpipe_3","text":"~ NamedPipe ()","title":"function ~NamedPipe"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-destroy","text":"cxx :: expected < IpcChannelError > destroy () destroys an initialized named pipe. Return : is always successful","title":"function destroy"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-isoutdated","text":"cxx :: expected < bool , IpcChannelError > isOutdated () for compatibility with IpcChannelError Return : always false","title":"function isOutdated"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-trysend","text":"cxx :: expected < IpcChannelError > trySend ( const std :: string & message ) const tries to send a message via the named pipe. if the pipe is full IpcChannelError::TIMEOUT is returned Return : on failure an error which describes the failure","title":"function trySend"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-send","text":"cxx :: expected < IpcChannelError > send ( const std :: string & message ) const sends a message via the named pipe. if the pipe is full this call is blocking until the message could be delivered Parameters : message the message which should be sent, is not allowed to be longer then MAX_MESSAGE_SIZE Return : success when message was sent otherwise an error which describes the failure","title":"function send"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-timedsend","text":"cxx :: expected < IpcChannelError > timedSend ( const std :: string & message , const units :: Duration & timeout ) const sends a message via the named pipe. Parameters : message the message which should be sent, is not allowed to be longer then MAX_MESSAGE_SIZE timeout the timeout on how long this method should retry to send the message Return : success when message was sent otherwise an error which describes the failure","title":"function timedSend"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-tryreceive","text":"cxx :: expected < std :: string , IpcChannelError > tryReceive () const tries to receive a message via the named pipe. if the pipe is empty IpcChannelError::TIMEOUT is returned Return : on success a string containing the message, otherwise an error which describes the failure","title":"function tryReceive"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-receive","text":"cxx :: expected < std :: string , IpcChannelError > receive () const receives a message via the named pipe. if the pipe is empty this call is blocking until a message was received Return : on success a string containing the message, otherwise an error which describes the failure","title":"function receive"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-timedreceive","text":"cxx :: expected < std :: string , IpcChannelError > timedReceive ( const units :: Duration & timeout ) const receives a message via the named pipe. Parameters : timeout the timeout on how long this method should retry to receive a message Return : on success a string containing the message, otherwise an error which describes the failure","title":"function timedReceive"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#function-unlinkifexists","text":"static cxx :: expected < bool , IpcChannelError > unlinkIfExists ( const IpcChannelName_t & name ) removes a named pipe artifact from the system Return : true if the artifact was removed, false when no artifact was found and IpcChannelError::INTERNAL_LOGIC_ERROR when shm_unlink failed","title":"function unlinkIfExists"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-max_message_size","text":"static constexpr uint64_t MAX_MESSAGE_SIZE = 4U * 1024U ;","title":"variable MAX_MESSAGE_SIZE"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-max_number_of_messages","text":"static constexpr uint64_t MAX_NUMBER_OF_MESSAGES = 10U ;","title":"variable MAX_NUMBER_OF_MESSAGES"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-null_terminator_size","text":"static constexpr uint64_t NULL_TERMINATOR_SIZE = 0U ;","title":"variable NULL_TERMINATOR_SIZE"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-cycle_time","text":"static constexpr units :: Duration CYCLE_TIME = units :: Duration :: fromMilliseconds ( 10 );","title":"variable CYCLE_TIME"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#variable-named_pipe_prefix","text":"static constexpr const char NAMED_PIPE_PREFIX = \"iox_np_\" ;","title":"variable NAMED_PIPE_PREFIX"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe/#friend-designpatterncreation-namedpipe-ipcchannelerror","text":"friend class DesignPattern :: Creation < NamedPipe , IpcChannelError > ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend DesignPattern::Creation&lt; NamedPipe, IpcChannelError &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/","text":"iox::posix::NamedPipe::NamedPipeData \ud83d\udd17 Public Functions \ud83d\udd17 Name NamedPipeData (bool & isInitialized, IpcChannelError & error, const uint64_t maxMsgNumber) NamedPipeData (const NamedPipeData & ) NamedPipeData (NamedPipeData && rhs) ~NamedPipeData () NamedPipeData & operator= (const NamedPipeData & ) NamedPipeData & operator= (NamedPipeData && rhs) Semaphore & sendSemaphore () Semaphore & receiveSemaphore () bool waitForInitialization () const bool hasValidState () const Public Attributes \ud83d\udd17 Name MessageQueue_t messages Public Functions Documentation \ud83d\udd17 function NamedPipeData \ud83d\udd17 NamedPipeData ( bool & isInitialized , IpcChannelError & error , const uint64_t maxMsgNumber ) function NamedPipeData \ud83d\udd17 NamedPipeData ( const NamedPipeData & ) function NamedPipeData \ud83d\udd17 NamedPipeData ( NamedPipeData && rhs ) function ~NamedPipeData \ud83d\udd17 ~ NamedPipeData () function operator= \ud83d\udd17 NamedPipeData & operator = ( const NamedPipeData & ) function operator= \ud83d\udd17 NamedPipeData & operator = ( NamedPipeData && rhs ) function sendSemaphore \ud83d\udd17 Semaphore & sendSemaphore () function receiveSemaphore \ud83d\udd17 Semaphore & receiveSemaphore () function waitForInitialization \ud83d\udd17 bool waitForInitialization () const function hasValidState \ud83d\udd17 bool hasValidState () const Public Attributes Documentation \ud83d\udd17 variable messages \ud83d\udd17 MessageQueue_t messages ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::NamedPipe::NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#ioxposixnamedpipenamedpipedata","text":"","title":"iox::posix::NamedPipe::NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-functions","text":"Name NamedPipeData (bool & isInitialized, IpcChannelError & error, const uint64_t maxMsgNumber) NamedPipeData (const NamedPipeData & ) NamedPipeData (NamedPipeData && rhs) ~NamedPipeData () NamedPipeData & operator= (const NamedPipeData & ) NamedPipeData & operator= (NamedPipeData && rhs) Semaphore & sendSemaphore () Semaphore & receiveSemaphore () bool waitForInitialization () const bool hasValidState () const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-attributes","text":"Name MessageQueue_t messages","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata","text":"NamedPipeData ( bool & isInitialized , IpcChannelError & error , const uint64_t maxMsgNumber )","title":"function NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata_1","text":"NamedPipeData ( const NamedPipeData & )","title":"function NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata_2","text":"NamedPipeData ( NamedPipeData && rhs )","title":"function NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-namedpipedata_3","text":"~ NamedPipeData ()","title":"function ~NamedPipeData"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-operator","text":"NamedPipeData & operator = ( const NamedPipeData & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-operator_1","text":"NamedPipeData & operator = ( NamedPipeData && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-sendsemaphore","text":"Semaphore & sendSemaphore ()","title":"function sendSemaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-receivesemaphore","text":"Semaphore & receiveSemaphore ()","title":"function receiveSemaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-waitforinitialization","text":"bool waitForInitialization () const","title":"function waitForInitialization"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#function-hasvalidstate","text":"bool hasValidState () const","title":"function hasValidState"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1NamedPipe_1_1NamedPipeData/#variable-messages","text":"MessageQueue_t messages ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable messages"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/","text":"iox::posix::PosixCallBuilder \ud83d\udd17 More... Public Types \ud83d\udd17 Name using ReturnType(*)(FunctionArguments...) FunctionType_t input function type Public Functions \ud83d\udd17 Name PosixCallVerificator < ReturnType > operator() (FunctionArguments... arguments) Call the underlying function with the provided arguments. If the underlying function fails and sets the errno to EINTR the call is repeated at most POSIX_CALL_EINTR_REPETITIONS times. Detailed Description \ud83d\udd17 template < typename ReturnType , typename ... FunctionArguments > class iox :: posix :: PosixCallBuilder ; Public Types Documentation \ud83d\udd17 using FunctionType_t \ud83d\udd17 using iox :: posix :: PosixCallBuilder < ReturnType , FunctionArguments >:: FunctionType_t = ReturnType ( * )( FunctionArguments ...); input function type Public Functions Documentation \ud83d\udd17 function operator() \ud83d\udd17 PosixCallVerificator < ReturnType > operator ()( FunctionArguments ... arguments ) Call the underlying function with the provided arguments. If the underlying function fails and sets the errno to EINTR the call is repeated at most POSIX_CALL_EINTR_REPETITIONS times. Parameters : arguments arguments which will be provided to the posix function Return : the PosixCallVerificator to verify the return value Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixCallBuilder"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#ioxposixposixcallbuilder","text":"More...","title":"iox::posix::PosixCallBuilder"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-types","text":"Name using ReturnType(*)(FunctionArguments...) FunctionType_t input function type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-functions","text":"Name PosixCallVerificator < ReturnType > operator() (FunctionArguments... arguments) Call the underlying function with the provided arguments. If the underlying function fails and sets the errno to EINTR the call is repeated at most POSIX_CALL_EINTR_REPETITIONS times.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#detailed-description","text":"template < typename ReturnType , typename ... FunctionArguments > class iox :: posix :: PosixCallBuilder ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#using-functiontype_t","text":"using iox :: posix :: PosixCallBuilder < ReturnType , FunctionArguments >:: FunctionType_t = ReturnType ( * )( FunctionArguments ...); input function type","title":"using FunctionType_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallBuilder/#function-operator","text":"PosixCallVerificator < ReturnType > operator ()( FunctionArguments ... arguments ) Call the underlying function with the provided arguments. If the underlying function fails and sets the errno to EINTR the call is repeated at most POSIX_CALL_EINTR_REPETITIONS times. Parameters : arguments arguments which will be provided to the posix function Return : the PosixCallVerificator to verify the return value Updated on 18 December 2023 at 13:11:42 CET","title":"function operator()"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/","text":"iox::posix::PosixCallEvaluator \ud83d\udd17 class which is created by the verificator to evaluate the result of a posix call More... #include <iceoryx_hoofs/posix_wrapper/posix_call.hpp> Public Functions \ud83d\udd17 Name template <typename... IgnoredErrnos> PosixCallEvaluator < ReturnType > ignoreErrnos (const IgnoredErrnos... ignoredErrnos) const ignore specified errnos from the evaluation template <typename... SilentErrnos> PosixCallEvaluator < ReturnType > suppressErrorMessagesForErrnos (const SilentErrnos... silentErrnos) const silence specified errnos from printing error messages in the evaluation cxx::expected< PosixCallResult < ReturnType >, PosixCallResult < ReturnType > > evaluate () const evaluate the result of a posix call Friends \ud83d\udd17 Name class PosixCallVerificator Detailed Description \ud83d\udd17 template < typename ReturnType > class iox :: posix :: PosixCallEvaluator ; class which is created by the verificator to evaluate the result of a posix call Public Functions Documentation \ud83d\udd17 function ignoreErrnos \ud83d\udd17 template < typename ... IgnoredErrnos > PosixCallEvaluator < ReturnType > ignoreErrnos ( const IgnoredErrnos ... ignoredErrnos ) const ignore specified errnos from the evaluation Parameters : ignoredErrnos the int32_t values of the errnos which should be ignored Template Parameters : IgnoredErrnos a list of int32_t variables Return : a PosixCallEvaluator for further setup of the evaluation function suppressErrorMessagesForErrnos \ud83d\udd17 template < typename ... SilentErrnos > PosixCallEvaluator < ReturnType > suppressErrorMessagesForErrnos ( const SilentErrnos ... silentErrnos ) const silence specified errnos from printing error messages in the evaluation Parameters : silentErrnos the int32_t values of the errnos which should be silent and not cause an error log Template Parameters : SilentErrnos a list of int32_t variables Return : a PosixCallEvaluator for further setup of the evaluation function evaluate \ud83d\udd17 cxx :: expected < PosixCallResult < ReturnType > , PosixCallResult < ReturnType > > evaluate () const evaluate the result of a posix call Return : returns an expected which contains in both cases a PosixCallResult with the return value (.value) and the errno value (.errnum) of the function call Friends \ud83d\udd17 friend PosixCallVerificator \ud83d\udd17 friend class PosixCallVerificator ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixCallEvaluator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#ioxposixposixcallevaluator","text":"class which is created by the verificator to evaluate the result of a posix call More... #include <iceoryx_hoofs/posix_wrapper/posix_call.hpp>","title":"iox::posix::PosixCallEvaluator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#public-functions","text":"Name template <typename... IgnoredErrnos> PosixCallEvaluator < ReturnType > ignoreErrnos (const IgnoredErrnos... ignoredErrnos) const ignore specified errnos from the evaluation template <typename... SilentErrnos> PosixCallEvaluator < ReturnType > suppressErrorMessagesForErrnos (const SilentErrnos... silentErrnos) const silence specified errnos from printing error messages in the evaluation cxx::expected< PosixCallResult < ReturnType >, PosixCallResult < ReturnType > > evaluate () const evaluate the result of a posix call","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#friends","text":"Name class PosixCallVerificator","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#detailed-description","text":"template < typename ReturnType > class iox :: posix :: PosixCallEvaluator ; class which is created by the verificator to evaluate the result of a posix call","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#function-ignoreerrnos","text":"template < typename ... IgnoredErrnos > PosixCallEvaluator < ReturnType > ignoreErrnos ( const IgnoredErrnos ... ignoredErrnos ) const ignore specified errnos from the evaluation Parameters : ignoredErrnos the int32_t values of the errnos which should be ignored Template Parameters : IgnoredErrnos a list of int32_t variables Return : a PosixCallEvaluator for further setup of the evaluation","title":"function ignoreErrnos"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#function-suppresserrormessagesforerrnos","text":"template < typename ... SilentErrnos > PosixCallEvaluator < ReturnType > suppressErrorMessagesForErrnos ( const SilentErrnos ... silentErrnos ) const silence specified errnos from printing error messages in the evaluation Parameters : silentErrnos the int32_t values of the errnos which should be silent and not cause an error log Template Parameters : SilentErrnos a list of int32_t variables Return : a PosixCallEvaluator for further setup of the evaluation","title":"function suppressErrorMessagesForErrnos"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#function-evaluate","text":"cxx :: expected < PosixCallResult < ReturnType > , PosixCallResult < ReturnType > > evaluate () const evaluate the result of a posix call Return : returns an expected which contains in both cases a PosixCallResult with the return value (.value) and the errno value (.errnum) of the function call","title":"function evaluate"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallEvaluator/#friend-posixcallverificator","text":"friend class PosixCallVerificator ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend PosixCallVerificator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/","text":"iox::posix::PosixCallVerificator \ud83d\udd17 class which verifies the return value of a posix function call More... #include <iceoryx_hoofs/posix_wrapper/posix_call.hpp> Public Functions \ud83d\udd17 Name template <typename... SuccessReturnValues> PosixCallEvaluator < ReturnType > successReturnValue (const SuccessReturnValues... successReturnValues) the posix function call defines success through a single value template <typename... FailureReturnValues> PosixCallEvaluator < ReturnType > failureReturnValue (const FailureReturnValues... failureReturnValues) the posix function call defines failure through a single value PosixCallEvaluator < ReturnType > returnValueMatchesErrno () the posix function call defines failure through return of the errno value instead of setting the errno Friends \ud83d\udd17 Name class PosixCallBuilder Detailed Description \ud83d\udd17 template < typename ReturnType > class iox :: posix :: PosixCallVerificator ; class which verifies the return value of a posix function call Public Functions Documentation \ud83d\udd17 function successReturnValue \ud83d\udd17 template < typename ... SuccessReturnValues > PosixCallEvaluator < ReturnType > successReturnValue ( const SuccessReturnValues ... successReturnValues ) the posix function call defines success through a single value Parameters : successReturnValues a list of values which define success Return : the PosixCallEvaluator which evaluates the errno values function failureReturnValue \ud83d\udd17 template < typename ... FailureReturnValues > PosixCallEvaluator < ReturnType > failureReturnValue ( const FailureReturnValues ... failureReturnValues ) the posix function call defines failure through a single value Parameters : failureReturnValues a list of values which define failure Return : the PosixCallEvaluator which evaluates the errno values function returnValueMatchesErrno \ud83d\udd17 PosixCallEvaluator < ReturnType > returnValueMatchesErrno () the posix function call defines failure through return of the errno value instead of setting the errno Return : the PosixCallEvaluator which evaluates the errno values Friends \ud83d\udd17 friend PosixCallBuilder \ud83d\udd17 friend class PosixCallBuilder ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixCallVerificator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#ioxposixposixcallverificator","text":"class which verifies the return value of a posix function call More... #include <iceoryx_hoofs/posix_wrapper/posix_call.hpp>","title":"iox::posix::PosixCallVerificator"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#public-functions","text":"Name template <typename... SuccessReturnValues> PosixCallEvaluator < ReturnType > successReturnValue (const SuccessReturnValues... successReturnValues) the posix function call defines success through a single value template <typename... FailureReturnValues> PosixCallEvaluator < ReturnType > failureReturnValue (const FailureReturnValues... failureReturnValues) the posix function call defines failure through a single value PosixCallEvaluator < ReturnType > returnValueMatchesErrno () the posix function call defines failure through return of the errno value instead of setting the errno","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#friends","text":"Name class PosixCallBuilder","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#detailed-description","text":"template < typename ReturnType > class iox :: posix :: PosixCallVerificator ; class which verifies the return value of a posix function call","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#function-successreturnvalue","text":"template < typename ... SuccessReturnValues > PosixCallEvaluator < ReturnType > successReturnValue ( const SuccessReturnValues ... successReturnValues ) the posix function call defines success through a single value Parameters : successReturnValues a list of values which define success Return : the PosixCallEvaluator which evaluates the errno values","title":"function successReturnValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#function-failurereturnvalue","text":"template < typename ... FailureReturnValues > PosixCallEvaluator < ReturnType > failureReturnValue ( const FailureReturnValues ... failureReturnValues ) the posix function call defines failure through a single value Parameters : failureReturnValues a list of values which define failure Return : the PosixCallEvaluator which evaluates the errno values","title":"function failureReturnValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#function-returnvaluematcheserrno","text":"PosixCallEvaluator < ReturnType > returnValueMatchesErrno () the posix function call defines failure through return of the errno value instead of setting the errno Return : the PosixCallEvaluator which evaluates the errno values","title":"function returnValueMatchesErrno"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixCallVerificator/#friend-posixcallbuilder","text":"friend class PosixCallBuilder ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend PosixCallBuilder"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/","text":"iox::posix::PosixGroup \ud83d\udd17 Public Types \ud83d\udd17 Name using cxx::string < 100 > string_t Public Functions \ud83d\udd17 Name PosixGroup (const gid_t f_id) PosixGroup (const string_t & f_name) bool operator== (const PosixGroup & other) const string_t getName () const gid_t getID () const bool doesExist () const PosixGroup getGroupOfCurrentProcess () cxx::optional < uid_t > getGroupID (const string_t & f_name) cxx::optional < string_t > getGroupName (gid_t f_id) Public Types Documentation \ud83d\udd17 using string_t \ud83d\udd17 using iox :: posix :: PosixGroup :: string_t = cxx :: string < 100 > ; Public Functions Documentation \ud83d\udd17 function PosixGroup \ud83d\udd17 explicit PosixGroup ( const gid_t f_id ) function PosixGroup \ud83d\udd17 explicit PosixGroup ( const string_t & f_name ) function operator== \ud83d\udd17 bool operator == ( const PosixGroup & other ) const function getName \ud83d\udd17 string_t getName () const function getID \ud83d\udd17 gid_t getID () const function doesExist \ud83d\udd17 bool doesExist () const function getGroupOfCurrentProcess \ud83d\udd17 static PosixGroup getGroupOfCurrentProcess () function getGroupID \ud83d\udd17 static cxx :: optional < uid_t > getGroupID ( const string_t & f_name ) function getGroupName \ud83d\udd17 static cxx :: optional < string_t > getGroupName ( gid_t f_id ) Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#ioxposixposixgroup","text":"","title":"iox::posix::PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-types","text":"Name using cxx::string < 100 > string_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-functions","text":"Name PosixGroup (const gid_t f_id) PosixGroup (const string_t & f_name) bool operator== (const PosixGroup & other) const string_t getName () const gid_t getID () const bool doesExist () const PosixGroup getGroupOfCurrentProcess () cxx::optional < uid_t > getGroupID (const string_t & f_name) cxx::optional < string_t > getGroupName (gid_t f_id)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#using-string_t","text":"using iox :: posix :: PosixGroup :: string_t = cxx :: string < 100 > ;","title":"using string_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-posixgroup","text":"explicit PosixGroup ( const gid_t f_id )","title":"function PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-posixgroup_1","text":"explicit PosixGroup ( const string_t & f_name )","title":"function PosixGroup"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-operator","text":"bool operator == ( const PosixGroup & other ) const","title":"function operator=="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getname","text":"string_t getName () const","title":"function getName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getid","text":"gid_t getID () const","title":"function getID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-doesexist","text":"bool doesExist () const","title":"function doesExist"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getgroupofcurrentprocess","text":"static PosixGroup getGroupOfCurrentProcess ()","title":"function getGroupOfCurrentProcess"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getgroupid","text":"static cxx :: optional < uid_t > getGroupID ( const string_t & f_name )","title":"function getGroupID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixGroup/#function-getgroupname","text":"static cxx :: optional < string_t > getGroupName ( gid_t f_id ) Updated on 18 December 2023 at 13:11:42 CET","title":"function getGroupName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/","text":"iox::posix::PosixUser \ud83d\udd17 Public Types \ud83d\udd17 Name using cxx::vector < PosixGroup , MaxNumberOfGroups > groupVector_t using cxx::string < 100 > string_t Public Functions \ud83d\udd17 Name PosixUser (const uid_t f_id) PosixUser (const string_t & f_name) groupVector_t getGroups () const string_t getName () const uid_t getID () const bool doesExist () const PosixUser getUserOfCurrentProcess () cxx::optional < uid_t > getUserID (const string_t & f_name) cxx::optional < string_t > getUserName (uid_t f_id) Public Types Documentation \ud83d\udd17 using groupVector_t \ud83d\udd17 using iox :: posix :: PosixUser :: groupVector_t = cxx :: vector < PosixGroup , MaxNumberOfGroups > ; using string_t \ud83d\udd17 using iox :: posix :: PosixUser :: string_t = cxx :: string < 100 > ; Public Functions Documentation \ud83d\udd17 function PosixUser \ud83d\udd17 explicit PosixUser ( const uid_t f_id ) function PosixUser \ud83d\udd17 explicit PosixUser ( const string_t & f_name ) function getGroups \ud83d\udd17 groupVector_t getGroups () const function getName \ud83d\udd17 string_t getName () const function getID \ud83d\udd17 uid_t getID () const function doesExist \ud83d\udd17 bool doesExist () const function getUserOfCurrentProcess \ud83d\udd17 static PosixUser getUserOfCurrentProcess () function getUserID \ud83d\udd17 static cxx :: optional < uid_t > getUserID ( const string_t & f_name ) function getUserName \ud83d\udd17 static cxx :: optional < string_t > getUserName ( uid_t f_id ) Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#ioxposixposixuser","text":"","title":"iox::posix::PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-types","text":"Name using cxx::vector < PosixGroup , MaxNumberOfGroups > groupVector_t using cxx::string < 100 > string_t","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-functions","text":"Name PosixUser (const uid_t f_id) PosixUser (const string_t & f_name) groupVector_t getGroups () const string_t getName () const uid_t getID () const bool doesExist () const PosixUser getUserOfCurrentProcess () cxx::optional < uid_t > getUserID (const string_t & f_name) cxx::optional < string_t > getUserName (uid_t f_id)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#using-groupvector_t","text":"using iox :: posix :: PosixUser :: groupVector_t = cxx :: vector < PosixGroup , MaxNumberOfGroups > ;","title":"using groupVector_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#using-string_t","text":"using iox :: posix :: PosixUser :: string_t = cxx :: string < 100 > ;","title":"using string_t"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-posixuser","text":"explicit PosixUser ( const uid_t f_id )","title":"function PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-posixuser_1","text":"explicit PosixUser ( const string_t & f_name )","title":"function PosixUser"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getgroups","text":"groupVector_t getGroups () const","title":"function getGroups"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getname","text":"string_t getName () const","title":"function getName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getid","text":"uid_t getID () const","title":"function getID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-doesexist","text":"bool doesExist () const","title":"function doesExist"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getuserofcurrentprocess","text":"static PosixUser getUserOfCurrentProcess ()","title":"function getUserOfCurrentProcess"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getuserid","text":"static cxx :: optional < uid_t > getUserID ( const string_t & f_name )","title":"function getUserID"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1PosixUser/#function-getusername","text":"static cxx :: optional < string_t > getUserName ( uid_t f_id ) Updated on 18 December 2023 at 13:11:42 CET","title":"function getUserName"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/","text":"iox::posix::Semaphore \ud83d\udd17 Posix semaphore C++ Wrapping class. More... #include <iceoryx_hoofs/posix_wrapper/semaphore.hpp> Inherits from DesignPattern::Creation< Semaphore, SemaphoreError > Public Functions \ud83d\udd17 Name Semaphore () Default constructor which creates an uninitialized semaphore. This semaphore object is unusable you need to reassign it with an object created by the semaphore factory methods. Semaphore ( Semaphore && rhs) Move constructor. Semaphore & operator= ( Semaphore && rhs) Move assignment operator. Semaphore (const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. Semaphore & operator= (const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. ~Semaphore () Destructor. cxx::expected< int, SemaphoreError > getValue () const calls sem_getvalue which gets the value of a semaphore From the sem_getvalue manpage: sem_getvalue() places the current value of the semaphore pointed to sem into the integer pointed to by sval. cxx::expected< SemaphoreError > post () calls sem_post which unlocks a semaphore From the sem_post manpage: sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. cxx::expected< SemaphoreWaitState, SemaphoreError > timedWait (const units::Duration abs_timeout) see wait() cxx::expected< bool, SemaphoreError > tryWait () see wait() cxx::expected< SemaphoreError > wait () calls sem_wait which locks a semaphore From the sem_wait manpage: sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call. Friends \ud83d\udd17 Name class DesignPattern::Creation< Semaphore, SemaphoreError > Additional inherited members \ud83d\udd17 Public Types inherited from DesignPattern::Creation< Semaphore, SemaphoreError > Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions inherited from DesignPattern::Creation< Semaphore, SemaphoreError > Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes inherited from DesignPattern::Creation< Semaphore, SemaphoreError > Name bool m_isInitialized ErrorType m_errorValue Detailed Description \ud83d\udd17 class iox :: posix :: Semaphore ; Posix semaphore C++ Wrapping class. auto semaphore = posix :: Semaphore :: CreateUnnamed ( false , 5 ); int value ; if ( semaphore . getValue ( value ) ) // no error has occurred { std :: cout << value << std :: endl ; } Public Functions Documentation \ud83d\udd17 function Semaphore \ud83d\udd17 Semaphore () Default constructor which creates an uninitialized semaphore. This semaphore object is unusable you need to reassign it with an object created by the semaphore factory methods. function Semaphore \ud83d\udd17 Semaphore ( Semaphore && rhs ) Move constructor. function operator= \ud83d\udd17 Semaphore & operator = ( Semaphore && rhs ) Move assignment operator. function Semaphore \ud83d\udd17 Semaphore ( const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. function operator= \ud83d\udd17 Semaphore & operator = ( const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. function ~Semaphore \ud83d\udd17 ~ Semaphore () Destructor. function getValue \ud83d\udd17 cxx :: expected < int , SemaphoreError > getValue () const calls sem_getvalue which gets the value of a semaphore From the sem_getvalue manpage: sem_getvalue() places the current value of the semaphore pointed to sem into the integer pointed to by sval. Parameters : value reference in which the value of the semaphore is written to Return : expected which contains either the value of the semaphore or the cause why the value could not be retrieved If one or more processes or threads are blocked waiting to lock the semaphore with sem_wait(3), POSIX.1 permits two possibilities for the value returned in sval: either 0 is returned; or a negative number whose absolute value is the count of the number of processes and threads currently blocked in sem_wait(3). Linux adopts the former behavior. function post \ud83d\udd17 cxx :: expected < SemaphoreError > post () calls sem_post which unlocks a semaphore From the sem_post manpage: sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. Return : if post fails the expected contains the error which occurred function timedWait \ud83d\udd17 cxx :: expected < SemaphoreWaitState , SemaphoreError > timedWait ( const units :: Duration abs_timeout ) see wait() Parameters : abs_timeout timeout of the wait Return : when successful the SemaphoreWaitState states if a timeout happened or not otherwise the SemaphoreError contains the error function tryWait \ud83d\udd17 cxx :: expected < bool , SemaphoreError > tryWait () see wait() Return : if the semaphore was decremented the expected contains the value true otherwise false. if an error occurred it is stored inside the expected function wait \ud83d\udd17 cxx :: expected < SemaphoreError > wait () calls sem_wait which locks a semaphore From the sem_wait manpage: sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call. Return : if an error during the call occurs the error value is set iox_sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking. iox_sem_timedwait() is the same as sem_wait(), except that abs_timeout specifies a limit on the amount of time that the call should block if the decrement cannot be immediately performed. If the timeout has already expired by the time of the call, and the semaphore could not be locked immediately, then iox_sem_timedwait() fails with a timeout error (errno set to ETIMEDOUT). If the operation can be performed immediately, then iox_sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout. Furthermore, the validity of abs_timeout is not checked in this case. Friends \ud83d\udd17 friend DesignPattern::Creation< Semaphore, SemaphoreError > \ud83d\udd17 friend class DesignPattern :: Creation < Semaphore , SemaphoreError > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#ioxposixsemaphore","text":"Posix semaphore C++ Wrapping class. More... #include <iceoryx_hoofs/posix_wrapper/semaphore.hpp> Inherits from DesignPattern::Creation< Semaphore, SemaphoreError >","title":"iox::posix::Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#public-functions","text":"Name Semaphore () Default constructor which creates an uninitialized semaphore. This semaphore object is unusable you need to reassign it with an object created by the semaphore factory methods. Semaphore ( Semaphore && rhs) Move constructor. Semaphore & operator= ( Semaphore && rhs) Move assignment operator. Semaphore (const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. Semaphore & operator= (const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying. ~Semaphore () Destructor. cxx::expected< int, SemaphoreError > getValue () const calls sem_getvalue which gets the value of a semaphore From the sem_getvalue manpage: sem_getvalue() places the current value of the semaphore pointed to sem into the integer pointed to by sval. cxx::expected< SemaphoreError > post () calls sem_post which unlocks a semaphore From the sem_post manpage: sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. cxx::expected< SemaphoreWaitState, SemaphoreError > timedWait (const units::Duration abs_timeout) see wait() cxx::expected< bool, SemaphoreError > tryWait () see wait() cxx::expected< SemaphoreError > wait () calls sem_wait which locks a semaphore From the sem_wait manpage: sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call.","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#friends","text":"Name class DesignPattern::Creation< Semaphore, SemaphoreError >","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#additional-inherited-members","text":"Public Types inherited from DesignPattern::Creation< Semaphore, SemaphoreError > Name using Creation < DerivedClass, ErrorType > CreationPattern_t using iox::cxx::expected< DerivedClass, ErrorType > result_t using ErrorType errorType_t Public Functions inherited from DesignPattern::Creation< Semaphore, SemaphoreError > Name template <typename... Targs> result_t create (Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction result_t verify (DerivedClass && newObject) verifies if a class was created successfully template <typename... Targs> iox::cxx::expected< ErrorType > placementCreate (void *const memory, Targs &&... args) factory method which guarantees that either a working object is produced or an error value describing the error during construction Creation () =default Creation ( Creation && rhs) Creation (const Creation & rhs) =default bool isInitialized () const returns true if the object was constructed successfully, otherwise false Protected Attributes inherited from DesignPattern::Creation< Semaphore, SemaphoreError > Name bool m_isInitialized ErrorType m_errorValue","title":"Additional inherited members"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#detailed-description","text":"class iox :: posix :: Semaphore ; Posix semaphore C++ Wrapping class. auto semaphore = posix :: Semaphore :: CreateUnnamed ( false , 5 ); int value ; if ( semaphore . getValue ( value ) ) // no error has occurred { std :: cout << value << std :: endl ; }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore","text":"Semaphore () Default constructor which creates an uninitialized semaphore. This semaphore object is unusable you need to reassign it with an object created by the semaphore factory methods.","title":"function Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore_1","text":"Semaphore ( Semaphore && rhs ) Move constructor.","title":"function Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-operator","text":"Semaphore & operator = ( Semaphore && rhs ) Move assignment operator.","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore_2","text":"Semaphore ( const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying.","title":"function Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-operator_1","text":"Semaphore & operator = ( const Semaphore & ) We are denying Semaphore copy since it manages the semaphore resource and the underlying concept did not include copying.","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-semaphore_3","text":"~ Semaphore () Destructor.","title":"function ~Semaphore"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-getvalue","text":"cxx :: expected < int , SemaphoreError > getValue () const calls sem_getvalue which gets the value of a semaphore From the sem_getvalue manpage: sem_getvalue() places the current value of the semaphore pointed to sem into the integer pointed to by sval. Parameters : value reference in which the value of the semaphore is written to Return : expected which contains either the value of the semaphore or the cause why the value could not be retrieved If one or more processes or threads are blocked waiting to lock the semaphore with sem_wait(3), POSIX.1 permits two possibilities for the value returned in sval: either 0 is returned; or a negative number whose absolute value is the count of the number of processes and threads currently blocked in sem_wait(3). Linux adopts the former behavior.","title":"function getValue"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-post","text":"cxx :: expected < SemaphoreError > post () calls sem_post which unlocks a semaphore From the sem_post manpage: sem_post() increments (unlocks) the semaphore pointed to by sem. If the semaphore's value consequently becomes greater than zero, then another process or thread blocked in a sem_wait(3) call will be woken up and proceed to lock the semaphore. Return : if post fails the expected contains the error which occurred","title":"function post"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-timedwait","text":"cxx :: expected < SemaphoreWaitState , SemaphoreError > timedWait ( const units :: Duration abs_timeout ) see wait() Parameters : abs_timeout timeout of the wait Return : when successful the SemaphoreWaitState states if a timeout happened or not otherwise the SemaphoreError contains the error","title":"function timedWait"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-trywait","text":"cxx :: expected < bool , SemaphoreError > tryWait () see wait() Return : if the semaphore was decremented the expected contains the value true otherwise false. if an error occurred it is stored inside the expected","title":"function tryWait"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#function-wait","text":"cxx :: expected < SemaphoreError > wait () calls sem_wait which locks a semaphore From the sem_wait manpage: sem_wait() decrements (locks) the semaphore pointed to by sem. If the semaphore's value is greater than zero, then the decrement proceeds, and the function returns, immediately. If the semaphore currently has the value zero, then the call blocks until either it becomes possible to perform the decrement (i.e., the semaphore value rises above zero), or a signal handler interrupts the call. Return : if an error during the call occurs the error value is set iox_sem_trywait() is the same as sem_wait(), except that if the decrement cannot be immediately performed, then call returns an error (errno set to EAGAIN) instead of blocking. iox_sem_timedwait() is the same as sem_wait(), except that abs_timeout specifies a limit on the amount of time that the call should block if the decrement cannot be immediately performed. If the timeout has already expired by the time of the call, and the semaphore could not be locked immediately, then iox_sem_timedwait() fails with a timeout error (errno set to ETIMEDOUT). If the operation can be performed immediately, then iox_sem_timedwait() never fails with a timeout error, regardless of the value of abs_timeout. Furthermore, the validity of abs_timeout is not checked in this case.","title":"function wait"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Semaphore/#friend-designpatterncreation-semaphore-semaphoreerror","text":"friend class DesignPattern :: Creation < Semaphore , SemaphoreError > ; Updated on 18 December 2023 at 13:11:42 CET","title":"friend DesignPattern::Creation&lt; Semaphore, SemaphoreError &gt;"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/","text":"iox::posix::SignalGuard \ud83d\udd17 The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. More... #include <iceoryx_hoofs/posix_wrapper/signal_handler.hpp> Public Functions \ud83d\udd17 Name SignalGuard ( SignalGuard && rhs) SignalGuard (const SignalGuard & ) ~SignalGuard () SignalGuard & operator= (const SignalGuard & rhs) SignalGuard & operator= ( SignalGuard && rhs) Friends \ud83d\udd17 Name SignalGuard registerSignalHandler * (const Signal, const SignalHandlerCallback_t) Register a callback for a specific posix signal (SIG ). Detailed Description \ud83d\udd17 class iox :: posix :: SignalGuard ; The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. Attention : NEVER USE THIS CLASS AS A MEMBER VARIABLE! A class which should be used only in method/function scopes. { auto signalGuard = registerSignalHandler ( Signal :: BUS , printErrorMessage ); my_c_call_which_can_cause_SIGBUS (); } // here we are out of scope and the signal action for Signal::BUS is restored Public Functions Documentation \ud83d\udd17 function SignalGuard \ud83d\udd17 SignalGuard ( SignalGuard && rhs ) function SignalGuard \ud83d\udd17 SignalGuard ( const SignalGuard & ) function ~SignalGuard \ud83d\udd17 ~ SignalGuard () function operator= \ud83d\udd17 SignalGuard & operator = ( const SignalGuard & rhs ) function operator= \ud83d\udd17 SignalGuard & operator = ( SignalGuard && rhs ) Friends \ud83d\udd17 friend registerSignalHandler \ud83d\udd17 friend SignalGuard registerSignalHandler ( const Signal , const SignalHandlerCallback_t ); Register a callback for a specific posix signal (SIG***). Parameters : Signal the signal to which the callback should be attached callback the callback which should be called when the signal is raised. Return : SignalGuard , when it goes out of scope the previous signal action is restored. Attention : if a signal callback was already registered for the provided signal with registerSignalHandler or with sigaction() or signal(), the signal callback is overridden until the SignalGuard goes out of scope and restores the previous callback. If you override the callbacks multiple times and the created SignalGuards goes out of scope in a different order then the callback is restored which was active when the last SignalGuard which is going out of scope was created. Updated on 18 December 2023 at 13:11:42 CET","title":"classiox 1 1posix 1 1SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#ioxposixsignalguard","text":"The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. More... #include <iceoryx_hoofs/posix_wrapper/signal_handler.hpp>","title":"iox::posix::SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#public-functions","text":"Name SignalGuard ( SignalGuard && rhs) SignalGuard (const SignalGuard & ) ~SignalGuard () SignalGuard & operator= (const SignalGuard & rhs) SignalGuard & operator= ( SignalGuard && rhs)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#friends","text":"Name SignalGuard registerSignalHandler * (const Signal, const SignalHandlerCallback_t) Register a callback for a specific posix signal (SIG ).","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#detailed-description","text":"class iox :: posix :: SignalGuard ; The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. Attention : NEVER USE THIS CLASS AS A MEMBER VARIABLE! A class which should be used only in method/function scopes. { auto signalGuard = registerSignalHandler ( Signal :: BUS , printErrorMessage ); my_c_call_which_can_cause_SIGBUS (); } // here we are out of scope and the signal action for Signal::BUS is restored","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-signalguard","text":"SignalGuard ( SignalGuard && rhs )","title":"function SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-signalguard_1","text":"SignalGuard ( const SignalGuard & )","title":"function SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-signalguard_2","text":"~ SignalGuard ()","title":"function ~SignalGuard"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-operator","text":"SignalGuard & operator = ( const SignalGuard & rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#function-operator_1","text":"SignalGuard & operator = ( SignalGuard && rhs )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalGuard/#friend-registersignalhandler","text":"friend SignalGuard registerSignalHandler ( const Signal , const SignalHandlerCallback_t ); Register a callback for a specific posix signal (SIG***). Parameters : Signal the signal to which the callback should be attached callback the callback which should be called when the signal is raised. Return : SignalGuard , when it goes out of scope the previous signal action is restored. Attention : if a signal callback was already registered for the provided signal with registerSignalHandler or with sigaction() or signal(), the signal callback is overridden until the SignalGuard goes out of scope and restores the previous callback. If you override the callbacks multiple times and the created SignalGuards goes out of scope in a different order then the callback is restored which was active when the last SignalGuard which is going out of scope was created. Updated on 18 December 2023 at 13:11:42 CET","title":"friend registerSignalHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/","text":"iox::posix::SignalWatcher \ud83d\udd17 The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. More... #include <iceoryx_hoofs/posix_wrapper/signal_watcher.hpp> Public Functions \ud83d\udd17 Name SignalWatcher (const SignalWatcher & ) SignalWatcher ( SignalWatcher && ) ~SignalWatcher () =default SignalWatcher & operator= (const SignalWatcher & ) SignalWatcher & operator= ( SignalWatcher && ) void waitForSignal () const Blocks until either SIGTERM or SIGINT has occurred. bool wasSignalTriggered () const Returns true when SIGTERM or SIGINT has occurred, otherwise false. SignalWatcher & getInstance () Returns the singleton instance of the SignalWatcher . Protected Functions \ud83d\udd17 Name SignalWatcher () Friends \ud83d\udd17 Name void internalSignalHandler (int ) Detailed Description \ud83d\udd17 class iox :: posix :: SignalWatcher ; The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. // can be used to loop until SIGINT or SIGTERM has occurred #include <iceoryx_hoofs/posix/signal_watcher.hpp> void loopUntilTerminationRequested () { while ( ! iox :: posix :: hasTerminationRequested ()) { // your algorithm } } // another possibility is to block until SIGINT or SIGTERM has occurred void blockUntilCtrlC () { // your objects which spawn threads iox :: posix :: waitForTerminationRequest (); } Public Functions Documentation \ud83d\udd17 function SignalWatcher \ud83d\udd17 SignalWatcher ( const SignalWatcher & ) function SignalWatcher \ud83d\udd17 SignalWatcher ( SignalWatcher && ) function ~SignalWatcher \ud83d\udd17 ~ SignalWatcher () = default function operator= \ud83d\udd17 SignalWatcher & operator = ( const SignalWatcher & ) function operator= \ud83d\udd17 SignalWatcher & operator = ( SignalWatcher && ) function waitForSignal \ud83d\udd17 void waitForSignal () const Blocks until either SIGTERM or SIGINT has occurred. function wasSignalTriggered \ud83d\udd17 bool wasSignalTriggered () const Returns true when SIGTERM or SIGINT has occurred, otherwise false. function getInstance \ud83d\udd17 static SignalWatcher & getInstance () Returns the singleton instance of the SignalWatcher . Protected Functions Documentation \ud83d\udd17 function SignalWatcher \ud83d\udd17 SignalWatcher () Friends \ud83d\udd17 friend internalSignalHandler \ud83d\udd17 friend void internalSignalHandler ( int ); Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#ioxposixsignalwatcher","text":"The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. More... #include <iceoryx_hoofs/posix_wrapper/signal_watcher.hpp>","title":"iox::posix::SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#public-functions","text":"Name SignalWatcher (const SignalWatcher & ) SignalWatcher ( SignalWatcher && ) ~SignalWatcher () =default SignalWatcher & operator= (const SignalWatcher & ) SignalWatcher & operator= ( SignalWatcher && ) void waitForSignal () const Blocks until either SIGTERM or SIGINT has occurred. bool wasSignalTriggered () const Returns true when SIGTERM or SIGINT has occurred, otherwise false. SignalWatcher & getInstance () Returns the singleton instance of the SignalWatcher .","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#protected-functions","text":"Name SignalWatcher ()","title":"Protected Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#friends","text":"Name void internalSignalHandler (int )","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#detailed-description","text":"class iox :: posix :: SignalWatcher ; The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. // can be used to loop until SIGINT or SIGTERM has occurred #include <iceoryx_hoofs/posix/signal_watcher.hpp> void loopUntilTerminationRequested () { while ( ! iox :: posix :: hasTerminationRequested ()) { // your algorithm } } // another possibility is to block until SIGINT or SIGTERM has occurred void blockUntilCtrlC () { // your objects which spawn threads iox :: posix :: waitForTerminationRequest (); }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher","text":"SignalWatcher ( const SignalWatcher & )","title":"function SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher_1","text":"SignalWatcher ( SignalWatcher && )","title":"function SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher_2","text":"~ SignalWatcher () = default","title":"function ~SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-operator","text":"SignalWatcher & operator = ( const SignalWatcher & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-operator_1","text":"SignalWatcher & operator = ( SignalWatcher && )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-waitforsignal","text":"void waitForSignal () const Blocks until either SIGTERM or SIGINT has occurred.","title":"function waitForSignal"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-wassignaltriggered","text":"bool wasSignalTriggered () const Returns true when SIGTERM or SIGINT has occurred, otherwise false.","title":"function wasSignalTriggered"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-getinstance","text":"static SignalWatcher & getInstance () Returns the singleton instance of the SignalWatcher .","title":"function getInstance"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#function-signalwatcher_3","text":"SignalWatcher ()","title":"function SignalWatcher"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#friends_1","text":"","title":"Friends"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1SignalWatcher/#friend-internalsignalhandler","text":"friend void internalSignalHandler ( int ); Updated on 18 December 2023 at 13:11:42 CET","title":"friend internalSignalHandler"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/","text":"iox::posix::Timer \ud83d\udd17 Interface for timers on POSIX operating systems. More... #include <iceoryx_hoofs/posix_wrapper/timer.hpp> Public Types \ud83d\udd17 Name enum RunMode { ONCE, PERIODIC} enum CatchUpPolicy { SKIP_TO_NEXT_BEAT, IMMEDIATE, TERMINATE} defines the behavior of the timer when the callback runtime is greater than the periodic trigger time. SKIP_TO_NEXT_BEAT skip callback and call it in the next cycle IMMEDIATE call the callback right after the currently running callback is finished TERMINATE terminates the process by calling the errorHandler with POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME Public Functions \ud83d\udd17 Name Timer (const units::Duration timeToWait) Creates a timer without an operating system callback. Timer (const units::Duration timeToWait, const std::function< void()> & callback) Creates a timer with an operating system callback. Timer (const Timer & other) Move or semantics are forbidden as address of object is not allowed to change. Timer ( Timer && other) Move or semantics are forbidden as address of object is not allowed to change. Timer & operator= (const Timer & other) Move or semantics are forbidden as address of object is not allowed to change. Timer & operator= ( Timer && other) Move or semantics are forbidden as address of object is not allowed to change. virtual ~Timer () =default D'tor. cxx::expected< TimerError > start (const RunMode runMode, const CatchUpPolicy catchUpPolicy) Starts the timer. cxx::expected< TimerError > stop () Disarms the timer. cxx::expected< TimerError > restart (const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy) Disarms the timer, assigns a new timeToWait value and arms the timer. cxx::expected< units::Duration, TimerError > timeUntilExpiration () cxx::expected< uint64_t, TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. bool hasError () const Returns true if the construction of the object was successful. TimerError getError () const Returns the error that occured on constructing the object. cxx::expected< units::Duration, TimerError > now () creates Duration from the result of clock_gettime(CLOCK_REALTIME, ...) Detailed Description \ud83d\udd17 class iox :: posix :: Timer ; Interface for timers on POSIX operating systems. Note : Can't be copied or moved as operating system has a pointer to this object. It needs to be ensured that this object lives longer than timeToWait, otherwise the operating system will unregister the timer posix :: Timer TiborTheTimer { 100 _ms , [ & ]() { fooBar ++ ; }}; // Start a periodic timer TiborTheTimer . start ( true ); // [.. wait ..] // Timer fires after 100_ms and calls the lambda which increments fooBar TiborTheTimer . stop (); This class will be DEPRECATED in the near future. In its current form there may still be potential races when start/stop/restart are called concurrently (this includes the callback, which is executed in a separate thread). The implementation also has too much overhead in the callback execution (due to execution logic and potentially multiple callback threads). It will be replaced with simpler versions for individual use cases, such as a CountdownTimer which can be used for watchdog/keepalive purposes. Public Types Documentation \ud83d\udd17 enum RunMode \ud83d\udd17 Enumerator Value Description ONCE PERIODIC enum CatchUpPolicy \ud83d\udd17 Enumerator Value Description SKIP_TO_NEXT_BEAT IMMEDIATE TERMINATE defines the behavior of the timer when the callback runtime is greater than the periodic trigger time. SKIP_TO_NEXT_BEAT skip callback and call it in the next cycle IMMEDIATE call the callback right after the currently running callback is finished TERMINATE terminates the process by calling the errorHandler with POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME Public Functions Documentation \ud83d\udd17 function Timer \ud83d\udd17 Timer ( const units :: Duration timeToWait ) Creates a timer without an operating system callback. Parameters : timeToWait - How long should be waited? Note : Does not set up an operating system timer, but uses CLOCK_REALTIME instead Todo : refactor this cTor and its functionality to a class called StopWatch Creates a light-weight timer object that can be used with hasExpiredComparedToCreationTime() resetCreationTime() function Timer \ud83d\udd17 Timer ( const units :: Duration timeToWait , const std :: function < void () > & callback ) Creates a timer with an operating system callback. Parameters : timeToWait - How long should be waited? callback - Function called after timeToWait (User needs to ensure lifetime of function till stop() call) Note : Operating systems needs a valid reference to this object, hence DesignPattern::Creation can't be used Initially the timer is stopped. function Timer \ud83d\udd17 Timer ( const Timer & other ) Move or semantics are forbidden as address of object is not allowed to change. function Timer \ud83d\udd17 Timer ( Timer && other ) Move or semantics are forbidden as address of object is not allowed to change. function operator= \ud83d\udd17 Timer & operator = ( const Timer & other ) Move or semantics are forbidden as address of object is not allowed to change. function operator= \ud83d\udd17 Timer & operator = ( Timer && other ) Move or semantics are forbidden as address of object is not allowed to change. function ~Timer \ud83d\udd17 virtual ~ Timer () = default D'tor. function start \ud83d\udd17 cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Starts the timer. Parameters : runMode for continuous callbacks PERIODIC otherwise ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given The callback is called by the operating system after the time has expired. function stop \ud83d\udd17 cxx :: expected < TimerError > stop () Disarms the timer. Note : Shall only be called when callback is given, guarantee after stop() call is callback is immediately called or never at all function restart \ud83d\udd17 cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Disarms the timer, assigns a new timeToWait value and arms the timer. Parameters : timeToWait duration till the callback should be called runMode for continuous callbacks PERIODIC otherwise ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given function timeUntilExpiration \ud83d\udd17 cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () Note : Shall only be called when callback is given function getOverruns \ud83d\udd17 cxx :: expected < uint64_t , TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. Note : Shall only be called when callback is given function hasError \ud83d\udd17 bool hasError () const Returns true if the construction of the object was successful. function getError \ud83d\udd17 TimerError getError () const Returns the error that occured on constructing the object. function now \ud83d\udd17 static cxx :: expected < units :: Duration , TimerError > now () creates Duration from the result of clock_gettime(CLOCK_REALTIME, ...) Return : if the clock_gettime call failed TimerError is returned otherwise Duration Todo : maybe move this to a clock implementation? Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#ioxposixtimer","text":"Interface for timers on POSIX operating systems. More... #include <iceoryx_hoofs/posix_wrapper/timer.hpp>","title":"iox::posix::Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-types","text":"Name enum RunMode { ONCE, PERIODIC} enum CatchUpPolicy { SKIP_TO_NEXT_BEAT, IMMEDIATE, TERMINATE} defines the behavior of the timer when the callback runtime is greater than the periodic trigger time. SKIP_TO_NEXT_BEAT skip callback and call it in the next cycle IMMEDIATE call the callback right after the currently running callback is finished TERMINATE terminates the process by calling the errorHandler with POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME","title":"Public Types"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-functions","text":"Name Timer (const units::Duration timeToWait) Creates a timer without an operating system callback. Timer (const units::Duration timeToWait, const std::function< void()> & callback) Creates a timer with an operating system callback. Timer (const Timer & other) Move or semantics are forbidden as address of object is not allowed to change. Timer ( Timer && other) Move or semantics are forbidden as address of object is not allowed to change. Timer & operator= (const Timer & other) Move or semantics are forbidden as address of object is not allowed to change. Timer & operator= ( Timer && other) Move or semantics are forbidden as address of object is not allowed to change. virtual ~Timer () =default D'tor. cxx::expected< TimerError > start (const RunMode runMode, const CatchUpPolicy catchUpPolicy) Starts the timer. cxx::expected< TimerError > stop () Disarms the timer. cxx::expected< TimerError > restart (const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy) Disarms the timer, assigns a new timeToWait value and arms the timer. cxx::expected< units::Duration, TimerError > timeUntilExpiration () cxx::expected< uint64_t, TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. bool hasError () const Returns true if the construction of the object was successful. TimerError getError () const Returns the error that occured on constructing the object. cxx::expected< units::Duration, TimerError > now () creates Duration from the result of clock_gettime(CLOCK_REALTIME, ...)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#detailed-description","text":"class iox :: posix :: Timer ; Interface for timers on POSIX operating systems. Note : Can't be copied or moved as operating system has a pointer to this object. It needs to be ensured that this object lives longer than timeToWait, otherwise the operating system will unregister the timer posix :: Timer TiborTheTimer { 100 _ms , [ & ]() { fooBar ++ ; }}; // Start a periodic timer TiborTheTimer . start ( true ); // [.. wait ..] // Timer fires after 100_ms and calls the lambda which increments fooBar TiborTheTimer . stop (); This class will be DEPRECATED in the near future. In its current form there may still be potential races when start/stop/restart are called concurrently (this includes the callback, which is executed in a separate thread). The implementation also has too much overhead in the callback execution (due to execution logic and potentially multiple callback threads). It will be replaced with simpler versions for individual use cases, such as a CountdownTimer which can be used for watchdog/keepalive purposes.","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#enum-runmode","text":"Enumerator Value Description ONCE PERIODIC","title":"enum RunMode"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#enum-catchuppolicy","text":"Enumerator Value Description SKIP_TO_NEXT_BEAT IMMEDIATE TERMINATE defines the behavior of the timer when the callback runtime is greater than the periodic trigger time. SKIP_TO_NEXT_BEAT skip callback and call it in the next cycle IMMEDIATE call the callback right after the currently running callback is finished TERMINATE terminates the process by calling the errorHandler with POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME","title":"enum CatchUpPolicy"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer","text":"Timer ( const units :: Duration timeToWait ) Creates a timer without an operating system callback. Parameters : timeToWait - How long should be waited? Note : Does not set up an operating system timer, but uses CLOCK_REALTIME instead Todo : refactor this cTor and its functionality to a class called StopWatch Creates a light-weight timer object that can be used with hasExpiredComparedToCreationTime() resetCreationTime()","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_1","text":"Timer ( const units :: Duration timeToWait , const std :: function < void () > & callback ) Creates a timer with an operating system callback. Parameters : timeToWait - How long should be waited? callback - Function called after timeToWait (User needs to ensure lifetime of function till stop() call) Note : Operating systems needs a valid reference to this object, hence DesignPattern::Creation can't be used Initially the timer is stopped.","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_2","text":"Timer ( const Timer & other ) Move or semantics are forbidden as address of object is not allowed to change.","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_3","text":"Timer ( Timer && other ) Move or semantics are forbidden as address of object is not allowed to change.","title":"function Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-operator","text":"Timer & operator = ( const Timer & other ) Move or semantics are forbidden as address of object is not allowed to change.","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-operator_1","text":"Timer & operator = ( Timer && other ) Move or semantics are forbidden as address of object is not allowed to change.","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timer_4","text":"virtual ~ Timer () = default D'tor.","title":"function ~Timer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-start","text":"cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Starts the timer. Parameters : runMode for continuous callbacks PERIODIC otherwise ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given The callback is called by the operating system after the time has expired.","title":"function start"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-stop","text":"cxx :: expected < TimerError > stop () Disarms the timer. Note : Shall only be called when callback is given, guarantee after stop() call is callback is immediately called or never at all","title":"function stop"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-restart","text":"cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Disarms the timer, assigns a new timeToWait value and arms the timer. Parameters : timeToWait duration till the callback should be called runMode for continuous callbacks PERIODIC otherwise ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given","title":"function restart"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-timeuntilexpiration","text":"cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () Note : Shall only be called when callback is given","title":"function timeUntilExpiration"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-getoverruns","text":"cxx :: expected < uint64_t , TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. Note : Shall only be called when callback is given","title":"function getOverruns"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-haserror","text":"bool hasError () const Returns true if the construction of the object was successful.","title":"function hasError"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-geterror","text":"TimerError getError () const Returns the error that occured on constructing the object.","title":"function getError"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer/#function-now","text":"static cxx :: expected < units :: Duration , TimerError > now () creates Duration from the result of clock_gettime(CLOCK_REALTIME, ...) Return : if the clock_gettime call failed TimerError is returned otherwise Duration Todo : maybe move this to a clock implementation? Updated on 18 December 2023 at 13:11:42 CET","title":"function now"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/","text":"iox::posix::Timer::OsTimer \ud83d\udd17 This class will be DEPRECATED in the near future. ## Public Functions Name void callbackHelper (sigval data) Wrapper that can be registered with the operating system. OsTimer (const units::Duration timeToWait, const std::function< void()> & callback) OsTimer (const OsTimer & ) OsTimer (OsTimer && ) OsTimer & operator= (const OsTimer & ) OsTimer & operator= (OsTimer && ) virtual ~OsTimer () D'tor. cxx::expected< TimerError > start (const RunMode runMode, const CatchUpPolicy catchUpPolicy) Starts the timer. cxx::expected< TimerError > stop () Disarms the timer. cxx::expected< TimerError > restart (const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy) Disarms the timer, assigns a new timeToWait value and arms the timer. cxx::expected< units::Duration, TimerError > timeUntilExpiration () cxx::expected< uint64_t, TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. bool hasError () const Returns true if the construction of the object was successful. TimerError getError () const Returns the error that occured on constructing the object. Public Functions Documentation \ud83d\udd17 function callbackHelper \ud83d\udd17 static void callbackHelper ( sigval data ) Wrapper that can be registered with the operating system. function OsTimer \ud83d\udd17 OsTimer ( const units :: Duration timeToWait , const std :: function < void () > & callback ) function OsTimer \ud83d\udd17 OsTimer ( const OsTimer & ) function OsTimer \ud83d\udd17 OsTimer ( OsTimer && ) function operator= \ud83d\udd17 OsTimer & operator = ( const OsTimer & ) function operator= \ud83d\udd17 OsTimer & operator = ( OsTimer && ) function ~OsTimer \ud83d\udd17 virtual ~ OsTimer () D'tor. function start \ud83d\udd17 cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Starts the timer. Parameters : runMode can be a periodic timer if set to RunMode::PERIODIC or it runs just once when it is set to RunMode::ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given The callback is called by the operating system after the time has expired. function stop \ud83d\udd17 cxx :: expected < TimerError > stop () Disarms the timer. Note : Shall only be called when callback is given, guarantee after stop() call is callback is immediately called or never at all function restart \ud83d\udd17 cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Disarms the timer, assigns a new timeToWait value and arms the timer. Parameters : runMode periodic can be a periodic timer if set to RunMode::PERIODIC or once when in RunMode::ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given function timeUntilExpiration \ud83d\udd17 cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () Note : Shall only be called when callback is given function getOverruns \ud83d\udd17 cxx :: expected < uint64_t , TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. Note : Shall only be called when callback is given function hasError \ud83d\udd17 bool hasError () const Returns true if the construction of the object was successful. function getError \ud83d\udd17 TimerError getError () const Returns the error that occured on constructing the object. Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::Timer::OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#ioxposixtimerostimer","text":"This class will be DEPRECATED in the near future. ## Public Functions Name void callbackHelper (sigval data) Wrapper that can be registered with the operating system. OsTimer (const units::Duration timeToWait, const std::function< void()> & callback) OsTimer (const OsTimer & ) OsTimer (OsTimer && ) OsTimer & operator= (const OsTimer & ) OsTimer & operator= (OsTimer && ) virtual ~OsTimer () D'tor. cxx::expected< TimerError > start (const RunMode runMode, const CatchUpPolicy catchUpPolicy) Starts the timer. cxx::expected< TimerError > stop () Disarms the timer. cxx::expected< TimerError > restart (const units::Duration timeToWait, const RunMode runMode, const CatchUpPolicy catchUpPolicy) Disarms the timer, assigns a new timeToWait value and arms the timer. cxx::expected< units::Duration, TimerError > timeUntilExpiration () cxx::expected< uint64_t, TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. bool hasError () const Returns true if the construction of the object was successful. TimerError getError () const Returns the error that occured on constructing the object.","title":"iox::posix::Timer::OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-callbackhelper","text":"static void callbackHelper ( sigval data ) Wrapper that can be registered with the operating system.","title":"function callbackHelper"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer","text":"OsTimer ( const units :: Duration timeToWait , const std :: function < void () > & callback )","title":"function OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer_1","text":"OsTimer ( const OsTimer & )","title":"function OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer_2","text":"OsTimer ( OsTimer && )","title":"function OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-operator","text":"OsTimer & operator = ( const OsTimer & )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-operator_1","text":"OsTimer & operator = ( OsTimer && )","title":"function operator="},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-ostimer_3","text":"virtual ~ OsTimer () D'tor.","title":"function ~OsTimer"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-start","text":"cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Starts the timer. Parameters : runMode can be a periodic timer if set to RunMode::PERIODIC or it runs just once when it is set to RunMode::ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given The callback is called by the operating system after the time has expired.","title":"function start"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-stop","text":"cxx :: expected < TimerError > stop () Disarms the timer. Note : Shall only be called when callback is given, guarantee after stop() call is callback is immediately called or never at all","title":"function stop"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-restart","text":"cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) Disarms the timer, assigns a new timeToWait value and arms the timer. Parameters : runMode periodic can be a periodic timer if set to RunMode::PERIODIC or once when in RunMode::ONCE CatchUpPolicy define behavior when callbackRuntime > timeToWait Note : Shall only be called when callback is given","title":"function restart"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-timeuntilexpiration","text":"cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () Note : Shall only be called when callback is given","title":"function timeUntilExpiration"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-getoverruns","text":"cxx :: expected < uint64_t , TimerError > getOverruns () In case the callback is not immediately called by the operating system, getOverruns() returns the additional overruns that happended in the delay interval. Note : Shall only be called when callback is given","title":"function getOverruns"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-haserror","text":"bool hasError () const Returns true if the construction of the object was successful.","title":"function hasError"},{"location":"API-reference/hoofs/Classes/classiox_1_1posix_1_1Timer_1_1OsTimer/#function-geterror","text":"TimerError getError () const Returns the error that occured on constructing the object. Updated on 18 December 2023 at 13:11:42 CET","title":"function getError"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/","text":"iox::cxx::BestFittingType \ud83d\udd17 get the best fitting unsigned integer type for a given value at compile time More... #include <iceoryx_hoofs/cxx/helplets.hpp> Public Types \ud83d\udd17 Name using typename internal::BestFittingTypeImpl<(Value > std::numeric_limits< uint8_t >::max()),(Value > std::numeric_limits< uint16_t >::max()),(Value > std::numeric_limits< uint32_t >::max())>:: Type_t Type_t ignore the warnings because we need the comparisons to find the best fitting type Detailed Description \ud83d\udd17 template < uint64_t Value > struct iox :: cxx :: BestFittingType ; get the best fitting unsigned integer type for a given value at compile time Public Types Documentation \ud83d\udd17 using Type_t \ud83d\udd17 using iox :: cxx :: BestFittingType < Value >:: Type_t = typename internal :: BestFittingTypeImpl < ( Value > std :: numeric_limits < uint8_t >:: max ()), ( Value > std :: numeric_limits < uint16_t >:: max ()), ( Value > std :: numeric_limits < uint32_t >:: max ()) >:: Type_t ; ignore the warnings because we need the comparisons to find the best fitting type Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::BestFittingType"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#ioxcxxbestfittingtype","text":"get the best fitting unsigned integer type for a given value at compile time More... #include <iceoryx_hoofs/cxx/helplets.hpp>","title":"iox::cxx::BestFittingType"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#public-types","text":"Name using typename internal::BestFittingTypeImpl<(Value > std::numeric_limits< uint8_t >::max()),(Value > std::numeric_limits< uint16_t >::max()),(Value > std::numeric_limits< uint32_t >::max())>:: Type_t Type_t ignore the warnings because we need the comparisons to find the best fitting type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#detailed-description","text":"template < uint64_t Value > struct iox :: cxx :: BestFittingType ; get the best fitting unsigned integer type for a given value at compile time","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1BestFittingType/#using-type_t","text":"using iox :: cxx :: BestFittingType < Value >:: Type_t = typename internal :: BestFittingTypeImpl < ( Value > std :: numeric_limits < uint8_t >:: max ()), ( Value > std :: numeric_limits < uint16_t >:: max ()), ( Value > std :: numeric_limits < uint32_t >:: max ()) >:: Type_t ; ignore the warnings because we need the comparisons to find the best fitting type Updated on 18 December 2023 at 13:11:42 CET","title":"using Type_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/","text":"iox::cxx::TruncateToCapacity_t \ud83d\udd17 struct used to define a compile time variable which is used to distinguish between constructors with certain behavior #include <iceoryx_hoofs/cxx/string.hpp> Public Functions \ud83d\udd17 Name TruncateToCapacity_t () =default Public Functions Documentation \ud83d\udd17 function TruncateToCapacity_t \ud83d\udd17 explicit TruncateToCapacity_t () = default Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::TruncateToCapacity_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#ioxcxxtruncatetocapacity_t","text":"struct used to define a compile time variable which is used to distinguish between constructors with certain behavior #include <iceoryx_hoofs/cxx/string.hpp>","title":"iox::cxx::TruncateToCapacity_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#public-functions","text":"Name TruncateToCapacity_t () =default","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1TruncateToCapacity__t/#function-truncatetocapacity_t","text":"explicit TruncateToCapacity_t () = default Updated on 18 December 2023 at 13:11:42 CET","title":"function TruncateToCapacity_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/","text":"iox::cxx::add_const_conditionally \ud83d\udd17 Conditionally add const to type T if C has the const qualifier. More... #include <iceoryx_hoofs/cxx/type_traits.hpp> Public Types \ud83d\udd17 Name using T type Detailed Description \ud83d\udd17 template < typename T , typename C > struct iox :: cxx :: add_const_conditionally ; Conditionally add const to type T if C has the const qualifier. Template Parameters : T is the type to conditionally add the const qualifier Condition is the type which determines if the const qualifier needs to be added to T Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 using iox :: cxx :: add_const_conditionally < T , C >:: type = T ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::add_const_conditionally"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#ioxcxxadd_const_conditionally","text":"Conditionally add const to type T if C has the const qualifier. More... #include <iceoryx_hoofs/cxx/type_traits.hpp>","title":"iox::cxx::add_const_conditionally"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#public-types","text":"Name using T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#detailed-description","text":"template < typename T , typename C > struct iox :: cxx :: add_const_conditionally ; Conditionally add const to type T if C has the const qualifier. Template Parameters : T is the type to conditionally add the const qualifier Condition is the type which determines if the const qualifier needs to be added to T","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally/#using-type","text":"using iox :: cxx :: add_const_conditionally < T , C >:: type = T ; Updated on 18 December 2023 at 13:11:42 CET","title":"using type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/","text":"iox::cxx::add_const_conditionally< T, const C > \ud83d\udd17 More... Public Types \ud83d\udd17 Name using const T type Detailed Description \ud83d\udd17 template < typename T , typename C > struct iox :: cxx :: add_const_conditionally < T , const C > ; Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 using iox :: cxx :: add_const_conditionally < T , const C >:: type = const T ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::add_const_conditionally< T, const C >"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#ioxcxxadd_const_conditionally-t-const-c","text":"More...","title":"iox::cxx::add_const_conditionally&lt; T, const C &gt;"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#public-types","text":"Name using const T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#detailed-description","text":"template < typename T , typename C > struct iox :: cxx :: add_const_conditionally < T , const C > ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1add__const__conditionally_3_01T_00_01const_01C_01_4/#using-type","text":"using iox :: cxx :: add_const_conditionally < T , const C >:: type = const T ; Updated on 18 December 2023 at 13:11:42 CET","title":"using type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/","text":"iox::cxx::error \ud83d\udd17 helper struct to create an expected which is signalling an error more easily More... #include <iceoryx_hoofs/cxx/expected.hpp> Public Functions \ud83d\udd17 Name error (const T & t) constructor which creates a error helper class by copying the value of t error (T && t) constructor which creates a error helper class by moving the value of t template <typename... Targs> error (Targs &&... args) constructor which creates a error helper class by forwarding arguments to the constructor of T Public Attributes \ud83d\udd17 Name T value Detailed Description \ud83d\udd17 template < typename T > struct iox :: cxx :: error ; helper struct to create an expected which is signalling an error more easily Parameters : T type which the success helper class should contain cxx :: expected < float > callMe () { //... return cxx :: error < float > ( 12.34f ); } Public Functions Documentation \ud83d\udd17 function error \ud83d\udd17 error ( const T & t ) constructor which creates a error helper class by copying the value of t Parameters : t value which should be later stored in an expected function error \ud83d\udd17 error ( T && t ) constructor which creates a error helper class by moving the value of t Parameters : t value which should be later moved into an expected function error \ud83d\udd17 template < typename ... Targs > error ( Targs && ... args ) constructor which creates a error helper class by forwarding arguments to the constructor of T Parameters : args... arguments which will be perfectly forwarded to the constructor Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 T value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#ioxcxxerror","text":"helper struct to create an expected which is signalling an error more easily More... #include <iceoryx_hoofs/cxx/expected.hpp>","title":"iox::cxx::error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-functions","text":"Name error (const T & t) constructor which creates a error helper class by copying the value of t error (T && t) constructor which creates a error helper class by moving the value of t template <typename... Targs> error (Targs &&... args) constructor which creates a error helper class by forwarding arguments to the constructor of T","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-attributes","text":"Name T value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#detailed-description","text":"template < typename T > struct iox :: cxx :: error ; helper struct to create an expected which is signalling an error more easily Parameters : T type which the success helper class should contain cxx :: expected < float > callMe () { //... return cxx :: error < float > ( 12.34f ); }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#function-error","text":"error ( const T & t ) constructor which creates a error helper class by copying the value of t Parameters : t value which should be later stored in an expected","title":"function error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#function-error_1","text":"error ( T && t ) constructor which creates a error helper class by moving the value of t Parameters : t value which should be later moved into an expected","title":"function error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#function-error_2","text":"template < typename ... Targs > error ( Targs && ... args ) constructor which creates a error helper class by forwarding arguments to the constructor of T Parameters : args... arguments which will be perfectly forwarded to the constructor","title":"function error"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1error/#variable-value","text":"T value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/","text":"iox::cxx::forward_list::NodeLink \ud83d\udd17 Public Attributes \ud83d\udd17 Name size_type nextIdx bool invalidElement Public Attributes Documentation \ud83d\udd17 variable nextIdx \ud83d\udd17 size_type nextIdx ; variable invalidElement \ud83d\udd17 bool invalidElement ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::forward_list::NodeLink"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#ioxcxxforward_listnodelink","text":"","title":"iox::cxx::forward_list::NodeLink"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#public-attributes","text":"Name size_type nextIdx bool invalidElement","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#variable-nextidx","text":"size_type nextIdx ;","title":"variable nextIdx"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1forward__list_1_1NodeLink/#variable-invalidelement","text":"bool invalidElement ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable invalidElement"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/","text":"iox::cxx::greater_or_equal \ud83d\udd17 More... Public Functions \ud83d\udd17 Name greater_or_equal (T t) constexpr operator T () const Detailed Description \ud83d\udd17 template < typename T , T Minimum > struct iox :: cxx :: greater_or_equal ; Public Functions Documentation \ud83d\udd17 function greater_or_equal \ud83d\udd17 inline greater_or_equal ( T t ) function operator T \ud83d\udd17 inline constexpr operator T () const Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::greater_or_equal"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#ioxcxxgreater_or_equal","text":"More...","title":"iox::cxx::greater_or_equal"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#public-functions","text":"Name greater_or_equal (T t) constexpr operator T () const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#detailed-description","text":"template < typename T , T Minimum > struct iox :: cxx :: greater_or_equal ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#function-greater_or_equal","text":"inline greater_or_equal ( T t )","title":"function greater_or_equal"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1greater__or__equal/#function-operator-t","text":"inline constexpr operator T () const Updated on 18 December 2023 at 13:11:42 CET","title":"function operator T"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/","text":"iox::cxx::in_place_index \ud83d\udd17 helper struct to perform an emplacement at a predefined index in the constructor of a variant More... #include <iceoryx_hoofs/cxx/variant.hpp> Public Attributes \ud83d\udd17 Name constexpr uint64_t value Detailed Description \ud83d\udd17 template < uint64_t N > struct iox :: cxx :: in_place_index ; helper struct to perform an emplacement at a predefined index in the constructor of a variant Template Parameters : Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 static constexpr uint64_t value = N ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::in_place_index"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#ioxcxxin_place_index","text":"helper struct to perform an emplacement at a predefined index in the constructor of a variant More... #include <iceoryx_hoofs/cxx/variant.hpp>","title":"iox::cxx::in_place_index"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#public-attributes","text":"Name constexpr uint64_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#detailed-description","text":"template < uint64_t N > struct iox :: cxx :: in_place_index ; helper struct to perform an emplacement at a predefined index in the constructor of a variant Template Parameters :","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__index/#variable-value","text":"static constexpr uint64_t value = N ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__t/","text":"iox::cxx::in_place_t \ud83d\udd17 helper struct which is used to call the in-place-construction constructor #include <iceoryx_hoofs/cxx/optional.hpp> Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::in_place_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__t/#ioxcxxin_place_t","text":"helper struct which is used to call the in-place-construction constructor #include <iceoryx_hoofs/cxx/optional.hpp> Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::in_place_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/","text":"iox::cxx::in_place_type \ud83d\udd17 helper struct to perform an emplacement of a predefined type in in the constructor of a variant More... #include <iceoryx_hoofs/cxx/variant.hpp> Public Types \ud83d\udd17 Name using T type Detailed Description \ud83d\udd17 template < typename T > struct iox :: cxx :: in_place_type ; helper struct to perform an emplacement of a predefined type in in the constructor of a variant Template Parameters : Public Types Documentation \ud83d\udd17 using type \ud83d\udd17 using iox :: cxx :: in_place_type < T >:: type = T ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::in_place_type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#ioxcxxin_place_type","text":"helper struct to perform an emplacement of a predefined type in in the constructor of a variant More... #include <iceoryx_hoofs/cxx/variant.hpp>","title":"iox::cxx::in_place_type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#public-types","text":"Name using T type","title":"Public Types"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#detailed-description","text":"template < typename T > struct iox :: cxx :: in_place_type ; helper struct to perform an emplacement of a predefined type in in the constructor of a variant Template Parameters :","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1in__place__type/#using-type","text":"using iox :: cxx :: in_place_type < T >:: type = T ; Updated on 18 December 2023 at 13:11:42 CET","title":"using type"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/","text":"iox::cxx::is_function_pointer \ud83d\udd17 Check whether T is a function pointer with arbitrary signature. More... #include <iceoryx_hoofs/cxx/type_traits.hpp> Inherits from false_type Detailed Description \ud83d\udd17 template < typename T > struct iox :: cxx :: is_function_pointer ; Check whether T is a function pointer with arbitrary signature. \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::is_function_pointer"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/#ioxcxxis_function_pointer","text":"Check whether T is a function pointer with arbitrary signature. More... #include <iceoryx_hoofs/cxx/type_traits.hpp> Inherits from false_type","title":"iox::cxx::is_function_pointer"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/#detailed-description","text":"template < typename T > struct iox :: cxx :: is_function_pointer ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer/#check-whether-t-is-a-function-pointer-with-arbitrary-signature","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"Check whether T is a function pointer with arbitrary signature."},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer_3_01ReturnType_07_5_08_07ArgTypes_8_8_8_08_4/","text":"iox::cxx::is_function_pointer< ReturnType(*)(ArgTypes...)> \ud83d\udd17 More... Inherits from true_type Detailed Description \ud83d\udd17 template < typename ReturnType , typename ... ArgTypes > struct iox :: cxx :: is_function_pointer < ReturnType ( * )( ArgTypes ...) > ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::is_function_pointer< ReturnType(*)(ArgTypes...)>"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer_3_01ReturnType_07_5_08_07ArgTypes_8_8_8_08_4/#ioxcxxis_function_pointer-returntypeargtypes","text":"More... Inherits from true_type","title":"iox::cxx::is_function_pointer&lt; ReturnType(*)(ArgTypes...)&gt;"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__function__pointer_3_01ReturnType_07_5_08_07ArgTypes_8_8_8_08_4/#detailed-description","text":"template < typename ReturnType , typename ... ArgTypes > struct iox :: cxx :: is_function_pointer < ReturnType ( * )( ArgTypes ...) > ; Updated on 18 December 2023 at 13:11:42 CET","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/","text":"iox::cxx::is_invocable \ud83d\udd17 Verifies whether the passed Callable type is in fact invocable with the given arguments. More... #include <iceoryx_hoofs/cxx/type_traits.hpp> Public Functions \ud83d\udd17 Name template <typename C ,typename... As> constexpr std::true_type test (typename cxx::invoke_result< C, As... >::type * ) template <typename C ,typename... As> constexpr std::false_type test (... ) Public Attributes \ud83d\udd17 Name constexpr bool value Detailed Description \ud83d\udd17 template < typename Callable , typename ... ArgTypes > struct iox :: cxx :: is_invocable ; Verifies whether the passed Callable type is in fact invocable with the given arguments. Public Functions Documentation \ud83d\udd17 function test \ud83d\udd17 template < typename C , typename ... As > static inline constexpr std :: true_type test ( typename cxx :: invoke_result < C , As ... >:: type * ) Note : result_of is deprecated, switch to invoke_result in C++17 function test \ud83d\udd17 template < typename C , typename ... As > static inline constexpr std :: false_type test ( ... ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 static constexpr bool value = decltype ([ test ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1cxx_1_1is__invocable / # function - test ) < Callable , ArgTypes ... > ( nullptr )) :: value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::is_invocable"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#ioxcxxis_invocable","text":"Verifies whether the passed Callable type is in fact invocable with the given arguments. More... #include <iceoryx_hoofs/cxx/type_traits.hpp>","title":"iox::cxx::is_invocable"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-functions","text":"Name template <typename C ,typename... As> constexpr std::true_type test (typename cxx::invoke_result< C, As... >::type * ) template <typename C ,typename... As> constexpr std::false_type test (... )","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-attributes","text":"Name constexpr bool value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#detailed-description","text":"template < typename Callable , typename ... ArgTypes > struct iox :: cxx :: is_invocable ; Verifies whether the passed Callable type is in fact invocable with the given arguments.","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#function-test","text":"template < typename C , typename ... As > static inline constexpr std :: true_type test ( typename cxx :: invoke_result < C , As ... >:: type * ) Note : result_of is deprecated, switch to invoke_result in C++17","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#function-test_1","text":"template < typename C , typename ... As > static inline constexpr std :: false_type test ( ... )","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable/#variable-value","text":"static constexpr bool value = decltype ([ test ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1cxx_1_1is__invocable / # function - test ) < Callable , ArgTypes ... > ( nullptr )) :: value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/","text":"iox::cxx::is_invocable_r \ud83d\udd17 Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. More... #include <iceoryx_hoofs/cxx/type_traits.hpp> Public Functions \ud83d\udd17 Name template <typename C ,typename... As> constexpr std::true_type test (std::enable_if_t< std::is_convertible< typename cxx::invoke_result< C, As... >::type, ReturnType >::value > * ) template <typename C ,typename... As> constexpr std::false_type test (... ) Public Attributes \ud83d\udd17 Name constexpr bool value Detailed Description \ud83d\udd17 template < typename ReturnType , typename Callable , typename ... ArgTypes > struct iox :: cxx :: is_invocable_r ; Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. Note : This is an implementation of std::is_invokable_r (C++17). Public Functions Documentation \ud83d\udd17 function test \ud83d\udd17 template < typename C , typename ... As > static inline constexpr std :: true_type test ( std :: enable_if_t < std :: is_convertible < typename cxx :: invoke_result < C , As ... >:: type , ReturnType >:: value > * ) function test \ud83d\udd17 template < typename C , typename ... As > static inline constexpr std :: false_type test ( ... ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 static constexpr bool value = decltype ( test < Callable , ArgTypes ... > ( nullptr )) :: value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::is_invocable_r"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#ioxcxxis_invocable_r","text":"Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. More... #include <iceoryx_hoofs/cxx/type_traits.hpp>","title":"iox::cxx::is_invocable_r"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-functions","text":"Name template <typename C ,typename... As> constexpr std::true_type test (std::enable_if_t< std::is_convertible< typename cxx::invoke_result< C, As... >::type, ReturnType >::value > * ) template <typename C ,typename... As> constexpr std::false_type test (... )","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-attributes","text":"Name constexpr bool value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#detailed-description","text":"template < typename ReturnType , typename Callable , typename ... ArgTypes > struct iox :: cxx :: is_invocable_r ; Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. Note : This is an implementation of std::is_invokable_r (C++17).","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#function-test","text":"template < typename C , typename ... As > static inline constexpr std :: true_type test ( std :: enable_if_t < std :: is_convertible < typename cxx :: invoke_result < C , As ... >:: type , ReturnType >:: value > * )","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#function-test_1","text":"template < typename C , typename ... As > static inline constexpr std :: false_type test ( ... )","title":"function test"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1is__invocable__r/#variable-value","text":"static constexpr bool value = decltype ( test < Callable , ArgTypes ... > ( nullptr )) :: value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/","text":"iox::cxx::list::NodeLink \ud83d\udd17 Public Attributes \ud83d\udd17 Name size_type nextIdx size_type prevIdx Public Attributes Documentation \ud83d\udd17 variable nextIdx \ud83d\udd17 size_type nextIdx ; variable prevIdx \ud83d\udd17 size_type prevIdx ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::list::NodeLink"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#ioxcxxlistnodelink","text":"","title":"iox::cxx::list::NodeLink"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#public-attributes","text":"Name size_type nextIdx size_type prevIdx","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#variable-nextidx","text":"size_type nextIdx ;","title":"variable nextIdx"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1list_1_1NodeLink/#variable-previdx","text":"size_type prevIdx ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable prevIdx"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/","text":"iox::cxx::not_null \ud83d\udd17 More... Public Functions \ud83d\udd17 Name not_null (T t) constexpr operator T () const Detailed Description \ud83d\udd17 template < typename T , typename = typename std :: enable_if < std :: is_pointer < T >:: value , void >:: type > struct iox :: cxx :: not_null ; Public Functions Documentation \ud83d\udd17 function not_null \ud83d\udd17 inline not_null ( T t ) function operator T \ud83d\udd17 inline constexpr operator T () const Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::not_null"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#ioxcxxnot_null","text":"More...","title":"iox::cxx::not_null"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#public-functions","text":"Name not_null (T t) constexpr operator T () const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#detailed-description","text":"template < typename T , typename = typename std :: enable_if < std :: is_pointer < T >:: value , void >:: type > struct iox :: cxx :: not_null ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#function-not_null","text":"inline not_null ( T t )","title":"function not_null"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1not__null/#function-operator-t","text":"inline constexpr operator T () const Updated on 18 December 2023 at 13:11:42 CET","title":"function operator T"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1nullopt__t/","text":"iox::cxx::nullopt_t \ud83d\udd17 Helper struct which is used to signal an empty optional. It is equivalent to no value. #include <iceoryx_hoofs/cxx/optional.hpp> Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::nullopt_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1nullopt__t/#ioxcxxnullopt_t","text":"Helper struct which is used to signal an empty optional. It is equivalent to no value. #include <iceoryx_hoofs/cxx/optional.hpp> Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::nullopt_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/","text":"iox::cxx::range \ud83d\udd17 More... Public Functions \ud83d\udd17 Name range (T t) constexpr operator T () const Detailed Description \ud83d\udd17 template < typename T , T Minimum , T Maximum > struct iox :: cxx :: range ; Public Functions Documentation \ud83d\udd17 function range \ud83d\udd17 inline range ( T t ) function operator T \ud83d\udd17 inline constexpr operator T () const Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::range"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#ioxcxxrange","text":"More...","title":"iox::cxx::range"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#public-functions","text":"Name range (T t) constexpr operator T () const","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#detailed-description","text":"template < typename T , T Minimum , T Maximum > struct iox :: cxx :: range ;","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#function-range","text":"inline range ( T t )","title":"function range"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1range/#function-operator-t","text":"inline constexpr operator T () const Updated on 18 December 2023 at 13:11:42 CET","title":"function operator T"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/","text":"iox::cxx::success \ud83d\udd17 helper struct to create an expected which is signalling success more easily More... #include <iceoryx_hoofs/cxx/expected.hpp> Public Functions \ud83d\udd17 Name success (const T & t) constructor which creates a success helper class by copying the value of t success (T && t) constructor which creates a success helper class by moving the value of t template <typename... Targs> success (Targs &&... args) constructor which creates a success helper class by forwarding arguments to the constructor of T Public Attributes \ud83d\udd17 Name T value Detailed Description \ud83d\udd17 template < typename T = void > struct iox :: cxx :: success ; helper struct to create an expected which is signalling success more easily Parameters : T type which the success helper class should contain cxx :: expected < int , float > callMe () { //... return cxx :: success < int > ( 55 ); } Public Functions Documentation \ud83d\udd17 function success \ud83d\udd17 success ( const T & t ) constructor which creates a success helper class by copying the value of t Parameters : t value which should be later stored in an expected function success \ud83d\udd17 success ( T && t ) constructor which creates a success helper class by moving the value of t Parameters : t value which should be later moved into an expected function success \ud83d\udd17 template < typename ... Targs > success ( Targs && ... args ) constructor which creates a success helper class by forwarding arguments to the constructor of T Parameters : args... arguments which will be perfectly forwarded to the constructor Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 T value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#ioxcxxsuccess","text":"helper struct to create an expected which is signalling success more easily More... #include <iceoryx_hoofs/cxx/expected.hpp>","title":"iox::cxx::success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-functions","text":"Name success (const T & t) constructor which creates a success helper class by copying the value of t success (T && t) constructor which creates a success helper class by moving the value of t template <typename... Targs> success (Targs &&... args) constructor which creates a success helper class by forwarding arguments to the constructor of T","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-attributes","text":"Name T value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#detailed-description","text":"template < typename T = void > struct iox :: cxx :: success ; helper struct to create an expected which is signalling success more easily Parameters : T type which the success helper class should contain cxx :: expected < int , float > callMe () { //... return cxx :: success < int > ( 55 ); }","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#function-success","text":"success ( const T & t ) constructor which creates a success helper class by copying the value of t Parameters : t value which should be later stored in an expected","title":"function success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#function-success_1","text":"success ( T && t ) constructor which creates a success helper class by moving the value of t Parameters : t value which should be later moved into an expected","title":"function success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#function-success_2","text":"template < typename ... Targs > success ( Targs && ... args ) constructor which creates a success helper class by forwarding arguments to the constructor of T Parameters : args... arguments which will be perfectly forwarded to the constructor","title":"function success"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success/#variable-value","text":"T value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success_3_01void_01_4/","text":"iox::cxx::success< void > \ud83d\udd17 helper struct to create an error only expected which is signalling success more easily More... #include <iceoryx_hoofs/cxx/expected.hpp> Detailed Description \ud83d\udd17 struct iox :: cxx :: success < void > ; helper struct to create an error only expected which is signalling success more easily cxx :: expected < float > callMe () { //... return cxx :: success <> (); } Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::success< void >"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success_3_01void_01_4/#ioxcxxsuccess-void","text":"helper struct to create an error only expected which is signalling success more easily More... #include <iceoryx_hoofs/cxx/expected.hpp>","title":"iox::cxx::success&lt; void &gt;"},{"location":"API-reference/hoofs/Classes/structiox_1_1cxx_1_1success_3_01void_01_4/#detailed-description","text":"struct iox :: cxx :: success < void > ; helper struct to create an error only expected which is signalling success more easily cxx :: expected < float > callMe () { //... return cxx :: success <> (); } Updated on 18 December 2023 at 13:11:42 CET","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin/","text":"iox::log::LogBin \ud83d\udd17 Inherited by iox::log::LogBin16 , iox::log::LogBin32 , iox::log::LogBin64 , iox::log::LogBin8 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogBin"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin/#ioxloglogbin","text":"Inherited by iox::log::LogBin16 , iox::log::LogBin32 , iox::log::LogBin64 , iox::log::LogBin8 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogBin"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/","text":"iox::log::LogBin16 \ud83d\udd17 Inherits from iox::log::LogBin Public Functions \ud83d\udd17 Name constexpr LogBin16 (uint16_t value) Public Attributes \ud83d\udd17 Name uint16_t value Public Functions Documentation \ud83d\udd17 function LogBin16 \ud83d\udd17 inline constexpr LogBin16 ( uint16_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint16_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogBin16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#ioxloglogbin16","text":"Inherits from iox::log::LogBin","title":"iox::log::LogBin16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-functions","text":"Name constexpr LogBin16 (uint16_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-attributes","text":"Name uint16_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#function-logbin16","text":"inline constexpr LogBin16 ( uint16_t value )","title":"function LogBin16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin16/#variable-value","text":"uint16_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/","text":"iox::log::LogBin32 \ud83d\udd17 Inherits from iox::log::LogBin Public Functions \ud83d\udd17 Name constexpr LogBin32 (uint32_t value) Public Attributes \ud83d\udd17 Name uint32_t value Public Functions Documentation \ud83d\udd17 function LogBin32 \ud83d\udd17 inline constexpr LogBin32 ( uint32_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint32_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogBin32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#ioxloglogbin32","text":"Inherits from iox::log::LogBin","title":"iox::log::LogBin32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-functions","text":"Name constexpr LogBin32 (uint32_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-attributes","text":"Name uint32_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#function-logbin32","text":"inline constexpr LogBin32 ( uint32_t value )","title":"function LogBin32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin32/#variable-value","text":"uint32_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/","text":"iox::log::LogBin64 \ud83d\udd17 Inherits from iox::log::LogBin Public Functions \ud83d\udd17 Name constexpr LogBin64 (uint64_t value) Public Attributes \ud83d\udd17 Name uint64_t value Public Functions Documentation \ud83d\udd17 function LogBin64 \ud83d\udd17 inline constexpr LogBin64 ( uint64_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint64_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogBin64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#ioxloglogbin64","text":"Inherits from iox::log::LogBin","title":"iox::log::LogBin64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-functions","text":"Name constexpr LogBin64 (uint64_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-attributes","text":"Name uint64_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#function-logbin64","text":"inline constexpr LogBin64 ( uint64_t value )","title":"function LogBin64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin64/#variable-value","text":"uint64_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/","text":"iox::log::LogBin8 \ud83d\udd17 Inherits from iox::log::LogBin Public Functions \ud83d\udd17 Name constexpr LogBin8 (uint8_t value) Public Attributes \ud83d\udd17 Name uint8_t value Public Functions Documentation \ud83d\udd17 function LogBin8 \ud83d\udd17 inline constexpr LogBin8 ( uint8_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint8_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogBin8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#ioxloglogbin8","text":"Inherits from iox::log::LogBin","title":"iox::log::LogBin8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-functions","text":"Name constexpr LogBin8 (uint8_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-attributes","text":"Name uint8_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#function-logbin8","text":"inline constexpr LogBin8 ( uint8_t value )","title":"function LogBin8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogBin8/#variable-value","text":"uint8_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/","text":"iox::log::LogEntry \ud83d\udd17 Public Attributes \ud83d\udd17 Name LogLevel level std::chrono::milliseconds time std::string message Public Attributes Documentation \ud83d\udd17 variable level \ud83d\udd17 LogLevel level { LogLevel :: kVerbose }; variable time \ud83d\udd17 std :: chrono :: milliseconds time { 0 }; variable message \ud83d\udd17 std :: string message ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogEntry"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#ioxloglogentry","text":"","title":"iox::log::LogEntry"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#public-attributes","text":"Name LogLevel level std::chrono::milliseconds time std::string message","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#variable-level","text":"LogLevel level { LogLevel :: kVerbose };","title":"variable level"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#variable-time","text":"std :: chrono :: milliseconds time { 0 };","title":"variable time"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogEntry/#variable-message","text":"std :: string message ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable message"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex/","text":"iox::log::LogHex \ud83d\udd17 Inherited by iox::log::LogHex16 , iox::log::LogHex32 , iox::log::LogHex64 , iox::log::LogHex8 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogHex"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex/#ioxlogloghex","text":"Inherited by iox::log::LogHex16 , iox::log::LogHex32 , iox::log::LogHex64 , iox::log::LogHex8 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogHex"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/","text":"iox::log::LogHex16 \ud83d\udd17 Inherits from iox::log::LogHex Public Functions \ud83d\udd17 Name constexpr LogHex16 (uint16_t value) Public Attributes \ud83d\udd17 Name uint16_t value Public Functions Documentation \ud83d\udd17 function LogHex16 \ud83d\udd17 inline constexpr LogHex16 ( uint16_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint16_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogHex16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#ioxlogloghex16","text":"Inherits from iox::log::LogHex","title":"iox::log::LogHex16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-functions","text":"Name constexpr LogHex16 (uint16_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-attributes","text":"Name uint16_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#function-loghex16","text":"inline constexpr LogHex16 ( uint16_t value )","title":"function LogHex16"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex16/#variable-value","text":"uint16_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/","text":"iox::log::LogHex32 \ud83d\udd17 Inherits from iox::log::LogHex Public Functions \ud83d\udd17 Name constexpr LogHex32 (uint32_t value) Public Attributes \ud83d\udd17 Name uint32_t value Public Functions Documentation \ud83d\udd17 function LogHex32 \ud83d\udd17 inline constexpr LogHex32 ( uint32_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint32_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogHex32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#ioxlogloghex32","text":"Inherits from iox::log::LogHex","title":"iox::log::LogHex32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-functions","text":"Name constexpr LogHex32 (uint32_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-attributes","text":"Name uint32_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#function-loghex32","text":"inline constexpr LogHex32 ( uint32_t value )","title":"function LogHex32"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex32/#variable-value","text":"uint32_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/","text":"iox::log::LogHex64 \ud83d\udd17 Inherits from iox::log::LogHex Public Functions \ud83d\udd17 Name constexpr LogHex64 (uint64_t value) Public Attributes \ud83d\udd17 Name uint64_t value Public Functions Documentation \ud83d\udd17 function LogHex64 \ud83d\udd17 inline constexpr LogHex64 ( uint64_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint64_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogHex64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#ioxlogloghex64","text":"Inherits from iox::log::LogHex","title":"iox::log::LogHex64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-functions","text":"Name constexpr LogHex64 (uint64_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-attributes","text":"Name uint64_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#function-loghex64","text":"inline constexpr LogHex64 ( uint64_t value )","title":"function LogHex64"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex64/#variable-value","text":"uint64_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/","text":"iox::log::LogHex8 \ud83d\udd17 Inherits from iox::log::LogHex Public Functions \ud83d\udd17 Name constexpr LogHex8 (uint8_t value) Public Attributes \ud83d\udd17 Name uint8_t value Public Functions Documentation \ud83d\udd17 function LogHex8 \ud83d\udd17 inline constexpr LogHex8 ( uint8_t value ) Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 uint8_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogHex8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#ioxlogloghex8","text":"Inherits from iox::log::LogHex","title":"iox::log::LogHex8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-functions","text":"Name constexpr LogHex8 (uint8_t value)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-attributes","text":"Name uint8_t value","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#function-loghex8","text":"inline constexpr LogHex8 ( uint8_t value )","title":"function LogHex8"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogHex8/#variable-value","text":"uint8_t value ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/","text":"iox::log::LogRawBuffer \ud83d\udd17 Public Attributes \ud83d\udd17 Name const uint8_t * data uint8_t size Public Attributes Documentation \ud83d\udd17 variable data \ud83d\udd17 const uint8_t * data ; variable size \ud83d\udd17 uint8_t size ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::LogRawBuffer"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#ioxloglograwbuffer","text":"","title":"iox::log::LogRawBuffer"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#public-attributes","text":"Name const uint8_t * data uint8_t size","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#variable-data","text":"const uint8_t * data ;","title":"variable data"},{"location":"API-reference/hoofs/Classes/structiox_1_1log_1_1LogRawBuffer/#variable-size","text":"uint8_t size ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable size"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateNamedSemaphore__t/","text":"iox::posix::CreateNamedSemaphore_t \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::CreateNamedSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateNamedSemaphore__t/#ioxposixcreatenamedsemaphore_t","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::CreateNamedSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSharedMemorySemaphore__t/","text":"iox::posix::CreateUnnamedSharedMemorySemaphore_t \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::CreateUnnamedSharedMemorySemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSharedMemorySemaphore__t/#ioxposixcreateunnamedsharedmemorysemaphore_t","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::CreateUnnamedSharedMemorySemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSingleProcessSemaphore__t/","text":"iox::posix::CreateUnnamedSingleProcessSemaphore_t \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::CreateUnnamedSingleProcessSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1CreateUnnamedSingleProcessSemaphore__t/#ioxposixcreateunnamedsingleprocesssemaphore_t","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::CreateUnnamedSingleProcessSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1OpenNamedSemaphore__t/","text":"iox::posix::OpenNamedSemaphore_t \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::OpenNamedSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1OpenNamedSemaphore__t/#ioxposixopennamedsemaphore_t","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::OpenNamedSemaphore_t"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/","text":"iox::posix::PosixCallResult \ud83d\udd17 result of a posix call More... #include <iceoryx_hoofs/posix_wrapper/posix_call.hpp> Public Functions \ud83d\udd17 Name PosixCallResult () =default cxx::string < POSIX_CALL_ERROR_STRING_SIZE > getHumanReadableErrnum () const returns the result of std::strerror(errnum) which acquires a human readable error string Public Attributes \ud83d\udd17 Name T value the return value of the posix function call int32_t errnum the errno value which was set by the posix function call Detailed Description \ud83d\udd17 template < typename T > struct iox :: posix :: PosixCallResult ; result of a posix call Public Functions Documentation \ud83d\udd17 function PosixCallResult \ud83d\udd17 PosixCallResult () = default function getHumanReadableErrnum \ud83d\udd17 cxx :: string < POSIX_CALL_ERROR_STRING_SIZE > getHumanReadableErrnum () const returns the result of std::strerror(errnum) which acquires a human readable error string Public Attributes Documentation \ud83d\udd17 variable value \ud83d\udd17 T value {}; the return value of the posix function call variable errnum \ud83d\udd17 int32_t errnum = POSIX_CALL_INVALID_ERRNO ; the errno value which was set by the posix function call Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixCallResult"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#ioxposixposixcallresult","text":"result of a posix call More... #include <iceoryx_hoofs/posix_wrapper/posix_call.hpp>","title":"iox::posix::PosixCallResult"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-functions","text":"Name PosixCallResult () =default cxx::string < POSIX_CALL_ERROR_STRING_SIZE > getHumanReadableErrnum () const returns the result of std::strerror(errnum) which acquires a human readable error string","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-attributes","text":"Name T value the return value of the posix function call int32_t errnum the errno value which was set by the posix function call","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#detailed-description","text":"template < typename T > struct iox :: posix :: PosixCallResult ; result of a posix call","title":"Detailed Description"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#function-posixcallresult","text":"PosixCallResult () = default","title":"function PosixCallResult"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#function-gethumanreadableerrnum","text":"cxx :: string < POSIX_CALL_ERROR_STRING_SIZE > getHumanReadableErrnum () const returns the result of std::strerror(errnum) which acquires a human readable error string","title":"function getHumanReadableErrnum"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#variable-value","text":"T value {}; the return value of the posix function call","title":"variable value"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixCallResult/#variable-errnum","text":"int32_t errnum = POSIX_CALL_INVALID_ERRNO ; the errno value which was set by the posix function call Updated on 18 December 2023 at 13:11:42 CET","title":"variable errnum"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/","text":"iox::posix::PosixRights \ud83d\udd17 Public Functions \ud83d\udd17 Name PosixRights (bool f_read, bool f_write, bool f_execute) Public Attributes \ud83d\udd17 Name bool m_read bool m_write bool m_execute Public Functions Documentation \ud83d\udd17 function PosixRights \ud83d\udd17 PosixRights ( bool f_read , bool f_write , bool f_execute ) Public Attributes Documentation \ud83d\udd17 variable m_read \ud83d\udd17 bool m_read ; variable m_write \ud83d\udd17 bool m_write ; variable m_execute \ud83d\udd17 bool m_execute ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::PosixRights"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#ioxposixposixrights","text":"","title":"iox::posix::PosixRights"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-functions","text":"Name PosixRights (bool f_read, bool f_write, bool f_execute)","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-attributes","text":"Name bool m_read bool m_write bool m_execute","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#function-posixrights","text":"PosixRights ( bool f_read , bool f_write , bool f_execute )","title":"function PosixRights"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#variable-m_read","text":"bool m_read ;","title":"variable m_read"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#variable-m_write","text":"bool m_write ;","title":"variable m_write"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1PosixRights/#variable-m_execute","text":"bool m_execute ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable m_execute"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/","text":"iox::posix::Timer::OsTimerCallbackHandle \ud83d\udd17 Public Functions \ud83d\udd17 Name sigval indexAndDescriptorToSigval (uint8_t index, uint32_t descriptor) uint8_t sigvalToIndex (sigval intVal) uint32_t sigvalToDescriptor (sigval intVal) void incrementDescriptor () Public Attributes \ud83d\udd17 Name constexpr uint32_t MAX_DESCRIPTOR_VALUE std::mutex m_accessMutex std::atomic< uint32_t > m_descriptor the descriptor is unique for a timer_t in OsTimer, if this handle is recycled, the descriptor needs to be incremented first std::atomic_flag m_callbackIsAboutToBeExecuted std::atomic< bool > m_inUse std::atomic< bool > m_isTimerActive std::atomic< uint64_t > m_timerInvocationCounter CatchUpPolicy m_catchUpPolicy OsTimer * m_timer Public Functions Documentation \ud83d\udd17 function indexAndDescriptorToSigval \ud83d\udd17 static sigval indexAndDescriptorToSigval ( uint8_t index , uint32_t descriptor ) function sigvalToIndex \ud83d\udd17 static uint8_t sigvalToIndex ( sigval intVal ) function sigvalToDescriptor \ud83d\udd17 static uint32_t sigvalToDescriptor ( sigval intVal ) function incrementDescriptor \ud83d\udd17 void incrementDescriptor () Public Attributes Documentation \ud83d\udd17 variable MAX_DESCRIPTOR_VALUE \ud83d\udd17 static constexpr uint32_t MAX_DESCRIPTOR_VALUE {( 1u << 24u ) - 1u }; variable m_accessMutex \ud83d\udd17 std :: mutex m_accessMutex ; variable m_descriptor \ud83d\udd17 std :: atomic < uint32_t > m_descriptor { 0u }; the descriptor is unique for a timer_t in OsTimer, if this handle is recycled, the descriptor needs to be incremented first variable m_callbackIsAboutToBeExecuted \ud83d\udd17 std :: atomic_flag m_callbackIsAboutToBeExecuted = ATOMIC_FLAG_INIT ; variable m_inUse \ud83d\udd17 std :: atomic < bool > m_inUse { false }; variable m_isTimerActive \ud83d\udd17 std :: atomic < bool > m_isTimerActive { false }; variable m_timerInvocationCounter \ud83d\udd17 std :: atomic < uint64_t > m_timerInvocationCounter { 0u }; variable m_catchUpPolicy \ud83d\udd17 CatchUpPolicy m_catchUpPolicy { CatchUpPolicy :: TERMINATE }; variable m_timer \ud83d\udd17 OsTimer * m_timer { nullptr }; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::Timer::OsTimerCallbackHandle"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#ioxposixtimerostimercallbackhandle","text":"","title":"iox::posix::Timer::OsTimerCallbackHandle"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-functions","text":"Name sigval indexAndDescriptorToSigval (uint8_t index, uint32_t descriptor) uint8_t sigvalToIndex (sigval intVal) uint32_t sigvalToDescriptor (sigval intVal) void incrementDescriptor ()","title":"Public Functions"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-attributes","text":"Name constexpr uint32_t MAX_DESCRIPTOR_VALUE std::mutex m_accessMutex std::atomic< uint32_t > m_descriptor the descriptor is unique for a timer_t in OsTimer, if this handle is recycled, the descriptor needs to be incremented first std::atomic_flag m_callbackIsAboutToBeExecuted std::atomic< bool > m_inUse std::atomic< bool > m_isTimerActive std::atomic< uint64_t > m_timerInvocationCounter CatchUpPolicy m_catchUpPolicy OsTimer * m_timer","title":"Public Attributes"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-indexanddescriptortosigval","text":"static sigval indexAndDescriptorToSigval ( uint8_t index , uint32_t descriptor )","title":"function indexAndDescriptorToSigval"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-sigvaltoindex","text":"static uint8_t sigvalToIndex ( sigval intVal )","title":"function sigvalToIndex"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-sigvaltodescriptor","text":"static uint32_t sigvalToDescriptor ( sigval intVal )","title":"function sigvalToDescriptor"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#function-incrementdescriptor","text":"void incrementDescriptor ()","title":"function incrementDescriptor"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-max_descriptor_value","text":"static constexpr uint32_t MAX_DESCRIPTOR_VALUE {( 1u << 24u ) - 1u };","title":"variable MAX_DESCRIPTOR_VALUE"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_accessmutex","text":"std :: mutex m_accessMutex ;","title":"variable m_accessMutex"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_descriptor","text":"std :: atomic < uint32_t > m_descriptor { 0u }; the descriptor is unique for a timer_t in OsTimer, if this handle is recycled, the descriptor needs to be incremented first","title":"variable m_descriptor"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_callbackisabouttobeexecuted","text":"std :: atomic_flag m_callbackIsAboutToBeExecuted = ATOMIC_FLAG_INIT ;","title":"variable m_callbackIsAboutToBeExecuted"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_inuse","text":"std :: atomic < bool > m_inUse { false };","title":"variable m_inUse"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_istimeractive","text":"std :: atomic < bool > m_isTimerActive { false };","title":"variable m_isTimerActive"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_timerinvocationcounter","text":"std :: atomic < uint64_t > m_timerInvocationCounter { 0u };","title":"variable m_timerInvocationCounter"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_catchuppolicy","text":"CatchUpPolicy m_catchUpPolicy { CatchUpPolicy :: TERMINATE };","title":"variable m_catchUpPolicy"},{"location":"API-reference/hoofs/Classes/structiox_1_1posix_1_1Timer_1_1OsTimerCallbackHandle/#variable-m_timer","text":"OsTimer * m_timer { nullptr }; Updated on 18 December 2023 at 13:11:42 CET","title":"variable m_timer"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/","text":"iceoryx_hoofs/cxx/algorithm.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::algorithm Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_ALGORITHM_HPP #define IOX_HOOFS_CXX_ALGORITHM_HPP #include <cstdint> #include <type_traits> namespace iox { namespace algorithm { template < typename T > constexpr T max ( const T & left ) noexcept ; template < typename T > constexpr T max ( const T & left , const T & right ) noexcept ; template < typename T , typename ... Targs > constexpr T max ( const T & left , const T & right , const Targs & ... args ) noexcept ; template < typename T > constexpr T min ( const T & left ) noexcept ; template < typename T > constexpr T min ( const T & left , const T & right ) noexcept ; template < typename T , typename ... Targs > constexpr T min ( const T & left , const T & right , const Targs & ... args ) noexcept ; template < typename T , typename CompareType > constexpr bool doesContainType () noexcept ; template < typename T , typename CompareType , typename Next , typename ... Remainder > constexpr bool doesContainType () noexcept ; template < typename T > inline constexpr bool doesContainValue ( const T ) noexcept ; template < typename T , typename ... ValueList > inline constexpr bool doesContainValue ( const T value , const T firstValueListEntry , const ValueList ... remainingValueListEntries ) noexcept ; template < typename Container > Container uniqueMergeSortedContainers ( const Container & v1 , const Container & v2 ) noexcept ; } // namespace algorithm } // namespace iox #include \"iceoryx_hoofs/internal/cxx/algorithm.inl\" #endif // IOX_HOOFS_CXX_ALGORITHM_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/algorithm.hpp"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/#iceoryx_hoofscxxalgorithmhpp","text":"","title":"iceoryx_hoofs/cxx/algorithm.hpp"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::algorithm","title":"Namespaces"},{"location":"API-reference/hoofs/Files/algorithm_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_ALGORITHM_HPP #define IOX_HOOFS_CXX_ALGORITHM_HPP #include <cstdint> #include <type_traits> namespace iox { namespace algorithm { template < typename T > constexpr T max ( const T & left ) noexcept ; template < typename T > constexpr T max ( const T & left , const T & right ) noexcept ; template < typename T , typename ... Targs > constexpr T max ( const T & left , const T & right , const Targs & ... args ) noexcept ; template < typename T > constexpr T min ( const T & left ) noexcept ; template < typename T > constexpr T min ( const T & left , const T & right ) noexcept ; template < typename T , typename ... Targs > constexpr T min ( const T & left , const T & right , const Targs & ... args ) noexcept ; template < typename T , typename CompareType > constexpr bool doesContainType () noexcept ; template < typename T , typename CompareType , typename Next , typename ... Remainder > constexpr bool doesContainType () noexcept ; template < typename T > inline constexpr bool doesContainValue ( const T ) noexcept ; template < typename T , typename ... ValueList > inline constexpr bool doesContainValue ( const T value , const T firstValueListEntry , const ValueList ... remainingValueListEntries ) noexcept ; template < typename Container > Container uniqueMergeSortedContainers ( const Container & v1 , const Container & v2 ) noexcept ; } // namespace algorithm } // namespace iox #include \"iceoryx_hoofs/internal/cxx/algorithm.inl\" #endif // IOX_HOOFS_CXX_ALGORITHM_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/attributes_8hpp/","text":"iceoryx_hoofs/cxx/attributes.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Defines \ud83d\udd17 Name IOX_DISCARD_RESULT (expr) if a function has a return value which you do not want to use then you can wrap the function with that macro. Purpose is to suppress the unused compiler warning by adding an attribute to the return value IOX_NO_DISCARD IOX_NO_DISCARD adds the [[nodiscard]] keyword if it is available for the current compiler. If additionally the keyword [[gnu::warn_unused]] is present it will be added as well. IOX_FALLTHROUGH IOX_FALLTHROUGH adds the [[fallthrough]] keyword when it is available for the current compiler. IOX_MAYBE_UNUSED IOX_MAYBE_UNUSED adds the [[gnu::unused]] or [[maybe_unused]] attribute when it is available for the current compiler. Macro Documentation \ud83d\udd17 define IOX_DISCARD_RESULT \ud83d\udd17 #define IOX_DISCARD_RESULT( expr ) static_cast < void > ( expr ) if a function has a return value which you do not want to use then you can wrap the function with that macro. Purpose is to suppress the unused compiler warning by adding an attribute to the return value Parameters : expr name of the function where the return value is not used. uint32_t foo (); IOX_DISCARD_RESULT ( foo ()); // suppress compiler warning for unused return value define IOX_NO_DISCARD \ud83d\udd17 #define IOX_NO_DISCARD IOX_NO_DISCARD adds the [[nodiscard]] keyword if it is available for the current compiler. If additionally the keyword [[gnu::warn_unused]] is present it will be added as well. Note : [[nodiscard]], [[gnu::warn_unused]] supported since clang 3.9 ( https://clang.llvm.org/cxx_status.html ) activate keywords for gcc>=5 or clang>=4 define IOX_FALLTHROUGH \ud83d\udd17 #define IOX_FALLTHROUGH IOX_FALLTHROUGH adds the [[fallthrough]] keyword when it is available for the current compiler. Note : [[fallthrough]] supported since clang 3.9 ( https://clang.llvm.org/cxx_status.html ) activate keywords for gcc>=7 or clang>=4 define IOX_MAYBE_UNUSED \ud83d\udd17 #define IOX_MAYBE_UNUSED IOX_MAYBE_UNUSED adds the [[gnu::unused]] or [[maybe_unused]] attribute when it is available for the current compiler. Note : activate attribute for gcc or clang Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_ATTRIBUTES_HPP #define IOX_HOOFS_CXX_ATTRIBUTES_HPP namespace iox { namespace cxx { // NOLINTNEXTLINE #define IOX_DISCARD_RESULT(expr) static_cast<void>(expr) // [[nodiscard]], [[gnu::warn_unused]] supported since gcc 4.8 (https://gcc.gnu.org/projects/cxx-status.html) #if defined(_WIN32) // On WIN32 we are using C++17 which makes the keyword [[nodiscard]] available // NOLINTNEXTLINE #define IOX_NO_DISCARD [[nodiscard]] #elif defined(__APPLE__) && defined(__clang__) // On APPLE we are using C++17 which makes the keyword [[nodiscard]] available // NOLINTNEXTLINE #define IOX_NO_DISCARD [[nodiscard, gnu::warn_unused]] #elif (defined(__clang__) && __clang_major__ >= 4) // NOLINTNEXTLINE #define IOX_NO_DISCARD [[gnu::warn_unused]] #elif (defined(__GNUC__) && __GNUC__ >= 5) // NOLINTNEXTLINE #define IOX_NO_DISCARD [[nodiscard, gnu::warn_unused]] #else // on an unknown platform we use for now nothing since we do not know what is supported there #define IOX_NO_DISCARD #endif // [[fallthrough]] supported since gcc 7 (https://gcc.gnu.org/projects/cxx-status.html) #if defined(_WIN32) // On WIN32 we are using C++17 which makes the keyword [[fallthrough]] available // NOLINTNEXTLINE #define IOX_FALLTHROUGH [[fallthrough]] #elif defined(__APPLE__) && defined(__clang__) // On APPLE we are using C++17 which makes the keyword [[fallthrough]] available // NOLINTNEXTLINE #define IOX_FALLTHROUGH [[fallthrough]] #elif (defined(__GNUC__) && __GNUC__ >= 7) && !defined(__clang__) // clang prints a warning therefore we exclude it here // NOLINTNEXTLINE #define IOX_FALLTHROUGH [[fallthrough]] #else // on an unknown platform we use for now nothing since we do not know what is supported there #define IOX_FALLTHROUGH #endif #if defined(__GNUC__) || defined(__clang__) // NOLINTNEXTLINE #define IOX_MAYBE_UNUSED [[gnu::unused]] #elif defined(_WIN32) // On WIN32 we are using C++17 which makes the attribute [[maybe_unused]] available // NOLINTNEXTLINE #define IOX_MAYBE_UNUSED [[maybe_unused]] // on an unknown platform we use for now nothing since we do not know what is supported there #else #define IOX_MAYBE_UNUSED #endif } // namespace cxx } // namespace iox #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/attributes.hpp"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#iceoryx_hoofscxxattributeshpp","text":"","title":"iceoryx_hoofs/cxx/attributes.hpp"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#defines","text":"Name IOX_DISCARD_RESULT (expr) if a function has a return value which you do not want to use then you can wrap the function with that macro. Purpose is to suppress the unused compiler warning by adding an attribute to the return value IOX_NO_DISCARD IOX_NO_DISCARD adds the [[nodiscard]] keyword if it is available for the current compiler. If additionally the keyword [[gnu::warn_unused]] is present it will be added as well. IOX_FALLTHROUGH IOX_FALLTHROUGH adds the [[fallthrough]] keyword when it is available for the current compiler. IOX_MAYBE_UNUSED IOX_MAYBE_UNUSED adds the [[gnu::unused]] or [[maybe_unused]] attribute when it is available for the current compiler.","title":"Defines"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_discard_result","text":"#define IOX_DISCARD_RESULT( expr ) static_cast < void > ( expr ) if a function has a return value which you do not want to use then you can wrap the function with that macro. Purpose is to suppress the unused compiler warning by adding an attribute to the return value Parameters : expr name of the function where the return value is not used. uint32_t foo (); IOX_DISCARD_RESULT ( foo ()); // suppress compiler warning for unused return value","title":"define IOX_DISCARD_RESULT"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_no_discard","text":"#define IOX_NO_DISCARD IOX_NO_DISCARD adds the [[nodiscard]] keyword if it is available for the current compiler. If additionally the keyword [[gnu::warn_unused]] is present it will be added as well. Note : [[nodiscard]], [[gnu::warn_unused]] supported since clang 3.9 ( https://clang.llvm.org/cxx_status.html ) activate keywords for gcc>=5 or clang>=4","title":"define IOX_NO_DISCARD"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_fallthrough","text":"#define IOX_FALLTHROUGH IOX_FALLTHROUGH adds the [[fallthrough]] keyword when it is available for the current compiler. Note : [[fallthrough]] supported since clang 3.9 ( https://clang.llvm.org/cxx_status.html ) activate keywords for gcc>=7 or clang>=4","title":"define IOX_FALLTHROUGH"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#define-iox_maybe_unused","text":"#define IOX_MAYBE_UNUSED IOX_MAYBE_UNUSED adds the [[gnu::unused]] or [[maybe_unused]] attribute when it is available for the current compiler. Note : activate attribute for gcc or clang","title":"define IOX_MAYBE_UNUSED"},{"location":"API-reference/hoofs/Files/attributes_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_ATTRIBUTES_HPP #define IOX_HOOFS_CXX_ATTRIBUTES_HPP namespace iox { namespace cxx { // NOLINTNEXTLINE #define IOX_DISCARD_RESULT(expr) static_cast<void>(expr) // [[nodiscard]], [[gnu::warn_unused]] supported since gcc 4.8 (https://gcc.gnu.org/projects/cxx-status.html) #if defined(_WIN32) // On WIN32 we are using C++17 which makes the keyword [[nodiscard]] available // NOLINTNEXTLINE #define IOX_NO_DISCARD [[nodiscard]] #elif defined(__APPLE__) && defined(__clang__) // On APPLE we are using C++17 which makes the keyword [[nodiscard]] available // NOLINTNEXTLINE #define IOX_NO_DISCARD [[nodiscard, gnu::warn_unused]] #elif (defined(__clang__) && __clang_major__ >= 4) // NOLINTNEXTLINE #define IOX_NO_DISCARD [[gnu::warn_unused]] #elif (defined(__GNUC__) && __GNUC__ >= 5) // NOLINTNEXTLINE #define IOX_NO_DISCARD [[nodiscard, gnu::warn_unused]] #else // on an unknown platform we use for now nothing since we do not know what is supported there #define IOX_NO_DISCARD #endif // [[fallthrough]] supported since gcc 7 (https://gcc.gnu.org/projects/cxx-status.html) #if defined(_WIN32) // On WIN32 we are using C++17 which makes the keyword [[fallthrough]] available // NOLINTNEXTLINE #define IOX_FALLTHROUGH [[fallthrough]] #elif defined(__APPLE__) && defined(__clang__) // On APPLE we are using C++17 which makes the keyword [[fallthrough]] available // NOLINTNEXTLINE #define IOX_FALLTHROUGH [[fallthrough]] #elif (defined(__GNUC__) && __GNUC__ >= 7) && !defined(__clang__) // clang prints a warning therefore we exclude it here // NOLINTNEXTLINE #define IOX_FALLTHROUGH [[fallthrough]] #else // on an unknown platform we use for now nothing since we do not know what is supported there #define IOX_FALLTHROUGH #endif #if defined(__GNUC__) || defined(__clang__) // NOLINTNEXTLINE #define IOX_MAYBE_UNUSED [[gnu::unused]] #elif defined(_WIN32) // On WIN32 we are using C++17 which makes the attribute [[maybe_unused]] available // NOLINTNEXTLINE #define IOX_MAYBE_UNUSED [[maybe_unused]] // on an unknown platform we use for now nothing since we do not know what is supported there #else #define IOX_MAYBE_UNUSED #endif } // namespace cxx } // namespace iox #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/convert_8hpp/","text":"iceoryx_hoofs/cxx/convert.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::convert Collection of static methods for conversion from and to string. Source code \ud83d\udd17 // Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_CONVERT_HPP #define IOX_HOOFS_CXX_CONVERT_HPP #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/posix_wrapper/posix_call.hpp\" #include <climits> #include <cmath> #include <cstdlib> #include <cstring> #include <iostream> #include <limits> #include <sstream> #include <string> namespace iox { namespace cxx { class convert { public : enum class NumberType { INTEGER , UNSIGNED_INTEGER , FLOAT }; static constexpr int32_t STRTOULL_BASE = 10 ; template < typename Source > static typename std :: enable_if <! std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) noexcept ; template < typename Source > static typename std :: enable_if < std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) noexcept ; template < typename Destination > static bool fromString ( const char * v , Destination & dest ) noexcept ; static bool stringIsNumber ( const char * v , const NumberType type ) noexcept ; private : static bool stringIsNumberWithErrorMessage ( const char * v , const NumberType type ) noexcept ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/convert.inl\" #endif // IOX_HOOFS_CXX_CONVERT_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/convert.hpp"},{"location":"API-reference/hoofs/Files/convert_8hpp/#iceoryx_hoofscxxconverthpp","text":"","title":"iceoryx_hoofs/cxx/convert.hpp"},{"location":"API-reference/hoofs/Files/convert_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/convert_8hpp/#classes","text":"Name class iox::cxx::convert Collection of static methods for conversion from and to string.","title":"Classes"},{"location":"API-reference/hoofs/Files/convert_8hpp/#source-code","text":"// Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_CONVERT_HPP #define IOX_HOOFS_CXX_CONVERT_HPP #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/posix_wrapper/posix_call.hpp\" #include <climits> #include <cmath> #include <cstdlib> #include <cstring> #include <iostream> #include <limits> #include <sstream> #include <string> namespace iox { namespace cxx { class convert { public : enum class NumberType { INTEGER , UNSIGNED_INTEGER , FLOAT }; static constexpr int32_t STRTOULL_BASE = 10 ; template < typename Source > static typename std :: enable_if <! std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) noexcept ; template < typename Source > static typename std :: enable_if < std :: is_convertible < Source , std :: string >:: value , std :: string >:: type toString ( const Source & t ) noexcept ; template < typename Destination > static bool fromString ( const char * v , Destination & dest ) noexcept ; static bool stringIsNumber ( const char * v , const NumberType type ) noexcept ; private : static bool stringIsNumberWithErrorMessage ( const char * v , const NumberType type ) noexcept ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/convert.inl\" #endif // IOX_HOOFS_CXX_CONVERT_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/creation_8hpp/","text":"iceoryx_hoofs/design_pattern/creation.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name DesignPattern Classes \ud83d\udd17 Name class DesignPattern::Creation This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP #define IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include <utility> namespace DesignPattern { template < typename DerivedClass , typename ErrorType > class Creation { public : using CreationPattern_t = Creation < DerivedClass , ErrorType > ; using result_t = iox :: cxx :: expected < DerivedClass , ErrorType > ; using errorType_t = ErrorType ; template < typename ... Targs > static result_t create ( Targs && ... args ) noexcept ; static result_t verify ( DerivedClass && newObject ) noexcept ; template < typename ... Targs > static iox :: cxx :: expected < ErrorType > placementCreate ( void * const memory , Targs && ... args ) noexcept ; Creation () noexcept = default ; Creation ( Creation && rhs ) noexcept ; Creation & operator = ( Creation && rhs ) noexcept ; Creation ( const Creation & rhs ) noexcept = default ; Creation & operator = ( const Creation & rhs ) noexcept = default ; bool isInitialized () const noexcept ; protected : bool m_isInitialized { false }; ErrorType m_errorValue ; }; } // namespace DesignPattern #include \"iceoryx_hoofs/internal/design_pattern/creation.inl\" #endif // IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/design_pattern/creation.hpp"},{"location":"API-reference/hoofs/Files/creation_8hpp/#iceoryx_hoofsdesign_patterncreationhpp","text":"","title":"iceoryx_hoofs/design_pattern/creation.hpp"},{"location":"API-reference/hoofs/Files/creation_8hpp/#namespaces","text":"Name DesignPattern","title":"Namespaces"},{"location":"API-reference/hoofs/Files/creation_8hpp/#classes","text":"Name class DesignPattern::Creation This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user.","title":"Classes"},{"location":"API-reference/hoofs/Files/creation_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP #define IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include <utility> namespace DesignPattern { template < typename DerivedClass , typename ErrorType > class Creation { public : using CreationPattern_t = Creation < DerivedClass , ErrorType > ; using result_t = iox :: cxx :: expected < DerivedClass , ErrorType > ; using errorType_t = ErrorType ; template < typename ... Targs > static result_t create ( Targs && ... args ) noexcept ; static result_t verify ( DerivedClass && newObject ) noexcept ; template < typename ... Targs > static iox :: cxx :: expected < ErrorType > placementCreate ( void * const memory , Targs && ... args ) noexcept ; Creation () noexcept = default ; Creation ( Creation && rhs ) noexcept ; Creation & operator = ( Creation && rhs ) noexcept ; Creation ( const Creation & rhs ) noexcept = default ; Creation & operator = ( const Creation & rhs ) noexcept = default ; bool isInitialized () const noexcept ; protected : bool m_isInitialized { false }; ErrorType m_errorValue ; }; } // namespace DesignPattern #include \"iceoryx_hoofs/internal/design_pattern/creation.inl\" #endif // IOX_HOOFS_DESIGN_PATTERN_CREATION_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/","text":"iceoryx_hoofs/cxx/deadline_timer.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::DeadlineTimer This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. Source code \ud83d\udd17 // Copyright (c) 2021 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_DEADLINETIMER_HPP #define IOX_HOOFS_CXX_DEADLINETIMER_HPP #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/platform/signal.hpp\" #include <chrono> #include <cstdint> namespace iox { namespace cxx { class DeadlineTimer { public : explicit DeadlineTimer ( const iox :: units :: Duration timeToWait ) noexcept ; bool hasExpired () const noexcept ; void reset () noexcept ; void reset ( const iox :: units :: Duration timeToWait ) noexcept ; iox :: units :: Duration remainingTime () const noexcept ; private : static iox :: units :: Duration getCurrentMonotonicTime () noexcept ; iox :: units :: Duration m_timeToWait ; iox :: units :: Duration m_endTime ; }; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_CXX_DEADLINETIMER_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/deadline_timer.hpp"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#iceoryx_hoofscxxdeadline_timerhpp","text":"","title":"iceoryx_hoofs/cxx/deadline_timer.hpp"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#classes","text":"Name class iox::cxx::DeadlineTimer This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off.","title":"Classes"},{"location":"API-reference/hoofs/Files/deadline__timer_8hpp/#source-code","text":"// Copyright (c) 2021 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_DEADLINETIMER_HPP #define IOX_HOOFS_CXX_DEADLINETIMER_HPP #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/platform/signal.hpp\" #include <chrono> #include <cstdint> namespace iox { namespace cxx { class DeadlineTimer { public : explicit DeadlineTimer ( const iox :: units :: Duration timeToWait ) noexcept ; bool hasExpired () const noexcept ; void reset () noexcept ; void reset ( const iox :: units :: Duration timeToWait ) noexcept ; iox :: units :: Duration remainingTime () const noexcept ; private : static iox :: units :: Duration getCurrentMonotonicTime () noexcept ; iox :: units :: Duration m_timeToWait ; iox :: units :: Duration m_endTime ; }; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_CXX_DEADLINETIMER_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/dir_43372932726f396de09d653db921856f/","text":"iceoryx_hoofs \ud83d\udd17 Directories \ud83d\udd17 Name iceoryx_hoofs/concurrent iceoryx_hoofs/cxx iceoryx_hoofs/design_pattern iceoryx_hoofs/error_handling iceoryx_hoofs/log iceoryx_hoofs/posix_wrapper Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs"},{"location":"API-reference/hoofs/Files/dir_43372932726f396de09d653db921856f/#iceoryx_hoofs","text":"","title":"iceoryx_hoofs"},{"location":"API-reference/hoofs/Files/dir_43372932726f396de09d653db921856f/#directories","text":"Name iceoryx_hoofs/concurrent iceoryx_hoofs/cxx iceoryx_hoofs/design_pattern iceoryx_hoofs/error_handling iceoryx_hoofs/log iceoryx_hoofs/posix_wrapper Updated on 18 December 2023 at 13:11:42 CET","title":"Directories"},{"location":"API-reference/hoofs/Files/dir_4554a0dfe1910cf7e5fc30606e89ec3b/","text":"iceoryx_hoofs/log \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_hoofs/log/logcommon.hpp iceoryx_hoofs/log/logger.hpp iceoryx_hoofs/log/logging.hpp iceoryx_hoofs/log/logging_free_function_building_block.hpp iceoryx_hoofs/log/logmanager.hpp iceoryx_hoofs/log/logstream.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/log"},{"location":"API-reference/hoofs/Files/dir_4554a0dfe1910cf7e5fc30606e89ec3b/#iceoryx_hoofslog","text":"","title":"iceoryx_hoofs/log"},{"location":"API-reference/hoofs/Files/dir_4554a0dfe1910cf7e5fc30606e89ec3b/#files","text":"Name iceoryx_hoofs/log/logcommon.hpp iceoryx_hoofs/log/logger.hpp iceoryx_hoofs/log/logging.hpp iceoryx_hoofs/log/logging_free_function_building_block.hpp iceoryx_hoofs/log/logmanager.hpp iceoryx_hoofs/log/logstream.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"Files"},{"location":"API-reference/hoofs/Files/dir_4be3a838476cf176e1cc6d252595800c/","text":"iceoryx_hoofs/error_handling \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_hoofs/error_handling/error_handling.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/error_handling"},{"location":"API-reference/hoofs/Files/dir_4be3a838476cf176e1cc6d252595800c/#iceoryx_hoofserror_handling","text":"","title":"iceoryx_hoofs/error_handling"},{"location":"API-reference/hoofs/Files/dir_4be3a838476cf176e1cc6d252595800c/#files","text":"Name iceoryx_hoofs/error_handling/error_handling.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"Files"},{"location":"API-reference/hoofs/Files/dir_80df14e6826adad25285ba7061a3cbc3/","text":"iceoryx_hoofs/posix_wrapper \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_hoofs/posix_wrapper/file_lock.hpp iceoryx_hoofs/posix_wrapper/named_pipe.hpp iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp iceoryx_hoofs/posix_wrapper/posix_call.hpp iceoryx_hoofs/posix_wrapper/semaphore.hpp iceoryx_hoofs/posix_wrapper/signal_handler.hpp iceoryx_hoofs/posix_wrapper/signal_watcher.hpp iceoryx_hoofs/posix_wrapper/thread.hpp iceoryx_hoofs/posix_wrapper/timer.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper"},{"location":"API-reference/hoofs/Files/dir_80df14e6826adad25285ba7061a3cbc3/#iceoryx_hoofsposix_wrapper","text":"","title":"iceoryx_hoofs/posix_wrapper"},{"location":"API-reference/hoofs/Files/dir_80df14e6826adad25285ba7061a3cbc3/#files","text":"Name iceoryx_hoofs/posix_wrapper/file_lock.hpp iceoryx_hoofs/posix_wrapper/named_pipe.hpp iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp iceoryx_hoofs/posix_wrapper/posix_call.hpp iceoryx_hoofs/posix_wrapper/semaphore.hpp iceoryx_hoofs/posix_wrapper/signal_handler.hpp iceoryx_hoofs/posix_wrapper/signal_watcher.hpp iceoryx_hoofs/posix_wrapper/thread.hpp iceoryx_hoofs/posix_wrapper/timer.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/hoofs/Files/dir_8475303a094ead7ab771a23b7ea9d6dc/","text":"iceoryx_hoofs/concurrent \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_hoofs/concurrent/lockfree_queue.hpp iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/concurrent"},{"location":"API-reference/hoofs/Files/dir_8475303a094ead7ab771a23b7ea9d6dc/#iceoryx_hoofsconcurrent","text":"","title":"iceoryx_hoofs/concurrent"},{"location":"API-reference/hoofs/Files/dir_8475303a094ead7ab771a23b7ea9d6dc/#files","text":"Name iceoryx_hoofs/concurrent/lockfree_queue.hpp iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"Files"},{"location":"API-reference/hoofs/Files/dir_9f0c002bf5da746f923d40dd18d0d6ea/","text":"iceoryx_hoofs/design_pattern \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_hoofs/design_pattern/creation.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/design_pattern"},{"location":"API-reference/hoofs/Files/dir_9f0c002bf5da746f923d40dd18d0d6ea/#iceoryx_hoofsdesign_pattern","text":"","title":"iceoryx_hoofs/design_pattern"},{"location":"API-reference/hoofs/Files/dir_9f0c002bf5da746f923d40dd18d0d6ea/#files","text":"Name iceoryx_hoofs/design_pattern/creation.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"Files"},{"location":"API-reference/hoofs/Files/dir_dd6b3e218624307615d59b658265510b/","text":"iceoryx_hoofs/cxx \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_hoofs/cxx/algorithm.hpp iceoryx_hoofs/cxx/attributes.hpp iceoryx_hoofs/cxx/convert.hpp iceoryx_hoofs/cxx/deadline_timer.hpp iceoryx_hoofs/cxx/expected.hpp iceoryx_hoofs/cxx/filesystem.hpp iceoryx_hoofs/cxx/forward_list.hpp iceoryx_hoofs/cxx/function.hpp iceoryx_hoofs/cxx/function_ref.hpp iceoryx_hoofs/cxx/functional_interface.hpp iceoryx_hoofs/cxx/generic_raii.hpp iceoryx_hoofs/cxx/helplets.hpp iceoryx_hoofs/cxx/list.hpp iceoryx_hoofs/cxx/method_callback.hpp iceoryx_hoofs/cxx/newtype.hpp iceoryx_hoofs/cxx/optional.hpp iceoryx_hoofs/cxx/poor_mans_heap.hpp iceoryx_hoofs/cxx/requires.hpp iceoryx_hoofs/cxx/scoped_static.hpp iceoryx_hoofs/cxx/serialization.hpp iceoryx_hoofs/cxx/stack.hpp iceoryx_hoofs/cxx/string.hpp iceoryx_hoofs/cxx/type_traits.hpp iceoryx_hoofs/cxx/types.hpp iceoryx_hoofs/cxx/unique_ptr.hpp iceoryx_hoofs/cxx/variant.hpp iceoryx_hoofs/cxx/variant_queue.hpp iceoryx_hoofs/cxx/vector.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx"},{"location":"API-reference/hoofs/Files/dir_dd6b3e218624307615d59b658265510b/#iceoryx_hoofscxx","text":"","title":"iceoryx_hoofs/cxx"},{"location":"API-reference/hoofs/Files/dir_dd6b3e218624307615d59b658265510b/#files","text":"Name iceoryx_hoofs/cxx/algorithm.hpp iceoryx_hoofs/cxx/attributes.hpp iceoryx_hoofs/cxx/convert.hpp iceoryx_hoofs/cxx/deadline_timer.hpp iceoryx_hoofs/cxx/expected.hpp iceoryx_hoofs/cxx/filesystem.hpp iceoryx_hoofs/cxx/forward_list.hpp iceoryx_hoofs/cxx/function.hpp iceoryx_hoofs/cxx/function_ref.hpp iceoryx_hoofs/cxx/functional_interface.hpp iceoryx_hoofs/cxx/generic_raii.hpp iceoryx_hoofs/cxx/helplets.hpp iceoryx_hoofs/cxx/list.hpp iceoryx_hoofs/cxx/method_callback.hpp iceoryx_hoofs/cxx/newtype.hpp iceoryx_hoofs/cxx/optional.hpp iceoryx_hoofs/cxx/poor_mans_heap.hpp iceoryx_hoofs/cxx/requires.hpp iceoryx_hoofs/cxx/scoped_static.hpp iceoryx_hoofs/cxx/serialization.hpp iceoryx_hoofs/cxx/stack.hpp iceoryx_hoofs/cxx/string.hpp iceoryx_hoofs/cxx/type_traits.hpp iceoryx_hoofs/cxx/types.hpp iceoryx_hoofs/cxx/unique_ptr.hpp iceoryx_hoofs/cxx/variant.hpp iceoryx_hoofs/cxx/variant_queue.hpp iceoryx_hoofs/cxx/vector.hpp Updated on 18 December 2023 at 13:11:42 CET","title":"Files"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/","text":"iceoryx_hoofs/error_handling/error_handling.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context Classes \ud83d\udd17 Name class iox::ErrorHandler This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling. Defines \ud83d\udd17 Name ICEORYX_ERRORS (error) CREATE_ICEORYX_ERROR_ENUM (name) CREATE_ICEORYX_ERROR_STRING (name) Macro Documentation \ud83d\udd17 define ICEORYX_ERRORS \ud83d\udd17 #define ICEORYX_ERRORS( error ) define CREATE_ICEORYX_ERROR_ENUM \ud83d\udd17 #define CREATE_ICEORYX_ERROR_ENUM( name ) k ## name , define CREATE_ICEORYX_ERROR_STRING \ud83d\udd17 #define CREATE_ICEORYX_ERROR_STRING( name ) #name, Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP #define IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cassert> #include <functional> #include <iostream> #include <mutex> namespace iox { // clang-format off #define ICEORYX_ERRORS(error) \\ error(NO_ERROR)\\ error(FILEREADER__FAILED_TO_OPEN_FILE) \\ error(POSH__ROUDI_PROCESS_SHUTDOWN_FAILED) \\ error(POSH__ROUDI_PROCESS_SEND_VIA_IPC_CHANNEL_FAILED)\\ error(POSH__RUNTIME_FACTORY_IS_NOT_SET) \\ error(POSH__RUNTIME_IS_CREATED_MULTIPLE_TIMES) \\ error(POSH__RUNTIME_PUBLISHER_PORT_NOT_UNIQUE) \\ error(POSH__RUNTIME_SERVICE_DESCRIPTION_FORBIDDEN) \\ error(POSH__RUNTIME_PUBLISHER_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_SUBSCRIBER_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_CLIENT_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_SERVER_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_ROUDI_PUBLISHER_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_SUBSCRIBER_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_OUT_OF_CLIENTS) \\ error(POSH__RUNTIME_ROUDI_OUT_OF_SERVERS) \\ error(POSH__RUNTIME_ROUDI_CONDITION_VARIABLE_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_EVENT_VARIABLE_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_REQUEST_PUBLISHER_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_PUBLISHER_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SUBSCRIBER_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SUBSCRIBER_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CLIENT_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CLIENT_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SERVER_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SERVER_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CONDITION_VARIABLE_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CONDITION_VARIABLE_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_GET_MW_INTERFACE_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_GET_MW_INTERFACE_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_CREATE_NODE_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_CREATE_NODE_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_CONDITION_VARIABLE_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_APP_WITH_SAME_RUNTIME_NAME_STILL_RUNNING) \\ error(POSH__RUNTIME_NO_WRITABLE_SHM_SEGMENT) \\ error(POSH__RUNTIME_NO_NAME_PROVIDED) \\ error(POSH__RUNTIME_NAME_EMPTY) \\ error(POSH__RUNTIME_LEADING_SLASH_PROVIDED) \\ error(POSH__SERVICE_DISCOVERY_UNKNOWN_EVENT_PROVIDED) \\ error(POSH__SERVICE_DISCOVERY_UNKNOWN_MESSAGE_PATTERN_PROVIDED) \\ error(POSH__PORT_MANAGER_PUBLISHERPORT_NOT_UNIQUE) \\ error(POSH__PORT_MANAGER_SERVERPORT_NOT_UNIQUE) \\ error(POSH__PORT_MANAGER_COULD_NOT_ADD_SERVICE_TO_REGISTRY) \\ error(POSH__PORT_MANAGER_INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN) \\ error(POSH__MEMPOOL_POSSIBLE_DOUBLE_FREE) \\ error(POSH__RECEIVERPORT_DELIVERYFIFO_OVERFLOW) \\ error(POSH__SENDERPORT_SAMPLE_SIZE_CHANGED_FOR_ACTIVE_PORT) \\ error(POSH__SENDERPORT_ACTIVATE_FIELD_WITHOUT_DATA) \\ error(POSH__SENDERPORT_FIELD_SUBSCRIBE_WITHOUT_DATA) \\ error(POSH__SENDERPORT_ACTIVATE_FIELD_WHEN_LATCHED_TOPIC_ACTIVATED) \\ error(POSH__SENDERPORT_ALLOCATE_FAILED) \\ error(POSH__SENDERPORT_SUBSCRIBER_LIST_OVERFLOW) \\ error(POSH__PUBLISHING_EMPTY_SAMPLE) \\ error(POSH__SENDING_EMPTY_REQUEST) \\ error(POSH__SENDING_EMPTY_RESPONSE) \\ error(POSH__SHM_APP_BASEADDRESS_VIOLATES_SPECIFICATION) \\ error(POSH__SHM_APP_SEGMENT_BASEADDRESS_VIOLATES_SPECIFICATION) \\ error(POSH__SHM_APP_MAPP_ERR) \\ error(POSH__SHM_APP_SEGMENT_MAPP_ERR) \\ error(POSH__SHM_APP_SEGMENT_COUNT_OVERFLOW) \\ error(POSH__INTERFACEPORT_CAPRO_MESSAGE_DISMISSED) \\ error(POSH__SERVICE_DISCOVERY_INSTANCE_CONTAINER_OVERFLOW) \\ error(POPO__BASE_SUBSCRIBER_OVERRIDING_WITH_EVENT_SINCE_HAS_DATA_OR_DATA_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_SUBSCRIBER_OVERRIDING_WITH_STATE_SINCE_HAS_DATA_OR_DATA_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_CLIENT_OVERRIDING_WITH_EVENT_SINCE_HAS_RESPONSE_OR_RESPONSE_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_CLIENT_OVERRIDING_WITH_STATE_SINCE_HAS_RESPONSE_OR_RESPONSE_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_SERVER_OVERRIDING_WITH_EVENT_SINCE_HAS_REQUEST_OR_REQUEST_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_SERVER_OVERRIDING_WITH_STATE_SINCE_HAS_REQUEST_OR_REQUEST_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__CHUNK_QUEUE_POPPER_CHUNK_WITH_INCOMPATIBLE_CHUNK_HEADER_VERSION) \\ error(POPO__CHUNK_DISTRIBUTOR_OVERFLOW_OF_QUEUE_CONTAINER) \\ error(POPO__CHUNK_DISTRIBUTOR_CLEANUP_DEADLOCK_BECAUSE_BAD_APPLICATION_TERMINATION) \\ error(POPO__CHUNK_SENDER_INVALID_CHUNK_TO_FREE_FROM_USER) \\ error(POPO__CHUNK_SENDER_INVALID_CHUNK_TO_SEND_FROM_USER) \\ error(POPO__CHUNK_RECEIVER_INVALID_CHUNK_TO_RELEASE_FROM_USER) \\ error(POPO__CHUNK_LOCKING_ERROR) \\ error(POPO__CHUNK_UNLOCKING_ERROR) \\ error(POPO__CAPRO_PROTOCOL_ERROR) \\ error(POPO__CLIENT_PORT_INVALID_REQUEST_TO_FREE_FROM_USER) \\ error(POPO__CLIENT_PORT_INVALID_REQUEST_TO_SEND_FROM_USER) \\ error(POPO__CLIENT_PORT_INVALID_RESPONSE_TO_RELEASE_FROM_USER) \\ error(POPO__SERVER_PORT_INVALID_REQUEST_TO_RELEASE_FROM_USER) \\ error(POPO__SERVER_PORT_INVALID_RESPONSE_TO_FREE_FROM_USER) \\ error(POPO__SERVER_PORT_INVALID_RESPONSE_TO_SEND_FROM_USER) \\ error(POPO__SERVER_PORT_NO_CLIENT_RESPONSE_QUEUE_TO_CONNECT) \\ error(POPO__CONDITION_VARIABLE_DATA_FAILED_TO_CREATE_SEMAPHORE) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_WAS_TRIGGERED) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_WAIT) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_TIMED_WAIT) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_RESET) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_DESTROY) \\ error(POPO__CONDITION_NOTIFIER_INDEX_TOO_LARGE) \\ error(POPO__CONDITION_NOTIFIER_SEMAPHORE_CORRUPT_IN_NOTIFY) \\ error(POPO__NOTIFICATION_INFO_TYPE_INCONSISTENCY_IN_GET_ORIGIN) \\ error(POPO__TRIGGER_INVALID_RESET_CALLBACK) \\ error(POPO__TRIGGER_INVALID_HAS_TRIGGERED_CALLBACK) \\ error(POPO__TRIGGER_HANDLE_INVALID_RESET_CALLBACK) \\ error(POPO__TYPED_UNIQUE_ID_ROUDI_HAS_ALREADY_DEFINED_CUSTOM_UNIQUE_ID) \\ error(POPO__TYPED_UNIQUE_ID_OVERFLOW) \\ error(POPO__WAITSET_COULD_NOT_DETACH_CONDITION) \\ error(MEPOO__MEMPOOL_CONFIG_MUST_BE_ORDERED_BY_INCREASING_SIZE) \\ error(MEPOO__MEMPOOL_GETCHUNK_CHUNK_WITHOUT_MEMPOOL) \\ error(MEPOO__MEMPOOL_GETCHUNK_CHUNK_IS_TOO_LARGE) \\ error(MEPOO__MEMPOOL_GETCHUNK_POOL_IS_RUNNING_OUT_OF_CHUNKS) \\ error(MEPOO__MEMPOOL_CHUNKSIZE_MUST_BE_MULTIPLE_OF_CHUNK_MEMORY_ALIGNMENT) \\ error(MEPOO__MEMPOOL_ADDMEMPOOL_AFTER_GENERATECHUNKMANAGEMENTPOOL) \\ error(MEPOO__TYPED_MEMPOOL_HAS_INCONSISTENT_STATE) \\ error(MEPOO__TYPED_MEMPOOL_MANAGEMENT_SEGMENT_IS_BROKEN) \\ error(MEPOO__USER_WITH_MORE_THAN_ONE_WRITE_SEGMENT) \\ error(MEPOO__SEGMENT_COULD_NOT_APPLY_POSIX_RIGHTS_TO_SHARED_MEMORY) \\ error(MEPOO__SEGMENT_UNABLE_TO_CREATE_SHARED_MEMORY_OBJECT) \\ error(MEPOO__INTROSPECTION_CONTAINER_FULL) \\ error(MEPOO__CANNOT_ALLOCATE_CHUNK) \\ error(MEPOO__MAXIMUM_NUMBER_OF_MEMPOOLS_REACHED) \\ error(PORT_POOL__PUBLISHERLIST_OVERFLOW) \\ error(PORT_POOL__SUBSCRIBERLIST_OVERFLOW) \\ error(PORT_POOL__CLIENTLIST_OVERFLOW) \\ error(PORT_POOL__SERVERLIST_OVERFLOW) \\ error(PORT_POOL__INTERFACELIST_OVERFLOW) \\ error(PORT_POOL__APPLICATIONLIST_OVERFLOW) \\ error(PORT_POOL__NODELIST_OVERFLOW) \\ error(PORT_POOL__CONDITION_VARIABLE_LIST_OVERFLOW) \\ error(PORT_POOL__EVENT_VARIABLE_LIST_OVERFLOW) \\ error(PORT_MANAGER__PORT_POOL_UNAVAILABLE) \\ error(PORT_MANAGER__INTROSPECTION_MEMORY_MANAGER_UNAVAILABLE) \\ error(PORT_MANAGER__HANDLE_PUBLISHER_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__HANDLE_SUBSCRIBER_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__HANDLE_CLIENT_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__HANDLE_SERVER_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__NO_PUBLISHER_PORT_FOR_INTERNAL_SERVICE) \\ error(ROUDI_COMPONENTS__SHARED_MEMORY_UNAVAILABLE) \\ error(ROUDI_APP__FAILED_TO_CREATE_SEMAPHORE) \\ error(ROUDI_APP__FAILED_TO_UNLOCK_SEMAPHORE_IN_SIG_HANDLER) \\ error(ROUDI__DEFAULT_ROUDI_MEMORY_FAILED_TO_ADD_SEGMENT_MANAGER_MEMORY_BLOCK) \\ error(ROUDI__DEFAULT_ROUDI_MEMORY_FAILED_TO_ADD_INTROSPECTION_MEMORY_BLOCK) \\ error(ROUDI__PRECONDITIONS_FOR_PROCESS_MANAGER_NOT_FULFILLED) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__COULD_NOT_ACQUIRE_FILE_LOCK) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__ROUDI_STILL_RUNNING) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__FAILED_TO_ADD_PORTPOOL_MEMORY_BLOCK) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__FAILED_TO_ADD_MANAGEMENT_MEMORY_BLOCK) \\ error(MQ_UNKNOWN_MSG) \\ error(MQ_INVALID_MSG) \\ error(IPC_INTERFACE__UNABLE_TO_CREATE_APPLICATION_CHANNEL) \\ error(IPC_INTERFACE__REG_ROUDI_NOT_AVAILABLE) \\ error(IPC_INTERFACE__REG_UNABLE_TO_WRITE_TO_ROUDI_CHANNEL) \\ error(IPC_INTERFACE__REG_ACK_INVALIG_NUMBER_OF_PARAMS) \\ error(IPC_INTERFACE__REG_ACK_NO_RESPONSE) \\ error(IPC_INTERFACE__CHECK_MQ_MAPS_TO_FILE) \\ error(IPC_INTERFACE__APP_WITH_SAME_NAME_STILL_RUNNING) \\ error(IPC_INTERFACE__COULD_NOT_ACQUIRE_FILE_LOCK) \\ error(POSIX_WRAPPER__FAILED_TO_CREATE_SEMAPHORE) \\ error(POSIX_TIMER__FIRED_TIMER_BUT_STATE_IS_INVALID) \\ error(POSIX_TIMER__TIMERPOOL_OVERFLOW) \\ error(POSIX_TIMER__INCONSISTENT_STATE) \\ error(POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME) \\ error(BINDING_C__UNDEFINED_STATE_IN_IOX_QUEUE_FULL_POLICY) \\ error(BINDING_C__UNDEFINED_STATE_IN_IOX_CONSUMER_TOO_SLOW_POLICY) \\ error(BINDING_C__PUBLISHER_OPTIONS_NOT_INITIALIZED) \\ error(BINDING_C__SUBSCRIBER_OPTIONS_NOT_INITIALIZED) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SUBSCRIBER_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SUBSCRIBER_STATE_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_CLIENT_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_CLIENT_STATE_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVER_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVER_STATE_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVICE_DISCOVERY_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_MESSAGING_PATTERN_VALUE) \\ error(EXPECTS_ENSURES_FAILED) // EXPECTS_ENSURES_FAILED is used as a temporary solution to make Expects/Ensures testable // clang-format on // DO NOT TOUCH START, you can doodle around with the lines above!!! #define CREATE_ICEORYX_ERROR_ENUM(name) k##name, #define CREATE_ICEORYX_ERROR_STRING(name) #name, enum class Error : uint32_t { ICEORYX_ERRORS ( CREATE_ICEORYX_ERROR_ENUM ) }; std :: ostream & operator << ( std :: ostream & stream , Error value ) noexcept ; enum class ErrorLevel : uint32_t { FATAL , SEVERE , MODERATE }; using HandlerFunction = std :: function < void ( const Error error , const std :: function < void () > , const ErrorLevel ) > ; class ErrorHandler { friend void errorHandler ( const Error error , const std :: function < void () >& errorCallBack , const ErrorLevel level ) noexcept ; public : static cxx :: GenericRAII setTemporaryErrorHandler ( const HandlerFunction & newHandler ) noexcept ; static const char * toString ( const Error error ) noexcept ; protected : static void reactOnErrorLevel ( const ErrorLevel level , const char * errorText ) noexcept ; private : static void defaultHandler ( const Error error , const std :: function < void () >& errorCallBack , const ErrorLevel level = ErrorLevel :: FATAL ) noexcept ; static const char * ERROR_NAMES []; static iox :: HandlerFunction handler ; static std :: mutex handler_mutex ; }; void errorHandler ( const Error error , const std :: function < void () >& errorCallBack = std :: function < void () > (), const ErrorLevel level = ErrorLevel :: FATAL ) noexcept ; } // namespace iox #endif // IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/error_handling/error_handling.hpp"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#iceoryx_hoofserror_handlingerror_handlinghpp","text":"","title":"iceoryx_hoofs/error_handling/error_handling.hpp"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context","title":"Namespaces"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#classes","text":"Name class iox::ErrorHandler This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling.","title":"Classes"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#defines","text":"Name ICEORYX_ERRORS (error) CREATE_ICEORYX_ERROR_ENUM (name) CREATE_ICEORYX_ERROR_STRING (name)","title":"Defines"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#define-iceoryx_errors","text":"#define ICEORYX_ERRORS( error )","title":"define ICEORYX_ERRORS"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#define-create_iceoryx_error_enum","text":"#define CREATE_ICEORYX_ERROR_ENUM( name ) k ## name ,","title":"define CREATE_ICEORYX_ERROR_ENUM"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#define-create_iceoryx_error_string","text":"#define CREATE_ICEORYX_ERROR_STRING( name ) #name,","title":"define CREATE_ICEORYX_ERROR_STRING"},{"location":"API-reference/hoofs/Files/error__handling_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP #define IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cassert> #include <functional> #include <iostream> #include <mutex> namespace iox { // clang-format off #define ICEORYX_ERRORS(error) \\ error(NO_ERROR)\\ error(FILEREADER__FAILED_TO_OPEN_FILE) \\ error(POSH__ROUDI_PROCESS_SHUTDOWN_FAILED) \\ error(POSH__ROUDI_PROCESS_SEND_VIA_IPC_CHANNEL_FAILED)\\ error(POSH__RUNTIME_FACTORY_IS_NOT_SET) \\ error(POSH__RUNTIME_IS_CREATED_MULTIPLE_TIMES) \\ error(POSH__RUNTIME_PUBLISHER_PORT_NOT_UNIQUE) \\ error(POSH__RUNTIME_SERVICE_DESCRIPTION_FORBIDDEN) \\ error(POSH__RUNTIME_PUBLISHER_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_SUBSCRIBER_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_CLIENT_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_SERVER_PORT_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_ROUDI_PUBLISHER_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_SUBSCRIBER_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_OUT_OF_CLIENTS) \\ error(POSH__RUNTIME_ROUDI_OUT_OF_SERVERS) \\ error(POSH__RUNTIME_ROUDI_CONDITION_VARIABLE_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_EVENT_VARIABLE_LIST_FULL) \\ error(POSH__RUNTIME_ROUDI_REQUEST_PUBLISHER_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_PUBLISHER_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SUBSCRIBER_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SUBSCRIBER_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CLIENT_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CLIENT_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SERVER_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_SERVER_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CONDITION_VARIABLE_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_REQUEST_CONDITION_VARIABLE_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_GET_MW_INTERFACE_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_GET_MW_INTERFACE_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_CREATE_NODE_INVALID_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_CREATE_NODE_WRONG_IPC_MESSAGE_RESPONSE) \\ error(POSH__RUNTIME_ROUDI_CONDITION_VARIABLE_CREATION_UNKNOWN_ERROR) \\ error(POSH__RUNTIME_APP_WITH_SAME_RUNTIME_NAME_STILL_RUNNING) \\ error(POSH__RUNTIME_NO_WRITABLE_SHM_SEGMENT) \\ error(POSH__RUNTIME_NO_NAME_PROVIDED) \\ error(POSH__RUNTIME_NAME_EMPTY) \\ error(POSH__RUNTIME_LEADING_SLASH_PROVIDED) \\ error(POSH__SERVICE_DISCOVERY_UNKNOWN_EVENT_PROVIDED) \\ error(POSH__SERVICE_DISCOVERY_UNKNOWN_MESSAGE_PATTERN_PROVIDED) \\ error(POSH__PORT_MANAGER_PUBLISHERPORT_NOT_UNIQUE) \\ error(POSH__PORT_MANAGER_SERVERPORT_NOT_UNIQUE) \\ error(POSH__PORT_MANAGER_COULD_NOT_ADD_SERVICE_TO_REGISTRY) \\ error(POSH__PORT_MANAGER_INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN) \\ error(POSH__MEMPOOL_POSSIBLE_DOUBLE_FREE) \\ error(POSH__RECEIVERPORT_DELIVERYFIFO_OVERFLOW) \\ error(POSH__SENDERPORT_SAMPLE_SIZE_CHANGED_FOR_ACTIVE_PORT) \\ error(POSH__SENDERPORT_ACTIVATE_FIELD_WITHOUT_DATA) \\ error(POSH__SENDERPORT_FIELD_SUBSCRIBE_WITHOUT_DATA) \\ error(POSH__SENDERPORT_ACTIVATE_FIELD_WHEN_LATCHED_TOPIC_ACTIVATED) \\ error(POSH__SENDERPORT_ALLOCATE_FAILED) \\ error(POSH__SENDERPORT_SUBSCRIBER_LIST_OVERFLOW) \\ error(POSH__PUBLISHING_EMPTY_SAMPLE) \\ error(POSH__SENDING_EMPTY_REQUEST) \\ error(POSH__SENDING_EMPTY_RESPONSE) \\ error(POSH__SHM_APP_BASEADDRESS_VIOLATES_SPECIFICATION) \\ error(POSH__SHM_APP_SEGMENT_BASEADDRESS_VIOLATES_SPECIFICATION) \\ error(POSH__SHM_APP_MAPP_ERR) \\ error(POSH__SHM_APP_SEGMENT_MAPP_ERR) \\ error(POSH__SHM_APP_SEGMENT_COUNT_OVERFLOW) \\ error(POSH__INTERFACEPORT_CAPRO_MESSAGE_DISMISSED) \\ error(POSH__SERVICE_DISCOVERY_INSTANCE_CONTAINER_OVERFLOW) \\ error(POPO__BASE_SUBSCRIBER_OVERRIDING_WITH_EVENT_SINCE_HAS_DATA_OR_DATA_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_SUBSCRIBER_OVERRIDING_WITH_STATE_SINCE_HAS_DATA_OR_DATA_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_CLIENT_OVERRIDING_WITH_EVENT_SINCE_HAS_RESPONSE_OR_RESPONSE_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_CLIENT_OVERRIDING_WITH_STATE_SINCE_HAS_RESPONSE_OR_RESPONSE_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_SERVER_OVERRIDING_WITH_EVENT_SINCE_HAS_REQUEST_OR_REQUEST_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__BASE_SERVER_OVERRIDING_WITH_STATE_SINCE_HAS_REQUEST_OR_REQUEST_RECEIVED_ALREADY_ATTACHED) \\ error(POPO__CHUNK_QUEUE_POPPER_CHUNK_WITH_INCOMPATIBLE_CHUNK_HEADER_VERSION) \\ error(POPO__CHUNK_DISTRIBUTOR_OVERFLOW_OF_QUEUE_CONTAINER) \\ error(POPO__CHUNK_DISTRIBUTOR_CLEANUP_DEADLOCK_BECAUSE_BAD_APPLICATION_TERMINATION) \\ error(POPO__CHUNK_SENDER_INVALID_CHUNK_TO_FREE_FROM_USER) \\ error(POPO__CHUNK_SENDER_INVALID_CHUNK_TO_SEND_FROM_USER) \\ error(POPO__CHUNK_RECEIVER_INVALID_CHUNK_TO_RELEASE_FROM_USER) \\ error(POPO__CHUNK_LOCKING_ERROR) \\ error(POPO__CHUNK_UNLOCKING_ERROR) \\ error(POPO__CAPRO_PROTOCOL_ERROR) \\ error(POPO__CLIENT_PORT_INVALID_REQUEST_TO_FREE_FROM_USER) \\ error(POPO__CLIENT_PORT_INVALID_REQUEST_TO_SEND_FROM_USER) \\ error(POPO__CLIENT_PORT_INVALID_RESPONSE_TO_RELEASE_FROM_USER) \\ error(POPO__SERVER_PORT_INVALID_REQUEST_TO_RELEASE_FROM_USER) \\ error(POPO__SERVER_PORT_INVALID_RESPONSE_TO_FREE_FROM_USER) \\ error(POPO__SERVER_PORT_INVALID_RESPONSE_TO_SEND_FROM_USER) \\ error(POPO__SERVER_PORT_NO_CLIENT_RESPONSE_QUEUE_TO_CONNECT) \\ error(POPO__CONDITION_VARIABLE_DATA_FAILED_TO_CREATE_SEMAPHORE) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_WAS_TRIGGERED) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_WAIT) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_TIMED_WAIT) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_RESET) \\ error(POPO__CONDITION_LISTENER_SEMAPHORE_CORRUPTED_IN_DESTROY) \\ error(POPO__CONDITION_NOTIFIER_INDEX_TOO_LARGE) \\ error(POPO__CONDITION_NOTIFIER_SEMAPHORE_CORRUPT_IN_NOTIFY) \\ error(POPO__NOTIFICATION_INFO_TYPE_INCONSISTENCY_IN_GET_ORIGIN) \\ error(POPO__TRIGGER_INVALID_RESET_CALLBACK) \\ error(POPO__TRIGGER_INVALID_HAS_TRIGGERED_CALLBACK) \\ error(POPO__TRIGGER_HANDLE_INVALID_RESET_CALLBACK) \\ error(POPO__TYPED_UNIQUE_ID_ROUDI_HAS_ALREADY_DEFINED_CUSTOM_UNIQUE_ID) \\ error(POPO__TYPED_UNIQUE_ID_OVERFLOW) \\ error(POPO__WAITSET_COULD_NOT_DETACH_CONDITION) \\ error(MEPOO__MEMPOOL_CONFIG_MUST_BE_ORDERED_BY_INCREASING_SIZE) \\ error(MEPOO__MEMPOOL_GETCHUNK_CHUNK_WITHOUT_MEMPOOL) \\ error(MEPOO__MEMPOOL_GETCHUNK_CHUNK_IS_TOO_LARGE) \\ error(MEPOO__MEMPOOL_GETCHUNK_POOL_IS_RUNNING_OUT_OF_CHUNKS) \\ error(MEPOO__MEMPOOL_CHUNKSIZE_MUST_BE_MULTIPLE_OF_CHUNK_MEMORY_ALIGNMENT) \\ error(MEPOO__MEMPOOL_ADDMEMPOOL_AFTER_GENERATECHUNKMANAGEMENTPOOL) \\ error(MEPOO__TYPED_MEMPOOL_HAS_INCONSISTENT_STATE) \\ error(MEPOO__TYPED_MEMPOOL_MANAGEMENT_SEGMENT_IS_BROKEN) \\ error(MEPOO__USER_WITH_MORE_THAN_ONE_WRITE_SEGMENT) \\ error(MEPOO__SEGMENT_COULD_NOT_APPLY_POSIX_RIGHTS_TO_SHARED_MEMORY) \\ error(MEPOO__SEGMENT_UNABLE_TO_CREATE_SHARED_MEMORY_OBJECT) \\ error(MEPOO__INTROSPECTION_CONTAINER_FULL) \\ error(MEPOO__CANNOT_ALLOCATE_CHUNK) \\ error(MEPOO__MAXIMUM_NUMBER_OF_MEMPOOLS_REACHED) \\ error(PORT_POOL__PUBLISHERLIST_OVERFLOW) \\ error(PORT_POOL__SUBSCRIBERLIST_OVERFLOW) \\ error(PORT_POOL__CLIENTLIST_OVERFLOW) \\ error(PORT_POOL__SERVERLIST_OVERFLOW) \\ error(PORT_POOL__INTERFACELIST_OVERFLOW) \\ error(PORT_POOL__APPLICATIONLIST_OVERFLOW) \\ error(PORT_POOL__NODELIST_OVERFLOW) \\ error(PORT_POOL__CONDITION_VARIABLE_LIST_OVERFLOW) \\ error(PORT_POOL__EVENT_VARIABLE_LIST_OVERFLOW) \\ error(PORT_MANAGER__PORT_POOL_UNAVAILABLE) \\ error(PORT_MANAGER__INTROSPECTION_MEMORY_MANAGER_UNAVAILABLE) \\ error(PORT_MANAGER__HANDLE_PUBLISHER_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__HANDLE_SUBSCRIBER_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__HANDLE_CLIENT_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__HANDLE_SERVER_PORTS_INVALID_CAPRO_MESSAGE) \\ error(PORT_MANAGER__NO_PUBLISHER_PORT_FOR_INTERNAL_SERVICE) \\ error(ROUDI_COMPONENTS__SHARED_MEMORY_UNAVAILABLE) \\ error(ROUDI_APP__FAILED_TO_CREATE_SEMAPHORE) \\ error(ROUDI_APP__FAILED_TO_UNLOCK_SEMAPHORE_IN_SIG_HANDLER) \\ error(ROUDI__DEFAULT_ROUDI_MEMORY_FAILED_TO_ADD_SEGMENT_MANAGER_MEMORY_BLOCK) \\ error(ROUDI__DEFAULT_ROUDI_MEMORY_FAILED_TO_ADD_INTROSPECTION_MEMORY_BLOCK) \\ error(ROUDI__PRECONDITIONS_FOR_PROCESS_MANAGER_NOT_FULFILLED) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__COULD_NOT_ACQUIRE_FILE_LOCK) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__ROUDI_STILL_RUNNING) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__FAILED_TO_ADD_PORTPOOL_MEMORY_BLOCK) \\ error(ICEORYX_ROUDI_MEMORY_MANAGER__FAILED_TO_ADD_MANAGEMENT_MEMORY_BLOCK) \\ error(MQ_UNKNOWN_MSG) \\ error(MQ_INVALID_MSG) \\ error(IPC_INTERFACE__UNABLE_TO_CREATE_APPLICATION_CHANNEL) \\ error(IPC_INTERFACE__REG_ROUDI_NOT_AVAILABLE) \\ error(IPC_INTERFACE__REG_UNABLE_TO_WRITE_TO_ROUDI_CHANNEL) \\ error(IPC_INTERFACE__REG_ACK_INVALIG_NUMBER_OF_PARAMS) \\ error(IPC_INTERFACE__REG_ACK_NO_RESPONSE) \\ error(IPC_INTERFACE__CHECK_MQ_MAPS_TO_FILE) \\ error(IPC_INTERFACE__APP_WITH_SAME_NAME_STILL_RUNNING) \\ error(IPC_INTERFACE__COULD_NOT_ACQUIRE_FILE_LOCK) \\ error(POSIX_WRAPPER__FAILED_TO_CREATE_SEMAPHORE) \\ error(POSIX_TIMER__FIRED_TIMER_BUT_STATE_IS_INVALID) \\ error(POSIX_TIMER__TIMERPOOL_OVERFLOW) \\ error(POSIX_TIMER__INCONSISTENT_STATE) \\ error(POSIX_TIMER__CALLBACK_RUNTIME_EXCEEDS_RETRIGGER_TIME) \\ error(BINDING_C__UNDEFINED_STATE_IN_IOX_QUEUE_FULL_POLICY) \\ error(BINDING_C__UNDEFINED_STATE_IN_IOX_CONSUMER_TOO_SLOW_POLICY) \\ error(BINDING_C__PUBLISHER_OPTIONS_NOT_INITIALIZED) \\ error(BINDING_C__SUBSCRIBER_OPTIONS_NOT_INITIALIZED) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SUBSCRIBER_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SUBSCRIBER_STATE_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_CLIENT_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_CLIENT_STATE_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVER_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVER_STATE_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_SERVICE_DISCOVERY_EVENT_VALUE) \\ error(BINDING_C__C2CPP_ENUM_TRANSLATION_INVALID_MESSAGING_PATTERN_VALUE) \\ error(EXPECTS_ENSURES_FAILED) // EXPECTS_ENSURES_FAILED is used as a temporary solution to make Expects/Ensures testable // clang-format on // DO NOT TOUCH START, you can doodle around with the lines above!!! #define CREATE_ICEORYX_ERROR_ENUM(name) k##name, #define CREATE_ICEORYX_ERROR_STRING(name) #name, enum class Error : uint32_t { ICEORYX_ERRORS ( CREATE_ICEORYX_ERROR_ENUM ) }; std :: ostream & operator << ( std :: ostream & stream , Error value ) noexcept ; enum class ErrorLevel : uint32_t { FATAL , SEVERE , MODERATE }; using HandlerFunction = std :: function < void ( const Error error , const std :: function < void () > , const ErrorLevel ) > ; class ErrorHandler { friend void errorHandler ( const Error error , const std :: function < void () >& errorCallBack , const ErrorLevel level ) noexcept ; public : static cxx :: GenericRAII setTemporaryErrorHandler ( const HandlerFunction & newHandler ) noexcept ; static const char * toString ( const Error error ) noexcept ; protected : static void reactOnErrorLevel ( const ErrorLevel level , const char * errorText ) noexcept ; private : static void defaultHandler ( const Error error , const std :: function < void () >& errorCallBack , const ErrorLevel level = ErrorLevel :: FATAL ) noexcept ; static const char * ERROR_NAMES []; static iox :: HandlerFunction handler ; static std :: mutex handler_mutex ; }; void errorHandler ( const Error error , const std :: function < void () >& errorCallBack = std :: function < void () > (), const ErrorLevel level = ErrorLevel :: FATAL ) noexcept ; } // namespace iox #endif // IOX_HOOFS_ERROR_HANDLING_ERROR_HANDLING_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/expected_8hpp/","text":"iceoryx_hoofs/cxx/expected.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal Classes \ud83d\udd17 Name struct iox::cxx::success helper struct to create an expected which is signalling success more easily struct iox::cxx::success< void > helper struct to create an error only expected which is signalling success more easily struct iox::cxx::error helper struct to create an expected which is signalling an error more easily class iox::cxx::expected< ErrorType > expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. class iox::cxx::expected< ValueType, ErrorType > specialization of the expected class which can contain an error as well as a success value class iox::cxx::expected< void, ErrorType > Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_EXPECTED_HPP #define IOX_HOOFS_CXX_EXPECTED_HPP #include \"iceoryx_hoofs/cxx/attributes.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/variant.hpp\" #include <utility> namespace iox { namespace cxx { namespace internal { template < typename ... > struct IsOptional ; } // namespace internal template < typename T = void > struct success { success ( const T & t ) noexcept ; success ( T && t ) noexcept ; template < typename ... Targs > success ( Targs && ... args ) noexcept ; T value ; }; template <> struct success < void > { }; template < typename T > struct error { error ( const T & t ) noexcept ; error ( T && t ) noexcept ; template < typename ... Targs > error ( Targs && ... args ) noexcept ; T value ; }; template < typename ... T > class IOX_NO_DISCARD expected ; template < typename ErrorType > class IOX_NO_DISCARD expected < ErrorType > { public : expected () = delete ; expected ( const expected & ) noexcept = default ; expected ( expected && rhs ) noexcept ; #if defined(_WIN32) template < typename ValueType > expected ( const expected < ValueType , ErrorType >& rhs ) noexcept ; template < typename ValueType > expected ( expected < ValueType , ErrorType >&& rhs ) noexcept ; #endif ~ expected () noexcept = default ; expected & operator = ( const expected & ) noexcept ; expected & operator = ( expected && rhs ) noexcept ; #if defined(_WIN32) template < typename ValueType > expected & operator = ( const expected < ValueType , ErrorType >& rhs ) noexcept ; template < typename ValueType > expected & operator = ( expected < ValueType , ErrorType >&& rhs ) noexcept ; #endif expected ( const success < void >& successValue ) noexcept ; expected ( const error < ErrorType >& errorValue ) noexcept ; expected ( error < ErrorType >&& errorValue ) noexcept ; static expected create_value () noexcept ; template < typename ... Targs > static expected create_error ( Targs && ... args ) noexcept ; explicit operator bool () const noexcept ; bool has_error () const noexcept ; ErrorType & get_error () & noexcept ; const ErrorType & get_error () const & noexcept ; ErrorType && get_error () && noexcept ; const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) const noexcept ; expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) noexcept ; const expected & and_then ( const cxx :: function_ref < void () >& callable ) const noexcept ; expected & and_then ( const cxx :: function_ref < void () >& callable ) noexcept ; private : expected ( variant < ErrorType >&& store , const bool hasError ) noexcept ; variant < ErrorType > m_store ; bool m_hasError ; static constexpr uint64_t ERROR_INDEX = 0U ; }; template < typename ValueType , typename ErrorType > class IOX_NO_DISCARD expected < ValueType , ErrorType > { public : expected () = delete ; expected ( const expected & ) noexcept = default ; expected ( expected && rhs ) noexcept ; ~ expected () noexcept = default ; expected & operator = ( const expected & ) noexcept ; expected & operator = ( expected && rhs ) noexcept ; expected ( const success < ValueType >& successValue ) noexcept ; expected ( success < ValueType >&& successValue ) noexcept ; expected ( const error < ErrorType >& errorValue ) noexcept ; expected ( error < ErrorType >&& errorValue ) noexcept ; template < typename ... Targs > static expected create_value ( Targs && ... args ) noexcept ; template < typename ... Targs > static expected create_error ( Targs && ... args ) noexcept ; explicit operator bool () const noexcept ; bool has_error () const noexcept ; ErrorType & get_error () & noexcept ; const ErrorType & get_error () const & noexcept ; ErrorType && get_error () && noexcept ; ValueType & value () & noexcept ; const ValueType & value () const & noexcept ; ValueType && value () && noexcept ; ValueType value_or ( const ValueType & value ) const noexcept ; ValueType value_or ( const ValueType & value ) noexcept ; ValueType & operator * () noexcept ; const ValueType & operator * () const noexcept ; ValueType * operator -> () noexcept ; const ValueType * operator -> () const noexcept ; template < typename T > operator expected < T > () noexcept ; template < typename T > operator expected < T > () const noexcept ; const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) const noexcept ; expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) noexcept ; const expected & and_then ( const cxx :: function_ref < void ( ValueType & ) >& callable ) const noexcept ; expected & and_then ( const cxx :: function_ref < void ( ValueType & ) >& callable ) noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > const expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) >& callable ) const noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) >& callable ) noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > [[ deprecated ]] const expected & if_empty ( const cxx :: function_ref < void () >& callable ) const noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > [[ deprecated ]] expected & if_empty ( const cxx :: function_ref < void () >& callable ) noexcept ; optional < ValueType > to_optional () const noexcept ; private : expected ( variant < ValueType , ErrorType >&& f_store , const bool hasError ) noexcept ; variant < ValueType , ErrorType > m_store ; bool m_hasError ; static constexpr uint64_t VALUE_INDEX = 0U ; static constexpr uint64_t ERROR_INDEX = 1U ; }; template < typename ErrorType > class IOX_NO_DISCARD expected < void , ErrorType > : public expected < ErrorType > { public : using expected < ErrorType >:: expected ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/expected.inl\" #endif // IOX_HOOFS_CXX_EXPECTED_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/expected.hpp"},{"location":"API-reference/hoofs/Files/expected_8hpp/#iceoryx_hoofscxxexpectedhpp","text":"","title":"iceoryx_hoofs/cxx/expected.hpp"},{"location":"API-reference/hoofs/Files/expected_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/expected_8hpp/#classes","text":"Name struct iox::cxx::success helper struct to create an expected which is signalling success more easily struct iox::cxx::success< void > helper struct to create an error only expected which is signalling success more easily struct iox::cxx::error helper struct to create an expected which is signalling an error more easily class iox::cxx::expected< ErrorType > expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. class iox::cxx::expected< ValueType, ErrorType > specialization of the expected class which can contain an error as well as a success value class iox::cxx::expected< void, ErrorType >","title":"Classes"},{"location":"API-reference/hoofs/Files/expected_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_EXPECTED_HPP #define IOX_HOOFS_CXX_EXPECTED_HPP #include \"iceoryx_hoofs/cxx/attributes.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/variant.hpp\" #include <utility> namespace iox { namespace cxx { namespace internal { template < typename ... > struct IsOptional ; } // namespace internal template < typename T = void > struct success { success ( const T & t ) noexcept ; success ( T && t ) noexcept ; template < typename ... Targs > success ( Targs && ... args ) noexcept ; T value ; }; template <> struct success < void > { }; template < typename T > struct error { error ( const T & t ) noexcept ; error ( T && t ) noexcept ; template < typename ... Targs > error ( Targs && ... args ) noexcept ; T value ; }; template < typename ... T > class IOX_NO_DISCARD expected ; template < typename ErrorType > class IOX_NO_DISCARD expected < ErrorType > { public : expected () = delete ; expected ( const expected & ) noexcept = default ; expected ( expected && rhs ) noexcept ; #if defined(_WIN32) template < typename ValueType > expected ( const expected < ValueType , ErrorType >& rhs ) noexcept ; template < typename ValueType > expected ( expected < ValueType , ErrorType >&& rhs ) noexcept ; #endif ~ expected () noexcept = default ; expected & operator = ( const expected & ) noexcept ; expected & operator = ( expected && rhs ) noexcept ; #if defined(_WIN32) template < typename ValueType > expected & operator = ( const expected < ValueType , ErrorType >& rhs ) noexcept ; template < typename ValueType > expected & operator = ( expected < ValueType , ErrorType >&& rhs ) noexcept ; #endif expected ( const success < void >& successValue ) noexcept ; expected ( const error < ErrorType >& errorValue ) noexcept ; expected ( error < ErrorType >&& errorValue ) noexcept ; static expected create_value () noexcept ; template < typename ... Targs > static expected create_error ( Targs && ... args ) noexcept ; explicit operator bool () const noexcept ; bool has_error () const noexcept ; ErrorType & get_error () & noexcept ; const ErrorType & get_error () const & noexcept ; ErrorType && get_error () && noexcept ; const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) const noexcept ; expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) noexcept ; const expected & and_then ( const cxx :: function_ref < void () >& callable ) const noexcept ; expected & and_then ( const cxx :: function_ref < void () >& callable ) noexcept ; private : expected ( variant < ErrorType >&& store , const bool hasError ) noexcept ; variant < ErrorType > m_store ; bool m_hasError ; static constexpr uint64_t ERROR_INDEX = 0U ; }; template < typename ValueType , typename ErrorType > class IOX_NO_DISCARD expected < ValueType , ErrorType > { public : expected () = delete ; expected ( const expected & ) noexcept = default ; expected ( expected && rhs ) noexcept ; ~ expected () noexcept = default ; expected & operator = ( const expected & ) noexcept ; expected & operator = ( expected && rhs ) noexcept ; expected ( const success < ValueType >& successValue ) noexcept ; expected ( success < ValueType >&& successValue ) noexcept ; expected ( const error < ErrorType >& errorValue ) noexcept ; expected ( error < ErrorType >&& errorValue ) noexcept ; template < typename ... Targs > static expected create_value ( Targs && ... args ) noexcept ; template < typename ... Targs > static expected create_error ( Targs && ... args ) noexcept ; explicit operator bool () const noexcept ; bool has_error () const noexcept ; ErrorType & get_error () & noexcept ; const ErrorType & get_error () const & noexcept ; ErrorType && get_error () && noexcept ; ValueType & value () & noexcept ; const ValueType & value () const & noexcept ; ValueType && value () && noexcept ; ValueType value_or ( const ValueType & value ) const noexcept ; ValueType value_or ( const ValueType & value ) noexcept ; ValueType & operator * () noexcept ; const ValueType & operator * () const noexcept ; ValueType * operator -> () noexcept ; const ValueType * operator -> () const noexcept ; template < typename T > operator expected < T > () noexcept ; template < typename T > operator expected < T > () const noexcept ; const expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) const noexcept ; expected & or_else ( const cxx :: function_ref < void ( ErrorType & ) >& callable ) noexcept ; const expected & and_then ( const cxx :: function_ref < void ( ValueType & ) >& callable ) const noexcept ; expected & and_then ( const cxx :: function_ref < void ( ValueType & ) >& callable ) noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > const expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) >& callable ) const noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > expected & and_then ( const cxx :: function_ref < void ( typename Optional :: type & ) >& callable ) noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > [[ deprecated ]] const expected & if_empty ( const cxx :: function_ref < void () >& callable ) const noexcept ; template < typename Optional = ValueType , typename std :: enable_if < internal :: IsOptional < Optional >:: value , int >:: type = 0 > [[ deprecated ]] expected & if_empty ( const cxx :: function_ref < void () >& callable ) noexcept ; optional < ValueType > to_optional () const noexcept ; private : expected ( variant < ValueType , ErrorType >&& f_store , const bool hasError ) noexcept ; variant < ValueType , ErrorType > m_store ; bool m_hasError ; static constexpr uint64_t VALUE_INDEX = 0U ; static constexpr uint64_t ERROR_INDEX = 1U ; }; template < typename ErrorType > class IOX_NO_DISCARD expected < void , ErrorType > : public expected < ErrorType > { public : using expected < ErrorType >:: expected ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/expected.inl\" #endif // IOX_HOOFS_CXX_EXPECTED_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/","text":"iceoryx_hoofs/posix_wrapper/file_lock.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Classes \ud83d\udd17 Name class iox::posix::FileLock Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) Source code \ud83d\udd17 // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP #define IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" namespace iox { namespace posix { enum class FileLockError { INVALID_FILE_NAME , LOCKED_BY_OTHER_PROCESS , ACCESS_DENIED , QUOTA_EXHAUSTED , INVALID_CHARACTERS_IN_FILE_NAME , SYSTEM_LIMIT , PROCESS_LIMIT , NO_SUCH_DIRECTORY , SPECIAL_FILE , FILE_TOO_LARGE , FILE_IN_USE , OUT_OF_MEMORY , I_O_ERROR , SYS_CALL_NOT_IMPLEMENTED , INTERNAL_LOGIC_ERROR , }; class FileLock : public DesignPattern :: Creation < FileLock , FileLockError > { public : static constexpr int32_t ERROR_CODE = -1 ; static constexpr int32_t INVALID_FD = -1 ; static constexpr const char LOCK_FILE_SUFFIX [] = \".lock\" ; static constexpr uint64_t FILENAME_LENGTH = platform :: IOX_MAX_FILENAME_LENGTH - sizeof ( platform :: IOX_LOCK_FILE_PATH_PREFIX ) / sizeof ( char ) - sizeof ( LOCK_FILE_SUFFIX ) / sizeof ( char ); using FileName_t = cxx :: string < FILENAME_LENGTH > ; using PathName_t = cxx :: string < platform :: IOX_MAX_PATH_LENGTH > ; FileLock ( const FileLock & ) = delete ; FileLock & operator = ( const FileLock & ) = delete ; FileLock ( FileLock && rhs ) noexcept ; FileLock & operator = ( FileLock && rhs ) noexcept ; ~ FileLock () noexcept ; private : int32_t m_fd { INVALID_FD }; FileName_t m_name ; PathName_t m_fileLockPath ; explicit FileLock ( const FileName_t & name ) noexcept ; void invalidate () noexcept ; cxx :: expected < FileLockError > initializeFileLock () noexcept ; FileLockError convertErrnoToFileLockError ( const int32_t errnum ) const noexcept ; cxx :: expected < FileLockError > closeFileDescriptor () noexcept ; friend class DesignPattern :: Creation < FileLock , FileLockError > ; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/file_lock.hpp"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#iceoryx_hoofsposix_wrapperfile_lockhpp","text":"","title":"iceoryx_hoofs/posix_wrapper/file_lock.hpp"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#classes","text":"Name class iox::posix::FileLock Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page)","title":"Classes"},{"location":"API-reference/hoofs/Files/file__lock_8hpp/#source-code","text":"// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP #define IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" namespace iox { namespace posix { enum class FileLockError { INVALID_FILE_NAME , LOCKED_BY_OTHER_PROCESS , ACCESS_DENIED , QUOTA_EXHAUSTED , INVALID_CHARACTERS_IN_FILE_NAME , SYSTEM_LIMIT , PROCESS_LIMIT , NO_SUCH_DIRECTORY , SPECIAL_FILE , FILE_TOO_LARGE , FILE_IN_USE , OUT_OF_MEMORY , I_O_ERROR , SYS_CALL_NOT_IMPLEMENTED , INTERNAL_LOGIC_ERROR , }; class FileLock : public DesignPattern :: Creation < FileLock , FileLockError > { public : static constexpr int32_t ERROR_CODE = -1 ; static constexpr int32_t INVALID_FD = -1 ; static constexpr const char LOCK_FILE_SUFFIX [] = \".lock\" ; static constexpr uint64_t FILENAME_LENGTH = platform :: IOX_MAX_FILENAME_LENGTH - sizeof ( platform :: IOX_LOCK_FILE_PATH_PREFIX ) / sizeof ( char ) - sizeof ( LOCK_FILE_SUFFIX ) / sizeof ( char ); using FileName_t = cxx :: string < FILENAME_LENGTH > ; using PathName_t = cxx :: string < platform :: IOX_MAX_PATH_LENGTH > ; FileLock ( const FileLock & ) = delete ; FileLock & operator = ( const FileLock & ) = delete ; FileLock ( FileLock && rhs ) noexcept ; FileLock & operator = ( FileLock && rhs ) noexcept ; ~ FileLock () noexcept ; private : int32_t m_fd { INVALID_FD }; FileName_t m_name ; PathName_t m_fileLockPath ; explicit FileLock ( const FileName_t & name ) noexcept ; void invalidate () noexcept ; cxx :: expected < FileLockError > initializeFileLock () noexcept ; FileLockError convertErrnoToFileLockError ( const int32_t errnum ) const noexcept ; cxx :: expected < FileLockError > closeFileDescriptor () noexcept ; friend class DesignPattern :: Creation < FileLock , FileLockError > ; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_FILE_LOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/","text":"iceoryx_hoofs/cxx/filesystem.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FILESYSTEM_HPP #define IOX_HOOFS_CXX_FILESYSTEM_HPP #include <cstdint> namespace iox { namespace cxx { enum class perms : uint64_t { none = 0 , owner_read = 0400 , owner_write = 0200 , owner_exec = 0100 , owner_all = 0700 , group_read = 040 , group_write = 020 , group_exec = 010 , group_all = 070 , others_read = 04 , others_write = 02 , others_exec = 01 , others_all = 07 , all = 0777 , set_uid = 04000 , set_gid = 02000 , sticky_bit = 01000 , mask = 07777 , unknown = 0xFFFF }; perms operator | ( const perms & lhs , const perms & rhs ) noexcept ; perms operator & ( const perms & lhs , const perms & rhs ) noexcept ; perms operator ^ ( const perms & lhs , const perms & rhs ) noexcept ; perms operator ~ ( const perms & value ) noexcept ; perms operator |= ( perms & lhs , const perms & rhs ) noexcept ; perms operator &= ( perms & lhs , const perms & rhs ) noexcept ; perms operator ^= ( perms & lhs , const perms & rhs ) noexcept ; template < typename StreamType > StreamType & operator << ( StreamType & stream , perms value ) noexcept ; } // namespace cxx } // namespace iox #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/filesystem.hpp"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/#iceoryx_hoofscxxfilesystemhpp","text":"","title":"iceoryx_hoofs/cxx/filesystem.hpp"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/filesystem_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FILESYSTEM_HPP #define IOX_HOOFS_CXX_FILESYSTEM_HPP #include <cstdint> namespace iox { namespace cxx { enum class perms : uint64_t { none = 0 , owner_read = 0400 , owner_write = 0200 , owner_exec = 0100 , owner_all = 0700 , group_read = 040 , group_write = 020 , group_exec = 010 , group_all = 070 , others_read = 04 , others_write = 02 , others_exec = 01 , others_all = 07 , all = 0777 , set_uid = 04000 , set_gid = 02000 , sticky_bit = 01000 , mask = 07777 , unknown = 0xFFFF }; perms operator | ( const perms & lhs , const perms & rhs ) noexcept ; perms operator & ( const perms & lhs , const perms & rhs ) noexcept ; perms operator ^ ( const perms & lhs , const perms & rhs ) noexcept ; perms operator ~ ( const perms & value ) noexcept ; perms operator |= ( perms & lhs , const perms & rhs ) noexcept ; perms operator &= ( perms & lhs , const perms & rhs ) noexcept ; perms operator ^= ( perms & lhs , const perms & rhs ) noexcept ; template < typename StreamType > StreamType & operator << ( StreamType & stream , perms value ) noexcept ; } // namespace cxx } // namespace iox #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/","text":"iceoryx_hoofs/cxx/forward_list.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::forward_list C++11 compatible uni-directional forward list implementation. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FORWARD_LIST_HPP #define IOX_HOOFS_CXX_FORWARD_LIST_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <cstdint> #include <iostream> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class forward_list { private : // forward declarations, private struct ListLink ; template < bool > class IteratorBase ; public : using iterator = IteratorBase < false > ; using const_iterator = IteratorBase < true > ; using value_type = T ; using size_type = decltype ( Capacity ); forward_list () noexcept ; ~ forward_list () noexcept ; forward_list ( const forward_list & rhs ) noexcept ; forward_list ( forward_list && rhs ) noexcept ; forward_list & operator = ( const forward_list & rhs ) noexcept ; forward_list & operator = ( forward_list && rhs ) noexcept ; iterator before_begin () noexcept ; const_iterator before_begin () const noexcept ; const_iterator cbefore_begin () const noexcept ; iterator begin () noexcept ; const_iterator begin () const noexcept ; const_iterator cbegin () const noexcept ; iterator end () noexcept ; const_iterator end () const noexcept ; const_iterator cend () const noexcept ; bool empty () const noexcept ; bool full () const noexcept ; size_type size () const noexcept ; size_type capacity () const noexcept ; size_type max_size () const noexcept ; T & front () noexcept ; const T & front () const noexcept ; bool push_front ( const T & data ) noexcept ; bool push_front ( T && data ) noexcept ; bool pop_front () noexcept ; void clear () noexcept ; iterator erase_after ( const_iterator beforeToBeErasedIter ) noexcept ; size_type remove ( const T & data ) noexcept ; template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) noexcept ; template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) noexcept ; template < typename ... ConstructorArgs > iterator emplace_after ( const_iterator afterToBeEmplacedIter , ConstructorArgs && ... args ) noexcept ; iterator insert_after ( const_iterator citer , const T & data ) noexcept ; iterator insert_after ( const_iterator citer , T && data ) noexcept ; private : template < bool IsConstIterator = true > class IteratorBase { public : // provide the following public types for a std::iterator compatible iterator_category interface using iterator_category = std :: forward_iterator_tag ; using value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ; using difference_type = void ; using pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ; using reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ; IteratorBase ( const IteratorBase < false >& iter ) noexcept ; IteratorBase & operator = ( const IteratorBase < false >& rhs ) noexcept ; IteratorBase & operator ++ () noexcept ; template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; reference operator * () const noexcept ; pointer operator -> () const noexcept ; private : using parentListPointer = typename std :: conditional < IsConstIterator , const forward_list < T , Capacity >* , forward_list < T , Capacity >*>:: type ; explicit IteratorBase ( parentListPointer parent , size_type idx ) noexcept ; // Make IteratorBase<true> a friend class of IteratorBase<false> so the copy constructor can access the // private member variables. friend class IteratorBase < true > ; friend class forward_list < T , Capacity > ; parentListPointer m_list ; size_type m_iterListNodeIdx ; }; struct NodeLink { size_type nextIdx ; bool invalidElement ; }; void init () noexcept ; T * getDataPtrFromIdx ( const size_type idx ) noexcept ; const T * getDataPtrFromIdx ( const size_type idx ) const noexcept ; bool isValidElementIdx ( const size_type idx ) const noexcept ; bool isInvalidIterator ( const const_iterator & iter ) const noexcept ; bool isInvalidIterOrDifferentLists ( const const_iterator & iter ) const noexcept ; bool isInvalidElement ( const size_type idx ) const noexcept ; void setInvalidElement ( const size_type idx , const bool value ) noexcept ; size_type & getNextIdx ( const size_type idx ) noexcept ; const size_type & getNextIdx ( const size_type idx ) const noexcept ; size_type & getNextIdx ( const const_iterator & iter ) noexcept ; const size_type & getNextIdx ( const const_iterator & iter ) const noexcept ; void setNextIdx ( const size_type idx , const size_type nextIdx ) noexcept ; static void errorMessage ( const char * source , const char * msg ) noexcept ; //*************************************** // members //*************************************** // two extra slots in the list to handle the 'before_begin' and 'end' element // the necessity for 'before_begin' elements stems from the way a forward_list removes elements at an arbitrary // position. Removing the front-most list element (aka begin()) requires an element pointing towards this position, // hence 'before_begin'. The before_begin index is the head of the list. static constexpr size_type BEFORE_BEGIN_INDEX { Capacity }; static constexpr size_type END_INDEX { size_type ( Capacity ) + 1U }; static constexpr size_type NODE_LINK_COUNT { size_type ( Capacity ) + 2U }; // available storage-indices are moved between a 'freeList' (m_freeListHeadIdx) and 'usedList' where elements // are inserted by the user (starting from BEFORE_BEGIN_INDEX) size_type m_freeListHeadIdx { 0U }; NodeLink m_links [ NODE_LINK_COUNT ]; using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; size_type m_size { 0U }; }; // forward_list } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/forward_list.inl\" #endif // IOX_HOOFS_CXX_FORWARD_LIST_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/forward_list.hpp"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#iceoryx_hoofscxxforward_listhpp","text":"","title":"iceoryx_hoofs/cxx/forward_list.hpp"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#classes","text":"Name class iox::cxx::forward_list C++11 compatible uni-directional forward list implementation.","title":"Classes"},{"location":"API-reference/hoofs/Files/forward__list_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FORWARD_LIST_HPP #define IOX_HOOFS_CXX_FORWARD_LIST_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <cstdint> #include <iostream> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class forward_list { private : // forward declarations, private struct ListLink ; template < bool > class IteratorBase ; public : using iterator = IteratorBase < false > ; using const_iterator = IteratorBase < true > ; using value_type = T ; using size_type = decltype ( Capacity ); forward_list () noexcept ; ~ forward_list () noexcept ; forward_list ( const forward_list & rhs ) noexcept ; forward_list ( forward_list && rhs ) noexcept ; forward_list & operator = ( const forward_list & rhs ) noexcept ; forward_list & operator = ( forward_list && rhs ) noexcept ; iterator before_begin () noexcept ; const_iterator before_begin () const noexcept ; const_iterator cbefore_begin () const noexcept ; iterator begin () noexcept ; const_iterator begin () const noexcept ; const_iterator cbegin () const noexcept ; iterator end () noexcept ; const_iterator end () const noexcept ; const_iterator cend () const noexcept ; bool empty () const noexcept ; bool full () const noexcept ; size_type size () const noexcept ; size_type capacity () const noexcept ; size_type max_size () const noexcept ; T & front () noexcept ; const T & front () const noexcept ; bool push_front ( const T & data ) noexcept ; bool push_front ( T && data ) noexcept ; bool pop_front () noexcept ; void clear () noexcept ; iterator erase_after ( const_iterator beforeToBeErasedIter ) noexcept ; size_type remove ( const T & data ) noexcept ; template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) noexcept ; template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) noexcept ; template < typename ... ConstructorArgs > iterator emplace_after ( const_iterator afterToBeEmplacedIter , ConstructorArgs && ... args ) noexcept ; iterator insert_after ( const_iterator citer , const T & data ) noexcept ; iterator insert_after ( const_iterator citer , T && data ) noexcept ; private : template < bool IsConstIterator = true > class IteratorBase { public : // provide the following public types for a std::iterator compatible iterator_category interface using iterator_category = std :: forward_iterator_tag ; using value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ; using difference_type = void ; using pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ; using reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ; IteratorBase ( const IteratorBase < false >& iter ) noexcept ; IteratorBase & operator = ( const IteratorBase < false >& rhs ) noexcept ; IteratorBase & operator ++ () noexcept ; template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; reference operator * () const noexcept ; pointer operator -> () const noexcept ; private : using parentListPointer = typename std :: conditional < IsConstIterator , const forward_list < T , Capacity >* , forward_list < T , Capacity >*>:: type ; explicit IteratorBase ( parentListPointer parent , size_type idx ) noexcept ; // Make IteratorBase<true> a friend class of IteratorBase<false> so the copy constructor can access the // private member variables. friend class IteratorBase < true > ; friend class forward_list < T , Capacity > ; parentListPointer m_list ; size_type m_iterListNodeIdx ; }; struct NodeLink { size_type nextIdx ; bool invalidElement ; }; void init () noexcept ; T * getDataPtrFromIdx ( const size_type idx ) noexcept ; const T * getDataPtrFromIdx ( const size_type idx ) const noexcept ; bool isValidElementIdx ( const size_type idx ) const noexcept ; bool isInvalidIterator ( const const_iterator & iter ) const noexcept ; bool isInvalidIterOrDifferentLists ( const const_iterator & iter ) const noexcept ; bool isInvalidElement ( const size_type idx ) const noexcept ; void setInvalidElement ( const size_type idx , const bool value ) noexcept ; size_type & getNextIdx ( const size_type idx ) noexcept ; const size_type & getNextIdx ( const size_type idx ) const noexcept ; size_type & getNextIdx ( const const_iterator & iter ) noexcept ; const size_type & getNextIdx ( const const_iterator & iter ) const noexcept ; void setNextIdx ( const size_type idx , const size_type nextIdx ) noexcept ; static void errorMessage ( const char * source , const char * msg ) noexcept ; //*************************************** // members //*************************************** // two extra slots in the list to handle the 'before_begin' and 'end' element // the necessity for 'before_begin' elements stems from the way a forward_list removes elements at an arbitrary // position. Removing the front-most list element (aka begin()) requires an element pointing towards this position, // hence 'before_begin'. The before_begin index is the head of the list. static constexpr size_type BEFORE_BEGIN_INDEX { Capacity }; static constexpr size_type END_INDEX { size_type ( Capacity ) + 1U }; static constexpr size_type NODE_LINK_COUNT { size_type ( Capacity ) + 2U }; // available storage-indices are moved between a 'freeList' (m_freeListHeadIdx) and 'usedList' where elements // are inserted by the user (starting from BEFORE_BEGIN_INDEX) size_type m_freeListHeadIdx { 0U }; NodeLink m_links [ NODE_LINK_COUNT ]; using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; size_type m_size { 0U }; }; // forward_list } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/forward_list.inl\" #endif // IOX_HOOFS_CXX_FORWARD_LIST_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/function_8hpp/","text":"iceoryx_hoofs/cxx/function.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Source code \ud83d\udd17 // Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_FUNCTION_HPP #define IOX_HOOFS_FUNCTION_HPP #include \"iceoryx_hoofs/internal/cxx/static_storage.hpp\" #include \"iceoryx_hoofs/internal/cxx/storable_function.hpp\" namespace iox { namespace cxx { template < typename Signature , uint64_t Capacity = 128U > using function = storable_function < static_storage < Capacity > , Signature > ; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_FUNCTION_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/function.hpp"},{"location":"API-reference/hoofs/Files/function_8hpp/#iceoryx_hoofscxxfunctionhpp","text":"","title":"iceoryx_hoofs/cxx/function.hpp"},{"location":"API-reference/hoofs/Files/function_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/function_8hpp/#source-code","text":"// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_FUNCTION_HPP #define IOX_HOOFS_FUNCTION_HPP #include \"iceoryx_hoofs/internal/cxx/static_storage.hpp\" #include \"iceoryx_hoofs/internal/cxx/storable_function.hpp\" namespace iox { namespace cxx { template < typename Signature , uint64_t Capacity = 128U > using function = storable_function < static_storage < Capacity > , Signature > ; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_FUNCTION_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/","text":"iceoryx_hoofs/cxx/function_ref.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::function_ref class iox::cxx::function_ref< ReturnType(ArgTypes...)> cxx::function_ref is a non-owning reference to a callable. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FUNCTION_REF_HPP #define IOX_HOOFS_CXX_FUNCTION_REF_HPP #include \"iceoryx_hoofs/cxx/requires.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include <cstddef> #include <iostream> #include <memory> #include <type_traits> namespace iox { namespace cxx { template < typename SignatureType > class function_ref ; template < class ReturnType , class ... ArgTypes > class function_ref < ReturnType ( ArgTypes ...) > { using SignatureType = ReturnType ( ArgTypes ...); template < typename T1 , typename T2 > using has_same_decayed_type = typename std :: integral_constant < bool , bool ( std :: is_same < typename std :: decay < T1 >:: type , typename std :: decay < T2 >:: type >:: value ) > ; public : function_ref () noexcept ; ~ function_ref () noexcept = default ; function_ref ( const function_ref & ) noexcept = default ; function_ref & operator = ( const function_ref & ) noexcept = default ; template < typename CallableType , typename = std :: enable_if_t <! is_function_pointer < CallableType >:: value && ! has_same_decayed_type < CallableType , function_ref >:: value && is_invocable < CallableType , ArgTypes ... >:: value >> function_ref ( CallableType && callable ) noexcept ; function_ref ( ReturnType ( * function )( ArgTypes ...)) noexcept ; function_ref ( function_ref && rhs ) noexcept ; function_ref & operator = ( function_ref && rhs ) noexcept ; ReturnType operator ()( ArgTypes ... args ) const noexcept ; explicit operator bool () const noexcept ; void swap ( function_ref & rhs ) noexcept ; private : void * m_pointerToCallable { nullptr }; ReturnType ( * m_functionPointer )( void * , ArgTypes ...){ nullptr }; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/function_ref.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/function_ref.hpp"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#iceoryx_hoofscxxfunction_refhpp","text":"","title":"iceoryx_hoofs/cxx/function_ref.hpp"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#classes","text":"Name class iox::cxx::function_ref class iox::cxx::function_ref< ReturnType(ArgTypes...)> cxx::function_ref is a non-owning reference to a callable.","title":"Classes"},{"location":"API-reference/hoofs/Files/function__ref_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FUNCTION_REF_HPP #define IOX_HOOFS_CXX_FUNCTION_REF_HPP #include \"iceoryx_hoofs/cxx/requires.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include <cstddef> #include <iostream> #include <memory> #include <type_traits> namespace iox { namespace cxx { template < typename SignatureType > class function_ref ; template < class ReturnType , class ... ArgTypes > class function_ref < ReturnType ( ArgTypes ...) > { using SignatureType = ReturnType ( ArgTypes ...); template < typename T1 , typename T2 > using has_same_decayed_type = typename std :: integral_constant < bool , bool ( std :: is_same < typename std :: decay < T1 >:: type , typename std :: decay < T2 >:: type >:: value ) > ; public : function_ref () noexcept ; ~ function_ref () noexcept = default ; function_ref ( const function_ref & ) noexcept = default ; function_ref & operator = ( const function_ref & ) noexcept = default ; template < typename CallableType , typename = std :: enable_if_t <! is_function_pointer < CallableType >:: value && ! has_same_decayed_type < CallableType , function_ref >:: value && is_invocable < CallableType , ArgTypes ... >:: value >> function_ref ( CallableType && callable ) noexcept ; function_ref ( ReturnType ( * function )( ArgTypes ...)) noexcept ; function_ref ( function_ref && rhs ) noexcept ; function_ref & operator = ( function_ref && rhs ) noexcept ; ReturnType operator ()( ArgTypes ... args ) const noexcept ; explicit operator bool () const noexcept ; void swap ( function_ref & rhs ) noexcept ; private : void * m_pointerToCallable { nullptr }; ReturnType ( * m_functionPointer )( void * , ArgTypes ...){ nullptr }; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/function_ref.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/","text":"iceoryx_hoofs/cxx/functional_interface.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FUNCTIONAL_POLICY_HPP #define IOX_HOOFS_CXX_FUNCTIONAL_POLICY_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <iostream> #include <utility> namespace iox { namespace cxx { namespace internal { template < typename Derived , class = void > struct HasValueMethod : std :: false_type { }; template < typename Derived > struct HasValueMethod < Derived , cxx :: void_t < decltype ( std :: declval < Derived > (). value ()) >> : std :: true_type { }; template < typename Derived , class = void > struct HasGetErrorMethod : std :: false_type { }; template < typename Derived > struct HasGetErrorMethod < Derived , cxx :: void_t < decltype ( std :: declval < Derived > (). get_error ()) >> : std :: true_type { }; template < typename Derived > struct Expect { void expect ( const char * const msg ) const noexcept ; }; template < typename Derived , typename ValueType > struct ExpectWithValue { // the method prints the provided message and induces a fatal error ValueType & expect ( const char * const msg ) & noexcept ; // the method prints the provided message and induces a fatal error const ValueType & expect ( const char * const msg ) const & noexcept ; // the method prints the provided message and induces a fatal error ValueType && expect ( const char * const msg ) && noexcept ; // the method prints the provided message and induces a fatal error const ValueType && expect ( const char * const msg ) const && noexcept ; }; template < typename Derived , typename ValueType > struct ValueOr { template < typename U > ValueType value_or ( U && alternative ) const & noexcept ; template < typename U > ValueType value_or ( U && alternative ) && noexcept ; }; template < typename Derived , typename ValueType > struct AndThenWithValue { using and_then_callback_t = cxx :: function_ref < void ( ValueType & ) > ; using const_and_then_callback_t = cxx :: function_ref < void ( const ValueType & ) > ; Derived & and_then ( const and_then_callback_t & callable ) & noexcept ; const Derived & and_then ( const const_and_then_callback_t & callable ) const & noexcept ; Derived && and_then ( const and_then_callback_t & callable ) && noexcept ; const Derived && and_then ( const const_and_then_callback_t & callable ) const && noexcept ; }; template < typename Derived > struct AndThen { using and_then_callback_t = cxx :: function_ref < void () > ; Derived & and_then ( const and_then_callback_t & callable ) & noexcept ; const Derived & and_then ( const and_then_callback_t & callable ) const & noexcept ; Derived && and_then ( const and_then_callback_t & callable ) && noexcept ; const Derived && and_then ( const and_then_callback_t & callable ) const && noexcept ; }; template < typename Derived , typename ErrorType > struct OrElseWithValue { using or_else_callback_t = cxx :: function_ref < void ( ErrorType & ) > ; using const_or_else_callback_t = cxx :: function_ref < void ( const ErrorType & ) > ; Derived & or_else ( const or_else_callback_t & callable ) & noexcept ; const Derived & or_else ( const const_or_else_callback_t & callable ) const & noexcept ; Derived && or_else ( const or_else_callback_t & callable ) && noexcept ; const Derived && or_else ( const const_or_else_callback_t & callable ) const && noexcept ; }; template < typename Derived > struct OrElse { using or_else_callback_t = cxx :: function_ref < void () > ; Derived & or_else ( const or_else_callback_t & callable ) & noexcept ; const Derived & or_else ( const or_else_callback_t & callable ) const & noexcept ; Derived && or_else ( const or_else_callback_t & callable ) && noexcept ; const Derived && or_else ( const or_else_callback_t & callable ) const && noexcept ; }; template < typename Derived , typename ValueType , typename ErrorType > struct FunctionalInterfaceImpl : public ExpectWithValue < Derived , ValueType > , public ValueOr < Derived , ValueType > , public AndThenWithValue < Derived , ValueType > , public OrElseWithValue < Derived , ErrorType > { }; template < typename Derived > struct FunctionalInterfaceImpl < Derived , void , void > : public Expect < Derived > , public AndThen < Derived > , public OrElse < Derived > { }; template < typename Derived , typename ValueType > struct FunctionalInterfaceImpl < Derived , ValueType , void > : public ExpectWithValue < Derived , ValueType > , public ValueOr < Derived , ValueType > , public AndThenWithValue < Derived , ValueType > , public OrElse < Derived > { }; template < typename Derived , typename ErrorType > struct FunctionalInterfaceImpl < Derived , void , ErrorType > : public Expect < Derived > , public AndThen < Derived > , public OrElseWithValue < Derived , ErrorType > { }; } // namespace internal template < typename Derived , typename ValueType , typename ErrorType > using FunctionalInterface = internal :: FunctionalInterfaceImpl < Derived , ValueType , ErrorType > ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/functional_interface.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/functional_interface.hpp"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/#iceoryx_hoofscxxfunctional_interfacehpp","text":"","title":"iceoryx_hoofs/cxx/functional_interface.hpp"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/functional__interface_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_FUNCTIONAL_POLICY_HPP #define IOX_HOOFS_CXX_FUNCTIONAL_POLICY_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <iostream> #include <utility> namespace iox { namespace cxx { namespace internal { template < typename Derived , class = void > struct HasValueMethod : std :: false_type { }; template < typename Derived > struct HasValueMethod < Derived , cxx :: void_t < decltype ( std :: declval < Derived > (). value ()) >> : std :: true_type { }; template < typename Derived , class = void > struct HasGetErrorMethod : std :: false_type { }; template < typename Derived > struct HasGetErrorMethod < Derived , cxx :: void_t < decltype ( std :: declval < Derived > (). get_error ()) >> : std :: true_type { }; template < typename Derived > struct Expect { void expect ( const char * const msg ) const noexcept ; }; template < typename Derived , typename ValueType > struct ExpectWithValue { // the method prints the provided message and induces a fatal error ValueType & expect ( const char * const msg ) & noexcept ; // the method prints the provided message and induces a fatal error const ValueType & expect ( const char * const msg ) const & noexcept ; // the method prints the provided message and induces a fatal error ValueType && expect ( const char * const msg ) && noexcept ; // the method prints the provided message and induces a fatal error const ValueType && expect ( const char * const msg ) const && noexcept ; }; template < typename Derived , typename ValueType > struct ValueOr { template < typename U > ValueType value_or ( U && alternative ) const & noexcept ; template < typename U > ValueType value_or ( U && alternative ) && noexcept ; }; template < typename Derived , typename ValueType > struct AndThenWithValue { using and_then_callback_t = cxx :: function_ref < void ( ValueType & ) > ; using const_and_then_callback_t = cxx :: function_ref < void ( const ValueType & ) > ; Derived & and_then ( const and_then_callback_t & callable ) & noexcept ; const Derived & and_then ( const const_and_then_callback_t & callable ) const & noexcept ; Derived && and_then ( const and_then_callback_t & callable ) && noexcept ; const Derived && and_then ( const const_and_then_callback_t & callable ) const && noexcept ; }; template < typename Derived > struct AndThen { using and_then_callback_t = cxx :: function_ref < void () > ; Derived & and_then ( const and_then_callback_t & callable ) & noexcept ; const Derived & and_then ( const and_then_callback_t & callable ) const & noexcept ; Derived && and_then ( const and_then_callback_t & callable ) && noexcept ; const Derived && and_then ( const and_then_callback_t & callable ) const && noexcept ; }; template < typename Derived , typename ErrorType > struct OrElseWithValue { using or_else_callback_t = cxx :: function_ref < void ( ErrorType & ) > ; using const_or_else_callback_t = cxx :: function_ref < void ( const ErrorType & ) > ; Derived & or_else ( const or_else_callback_t & callable ) & noexcept ; const Derived & or_else ( const const_or_else_callback_t & callable ) const & noexcept ; Derived && or_else ( const or_else_callback_t & callable ) && noexcept ; const Derived && or_else ( const const_or_else_callback_t & callable ) const && noexcept ; }; template < typename Derived > struct OrElse { using or_else_callback_t = cxx :: function_ref < void () > ; Derived & or_else ( const or_else_callback_t & callable ) & noexcept ; const Derived & or_else ( const or_else_callback_t & callable ) const & noexcept ; Derived && or_else ( const or_else_callback_t & callable ) && noexcept ; const Derived && or_else ( const or_else_callback_t & callable ) const && noexcept ; }; template < typename Derived , typename ValueType , typename ErrorType > struct FunctionalInterfaceImpl : public ExpectWithValue < Derived , ValueType > , public ValueOr < Derived , ValueType > , public AndThenWithValue < Derived , ValueType > , public OrElseWithValue < Derived , ErrorType > { }; template < typename Derived > struct FunctionalInterfaceImpl < Derived , void , void > : public Expect < Derived > , public AndThen < Derived > , public OrElse < Derived > { }; template < typename Derived , typename ValueType > struct FunctionalInterfaceImpl < Derived , ValueType , void > : public ExpectWithValue < Derived , ValueType > , public ValueOr < Derived , ValueType > , public AndThenWithValue < Derived , ValueType > , public OrElse < Derived > { }; template < typename Derived , typename ErrorType > struct FunctionalInterfaceImpl < Derived , void , ErrorType > : public Expect < Derived > , public AndThen < Derived > , public OrElseWithValue < Derived , ErrorType > { }; } // namespace internal template < typename Derived , typename ValueType , typename ErrorType > using FunctionalInterface = internal :: FunctionalInterfaceImpl < Derived , ValueType , ErrorType > ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/functional_interface.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/","text":"iceoryx_hoofs/cxx/generic_raii.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::GenericRAII The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_GENERIC_RAII_HPP #define IOX_HOOFS_CXX_GENERIC_RAII_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include <functional> namespace iox { namespace cxx { class GenericRAII { public : explicit GenericRAII ( const std :: function < void () >& cleanupFunction ) noexcept ; GenericRAII ( const function_ref < void () >& initFunction , const std :: function < void () >& cleanupFunction ) noexcept ; ~ GenericRAII () noexcept ; GenericRAII ( const GenericRAII & ) = delete ; GenericRAII & operator = ( const GenericRAII & ) = delete ; GenericRAII ( GenericRAII && rhs ) noexcept ; GenericRAII & operator = ( GenericRAII && rhs ) noexcept ; private : void destroy () noexcept ; private : std :: function < void () > m_cleanupFunction ; }; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_CXX_GENERIC_RAII_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/generic_raii.hpp"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#iceoryx_hoofscxxgeneric_raiihpp","text":"","title":"iceoryx_hoofs/cxx/generic_raii.hpp"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#classes","text":"Name class iox::cxx::GenericRAII The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources.","title":"Classes"},{"location":"API-reference/hoofs/Files/generic__raii_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_GENERIC_RAII_HPP #define IOX_HOOFS_CXX_GENERIC_RAII_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include <functional> namespace iox { namespace cxx { class GenericRAII { public : explicit GenericRAII ( const std :: function < void () >& cleanupFunction ) noexcept ; GenericRAII ( const function_ref < void () >& initFunction , const std :: function < void () >& cleanupFunction ) noexcept ; ~ GenericRAII () noexcept ; GenericRAII ( const GenericRAII & ) = delete ; GenericRAII & operator = ( const GenericRAII & ) = delete ; GenericRAII ( GenericRAII && rhs ) noexcept ; GenericRAII & operator = ( GenericRAII && rhs ) noexcept ; private : void destroy () noexcept ; private : std :: function < void () > m_cleanupFunction ; }; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_CXX_GENERIC_RAII_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/helplets_8hpp/","text":"iceoryx_hoofs/cxx/helplets.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal Classes \ud83d\udd17 Name class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. struct iox::cxx::not_null struct iox::cxx::greater_or_equal struct iox::cxx::range struct iox::cxx::BestFittingType get the best fitting unsigned integer type for a given value at compile time Defines \ud83d\udd17 Name IOX_BUILDER_PARAMETER (type, name, defaultValue) Macro which generates a setter method useful for a builder pattern. Macro Documentation \ud83d\udd17 define IOX_BUILDER_PARAMETER \ud83d\udd17 #define IOX_BUILDER_PARAMETER( type , name , defaultValue ) public : \\ decltype ( auto ) name ( type const & value ) && \\ { \\ m_ ## name = value ; \\ return std :: move ( * this ); \\ } \\ \\ decltype ( auto ) name ( type && value ) && \\ { \\ m_ ## name = std :: move ( value ); \\ return std :: move ( * this ); \\ } \\ \\ private : \\ type m_ ## name { defaultValue }; Macro which generates a setter method useful for a builder pattern. Parameters : type the data type of the parameter name the name of the parameter defaultValue the default value of the parameter class MyBuilder { IOX_BUILDER_PARAMETER ( TypeA , NameB , ValueC ) // START generates the following code public : decltype ( auto ) NameB ( TypeA const & value ) && { m_NameB = value ; return std :: move ( * this ); } decltype ( auto ) NameB ( TypeA && value ) && { m_NameB = std :: move ( value ); return std :: move ( * this ); } private : TypeA m_NameB = ValueC ; // END }; Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_HELPLETS_HPP #define IOX_HOOFS_CXX_HELPLETS_HPP #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include <cassert> #include <cstdint> #include <cstring> #include <iostream> #include <limits> #include <type_traits> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" #include \"iceoryx_hoofs/platform/platform_settings.hpp\" namespace iox { namespace cxx { template < uint64_t Capacity > class string ; struct TruncateToCapacity_t ; namespace internal { template < bool GreaterUint8 , bool GreaterUint16 , bool GreaterUint32 > struct BestFittingTypeImpl { using Type_t = uint64_t ; }; template <> struct BestFittingTypeImpl < false , false , false > { using Type_t = uint8_t ; }; template <> struct BestFittingTypeImpl < true , false , false > { using Type_t = uint16_t ; }; template <> struct BestFittingTypeImpl < true , true , false > { using Type_t = uint32_t ; }; constexpr char ASCII_A = 'a' ; constexpr char ASCII_Z = 'z' ; constexpr char ASCII_CAPITAL_A = 'A' ; constexpr char ASCII_CAPITAL_Z = 'Z' ; constexpr char ASCII_0 = '0' ; constexpr char ASCII_9 = '9' ; constexpr char ASCII_MINUS = '-' ; constexpr char ASCII_DOT = '.' ; constexpr char ASCII_COLON = ':' ; constexpr char ASCII_UNDERSCORE = '_' ; } // namespace internal template < typename T , typename = typename std :: enable_if < std :: is_pointer < T >:: value , void >:: type > struct not_null { public : not_null ( T t ) noexcept : value ( t ) { Expects ( t != nullptr ); } constexpr operator T () const noexcept { return value ; } private : T value ; }; template < typename T , T Minimum > struct greater_or_equal { public : greater_or_equal ( T t ) noexcept : value ( t ) { Expects ( t >= Minimum ); } constexpr operator T () const noexcept { return value ; } private : T value ; }; template < typename T , T Minimum , T Maximum > struct range { public : range ( T t ) noexcept : value ( t ) { Expects ( t >= Minimum && t <= Maximum ); } constexpr operator T () const noexcept { return value ; } private : T value ; }; template < typename T > T align ( const T value , const T alignment ) noexcept { T remainder = value % alignment ; return value + (( remainder == 0u ) ? 0u : alignment - remainder ); } void * alignedAlloc ( const uint64_t alignment , const uint64_t size ) noexcept ; void alignedFree ( void * const memory ) noexcept ; template < size_t s = 0 > constexpr size_t maxAlignment () noexcept { return s ; } template < typename T , typename ... Args > constexpr size_t maxAlignment () noexcept { return alignof ( T ) > maxAlignment < Args ... > () ? alignof ( T ) : maxAlignment < Args ... > (); } template < size_t s = 0 > constexpr size_t maxSize () noexcept { return s ; } template < typename T , typename ... Args > constexpr size_t maxSize () noexcept { return sizeof ( T ) > maxSize < Args ... > () ? sizeof ( T ) : maxSize < Args ... > (); } template < typename T , typename Enumeration > const char * convertEnumToString ( T port , const Enumeration source ) noexcept { return port [ static_cast < size_t > ( source )]; } template < typename enum_type > auto enumTypeAsUnderlyingType ( enum_type const value ) noexcept -> typename std :: underlying_type < enum_type >:: type { return static_cast < typename std :: underlying_type < enum_type >:: type > ( value ); } template < typename Container , typename Functor > void forEach ( Container & c , const Functor & f ) noexcept { for ( auto & element : c ) { f ( element ); } } template < uint64_t SizeValue > static constexpr uint64_t strlen2 ( char const ( & /*notInterested*/ )[ SizeValue ]) noexcept { return SizeValue - 1 ; } template < uint64_t Value > struct BestFittingType { #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wtype-limits\" using Type_t = typename internal :: BestFittingTypeImpl < ( Value > std :: numeric_limits < uint8_t >:: max ()), ( Value > std :: numeric_limits < uint16_t >:: max ()), ( Value > std :: numeric_limits < uint32_t >:: max ()) >:: Type_t ; #pragma GCC diagnostic pop }; template < uint64_t Value > using BestFittingType_t = typename BestFittingType < Value >:: Type_t ; constexpr bool isCompiledOn32BitSystem () noexcept { return INTPTR_MAX == INT32_MAX ; } template < typename T > constexpr bool isPowerOfTwo ( const T n ) noexcept { static_assert ( std :: is_unsigned < T >:: value && ! std :: is_same < T , bool >:: value , \"Only unsigned integer are allowed!\" ); return n && (( n & ( n - 1U )) == 0U ); } template < uint64_t StringCapacity > bool isValidFileName ( const string < StringCapacity >& name ) noexcept ; template < uint64_t StringCapacity > bool isValidFilePath ( const string < StringCapacity >& name ) noexcept ; template < typename F , typename T > constexpr T from ( const F value ) noexcept ; template < typename T , typename F > constexpr T into ( const F value ) noexcept ; #define IOX_BUILDER_PARAMETER(type, name, defaultValue) \\ public: \\ decltype(auto) name(type const& value)&& \\ { \\ m_##name = value; \\ return std::move(*this); \\ } \\ \\ decltype(auto) name(type&& value)&& \\ { \\ m_##name = std::move(value); \\ return std::move(*this); \\ } \\ \\ private: \\ type m_##name{defaultValue}; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/helplets.inl\" #endif // IOX_HOOFS_CXX_HELPLETS_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/helplets.hpp"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#iceoryx_hoofscxxhelpletshpp","text":"","title":"iceoryx_hoofs/cxx/helplets.hpp"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#classes","text":"Name class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. struct iox::cxx::not_null struct iox::cxx::greater_or_equal struct iox::cxx::range struct iox::cxx::BestFittingType get the best fitting unsigned integer type for a given value at compile time","title":"Classes"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#defines","text":"Name IOX_BUILDER_PARAMETER (type, name, defaultValue) Macro which generates a setter method useful for a builder pattern.","title":"Defines"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#define-iox_builder_parameter","text":"#define IOX_BUILDER_PARAMETER( type , name , defaultValue ) public : \\ decltype ( auto ) name ( type const & value ) && \\ { \\ m_ ## name = value ; \\ return std :: move ( * this ); \\ } \\ \\ decltype ( auto ) name ( type && value ) && \\ { \\ m_ ## name = std :: move ( value ); \\ return std :: move ( * this ); \\ } \\ \\ private : \\ type m_ ## name { defaultValue }; Macro which generates a setter method useful for a builder pattern. Parameters : type the data type of the parameter name the name of the parameter defaultValue the default value of the parameter class MyBuilder { IOX_BUILDER_PARAMETER ( TypeA , NameB , ValueC ) // START generates the following code public : decltype ( auto ) NameB ( TypeA const & value ) && { m_NameB = value ; return std :: move ( * this ); } decltype ( auto ) NameB ( TypeA && value ) && { m_NameB = std :: move ( value ); return std :: move ( * this ); } private : TypeA m_NameB = ValueC ; // END };","title":"define IOX_BUILDER_PARAMETER"},{"location":"API-reference/hoofs/Files/helplets_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_HELPLETS_HPP #define IOX_HOOFS_CXX_HELPLETS_HPP #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include <cassert> #include <cstdint> #include <cstring> #include <iostream> #include <limits> #include <type_traits> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" #include \"iceoryx_hoofs/platform/platform_settings.hpp\" namespace iox { namespace cxx { template < uint64_t Capacity > class string ; struct TruncateToCapacity_t ; namespace internal { template < bool GreaterUint8 , bool GreaterUint16 , bool GreaterUint32 > struct BestFittingTypeImpl { using Type_t = uint64_t ; }; template <> struct BestFittingTypeImpl < false , false , false > { using Type_t = uint8_t ; }; template <> struct BestFittingTypeImpl < true , false , false > { using Type_t = uint16_t ; }; template <> struct BestFittingTypeImpl < true , true , false > { using Type_t = uint32_t ; }; constexpr char ASCII_A = 'a' ; constexpr char ASCII_Z = 'z' ; constexpr char ASCII_CAPITAL_A = 'A' ; constexpr char ASCII_CAPITAL_Z = 'Z' ; constexpr char ASCII_0 = '0' ; constexpr char ASCII_9 = '9' ; constexpr char ASCII_MINUS = '-' ; constexpr char ASCII_DOT = '.' ; constexpr char ASCII_COLON = ':' ; constexpr char ASCII_UNDERSCORE = '_' ; } // namespace internal template < typename T , typename = typename std :: enable_if < std :: is_pointer < T >:: value , void >:: type > struct not_null { public : not_null ( T t ) noexcept : value ( t ) { Expects ( t != nullptr ); } constexpr operator T () const noexcept { return value ; } private : T value ; }; template < typename T , T Minimum > struct greater_or_equal { public : greater_or_equal ( T t ) noexcept : value ( t ) { Expects ( t >= Minimum ); } constexpr operator T () const noexcept { return value ; } private : T value ; }; template < typename T , T Minimum , T Maximum > struct range { public : range ( T t ) noexcept : value ( t ) { Expects ( t >= Minimum && t <= Maximum ); } constexpr operator T () const noexcept { return value ; } private : T value ; }; template < typename T > T align ( const T value , const T alignment ) noexcept { T remainder = value % alignment ; return value + (( remainder == 0u ) ? 0u : alignment - remainder ); } void * alignedAlloc ( const uint64_t alignment , const uint64_t size ) noexcept ; void alignedFree ( void * const memory ) noexcept ; template < size_t s = 0 > constexpr size_t maxAlignment () noexcept { return s ; } template < typename T , typename ... Args > constexpr size_t maxAlignment () noexcept { return alignof ( T ) > maxAlignment < Args ... > () ? alignof ( T ) : maxAlignment < Args ... > (); } template < size_t s = 0 > constexpr size_t maxSize () noexcept { return s ; } template < typename T , typename ... Args > constexpr size_t maxSize () noexcept { return sizeof ( T ) > maxSize < Args ... > () ? sizeof ( T ) : maxSize < Args ... > (); } template < typename T , typename Enumeration > const char * convertEnumToString ( T port , const Enumeration source ) noexcept { return port [ static_cast < size_t > ( source )]; } template < typename enum_type > auto enumTypeAsUnderlyingType ( enum_type const value ) noexcept -> typename std :: underlying_type < enum_type >:: type { return static_cast < typename std :: underlying_type < enum_type >:: type > ( value ); } template < typename Container , typename Functor > void forEach ( Container & c , const Functor & f ) noexcept { for ( auto & element : c ) { f ( element ); } } template < uint64_t SizeValue > static constexpr uint64_t strlen2 ( char const ( & /*notInterested*/ )[ SizeValue ]) noexcept { return SizeValue - 1 ; } template < uint64_t Value > struct BestFittingType { #pragma GCC diagnostic push #pragma GCC diagnostic ignored \"-Wtype-limits\" using Type_t = typename internal :: BestFittingTypeImpl < ( Value > std :: numeric_limits < uint8_t >:: max ()), ( Value > std :: numeric_limits < uint16_t >:: max ()), ( Value > std :: numeric_limits < uint32_t >:: max ()) >:: Type_t ; #pragma GCC diagnostic pop }; template < uint64_t Value > using BestFittingType_t = typename BestFittingType < Value >:: Type_t ; constexpr bool isCompiledOn32BitSystem () noexcept { return INTPTR_MAX == INT32_MAX ; } template < typename T > constexpr bool isPowerOfTwo ( const T n ) noexcept { static_assert ( std :: is_unsigned < T >:: value && ! std :: is_same < T , bool >:: value , \"Only unsigned integer are allowed!\" ); return n && (( n & ( n - 1U )) == 0U ); } template < uint64_t StringCapacity > bool isValidFileName ( const string < StringCapacity >& name ) noexcept ; template < uint64_t StringCapacity > bool isValidFilePath ( const string < StringCapacity >& name ) noexcept ; template < typename F , typename T > constexpr T from ( const F value ) noexcept ; template < typename T , typename F > constexpr T into ( const F value ) noexcept ; #define IOX_BUILDER_PARAMETER(type, name, defaultValue) \\ public: \\ decltype(auto) name(type const& value)&& \\ { \\ m_##name = value; \\ return std::move(*this); \\ } \\ \\ decltype(auto) name(type&& value)&& \\ { \\ m_##name = std::move(value); \\ return std::move(*this); \\ } \\ \\ private: \\ type m_##name{defaultValue}; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/helplets.inl\" #endif // IOX_HOOFS_CXX_HELPLETS_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/list_8hpp/","text":"iceoryx_hoofs/cxx/list.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::list C++11 compatible bi-directional list implementation. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_LIST_HPP #define IOX_HOOFS_CXX_LIST_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <cstdint> #include <iostream> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class list { private : // forward declarations, private struct ListLink ; template < bool > class IteratorBase ; public : using iterator = IteratorBase < false > ; using const_iterator = IteratorBase < true > ; using value_type = T ; using size_type = decltype ( Capacity ); list () noexcept ; ~ list () noexcept ; list ( const list & rhs ) noexcept ; list ( list && rhs ) noexcept ; list & operator = ( const list & rhs ) noexcept ; list & operator = ( list && rhs ) noexcept ; iterator begin () noexcept ; const_iterator begin () const noexcept ; const_iterator cbegin () const noexcept ; iterator end () noexcept ; const_iterator end () const noexcept ; const_iterator cend () const noexcept ; bool empty () const noexcept ; bool full () const noexcept ; size_type size () const noexcept ; size_type capacity () const noexcept ; size_type max_size () const noexcept ; T & front () noexcept ; const T & front () const noexcept ; T & back () noexcept ; const T & back () const noexcept ; bool push_front ( const T & data ) noexcept ; bool push_front ( T && data ) noexcept ; bool push_back ( const T & data ) noexcept ; bool push_back ( T && data ) noexcept ; bool pop_front () noexcept ; bool pop_back () noexcept ; void clear () noexcept ; iterator erase ( const_iterator iter ) noexcept ; size_type remove ( const T & data ) noexcept ; template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) noexcept ; template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) noexcept ; template < typename ... ConstructorArgs > T & emplace_back ( ConstructorArgs && ... args ) noexcept ; template < typename ... ConstructorArgs > iterator emplace ( const_iterator iter , ConstructorArgs && ... args ) noexcept ; iterator insert ( const_iterator citer , const T & data ) noexcept ; iterator insert ( const_iterator citer , T && data ) noexcept ; private : template < bool IsConstIterator = true > class IteratorBase { public : // provide the following public types for a std::iterator compatible iterator_category interface using iterator_category = std :: bidirectional_iterator_tag ; using value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ; using difference_type = void ; using pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ; using reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ; IteratorBase ( const IteratorBase < false >& iter ) noexcept ; IteratorBase & operator = ( const IteratorBase < false >& rhs ) noexcept ; IteratorBase & operator ++ () noexcept ; IteratorBase & operator -- () noexcept ; template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; reference operator * () const noexcept ; pointer operator -> () const noexcept ; private : using parentListPointer = typename std :: conditional < IsConstIterator , const list < T , Capacity >* , list < T , Capacity >*>:: type ; explicit IteratorBase ( parentListPointer parent , size_type idx ) noexcept ; // Make IteratorBase<true> a friend class of IteratorBase<false> so the copy constructor can access the // private member variables. friend class IteratorBase < true > ; friend class list < T , Capacity > ; parentListPointer m_list ; size_type m_iterListNodeIdx ; }; struct NodeLink { size_type nextIdx ; size_type prevIdx ; }; void init () noexcept ; T * getDataPtrFromIdx ( const size_type idx ) noexcept ; const T * getDataPtrFromIdx ( const size_type idx ) const noexcept ; bool isValidElementIdx ( const size_type idx ) const noexcept ; bool isInvalidIterator ( const const_iterator & iter ) const noexcept ; bool isInvalidIterOrDifferentLists ( const const_iterator & iter ) const noexcept ; size_type & getPrevIdx ( const size_type idx ) noexcept ; size_type & getNextIdx ( const size_type idx ) noexcept ; size_type & getPrevIdx ( const const_iterator & iter ) noexcept ; size_type & getNextIdx ( const const_iterator & iter ) noexcept ; const size_type & getPrevIdx ( const size_type idx ) const noexcept ; const size_type & getNextIdx ( const size_type idx ) const noexcept ; const size_type & getPrevIdx ( const const_iterator & iter ) const noexcept ; const size_type & getNextIdx ( const const_iterator & iter ) const noexcept ; void setPrevIdx ( const size_type idx , const size_type prevIdx ) noexcept ; void setNextIdx ( const size_type idx , const size_type nextIdx ) noexcept ; static void errorMessage ( const char * source , const char * msg ) noexcept ; //*************************************** // members //*************************************** static constexpr size_type BEGIN_END_LINK_INDEX { size_type ( Capacity )}; static constexpr size_type NODE_LINK_COUNT { size_type ( Capacity ) + 1U }; static constexpr size_type INVALID_INDEX { NODE_LINK_COUNT }; // unused/free elements are stored in an internal list (freeList), this freeList is accessed via the // member variable m_freeListHeadIdx; user insert- and erase- operations move elements between the freeList and // active list size_type m_freeListHeadIdx { 0U }; // m_links array is one element bigger than request element count. In this additional element links are stored // to the beginning and end of the list. This additional element (index position 'capacity' aka // BEGIN_END_LINK_INDEX) 'previous' will point to the last valid element (end()) and 'next' will point to the // first used list element (begin()) NodeLink m_links [ NODE_LINK_COUNT ]; using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; size_type m_size { 0U }; }; // list } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/list.inl\" #endif // IOX_HOOFS_CXX_LIST_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/list.hpp"},{"location":"API-reference/hoofs/Files/list_8hpp/#iceoryx_hoofscxxlisthpp","text":"","title":"iceoryx_hoofs/cxx/list.hpp"},{"location":"API-reference/hoofs/Files/list_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/list_8hpp/#classes","text":"Name class iox::cxx::list C++11 compatible bi-directional list implementation.","title":"Classes"},{"location":"API-reference/hoofs/Files/list_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_LIST_HPP #define IOX_HOOFS_CXX_LIST_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include <cstdint> #include <iostream> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class list { private : // forward declarations, private struct ListLink ; template < bool > class IteratorBase ; public : using iterator = IteratorBase < false > ; using const_iterator = IteratorBase < true > ; using value_type = T ; using size_type = decltype ( Capacity ); list () noexcept ; ~ list () noexcept ; list ( const list & rhs ) noexcept ; list ( list && rhs ) noexcept ; list & operator = ( const list & rhs ) noexcept ; list & operator = ( list && rhs ) noexcept ; iterator begin () noexcept ; const_iterator begin () const noexcept ; const_iterator cbegin () const noexcept ; iterator end () noexcept ; const_iterator end () const noexcept ; const_iterator cend () const noexcept ; bool empty () const noexcept ; bool full () const noexcept ; size_type size () const noexcept ; size_type capacity () const noexcept ; size_type max_size () const noexcept ; T & front () noexcept ; const T & front () const noexcept ; T & back () noexcept ; const T & back () const noexcept ; bool push_front ( const T & data ) noexcept ; bool push_front ( T && data ) noexcept ; bool push_back ( const T & data ) noexcept ; bool push_back ( T && data ) noexcept ; bool pop_front () noexcept ; bool pop_back () noexcept ; void clear () noexcept ; iterator erase ( const_iterator iter ) noexcept ; size_type remove ( const T & data ) noexcept ; template < typename UnaryPredicate > size_type remove_if ( UnaryPredicate pred ) noexcept ; template < typename ... ConstructorArgs > T & emplace_front ( ConstructorArgs && ... args ) noexcept ; template < typename ... ConstructorArgs > T & emplace_back ( ConstructorArgs && ... args ) noexcept ; template < typename ... ConstructorArgs > iterator emplace ( const_iterator iter , ConstructorArgs && ... args ) noexcept ; iterator insert ( const_iterator citer , const T & data ) noexcept ; iterator insert ( const_iterator citer , T && data ) noexcept ; private : template < bool IsConstIterator = true > class IteratorBase { public : // provide the following public types for a std::iterator compatible iterator_category interface using iterator_category = std :: bidirectional_iterator_tag ; using value_type = typename std :: conditional < IsConstIterator , const T , T >:: type ; using difference_type = void ; using pointer = typename std :: conditional < IsConstIterator , const T * , T *>:: type ; using reference = typename std :: conditional < IsConstIterator , const T & , T &>:: type ; IteratorBase ( const IteratorBase < false >& iter ) noexcept ; IteratorBase & operator = ( const IteratorBase < false >& rhs ) noexcept ; IteratorBase & operator ++ () noexcept ; IteratorBase & operator -- () noexcept ; template < bool IsConstIteratorOther > bool operator == ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; template < bool IsConstIteratorOther > bool operator != ( const IteratorBase < IsConstIteratorOther >& rhs ) const noexcept ; reference operator * () const noexcept ; pointer operator -> () const noexcept ; private : using parentListPointer = typename std :: conditional < IsConstIterator , const list < T , Capacity >* , list < T , Capacity >*>:: type ; explicit IteratorBase ( parentListPointer parent , size_type idx ) noexcept ; // Make IteratorBase<true> a friend class of IteratorBase<false> so the copy constructor can access the // private member variables. friend class IteratorBase < true > ; friend class list < T , Capacity > ; parentListPointer m_list ; size_type m_iterListNodeIdx ; }; struct NodeLink { size_type nextIdx ; size_type prevIdx ; }; void init () noexcept ; T * getDataPtrFromIdx ( const size_type idx ) noexcept ; const T * getDataPtrFromIdx ( const size_type idx ) const noexcept ; bool isValidElementIdx ( const size_type idx ) const noexcept ; bool isInvalidIterator ( const const_iterator & iter ) const noexcept ; bool isInvalidIterOrDifferentLists ( const const_iterator & iter ) const noexcept ; size_type & getPrevIdx ( const size_type idx ) noexcept ; size_type & getNextIdx ( const size_type idx ) noexcept ; size_type & getPrevIdx ( const const_iterator & iter ) noexcept ; size_type & getNextIdx ( const const_iterator & iter ) noexcept ; const size_type & getPrevIdx ( const size_type idx ) const noexcept ; const size_type & getNextIdx ( const size_type idx ) const noexcept ; const size_type & getPrevIdx ( const const_iterator & iter ) const noexcept ; const size_type & getNextIdx ( const const_iterator & iter ) const noexcept ; void setPrevIdx ( const size_type idx , const size_type prevIdx ) noexcept ; void setNextIdx ( const size_type idx , const size_type nextIdx ) noexcept ; static void errorMessage ( const char * source , const char * msg ) noexcept ; //*************************************** // members //*************************************** static constexpr size_type BEGIN_END_LINK_INDEX { size_type ( Capacity )}; static constexpr size_type NODE_LINK_COUNT { size_type ( Capacity ) + 1U }; static constexpr size_type INVALID_INDEX { NODE_LINK_COUNT }; // unused/free elements are stored in an internal list (freeList), this freeList is accessed via the // member variable m_freeListHeadIdx; user insert- and erase- operations move elements between the freeList and // active list size_type m_freeListHeadIdx { 0U }; // m_links array is one element bigger than request element count. In this additional element links are stored // to the beginning and end of the list. This additional element (index position 'capacity' aka // BEGIN_END_LINK_INDEX) 'previous' will point to the last valid element (end()) and 'next' will point to the // first used list element (begin()) NodeLink m_links [ NODE_LINK_COUNT ]; using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; size_type m_size { 0U }; }; // list } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/list.inl\" #endif // IOX_HOOFS_CXX_LIST_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/","text":"iceoryx_hoofs/concurrent/lockfree_queue.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::concurrent Classes \ud83d\udd17 Name class iox::concurrent::LockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP #define IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/buffer.hpp\" #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/index_queue.hpp\" #include <atomic> namespace iox { namespace concurrent { template < typename ElementType , uint64_t Capacity > class LockFreeQueue { public : using element_t = ElementType ; LockFreeQueue () noexcept ; ~ LockFreeQueue () noexcept = default ; // remark: a thread-safe and lockfree implementation of copy seems impossible // but unsafe copying (i.e. where synchronization is up to the user) would be possible // can be implemented when it is needed LockFreeQueue ( const LockFreeQueue & ) = delete ; LockFreeQueue ( LockFreeQueue && ) = delete ; LockFreeQueue & operator = ( const LockFreeQueue & ) = delete ; LockFreeQueue & operator = ( LockFreeQueue && ) = delete ; constexpr uint64_t capacity () const noexcept ; bool tryPush ( ElementType && value ) noexcept ; bool tryPush ( const ElementType & value ) noexcept ; iox :: cxx :: optional < ElementType > push ( const ElementType & value ) noexcept ; iox :: cxx :: optional < ElementType > push ( ElementType && value ) noexcept ; iox :: cxx :: optional < ElementType > pop () noexcept ; bool empty () const noexcept ; uint64_t size () const noexcept ; protected : using Queue = IndexQueue < Capacity > ; using BufferIndex = typename Queue :: value_t ; // remark: actually m_freeIndices do not have to be in a queue, it could be another // multi-push multi-pop capable lockfree container (e.g. a stack or a list) Queue m_freeIndices ; // required to be a queue for LockFreeQueue to exhibit FIFO behaviour Queue m_usedIndices ; Buffer < ElementType , Capacity , BufferIndex > m_buffer ; std :: atomic < uint64_t > m_size { 0u }; // template is needed to distinguish between lvalue and rvalue T references // (universal reference type deduction) template < typename T > void writeBufferAt ( const BufferIndex & , T && ) noexcept ; // needed to avoid code duplication (via universal reference type deduction) template < typename T > iox :: cxx :: optional < ElementType > pushImpl ( T && value ) noexcept ; cxx :: optional < ElementType > readBufferAt ( const BufferIndex & ) noexcept ; }; } // namespace concurrent } // namespace iox #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/lockfree_queue.inl\" #endif // IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/concurrent/lockfree_queue.hpp"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#iceoryx_hoofsconcurrentlockfree_queuehpp","text":"","title":"iceoryx_hoofs/concurrent/lockfree_queue.hpp"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::concurrent","title":"Namespaces"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#classes","text":"Name class iox::concurrent::LockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity","title":"Classes"},{"location":"API-reference/hoofs/Files/lockfree__queue_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP #define IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/buffer.hpp\" #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/index_queue.hpp\" #include <atomic> namespace iox { namespace concurrent { template < typename ElementType , uint64_t Capacity > class LockFreeQueue { public : using element_t = ElementType ; LockFreeQueue () noexcept ; ~ LockFreeQueue () noexcept = default ; // remark: a thread-safe and lockfree implementation of copy seems impossible // but unsafe copying (i.e. where synchronization is up to the user) would be possible // can be implemented when it is needed LockFreeQueue ( const LockFreeQueue & ) = delete ; LockFreeQueue ( LockFreeQueue && ) = delete ; LockFreeQueue & operator = ( const LockFreeQueue & ) = delete ; LockFreeQueue & operator = ( LockFreeQueue && ) = delete ; constexpr uint64_t capacity () const noexcept ; bool tryPush ( ElementType && value ) noexcept ; bool tryPush ( const ElementType & value ) noexcept ; iox :: cxx :: optional < ElementType > push ( const ElementType & value ) noexcept ; iox :: cxx :: optional < ElementType > push ( ElementType && value ) noexcept ; iox :: cxx :: optional < ElementType > pop () noexcept ; bool empty () const noexcept ; uint64_t size () const noexcept ; protected : using Queue = IndexQueue < Capacity > ; using BufferIndex = typename Queue :: value_t ; // remark: actually m_freeIndices do not have to be in a queue, it could be another // multi-push multi-pop capable lockfree container (e.g. a stack or a list) Queue m_freeIndices ; // required to be a queue for LockFreeQueue to exhibit FIFO behaviour Queue m_usedIndices ; Buffer < ElementType , Capacity , BufferIndex > m_buffer ; std :: atomic < uint64_t > m_size { 0u }; // template is needed to distinguish between lvalue and rvalue T references // (universal reference type deduction) template < typename T > void writeBufferAt ( const BufferIndex & , T && ) noexcept ; // needed to avoid code duplication (via universal reference type deduction) template < typename T > iox :: cxx :: optional < ElementType > pushImpl ( T && value ) noexcept ; cxx :: optional < ElementType > readBufferAt ( const BufferIndex & ) noexcept ; }; } // namespace concurrent } // namespace iox #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/lockfree_queue.inl\" #endif // IOX_HOOFS_CONCURRENT_LOCKFREE_QUEUE_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/","text":"iceoryx_hoofs/log/logcommon.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::log Classes \ud83d\udd17 Name struct iox::log::LogEntry Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGCOMMON_HPP #define IOX_HOOFS_LOG_LOGCOMMON_HPP #include <chrono> #include <string> namespace iox { namespace log { enum class LogLevel : uint8_t { kOff = 0 , kFatal , kError , kWarn , kInfo , kDebug , kVerbose }; enum class LogMode : uint8_t { kRemote = 0x01 , kFile = 0x02 , kConsole = 0x04 }; constexpr const char * LogLevelColor [] = { \"\" , // nothing \" \\033 [0;1;97;41m\" , // bold bright white on red \" \\033 [0;1;31;103m\" , // bold red on light yellow \" \\033 [0;1;93m\" , // bold bright yellow \" \\033 [0;1;92m\" , // bold bright green \" \\033 [0;1;96m\" , // bold bright cyan \" \\033 [0;1;36m\" , // bold cyan }; constexpr const char * LogLevelText [] = { \"[ Off ]\" , // nothing \"[ Fatal ]\" , // bold bright white on red \"[ Error ]\" , // bold red on light yellow \"[Warning]\" , // bold bright yellow \"[ Info ]\" , // bold bright green \"[ Debug ]\" , // bold bright cyan \"[Verbose]\" , // bold cyan }; LogMode operator | ( LogMode lhs , LogMode rhs ) noexcept ; LogMode & operator |= ( LogMode & lhs , LogMode rhs ) noexcept ; LogMode operator & ( LogMode lhs , LogMode rhs ) noexcept ; LogMode & operator &= ( LogMode & lhs , LogMode rhs ) noexcept ; struct LogEntry { LogLevel level { LogLevel :: kVerbose }; std :: chrono :: milliseconds time { 0 }; std :: string message ; }; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGCOMMON_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/log/logcommon.hpp"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#iceoryx_hoofsloglogcommonhpp","text":"","title":"iceoryx_hoofs/log/logcommon.hpp"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#classes","text":"Name struct iox::log::LogEntry","title":"Classes"},{"location":"API-reference/hoofs/Files/logcommon_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGCOMMON_HPP #define IOX_HOOFS_LOG_LOGCOMMON_HPP #include <chrono> #include <string> namespace iox { namespace log { enum class LogLevel : uint8_t { kOff = 0 , kFatal , kError , kWarn , kInfo , kDebug , kVerbose }; enum class LogMode : uint8_t { kRemote = 0x01 , kFile = 0x02 , kConsole = 0x04 }; constexpr const char * LogLevelColor [] = { \"\" , // nothing \" \\033 [0;1;97;41m\" , // bold bright white on red \" \\033 [0;1;31;103m\" , // bold red on light yellow \" \\033 [0;1;93m\" , // bold bright yellow \" \\033 [0;1;92m\" , // bold bright green \" \\033 [0;1;96m\" , // bold bright cyan \" \\033 [0;1;36m\" , // bold cyan }; constexpr const char * LogLevelText [] = { \"[ Off ]\" , // nothing \"[ Fatal ]\" , // bold bright white on red \"[ Error ]\" , // bold red on light yellow \"[Warning]\" , // bold bright yellow \"[ Info ]\" , // bold bright green \"[ Debug ]\" , // bold bright cyan \"[Verbose]\" , // bold cyan }; LogMode operator | ( LogMode lhs , LogMode rhs ) noexcept ; LogMode & operator |= ( LogMode & lhs , LogMode rhs ) noexcept ; LogMode operator & ( LogMode lhs , LogMode rhs ) noexcept ; LogMode & operator &= ( LogMode & lhs , LogMode rhs ) noexcept ; struct LogEntry { LogLevel level { LogLevel :: kVerbose }; std :: chrono :: milliseconds time { 0 }; std :: string message ; }; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGCOMMON_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/logger_8hpp/","text":"iceoryx_hoofs/log/logger.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::log Classes \ud83d\udd17 Name class iox::log::Logger Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGGER_HPP #define IOX_HOOFS_LOG_LOGGER_HPP #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include <atomic> #include <chrono> #include <functional> #include <string> namespace iox { namespace log { class Logger { friend class LogManager ; friend class LogStream ; public : Logger ( Logger && other ) noexcept ; Logger & operator = ( Logger && rhs ) noexcept ; Logger ( const Logger & other ) = delete ; Logger & operator = ( const Logger & rhs ) = delete ; // NOLINTNEXTLINE(readability-identifier-naming) LogLevel GetLogLevel () const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetLogLevel ( const LogLevel logLevel ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) cxx :: GenericRAII SetLogLevelForScope ( const LogLevel logLevel ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetLogMode ( const LogMode logMode ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) bool IsEnabled ( const LogLevel logLevel ) const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogFatal () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogError () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogWarn () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogInfo () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogDebug () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogVerbose () noexcept ; protected : Logger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appLogLevel ) noexcept ; // virtual because of Logger_Mock // NOLINTNEXTLINE(readability-identifier-naming) virtual void Log ( const LogEntry & entry ) const noexcept ; private : // NOLINTNEXTLINE(readability-identifier-naming) static void Print ( const LogEntry & entry ) noexcept ; std :: atomic < LogLevel > m_logLevel { LogLevel :: kVerbose }; std :: atomic < LogLevel > m_logLevelPredecessor { LogLevel :: kVerbose }; std :: atomic < LogMode > m_logMode { LogMode :: kConsole }; }; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/log/logger.hpp"},{"location":"API-reference/hoofs/Files/logger_8hpp/#iceoryx_hoofslogloggerhpp","text":"","title":"iceoryx_hoofs/log/logger.hpp"},{"location":"API-reference/hoofs/Files/logger_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logger_8hpp/#classes","text":"Name class iox::log::Logger","title":"Classes"},{"location":"API-reference/hoofs/Files/logger_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGGER_HPP #define IOX_HOOFS_LOG_LOGGER_HPP #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include <atomic> #include <chrono> #include <functional> #include <string> namespace iox { namespace log { class Logger { friend class LogManager ; friend class LogStream ; public : Logger ( Logger && other ) noexcept ; Logger & operator = ( Logger && rhs ) noexcept ; Logger ( const Logger & other ) = delete ; Logger & operator = ( const Logger & rhs ) = delete ; // NOLINTNEXTLINE(readability-identifier-naming) LogLevel GetLogLevel () const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetLogLevel ( const LogLevel logLevel ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) cxx :: GenericRAII SetLogLevelForScope ( const LogLevel logLevel ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetLogMode ( const LogMode logMode ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) bool IsEnabled ( const LogLevel logLevel ) const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogFatal () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogError () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogWarn () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogInfo () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogDebug () noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogStream LogVerbose () noexcept ; protected : Logger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appLogLevel ) noexcept ; // virtual because of Logger_Mock // NOLINTNEXTLINE(readability-identifier-naming) virtual void Log ( const LogEntry & entry ) const noexcept ; private : // NOLINTNEXTLINE(readability-identifier-naming) static void Print ( const LogEntry & entry ) noexcept ; std :: atomic < LogLevel > m_logLevel { LogLevel :: kVerbose }; std :: atomic < LogLevel > m_logLevelPredecessor { LogLevel :: kVerbose }; std :: atomic < LogMode > m_logMode { LogMode :: kConsole }; }; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/logging_8hpp/","text":"iceoryx_hoofs/log/logging.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::log Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGGING_HPP #define IOX_HOOFS_LOG_LOGGING_HPP #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/log/logger.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include <chrono> #include <string> namespace iox { namespace log { Logger & createLogger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel = LogLevel :: kWarn ) noexcept ; inline constexpr LogHex8 HexFormat ( uint8_t value ) noexcept { return LogHex8 ( value ); } inline constexpr LogHex8 HexFormat ( int8_t value ) noexcept { return LogHex8 ( static_cast < uint8_t > ( value )); } inline constexpr LogHex16 HexFormat ( uint16_t value ) noexcept { return LogHex16 ( value ); } inline constexpr LogHex16 HexFormat ( int16_t value ) noexcept { return LogHex16 ( static_cast < uint16_t > ( value )); } inline constexpr LogHex32 HexFormat ( uint32_t value ) noexcept { return LogHex32 ( value ); } inline constexpr LogHex32 HexFormat ( int32_t value ) noexcept { return LogHex32 ( static_cast < uint32_t > ( value )); } inline constexpr LogHex64 HexFormat ( uint64_t value ) noexcept { return LogHex64 ( value ); } inline constexpr LogHex64 HexFormat ( int64_t value ) noexcept { return LogHex64 ( static_cast < uint64_t > ( value )); } inline constexpr LogBin8 BinFormat ( uint8_t value ) noexcept { return LogBin8 ( value ); } inline constexpr LogBin8 BinFormat ( int8_t value ) noexcept { return LogBin8 ( static_cast < uint8_t > ( value )); } inline constexpr LogBin16 BinFormat ( uint16_t value ) noexcept { return LogBin16 ( value ); } inline constexpr LogBin16 BinFormat ( int16_t value ) noexcept { return LogBin16 ( static_cast < uint16_t > ( value )); } inline constexpr LogBin32 BinFormat ( uint32_t value ) noexcept { return LogBin32 ( value ); } inline constexpr LogBin32 BinFormat ( int32_t value ) noexcept { return LogBin32 ( static_cast < uint32_t > ( value )); } inline constexpr LogBin64 BinFormat ( uint64_t value ) noexcept { return LogBin64 ( value ); } inline constexpr LogBin64 BinFormat ( int64_t value ) noexcept { return LogBin64 ( static_cast < uint64_t > ( value )); } template < typename T , typename std :: enable_if <! std :: is_pointer < T >:: value , std :: nullptr_t >:: type = nullptr > inline constexpr LogRawBuffer RawBuffer ( const T & value ) noexcept { // LogRawBuffer is used with the streaming operator which converts the data into a string, // therefore we shouldn't get lifetime issues return LogRawBuffer { reinterpret_cast < const uint8_t *> ( & value ), sizeof ( T )}; } } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGGING_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/log/logging.hpp"},{"location":"API-reference/hoofs/Files/logging_8hpp/#iceoryx_hoofsloglogginghpp","text":"","title":"iceoryx_hoofs/log/logging.hpp"},{"location":"API-reference/hoofs/Files/logging_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logging_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGGING_HPP #define IOX_HOOFS_LOG_LOGGING_HPP #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/log/logger.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include <chrono> #include <string> namespace iox { namespace log { Logger & createLogger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel = LogLevel :: kWarn ) noexcept ; inline constexpr LogHex8 HexFormat ( uint8_t value ) noexcept { return LogHex8 ( value ); } inline constexpr LogHex8 HexFormat ( int8_t value ) noexcept { return LogHex8 ( static_cast < uint8_t > ( value )); } inline constexpr LogHex16 HexFormat ( uint16_t value ) noexcept { return LogHex16 ( value ); } inline constexpr LogHex16 HexFormat ( int16_t value ) noexcept { return LogHex16 ( static_cast < uint16_t > ( value )); } inline constexpr LogHex32 HexFormat ( uint32_t value ) noexcept { return LogHex32 ( value ); } inline constexpr LogHex32 HexFormat ( int32_t value ) noexcept { return LogHex32 ( static_cast < uint32_t > ( value )); } inline constexpr LogHex64 HexFormat ( uint64_t value ) noexcept { return LogHex64 ( value ); } inline constexpr LogHex64 HexFormat ( int64_t value ) noexcept { return LogHex64 ( static_cast < uint64_t > ( value )); } inline constexpr LogBin8 BinFormat ( uint8_t value ) noexcept { return LogBin8 ( value ); } inline constexpr LogBin8 BinFormat ( int8_t value ) noexcept { return LogBin8 ( static_cast < uint8_t > ( value )); } inline constexpr LogBin16 BinFormat ( uint16_t value ) noexcept { return LogBin16 ( value ); } inline constexpr LogBin16 BinFormat ( int16_t value ) noexcept { return LogBin16 ( static_cast < uint16_t > ( value )); } inline constexpr LogBin32 BinFormat ( uint32_t value ) noexcept { return LogBin32 ( value ); } inline constexpr LogBin32 BinFormat ( int32_t value ) noexcept { return LogBin32 ( static_cast < uint32_t > ( value )); } inline constexpr LogBin64 BinFormat ( uint64_t value ) noexcept { return LogBin64 ( value ); } inline constexpr LogBin64 BinFormat ( int64_t value ) noexcept { return LogBin64 ( static_cast < uint64_t > ( value )); } template < typename T , typename std :: enable_if <! std :: is_pointer < T >:: value , std :: nullptr_t >:: type = nullptr > inline constexpr LogRawBuffer RawBuffer ( const T & value ) noexcept { // LogRawBuffer is used with the streaming operator which converts the data into a string, // therefore we shouldn't get lifetime issues return LogRawBuffer { reinterpret_cast < const uint8_t *> ( & value ), sizeof ( T )}; } } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGGING_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/","text":"iceoryx_hoofs/log/logging_free_function_building_block.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::log iox::log::ffbb Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP #define IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP #include \"iceoryx_hoofs/log/logger.hpp\" #include \"iceoryx_hoofs/log/logging.hpp\" #include \"iceoryx_hoofs/log/logmanager.hpp\" namespace iox { namespace log { namespace ffbb { template < typename T > static Logger & ComponentLogger () noexcept { static auto & logger = createLogger ( T :: Ctx , T :: Description , LogManager :: GetLogManager (). DefaultLogLevel ()); return logger ; } template < typename T > inline LogStream LogFatal () noexcept { return ComponentLogger < T > (). LogFatal (); } template < typename T > inline LogStream LogError () noexcept { return ComponentLogger < T > (). LogError (); } template < typename T > inline LogStream LogWarn () noexcept { return ComponentLogger < T > (). LogWarn (); } template < typename T > inline LogStream LogInfo () noexcept { return ComponentLogger < T > (). LogInfo (); } template < typename T > inline LogStream LogDebug () noexcept { return ComponentLogger < T > (). LogDebug (); } template < typename T > inline LogStream LogVerbose () noexcept { return ComponentLogger < T > (). LogVerbose (); } } // namespace ffbb } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/log/logging_free_function_building_block.hpp"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/#iceoryx_hoofsloglogging_free_function_building_blockhpp","text":"","title":"iceoryx_hoofs/log/logging_free_function_building_block.hpp"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::log iox::log::ffbb","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logging__free__function__building__block_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP #define IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP #include \"iceoryx_hoofs/log/logger.hpp\" #include \"iceoryx_hoofs/log/logging.hpp\" #include \"iceoryx_hoofs/log/logmanager.hpp\" namespace iox { namespace log { namespace ffbb { template < typename T > static Logger & ComponentLogger () noexcept { static auto & logger = createLogger ( T :: Ctx , T :: Description , LogManager :: GetLogManager (). DefaultLogLevel ()); return logger ; } template < typename T > inline LogStream LogFatal () noexcept { return ComponentLogger < T > (). LogFatal (); } template < typename T > inline LogStream LogError () noexcept { return ComponentLogger < T > (). LogError (); } template < typename T > inline LogStream LogWarn () noexcept { return ComponentLogger < T > (). LogWarn (); } template < typename T > inline LogStream LogInfo () noexcept { return ComponentLogger < T > (). LogInfo (); } template < typename T > inline LogStream LogDebug () noexcept { return ComponentLogger < T > (). LogDebug (); } template < typename T > inline LogStream LogVerbose () noexcept { return ComponentLogger < T > (). LogVerbose (); } } // namespace ffbb } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGGING_FREE_FUNCTION_BUILDING_BLOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/","text":"iceoryx_hoofs/log/logmanager.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::log Classes \ud83d\udd17 Name class iox::log::LogManager Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGMANAGER_HPP #define IOX_HOOFS_LOG_LOGMANAGER_HPP #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/log/logger.hpp\" #include <atomic> #include <map> #include <string> namespace iox { namespace log { enum class LogLevelOutput : uint8_t { kDisplayLogLevel = 0 , kHideLogLevel }; class LogManager { public : // NOLINTNEXTLINE(readability-identifier-naming) static LogManager & GetLogManager () noexcept ; static Logger & // NOLINTNEXTLINE(readability-identifier-naming) CreateLogContext ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel ) noexcept ; ~ LogManager () noexcept = default ; LogManager ( const LogManager & ) = delete ; LogManager ( LogManager && ) = delete ; LogManager & operator = ( const LogManager & ) = delete ; LogManager & operator = ( LogManager && ) = delete ; // NOLINTNEXTLINE(readability-identifier-naming) LogLevel DefaultLogLevel () const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetDefaultLogLevel ( const LogLevel logLevel , const LogLevelOutput logLevelOutput = LogLevelOutput :: kDisplayLogLevel ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogMode DefaultLogMode () const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetDefaultLogMode ( const LogMode logMode ) noexcept ; protected : LogManager () noexcept = default ; private : std :: atomic < LogLevel > m_defaultLogLevel { LogLevel :: kVerbose }; std :: atomic < LogMode > m_defaultLogMode { LogMode :: kConsole }; std :: map < std :: string , Logger > m_loggers ; }; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGMANAGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/log/logmanager.hpp"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#iceoryx_hoofsloglogmanagerhpp","text":"","title":"iceoryx_hoofs/log/logmanager.hpp"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#classes","text":"Name class iox::log::LogManager","title":"Classes"},{"location":"API-reference/hoofs/Files/logmanager_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGMANAGER_HPP #define IOX_HOOFS_LOG_LOGMANAGER_HPP #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/log/logger.hpp\" #include <atomic> #include <map> #include <string> namespace iox { namespace log { enum class LogLevelOutput : uint8_t { kDisplayLogLevel = 0 , kHideLogLevel }; class LogManager { public : // NOLINTNEXTLINE(readability-identifier-naming) static LogManager & GetLogManager () noexcept ; static Logger & // NOLINTNEXTLINE(readability-identifier-naming) CreateLogContext ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel ) noexcept ; ~ LogManager () noexcept = default ; LogManager ( const LogManager & ) = delete ; LogManager ( LogManager && ) = delete ; LogManager & operator = ( const LogManager & ) = delete ; LogManager & operator = ( LogManager && ) = delete ; // NOLINTNEXTLINE(readability-identifier-naming) LogLevel DefaultLogLevel () const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetDefaultLogLevel ( const LogLevel logLevel , const LogLevelOutput logLevelOutput = LogLevelOutput :: kDisplayLogLevel ) noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) LogMode DefaultLogMode () const noexcept ; // NOLINTNEXTLINE(readability-identifier-naming) void SetDefaultLogMode ( const LogMode logMode ) noexcept ; protected : LogManager () noexcept = default ; private : std :: atomic < LogLevel > m_defaultLogLevel { LogLevel :: kVerbose }; std :: atomic < LogMode > m_defaultLogMode { LogMode :: kConsole }; std :: map < std :: string , Logger > m_loggers ; }; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGMANAGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/logstream_8hpp/","text":"iceoryx_hoofs/log/logstream.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::log Classes \ud83d\udd17 Name struct iox::log::LogHex struct iox::log::LogHex8 struct iox::log::LogHex16 struct iox::log::LogHex32 struct iox::log::LogHex64 struct iox::log::LogBin struct iox::log::LogBin8 struct iox::log::LogBin16 struct iox::log::LogBin32 struct iox::log::LogBin64 struct iox::log::LogRawBuffer class iox::log::LogStream Source code \ud83d\udd17 // Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGSTREAM_HPP #define IOX_HOOFS_LOG_LOGSTREAM_HPP #include \"iceoryx_hoofs/cxx/convert.hpp\" #include \"iceoryx_hoofs/log/logcommon.hpp\" #include <bitset> #include <chrono> #include <iostream> #include <sstream> #include <string> namespace iox { namespace log { // helper struct for SFINAE of LogStream& operator<< struct LogHex { }; struct LogHex8 : private LogHex { uint8_t value ; constexpr LogHex8 ( uint8_t value ) noexcept : value ( value ) { } }; struct LogHex16 : private LogHex { uint16_t value ; constexpr LogHex16 ( uint16_t value ) noexcept : value ( value ) { } }; struct LogHex32 : private LogHex { uint32_t value ; constexpr LogHex32 ( uint32_t value ) noexcept : value ( value ) { } }; struct LogHex64 : private LogHex { uint64_t value ; constexpr LogHex64 ( uint64_t value ) noexcept : value ( value ) { } }; // helper struct for SFINAE of LogStream& operator<< struct LogBin { }; struct LogBin8 : private LogBin { uint8_t value ; constexpr LogBin8 ( uint8_t value ) noexcept : value ( value ) { } }; struct LogBin16 : private LogBin { uint16_t value ; constexpr LogBin16 ( uint16_t value ) noexcept : value ( value ) { } }; struct LogBin32 : private LogBin { uint32_t value ; constexpr LogBin32 ( uint32_t value ) noexcept : value ( value ) { } }; struct LogBin64 : private LogBin { uint64_t value ; constexpr LogBin64 ( uint64_t value ) noexcept : value ( value ) { } }; struct LogRawBuffer { const uint8_t * data ; uint8_t size ; }; class Logger ; class LogStream { public : LogStream ( Logger & logger , LogLevel logLevel = LogLevel :: kWarn ) noexcept ; virtual ~ LogStream () noexcept ; void Flush () noexcept ; LogStream & operator << ( const char * cstr ) noexcept ; LogStream & operator << ( const std :: string & str ) noexcept ; template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > LogStream & operator << ( const T val ) noexcept { m_logEntry . message . append ( cxx :: convert :: toString ( val )); m_flushed = false ; return * this ; } template < typename T , typename std :: enable_if < std :: is_base_of < LogHex , T >:: value , int >:: type = 0 > LogStream & operator << ( const T val ) noexcept { std :: stringstream ss ; // the '+val' is there to not interpret the uint8_t as char and print the character instead of the hex value ss << \"0x\" << std :: hex << + val . value ; m_logEntry . message . append ( ss . str ()); m_flushed = false ; return * this ; } template < typename T , typename std :: enable_if < std :: is_base_of < LogBin , T >:: value , int >:: type = 0 > LogStream & operator << ( const T val ) noexcept { m_logEntry . message . append ( \"0b\" ); m_logEntry . message . append ( std :: bitset < std :: numeric_limits < decltype ( val . value ) >:: digits > ( val . value ). to_string ()); m_flushed = false ; return * this ; } LogStream & operator << ( const LogRawBuffer & value ) noexcept ; private : Logger & m_logger ; bool m_flushed { false }; LogEntry m_logEntry ; }; LogStream & operator << ( LogStream & out , LogLevel value ) noexcept ; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGSTREAM_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/log/logstream.hpp"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#iceoryx_hoofsloglogstreamhpp","text":"","title":"iceoryx_hoofs/log/logstream.hpp"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::log","title":"Namespaces"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#classes","text":"Name struct iox::log::LogHex struct iox::log::LogHex8 struct iox::log::LogHex16 struct iox::log::LogHex32 struct iox::log::LogHex64 struct iox::log::LogBin struct iox::log::LogBin8 struct iox::log::LogBin16 struct iox::log::LogBin32 struct iox::log::LogBin64 struct iox::log::LogRawBuffer class iox::log::LogStream","title":"Classes"},{"location":"API-reference/hoofs/Files/logstream_8hpp/#source-code","text":"// Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_LOG_LOGSTREAM_HPP #define IOX_HOOFS_LOG_LOGSTREAM_HPP #include \"iceoryx_hoofs/cxx/convert.hpp\" #include \"iceoryx_hoofs/log/logcommon.hpp\" #include <bitset> #include <chrono> #include <iostream> #include <sstream> #include <string> namespace iox { namespace log { // helper struct for SFINAE of LogStream& operator<< struct LogHex { }; struct LogHex8 : private LogHex { uint8_t value ; constexpr LogHex8 ( uint8_t value ) noexcept : value ( value ) { } }; struct LogHex16 : private LogHex { uint16_t value ; constexpr LogHex16 ( uint16_t value ) noexcept : value ( value ) { } }; struct LogHex32 : private LogHex { uint32_t value ; constexpr LogHex32 ( uint32_t value ) noexcept : value ( value ) { } }; struct LogHex64 : private LogHex { uint64_t value ; constexpr LogHex64 ( uint64_t value ) noexcept : value ( value ) { } }; // helper struct for SFINAE of LogStream& operator<< struct LogBin { }; struct LogBin8 : private LogBin { uint8_t value ; constexpr LogBin8 ( uint8_t value ) noexcept : value ( value ) { } }; struct LogBin16 : private LogBin { uint16_t value ; constexpr LogBin16 ( uint16_t value ) noexcept : value ( value ) { } }; struct LogBin32 : private LogBin { uint32_t value ; constexpr LogBin32 ( uint32_t value ) noexcept : value ( value ) { } }; struct LogBin64 : private LogBin { uint64_t value ; constexpr LogBin64 ( uint64_t value ) noexcept : value ( value ) { } }; struct LogRawBuffer { const uint8_t * data ; uint8_t size ; }; class Logger ; class LogStream { public : LogStream ( Logger & logger , LogLevel logLevel = LogLevel :: kWarn ) noexcept ; virtual ~ LogStream () noexcept ; void Flush () noexcept ; LogStream & operator << ( const char * cstr ) noexcept ; LogStream & operator << ( const std :: string & str ) noexcept ; template < typename T , typename std :: enable_if < std :: is_arithmetic < T >:: value , int >:: type = 0 > LogStream & operator << ( const T val ) noexcept { m_logEntry . message . append ( cxx :: convert :: toString ( val )); m_flushed = false ; return * this ; } template < typename T , typename std :: enable_if < std :: is_base_of < LogHex , T >:: value , int >:: type = 0 > LogStream & operator << ( const T val ) noexcept { std :: stringstream ss ; // the '+val' is there to not interpret the uint8_t as char and print the character instead of the hex value ss << \"0x\" << std :: hex << + val . value ; m_logEntry . message . append ( ss . str ()); m_flushed = false ; return * this ; } template < typename T , typename std :: enable_if < std :: is_base_of < LogBin , T >:: value , int >:: type = 0 > LogStream & operator << ( const T val ) noexcept { m_logEntry . message . append ( \"0b\" ); m_logEntry . message . append ( std :: bitset < std :: numeric_limits < decltype ( val . value ) >:: digits > ( val . value ). to_string ()); m_flushed = false ; return * this ; } LogStream & operator << ( const LogRawBuffer & value ) noexcept ; private : Logger & m_logger ; bool m_flushed { false }; LogEntry m_logEntry ; }; LogStream & operator << ( LogStream & out , LogLevel value ) noexcept ; } // namespace log } // namespace iox #endif // IOX_HOOFS_LOG_LOGSTREAM_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/","text":"iceoryx_hoofs/cxx/method_callback.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal Classes \ud83d\udd17 Name class iox::cxx::ConstMethodCallback class iox::cxx::MethodCallback Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_METHOD_CALLBACK_HPP #define IOX_HOOFS_CXX_METHOD_CALLBACK_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" namespace iox { namespace cxx { namespace internal { class GenericClass { }; } // namespace internal enum class MethodCallbackError { UNINITIALIZED_CALLBACK }; template < typename ReturnValue , typename ... Args > class ConstMethodCallback { public : template < typename T > using ConstMethodPointer = ReturnValue ( T ::* )( Args ...) const ; ConstMethodCallback () noexcept = default ; ConstMethodCallback ( const ConstMethodCallback & rhs ) noexcept = default ; ConstMethodCallback & operator = ( const ConstMethodCallback & rhs ) noexcept = default ; ~ ConstMethodCallback () noexcept = default ; template < typename ClassType > ConstMethodCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > const methodPtr ) noexcept ; ConstMethodCallback ( ConstMethodCallback && rhs ) noexcept ; ConstMethodCallback & operator = ( ConstMethodCallback && rhs ) noexcept ; template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) const noexcept ; bool operator == ( const ConstMethodCallback & rhs ) const noexcept ; bool operator != ( const ConstMethodCallback & rhs ) const noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; template < typename ClassType > void setCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > methodPtr ) noexcept ; template < typename ClassType > const ClassType * getObjectPointer () const noexcept ; template < typename ClassType > auto getMethodPointer () const noexcept -> ConstMethodPointer < ClassType > ; private : const void * m_objectPtr { nullptr }; ConstMethodPointer < internal :: GenericClass > m_methodPtr { nullptr }; cxx :: function_ref < ReturnValue ( const void * , ConstMethodPointer < internal :: GenericClass > , Args ...) > m_callback ; }; template < typename ReturnValue , typename ... Args > class MethodCallback { public : template < typename T > using MethodPointer = ReturnValue ( T ::* )( Args ...); MethodCallback () noexcept = default ; MethodCallback ( const MethodCallback & rhs ) noexcept = default ; MethodCallback & operator = ( const MethodCallback & rhs ) noexcept = default ; ~ MethodCallback () noexcept = default ; template < typename ClassType > MethodCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) noexcept ; MethodCallback ( MethodCallback && rhs ) noexcept ; MethodCallback & operator = ( MethodCallback && rhs ) noexcept ; template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) noexcept ; bool operator == ( const MethodCallback & rhs ) const noexcept ; bool operator != ( const MethodCallback & rhs ) const noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; template < typename ClassType > void setCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) noexcept ; template < typename ClassType > ClassType * getObjectPointer () const noexcept ; template < typename ClassType > auto getMethodPointer () const noexcept -> MethodPointer < ClassType > ; private : void * m_objectPtr { nullptr }; MethodPointer < internal :: GenericClass > m_methodPtr { nullptr }; cxx :: function_ref < ReturnValue ( void * , MethodPointer < internal :: GenericClass > , Args ...) > m_callback ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/method_callback.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/method_callback.hpp"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#iceoryx_hoofscxxmethod_callbackhpp","text":"","title":"iceoryx_hoofs/cxx/method_callback.hpp"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#classes","text":"Name class iox::cxx::ConstMethodCallback class iox::cxx::MethodCallback","title":"Classes"},{"location":"API-reference/hoofs/Files/method__callback_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_METHOD_CALLBACK_HPP #define IOX_HOOFS_CXX_METHOD_CALLBACK_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" namespace iox { namespace cxx { namespace internal { class GenericClass { }; } // namespace internal enum class MethodCallbackError { UNINITIALIZED_CALLBACK }; template < typename ReturnValue , typename ... Args > class ConstMethodCallback { public : template < typename T > using ConstMethodPointer = ReturnValue ( T ::* )( Args ...) const ; ConstMethodCallback () noexcept = default ; ConstMethodCallback ( const ConstMethodCallback & rhs ) noexcept = default ; ConstMethodCallback & operator = ( const ConstMethodCallback & rhs ) noexcept = default ; ~ ConstMethodCallback () noexcept = default ; template < typename ClassType > ConstMethodCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > const methodPtr ) noexcept ; ConstMethodCallback ( ConstMethodCallback && rhs ) noexcept ; ConstMethodCallback & operator = ( ConstMethodCallback && rhs ) noexcept ; template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) const noexcept ; bool operator == ( const ConstMethodCallback & rhs ) const noexcept ; bool operator != ( const ConstMethodCallback & rhs ) const noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; template < typename ClassType > void setCallback ( const ClassType & objectRef , ConstMethodPointer < ClassType > methodPtr ) noexcept ; template < typename ClassType > const ClassType * getObjectPointer () const noexcept ; template < typename ClassType > auto getMethodPointer () const noexcept -> ConstMethodPointer < ClassType > ; private : const void * m_objectPtr { nullptr }; ConstMethodPointer < internal :: GenericClass > m_methodPtr { nullptr }; cxx :: function_ref < ReturnValue ( const void * , ConstMethodPointer < internal :: GenericClass > , Args ...) > m_callback ; }; template < typename ReturnValue , typename ... Args > class MethodCallback { public : template < typename T > using MethodPointer = ReturnValue ( T ::* )( Args ...); MethodCallback () noexcept = default ; MethodCallback ( const MethodCallback & rhs ) noexcept = default ; MethodCallback & operator = ( const MethodCallback & rhs ) noexcept = default ; ~ MethodCallback () noexcept = default ; template < typename ClassType > MethodCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) noexcept ; MethodCallback ( MethodCallback && rhs ) noexcept ; MethodCallback & operator = ( MethodCallback && rhs ) noexcept ; template < typename ... MethodArguments > expected < ReturnValue , MethodCallbackError > operator ()( MethodArguments && ... args ) noexcept ; bool operator == ( const MethodCallback & rhs ) const noexcept ; bool operator != ( const MethodCallback & rhs ) const noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; template < typename ClassType > void setCallback ( ClassType & objectRef , MethodPointer < ClassType > methodPtr ) noexcept ; template < typename ClassType > ClassType * getObjectPointer () const noexcept ; template < typename ClassType > auto getMethodPointer () const noexcept -> MethodPointer < ClassType > ; private : void * m_objectPtr { nullptr }; MethodPointer < internal :: GenericClass > m_methodPtr { nullptr }; cxx :: function_ref < ReturnValue ( void * , MethodPointer < internal :: GenericClass > , Args ...) > m_callback ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/method_callback.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/","text":"iceoryx_hoofs/posix_wrapper/named_pipe.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Classes \ud83d\udd17 Name class iox::posix::NamedPipe Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_NAMED_PIPE_HPP #define IOX_HOOFS_POSIX_WRAPPER_NAMED_PIPE_HPP #include \"iceoryx_hoofs/concurrent/lockfree_queue.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/ipc_channel.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/shared_memory_object.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\" #include <cstdint> namespace iox { namespace posix { class NamedPipe : public DesignPattern :: Creation < NamedPipe , IpcChannelError > { public : // no system restrictions at all, except available memory. MAX_MESSAGE_SIZE and MAX_NUMBER_OF_MESSAGES can be // increased as long as there is enough memory available static constexpr uint64_t MAX_MESSAGE_SIZE = 4U * 1024U ; static constexpr uint64_t MAX_NUMBER_OF_MESSAGES = 10U ; static constexpr uint64_t NULL_TERMINATOR_SIZE = 0U ; static constexpr units :: Duration CYCLE_TIME = units :: Duration :: fromMilliseconds ( 10 ); static constexpr const char NAMED_PIPE_PREFIX [] = \"iox_np_\" ; using Message_t = cxx :: string < MAX_MESSAGE_SIZE > ; using MessageQueue_t = concurrent :: LockFreeQueue < Message_t , MAX_NUMBER_OF_MESSAGES > ; NamedPipe ( const NamedPipe & ) = delete ; NamedPipe & operator = ( const NamedPipe & ) = delete ; NamedPipe () noexcept ; NamedPipe ( NamedPipe && rhs ) noexcept ; NamedPipe & operator = ( NamedPipe && rhs ) noexcept ; ~ NamedPipe () noexcept ; cxx :: expected < IpcChannelError > destroy () noexcept ; static cxx :: expected < bool , IpcChannelError > unlinkIfExists ( const IpcChannelName_t & name ) noexcept ; cxx :: expected < bool , IpcChannelError > isOutdated () noexcept ; cxx :: expected < IpcChannelError > trySend ( const std :: string & message ) const noexcept ; cxx :: expected < IpcChannelError > send ( const std :: string & message ) const noexcept ; cxx :: expected < IpcChannelError > timedSend ( const std :: string & message , const units :: Duration & timeout ) const noexcept ; cxx :: expected < std :: string , IpcChannelError > tryReceive () const noexcept ; cxx :: expected < std :: string , IpcChannelError > receive () const noexcept ; cxx :: expected < std :: string , IpcChannelError > timedReceive ( const units :: Duration & timeout ) const noexcept ; private : friend class DesignPattern :: Creation < NamedPipe , IpcChannelError > ; NamedPipe ( const IpcChannelName_t & name , const IpcChannelSide channelSide , const size_t maxMsgSize = MAX_MESSAGE_SIZE , const uint64_t maxMsgNumber = MAX_NUMBER_OF_MESSAGES ) noexcept ; template < typename Prefix > static IpcChannelName_t convertName ( const Prefix & p , const IpcChannelName_t & name ) noexcept ; private : cxx :: optional < SharedMemoryObject > m_sharedMemory ; class NamedPipeData { public : NamedPipeData ( bool & isInitialized , IpcChannelError & error , const uint64_t maxMsgNumber ) noexcept ; NamedPipeData ( const NamedPipeData & ) = delete ; NamedPipeData ( NamedPipeData && rhs ) = delete ; ~ NamedPipeData () noexcept ; NamedPipeData & operator = ( const NamedPipeData & ) = delete ; NamedPipeData & operator = ( NamedPipeData && rhs ) = delete ; Semaphore & sendSemaphore () noexcept ; Semaphore & receiveSemaphore () noexcept ; bool waitForInitialization () const noexcept ; bool hasValidState () const noexcept ; MessageQueue_t messages ; private : static constexpr uint64_t SEND_SEMAPHORE = 0U ; static constexpr uint64_t RECEIVE_SEMAPHORE = 1U ; static constexpr uint64_t INVALID_DATA = 0xBAADF00DAFFEDEAD ; static constexpr uint64_t VALID_DATA = 0xBAD0FF1CEBEEFBEE ; static constexpr units :: Duration WAIT_FOR_INIT_TIMEOUT = units :: Duration :: fromSeconds ( 1 ); static constexpr units :: Duration WAIT_FOR_INIT_SLEEP_TIME = units :: Duration :: fromMilliseconds ( 1 ); std :: atomic < uint64_t > initializationGuard { INVALID_DATA }; using semaphoreMemory_t = uint8_t [ sizeof ( Semaphore )]; alignas ( Semaphore ) semaphoreMemory_t semaphores [ 2U ]; }; NamedPipeData * m_data = nullptr ; }; } // namespace posix } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/named_pipe.hpp"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#iceoryx_hoofsposix_wrappernamed_pipehpp","text":"","title":"iceoryx_hoofs/posix_wrapper/named_pipe.hpp"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#classes","text":"Name class iox::posix::NamedPipe","title":"Classes"},{"location":"API-reference/hoofs/Files/named__pipe_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_NAMED_PIPE_HPP #define IOX_HOOFS_POSIX_WRAPPER_NAMED_PIPE_HPP #include \"iceoryx_hoofs/concurrent/lockfree_queue.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/ipc_channel.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/shared_memory_object.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\" #include <cstdint> namespace iox { namespace posix { class NamedPipe : public DesignPattern :: Creation < NamedPipe , IpcChannelError > { public : // no system restrictions at all, except available memory. MAX_MESSAGE_SIZE and MAX_NUMBER_OF_MESSAGES can be // increased as long as there is enough memory available static constexpr uint64_t MAX_MESSAGE_SIZE = 4U * 1024U ; static constexpr uint64_t MAX_NUMBER_OF_MESSAGES = 10U ; static constexpr uint64_t NULL_TERMINATOR_SIZE = 0U ; static constexpr units :: Duration CYCLE_TIME = units :: Duration :: fromMilliseconds ( 10 ); static constexpr const char NAMED_PIPE_PREFIX [] = \"iox_np_\" ; using Message_t = cxx :: string < MAX_MESSAGE_SIZE > ; using MessageQueue_t = concurrent :: LockFreeQueue < Message_t , MAX_NUMBER_OF_MESSAGES > ; NamedPipe ( const NamedPipe & ) = delete ; NamedPipe & operator = ( const NamedPipe & ) = delete ; NamedPipe () noexcept ; NamedPipe ( NamedPipe && rhs ) noexcept ; NamedPipe & operator = ( NamedPipe && rhs ) noexcept ; ~ NamedPipe () noexcept ; cxx :: expected < IpcChannelError > destroy () noexcept ; static cxx :: expected < bool , IpcChannelError > unlinkIfExists ( const IpcChannelName_t & name ) noexcept ; cxx :: expected < bool , IpcChannelError > isOutdated () noexcept ; cxx :: expected < IpcChannelError > trySend ( const std :: string & message ) const noexcept ; cxx :: expected < IpcChannelError > send ( const std :: string & message ) const noexcept ; cxx :: expected < IpcChannelError > timedSend ( const std :: string & message , const units :: Duration & timeout ) const noexcept ; cxx :: expected < std :: string , IpcChannelError > tryReceive () const noexcept ; cxx :: expected < std :: string , IpcChannelError > receive () const noexcept ; cxx :: expected < std :: string , IpcChannelError > timedReceive ( const units :: Duration & timeout ) const noexcept ; private : friend class DesignPattern :: Creation < NamedPipe , IpcChannelError > ; NamedPipe ( const IpcChannelName_t & name , const IpcChannelSide channelSide , const size_t maxMsgSize = MAX_MESSAGE_SIZE , const uint64_t maxMsgNumber = MAX_NUMBER_OF_MESSAGES ) noexcept ; template < typename Prefix > static IpcChannelName_t convertName ( const Prefix & p , const IpcChannelName_t & name ) noexcept ; private : cxx :: optional < SharedMemoryObject > m_sharedMemory ; class NamedPipeData { public : NamedPipeData ( bool & isInitialized , IpcChannelError & error , const uint64_t maxMsgNumber ) noexcept ; NamedPipeData ( const NamedPipeData & ) = delete ; NamedPipeData ( NamedPipeData && rhs ) = delete ; ~ NamedPipeData () noexcept ; NamedPipeData & operator = ( const NamedPipeData & ) = delete ; NamedPipeData & operator = ( NamedPipeData && rhs ) = delete ; Semaphore & sendSemaphore () noexcept ; Semaphore & receiveSemaphore () noexcept ; bool waitForInitialization () const noexcept ; bool hasValidState () const noexcept ; MessageQueue_t messages ; private : static constexpr uint64_t SEND_SEMAPHORE = 0U ; static constexpr uint64_t RECEIVE_SEMAPHORE = 1U ; static constexpr uint64_t INVALID_DATA = 0xBAADF00DAFFEDEAD ; static constexpr uint64_t VALID_DATA = 0xBAD0FF1CEBEEFBEE ; static constexpr units :: Duration WAIT_FOR_INIT_TIMEOUT = units :: Duration :: fromSeconds ( 1 ); static constexpr units :: Duration WAIT_FOR_INIT_SLEEP_TIME = units :: Duration :: fromMilliseconds ( 1 ); std :: atomic < uint64_t > initializationGuard { INVALID_DATA }; using semaphoreMemory_t = uint8_t [ sizeof ( Semaphore )]; alignas ( Semaphore ) semaphoreMemory_t semaphores [ 2U ]; }; NamedPipeData * m_data = nullptr ; }; } // namespace posix } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/newtype_8hpp/","text":"iceoryx_hoofs/cxx/newtype.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::NewType Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_NEWTYPE_HPP #define IOX_HOOFS_CXX_NEWTYPE_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/assignment.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/comparable.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/constructor.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/convertable.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/internal.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/protected_constructor.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/sortable.hpp\" #include <type_traits> namespace iox { namespace cxx { template < typename T , template < typename > class ... Policies > class NewType : public Policies < NewType < T , Policies ... >> ... { protected : NewType ( newtype :: internal :: ProtectedConstructor_t , const T & rhs ) noexcept ; public : using ThisType = NewType < T , Policies ... > ; using value_type = T ; NewType () noexcept ; explicit NewType ( const T & rhs ) noexcept ; NewType ( const NewType & rhs ) noexcept ; NewType ( NewType && rhs ) noexcept ; NewType & operator = ( const NewType & rhs ) noexcept ; NewType & operator = ( NewType && rhs ) noexcept ; NewType & operator = ( const T & rhs ) noexcept ; NewType & operator = ( T && rhs ) noexcept ; explicit operator T () const noexcept ; template < typename Type > friend typename Type :: value_type newtype :: internal :: newTypeAccessor ( const Type & ) noexcept ; private : T m_value ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/newtype.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/newtype.hpp"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#iceoryx_hoofscxxnewtypehpp","text":"","title":"iceoryx_hoofs/cxx/newtype.hpp"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#classes","text":"Name class iox::cxx::NewType Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods.","title":"Classes"},{"location":"API-reference/hoofs/Files/newtype_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_NEWTYPE_HPP #define IOX_HOOFS_CXX_NEWTYPE_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/assignment.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/comparable.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/constructor.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/convertable.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/internal.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/protected_constructor.hpp\" #include \"iceoryx_hoofs/internal/cxx/newtype/sortable.hpp\" #include <type_traits> namespace iox { namespace cxx { template < typename T , template < typename > class ... Policies > class NewType : public Policies < NewType < T , Policies ... >> ... { protected : NewType ( newtype :: internal :: ProtectedConstructor_t , const T & rhs ) noexcept ; public : using ThisType = NewType < T , Policies ... > ; using value_type = T ; NewType () noexcept ; explicit NewType ( const T & rhs ) noexcept ; NewType ( const NewType & rhs ) noexcept ; NewType ( NewType && rhs ) noexcept ; NewType & operator = ( const NewType & rhs ) noexcept ; NewType & operator = ( NewType && rhs ) noexcept ; NewType & operator = ( const T & rhs ) noexcept ; NewType & operator = ( T && rhs ) noexcept ; explicit operator T () const noexcept ; template < typename Type > friend typename Type :: value_type newtype :: internal :: newTypeAccessor ( const Type & ) noexcept ; private : T m_value ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/newtype.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/optional_8hpp/","text":"iceoryx_hoofs/cxx/optional.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name struct iox::cxx::nullopt_t Helper struct which is used to signal an empty optional. It is equivalent to no value. struct iox::cxx::in_place_t helper struct which is used to call the in-place-construction constructor class iox::cxx::optional Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_OPTIONAL_HPP #define IOX_HOOFS_CXX_OPTIONAL_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/requires.hpp\" #include \"iceoryx_hoofs/cxx/types.hpp\" #include <new> // needed for placement new in the construct_value member function #include <utility> namespace iox { namespace cxx { struct nullopt_t { }; constexpr nullopt_t nullopt = nullopt_t (); struct in_place_t { }; constexpr in_place_t in_place {}; template < typename T > class optional { public : using type = T ; optional () noexcept ; optional ( const nullopt_t & ) noexcept ; optional ( T && value ) noexcept ; optional ( const T & value ) noexcept ; template < typename ... Targs > optional ( in_place_t , Targs && ... args ) noexcept ; ~ optional () noexcept ; optional ( const optional & rhs ) noexcept ; optional ( optional && rhs ) noexcept ; optional & operator = ( const optional & rhs ) noexcept ; optional & operator = ( optional && rhs ) noexcept ; constexpr bool operator == ( const optional < T >& rhs ) const noexcept ; constexpr bool operator == ( const nullopt_t & ) const noexcept ; constexpr bool operator != ( const optional < T >& rhs ) const noexcept ; constexpr bool operator != ( const nullopt_t & ) const noexcept ; template < typename U = T > typename std :: enable_if <! std :: is_same < U , optional < T >&>:: value , optional >:: type & operator = ( U && value ) noexcept ; const T * operator -> () const noexcept ; const T & operator * () const noexcept ; T * operator -> () noexcept ; T & operator * () noexcept ; constexpr explicit operator bool () const noexcept ; constexpr bool has_value () const noexcept ; template < typename ... Targs > T & emplace ( Targs && ... args ) noexcept ; void reset () noexcept ; T & value () & noexcept ; const T & value () const & noexcept ; T && value () && noexcept ; const T && value () const && noexcept ; template < typename U > constexpr T value_or ( U && default_value ) const noexcept ; optional & and_then ( const cxx :: function_ref < void ( T & ) >& callable ) noexcept ; const optional & and_then ( const cxx :: function_ref < void ( const T & ) >& callable ) const noexcept ; optional & or_else ( const cxx :: function_ref < void () >& callable ) noexcept ; const optional & or_else ( const cxx :: function_ref < void () >& callable ) const noexcept ; private : alignas ( T ) byte_t m_data [ sizeof ( T )]; bool m_hasValue { false }; private : template < typename ... Targs > void construct_value ( Targs && ... args ) noexcept ; void destruct_value () noexcept ; }; template < typename OptionalBaseType , typename ... Targs > optional < OptionalBaseType > make_optional ( Targs && ... args ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/optional.inl\" #endif // IOX_HOOFS_CXX_OPTIONAL_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/optional.hpp"},{"location":"API-reference/hoofs/Files/optional_8hpp/#iceoryx_hoofscxxoptionalhpp","text":"","title":"iceoryx_hoofs/cxx/optional.hpp"},{"location":"API-reference/hoofs/Files/optional_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/optional_8hpp/#classes","text":"Name struct iox::cxx::nullopt_t Helper struct which is used to signal an empty optional. It is equivalent to no value. struct iox::cxx::in_place_t helper struct which is used to call the in-place-construction constructor class iox::cxx::optional Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail.","title":"Classes"},{"location":"API-reference/hoofs/Files/optional_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_OPTIONAL_HPP #define IOX_HOOFS_CXX_OPTIONAL_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/requires.hpp\" #include \"iceoryx_hoofs/cxx/types.hpp\" #include <new> // needed for placement new in the construct_value member function #include <utility> namespace iox { namespace cxx { struct nullopt_t { }; constexpr nullopt_t nullopt = nullopt_t (); struct in_place_t { }; constexpr in_place_t in_place {}; template < typename T > class optional { public : using type = T ; optional () noexcept ; optional ( const nullopt_t & ) noexcept ; optional ( T && value ) noexcept ; optional ( const T & value ) noexcept ; template < typename ... Targs > optional ( in_place_t , Targs && ... args ) noexcept ; ~ optional () noexcept ; optional ( const optional & rhs ) noexcept ; optional ( optional && rhs ) noexcept ; optional & operator = ( const optional & rhs ) noexcept ; optional & operator = ( optional && rhs ) noexcept ; constexpr bool operator == ( const optional < T >& rhs ) const noexcept ; constexpr bool operator == ( const nullopt_t & ) const noexcept ; constexpr bool operator != ( const optional < T >& rhs ) const noexcept ; constexpr bool operator != ( const nullopt_t & ) const noexcept ; template < typename U = T > typename std :: enable_if <! std :: is_same < U , optional < T >&>:: value , optional >:: type & operator = ( U && value ) noexcept ; const T * operator -> () const noexcept ; const T & operator * () const noexcept ; T * operator -> () noexcept ; T & operator * () noexcept ; constexpr explicit operator bool () const noexcept ; constexpr bool has_value () const noexcept ; template < typename ... Targs > T & emplace ( Targs && ... args ) noexcept ; void reset () noexcept ; T & value () & noexcept ; const T & value () const & noexcept ; T && value () && noexcept ; const T && value () const && noexcept ; template < typename U > constexpr T value_or ( U && default_value ) const noexcept ; optional & and_then ( const cxx :: function_ref < void ( T & ) >& callable ) noexcept ; const optional & and_then ( const cxx :: function_ref < void ( const T & ) >& callable ) const noexcept ; optional & or_else ( const cxx :: function_ref < void () >& callable ) noexcept ; const optional & or_else ( const cxx :: function_ref < void () >& callable ) const noexcept ; private : alignas ( T ) byte_t m_data [ sizeof ( T )]; bool m_hasValue { false }; private : template < typename ... Targs > void construct_value ( Targs && ... args ) noexcept ; void destruct_value () noexcept ; }; template < typename OptionalBaseType , typename ... Targs > optional < OptionalBaseType > make_optional ( Targs && ... args ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/optional.inl\" #endif // IOX_HOOFS_CXX_OPTIONAL_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/","text":"iceoryx_hoofs/cxx/poor_mans_heap.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::PoorMansHeapType This is a proxy which must be used for the non default PoorMansHeap ctor. class iox::cxx::PoorMansHeap Reserves space on stack for placement new instatiation. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP #define IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP #include <cstddef> #include <cstdint> #include <utility> namespace iox { namespace cxx { template < typename Type > class PoorMansHeapType { }; template < typename Interface , size_t TypeSize , size_t TypeAlignment = 8 > class PoorMansHeap { public : PoorMansHeap () = default ; ~ PoorMansHeap () noexcept ; template < typename Type , typename ... CTorArgs > PoorMansHeap ( PoorMansHeapType < Type > , CTorArgs && ... ctorArgs ) noexcept ; PoorMansHeap ( PoorMansHeap && other ) = delete ; PoorMansHeap & operator = ( PoorMansHeap && rhs ) = delete ; PoorMansHeap ( const PoorMansHeap & ) = delete ; PoorMansHeap & operator = ( const PoorMansHeap & ) = delete ; template < typename Type , typename ... CTorArgs > void newInstance ( CTorArgs && ... ctorArgs ) noexcept ; void deleteInstance () noexcept ; bool hasInstance () const noexcept ; Interface * operator -> () const noexcept ; Interface & operator * () const noexcept ; private : Interface * m_instance { nullptr }; alignas ( TypeAlignment ) uint8_t m_heap [ TypeSize ]; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/poor_mans_heap.inl\" #endif // IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/poor_mans_heap.hpp"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#iceoryx_hoofscxxpoor_mans_heaphpp","text":"","title":"iceoryx_hoofs/cxx/poor_mans_heap.hpp"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#classes","text":"Name class iox::cxx::PoorMansHeapType This is a proxy which must be used for the non default PoorMansHeap ctor. class iox::cxx::PoorMansHeap Reserves space on stack for placement new instatiation.","title":"Classes"},{"location":"API-reference/hoofs/Files/poor__mans__heap_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP #define IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP #include <cstddef> #include <cstdint> #include <utility> namespace iox { namespace cxx { template < typename Type > class PoorMansHeapType { }; template < typename Interface , size_t TypeSize , size_t TypeAlignment = 8 > class PoorMansHeap { public : PoorMansHeap () = default ; ~ PoorMansHeap () noexcept ; template < typename Type , typename ... CTorArgs > PoorMansHeap ( PoorMansHeapType < Type > , CTorArgs && ... ctorArgs ) noexcept ; PoorMansHeap ( PoorMansHeap && other ) = delete ; PoorMansHeap & operator = ( PoorMansHeap && rhs ) = delete ; PoorMansHeap ( const PoorMansHeap & ) = delete ; PoorMansHeap & operator = ( const PoorMansHeap & ) = delete ; template < typename Type , typename ... CTorArgs > void newInstance ( CTorArgs && ... ctorArgs ) noexcept ; void deleteInstance () noexcept ; bool hasInstance () const noexcept ; Interface * operator -> () const noexcept ; Interface & operator * () const noexcept ; private : Interface * m_instance { nullptr }; alignas ( TypeAlignment ) uint8_t m_heap [ TypeSize ]; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/poor_mans_heap.inl\" #endif // IOX_HOOFS_CXX_POOR_MANS_HEAP_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/","text":"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Classes \ud83d\udd17 Name struct iox::posix::PosixRights class iox::posix::PosixGroup class iox::posix::PosixUser Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP #define IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/platform/types.hpp\" #include <string> namespace iox { namespace posix { static constexpr int MaxNumberOfGroups = 888 ; struct PosixRights { PosixRights ( bool f_read , bool f_write , bool f_execute ) noexcept ; bool m_read ; bool m_write ; bool m_execute ; }; class PosixGroup { public : using string_t = cxx :: string < 100 > ; explicit PosixGroup ( const gid_t f_id ) noexcept ; explicit PosixGroup ( const string_t & f_name ) noexcept ; bool operator == ( const PosixGroup & other ) const noexcept ; string_t getName () const noexcept ; gid_t getID () const noexcept ; bool doesExist () const noexcept ; static PosixGroup getGroupOfCurrentProcess () noexcept ; static cxx :: optional < uid_t > getGroupID ( const string_t & f_name ) noexcept ; static cxx :: optional < string_t > getGroupName ( gid_t f_id ) noexcept ; private : gid_t m_id ; bool m_doesExist { false }; }; class PosixUser { public : using groupVector_t = cxx :: vector < PosixGroup , MaxNumberOfGroups > ; using string_t = cxx :: string < 100 > ; explicit PosixUser ( const uid_t f_id ) noexcept ; explicit PosixUser ( const string_t & f_name ) noexcept ; groupVector_t getGroups () const noexcept ; string_t getName () const noexcept ; uid_t getID () const noexcept ; bool doesExist () const noexcept ; static PosixUser getUserOfCurrentProcess () noexcept ; static cxx :: optional < uid_t > getUserID ( const string_t & f_name ) noexcept ; static cxx :: optional < string_t > getUserName ( uid_t f_id ) noexcept ; private : uid_t m_id ; bool m_doesExist { false }; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#iceoryx_hoofsposix_wrapperposix_access_rightshpp","text":"","title":"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#classes","text":"Name struct iox::posix::PosixRights class iox::posix::PosixGroup class iox::posix::PosixUser","title":"Classes"},{"location":"API-reference/hoofs/Files/posix__access__rights_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP #define IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/platform/types.hpp\" #include <string> namespace iox { namespace posix { static constexpr int MaxNumberOfGroups = 888 ; struct PosixRights { PosixRights ( bool f_read , bool f_write , bool f_execute ) noexcept ; bool m_read ; bool m_write ; bool m_execute ; }; class PosixGroup { public : using string_t = cxx :: string < 100 > ; explicit PosixGroup ( const gid_t f_id ) noexcept ; explicit PosixGroup ( const string_t & f_name ) noexcept ; bool operator == ( const PosixGroup & other ) const noexcept ; string_t getName () const noexcept ; gid_t getID () const noexcept ; bool doesExist () const noexcept ; static PosixGroup getGroupOfCurrentProcess () noexcept ; static cxx :: optional < uid_t > getGroupID ( const string_t & f_name ) noexcept ; static cxx :: optional < string_t > getGroupName ( gid_t f_id ) noexcept ; private : gid_t m_id ; bool m_doesExist { false }; }; class PosixUser { public : using groupVector_t = cxx :: vector < PosixGroup , MaxNumberOfGroups > ; using string_t = cxx :: string < 100 > ; explicit PosixUser ( const uid_t f_id ) noexcept ; explicit PosixUser ( const string_t & f_name ) noexcept ; groupVector_t getGroups () const noexcept ; string_t getName () const noexcept ; uid_t getID () const noexcept ; bool doesExist () const noexcept ; static PosixUser getUserOfCurrentProcess () noexcept ; static cxx :: optional < uid_t > getUserID ( const string_t & f_name ) noexcept ; static cxx :: optional < string_t > getUserName ( uid_t f_id ) noexcept ; private : uid_t m_id ; bool m_doesExist { false }; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_POSIX_ACCESS_RIGHTS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/","text":"iceoryx_hoofs/posix_wrapper/posix_call.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix iox::posix::internal Classes \ud83d\udd17 Name class iox::posix::PosixCallBuilder struct iox::posix::PosixCallResult result of a posix call class iox::posix::PosixCallEvaluator class which is created by the verificator to evaluate the result of a posix call class iox::posix::PosixCallVerificator class which verifies the return value of a posix function call class iox::posix::PosixCallBuilder Defines \ud83d\udd17 Name posixCall (f) Calling a posix function with automated error handling. If the posix function returns void you do not need to use posixCall since it cannot fail, (see: man errno). We use a builder pattern to create a design which sets the usage contract so that it cannot be used in the wrong way. Macro Documentation \ud83d\udd17 define posixCall \ud83d\udd17 #define posixCall( f ) internal :: createPosixCallBuilder ( f , # f , __FILE__ , __LINE__ , __PRETTY_FUNCTION__ ) Calling a posix function with automated error handling. If the posix function returns void you do not need to use posixCall since it cannot fail, (see: man errno). We use a builder pattern to create a design which sets the usage contract so that it cannot be used in the wrong way. iox :: posix :: posixCall ( sem_timedwait )( handle , timeout ) . successReturnValue ( 0 ) . ignoreErrnos ( ETIMEDOUT ) // can be a comma separated list of errnos . evaluate () . and_then ([]( auto & result ){ std :: cout << result . value << std :: endl ; // return value of sem_timedwait std :: cout << result . errno << std :: endl ; // errno which was set by sem_timedwait std :: cout << result . getHumanReadableErrnum () << std :: endl ; // get string returned by strerror(errno) }) . or_else ([]( auto & result ){ std :: cout << result . value << std :: endl ; // return value of sem_timedwait std :: cout << result . errno << std :: endl ; // errno which was set by sem_timedwait std :: cout << result . getHumanReadableErrnum () << std :: endl ; // get string returned by strerror(errno) }) // when your posix call signals failure with one specific return value use // .failureReturnValue(_) instead of .successReturnValue(_) // when your posix call signals failure by returning the errno value instead of setting the errno use // .returnValueMatchesErrno() instead of .successReturnValue(_) Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP #define IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/cxx/attributes.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include <cstdint> #include <cstring> namespace iox { namespace posix { static constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE = 128U ; static constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS = 5U ; static constexpr int32_t POSIX_CALL_INVALID_ERRNO = -1 ; template < typename ReturnType , typename ... FunctionArguments > class PosixCallBuilder ; template < typename T > struct PosixCallResult { PosixCallResult () noexcept = default ; cxx :: string < POSIX_CALL_ERROR_STRING_SIZE > getHumanReadableErrnum () const noexcept ; T value {}; int32_t errnum = POSIX_CALL_INVALID_ERRNO ; }; namespace internal { template < typename ReturnType , typename ... FunctionArguments > PosixCallBuilder < ReturnType , FunctionArguments ... > createPosixCallBuilder ( ReturnType ( * posixCall )( FunctionArguments ...), const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) noexcept ; template < typename ReturnType > struct PosixCallDetails { PosixCallDetails ( const char * posixFunctionName , const char * file , int line , const char * callingFunction ) noexcept ; const char * posixFunctionName = nullptr ; const char * file = nullptr ; const char * callingFunction = nullptr ; int32_t line = 0 ; bool hasSuccess = true ; bool hasIgnoredErrno = false ; bool hasSilentErrno = false ; PosixCallResult < ReturnType > result ; }; } // namespace internal #define posixCall(f) internal::createPosixCallBuilder(f, #f, __FILE__, __LINE__, __PRETTY_FUNCTION__) template < typename ReturnType > class IOX_NO_DISCARD PosixCallEvaluator { public : template < typename ... IgnoredErrnos > PosixCallEvaluator < ReturnType > ignoreErrnos ( const IgnoredErrnos ... ignoredErrnos ) const && noexcept ; template < typename ... SilentErrnos > PosixCallEvaluator < ReturnType > suppressErrorMessagesForErrnos ( const SilentErrnos ... silentErrnos ) const && noexcept ; cxx :: expected < PosixCallResult < ReturnType > , PosixCallResult < ReturnType >> evaluate () const && noexcept ; private : template < typename > friend class PosixCallVerificator ; explicit PosixCallEvaluator ( internal :: PosixCallDetails < ReturnType >& details ) noexcept ; private : internal :: PosixCallDetails < ReturnType >& m_details ; }; template < typename ReturnType > class IOX_NO_DISCARD PosixCallVerificator { public : template < typename ... SuccessReturnValues > PosixCallEvaluator < ReturnType > successReturnValue ( const SuccessReturnValues ... successReturnValues ) && noexcept ; template < typename ... FailureReturnValues > PosixCallEvaluator < ReturnType > failureReturnValue ( const FailureReturnValues ... failureReturnValues ) && noexcept ; PosixCallEvaluator < ReturnType > returnValueMatchesErrno () && noexcept ; private : template < typename , typename ... > friend class PosixCallBuilder ; explicit PosixCallVerificator ( internal :: PosixCallDetails < ReturnType >& details ) noexcept ; private : internal :: PosixCallDetails < ReturnType >& m_details ; }; template < typename ReturnType , typename ... FunctionArguments > class IOX_NO_DISCARD PosixCallBuilder { public : using FunctionType_t = ReturnType ( * )( FunctionArguments ...); PosixCallVerificator < ReturnType > operator ()( FunctionArguments ... arguments ) && noexcept ; private : template < typename ReturnTypeFriend , typename ... FunctionArgumentsFriend > friend PosixCallBuilder < ReturnTypeFriend , FunctionArgumentsFriend ... > internal :: createPosixCallBuilder ( ReturnTypeFriend ( * posixCall )( FunctionArgumentsFriend ...), const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) noexcept ; PosixCallBuilder ( FunctionType_t posixCall , const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) noexcept ; private : FunctionType_t m_posixCall = nullptr ; internal :: PosixCallDetails < ReturnType > m_details ; }; } // namespace posix } // namespace iox #include \"iceoryx_hoofs/internal/posix_wrapper/posix_call.inl\" #endif // IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/posix_call.hpp"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#iceoryx_hoofsposix_wrapperposix_callhpp","text":"","title":"iceoryx_hoofs/posix_wrapper/posix_call.hpp"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix iox::posix::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#classes","text":"Name class iox::posix::PosixCallBuilder struct iox::posix::PosixCallResult result of a posix call class iox::posix::PosixCallEvaluator class which is created by the verificator to evaluate the result of a posix call class iox::posix::PosixCallVerificator class which verifies the return value of a posix function call class iox::posix::PosixCallBuilder","title":"Classes"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#defines","text":"Name posixCall (f) Calling a posix function with automated error handling. If the posix function returns void you do not need to use posixCall since it cannot fail, (see: man errno). We use a builder pattern to create a design which sets the usage contract so that it cannot be used in the wrong way.","title":"Defines"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#define-posixcall","text":"#define posixCall( f ) internal :: createPosixCallBuilder ( f , # f , __FILE__ , __LINE__ , __PRETTY_FUNCTION__ ) Calling a posix function with automated error handling. If the posix function returns void you do not need to use posixCall since it cannot fail, (see: man errno). We use a builder pattern to create a design which sets the usage contract so that it cannot be used in the wrong way. iox :: posix :: posixCall ( sem_timedwait )( handle , timeout ) . successReturnValue ( 0 ) . ignoreErrnos ( ETIMEDOUT ) // can be a comma separated list of errnos . evaluate () . and_then ([]( auto & result ){ std :: cout << result . value << std :: endl ; // return value of sem_timedwait std :: cout << result . errno << std :: endl ; // errno which was set by sem_timedwait std :: cout << result . getHumanReadableErrnum () << std :: endl ; // get string returned by strerror(errno) }) . or_else ([]( auto & result ){ std :: cout << result . value << std :: endl ; // return value of sem_timedwait std :: cout << result . errno << std :: endl ; // errno which was set by sem_timedwait std :: cout << result . getHumanReadableErrnum () << std :: endl ; // get string returned by strerror(errno) }) // when your posix call signals failure with one specific return value use // .failureReturnValue(_) instead of .successReturnValue(_) // when your posix call signals failure by returning the errno value instead of setting the errno use // .returnValueMatchesErrno() instead of .successReturnValue(_)","title":"define posixCall"},{"location":"API-reference/hoofs/Files/posix__call_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP #define IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/cxx/attributes.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include <cstdint> #include <cstring> namespace iox { namespace posix { static constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE = 128U ; static constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS = 5U ; static constexpr int32_t POSIX_CALL_INVALID_ERRNO = -1 ; template < typename ReturnType , typename ... FunctionArguments > class PosixCallBuilder ; template < typename T > struct PosixCallResult { PosixCallResult () noexcept = default ; cxx :: string < POSIX_CALL_ERROR_STRING_SIZE > getHumanReadableErrnum () const noexcept ; T value {}; int32_t errnum = POSIX_CALL_INVALID_ERRNO ; }; namespace internal { template < typename ReturnType , typename ... FunctionArguments > PosixCallBuilder < ReturnType , FunctionArguments ... > createPosixCallBuilder ( ReturnType ( * posixCall )( FunctionArguments ...), const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) noexcept ; template < typename ReturnType > struct PosixCallDetails { PosixCallDetails ( const char * posixFunctionName , const char * file , int line , const char * callingFunction ) noexcept ; const char * posixFunctionName = nullptr ; const char * file = nullptr ; const char * callingFunction = nullptr ; int32_t line = 0 ; bool hasSuccess = true ; bool hasIgnoredErrno = false ; bool hasSilentErrno = false ; PosixCallResult < ReturnType > result ; }; } // namespace internal #define posixCall(f) internal::createPosixCallBuilder(f, #f, __FILE__, __LINE__, __PRETTY_FUNCTION__) template < typename ReturnType > class IOX_NO_DISCARD PosixCallEvaluator { public : template < typename ... IgnoredErrnos > PosixCallEvaluator < ReturnType > ignoreErrnos ( const IgnoredErrnos ... ignoredErrnos ) const && noexcept ; template < typename ... SilentErrnos > PosixCallEvaluator < ReturnType > suppressErrorMessagesForErrnos ( const SilentErrnos ... silentErrnos ) const && noexcept ; cxx :: expected < PosixCallResult < ReturnType > , PosixCallResult < ReturnType >> evaluate () const && noexcept ; private : template < typename > friend class PosixCallVerificator ; explicit PosixCallEvaluator ( internal :: PosixCallDetails < ReturnType >& details ) noexcept ; private : internal :: PosixCallDetails < ReturnType >& m_details ; }; template < typename ReturnType > class IOX_NO_DISCARD PosixCallVerificator { public : template < typename ... SuccessReturnValues > PosixCallEvaluator < ReturnType > successReturnValue ( const SuccessReturnValues ... successReturnValues ) && noexcept ; template < typename ... FailureReturnValues > PosixCallEvaluator < ReturnType > failureReturnValue ( const FailureReturnValues ... failureReturnValues ) && noexcept ; PosixCallEvaluator < ReturnType > returnValueMatchesErrno () && noexcept ; private : template < typename , typename ... > friend class PosixCallBuilder ; explicit PosixCallVerificator ( internal :: PosixCallDetails < ReturnType >& details ) noexcept ; private : internal :: PosixCallDetails < ReturnType >& m_details ; }; template < typename ReturnType , typename ... FunctionArguments > class IOX_NO_DISCARD PosixCallBuilder { public : using FunctionType_t = ReturnType ( * )( FunctionArguments ...); PosixCallVerificator < ReturnType > operator ()( FunctionArguments ... arguments ) && noexcept ; private : template < typename ReturnTypeFriend , typename ... FunctionArgumentsFriend > friend PosixCallBuilder < ReturnTypeFriend , FunctionArgumentsFriend ... > internal :: createPosixCallBuilder ( ReturnTypeFriend ( * posixCall )( FunctionArgumentsFriend ...), const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) noexcept ; PosixCallBuilder ( FunctionType_t posixCall , const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) noexcept ; private : FunctionType_t m_posixCall = nullptr ; internal :: PosixCallDetails < ReturnType > m_details ; }; } // namespace posix } // namespace iox #include \"iceoryx_hoofs/internal/posix_wrapper/posix_call.inl\" #endif // IOX_HOOFS_POSIX_WRAPPER_POSIX_CALL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/requires_8hpp/","text":"iceoryx_hoofs/cxx/requires.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal Defines \ud83d\udd17 Name Expects (condition) Ensures (condition) Macro Documentation \ud83d\udd17 define Expects \ud83d\udd17 #define Expects( condition ) internal :: Require ( condition , __FILE__ , __LINE__ , __PRETTY_FUNCTION__ , # condition ) define Ensures \ud83d\udd17 #define Ensures( condition ) internal :: Require ( condition , __FILE__ , __LINE__ , __PRETTY_FUNCTION__ , # condition ) Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_REQUIRES_HPP #define IOX_HOOFS_CXX_REQUIRES_HPP #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { namespace internal { void Require ( const bool condition , const char * file , const int line , const char * function , const char * conditionString ) noexcept ; } // namespace internal // implementing C++ Core Guideline, I.6. Prefer Expects // see: // https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-expects #define Expects(condition) internal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition) // implementing C++ Core Guideline, I.8. Prefer Ensures // see: // https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-ensures #define Ensures(condition) internal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition) } // namespace cxx } // namespace iox #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/requires.hpp"},{"location":"API-reference/hoofs/Files/requires_8hpp/#iceoryx_hoofscxxrequireshpp","text":"","title":"iceoryx_hoofs/cxx/requires.hpp"},{"location":"API-reference/hoofs/Files/requires_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Files/requires_8hpp/#defines","text":"Name Expects (condition) Ensures (condition)","title":"Defines"},{"location":"API-reference/hoofs/Files/requires_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/hoofs/Files/requires_8hpp/#define-expects","text":"#define Expects( condition ) internal :: Require ( condition , __FILE__ , __LINE__ , __PRETTY_FUNCTION__ , # condition )","title":"define Expects"},{"location":"API-reference/hoofs/Files/requires_8hpp/#define-ensures","text":"#define Ensures( condition ) internal :: Require ( condition , __FILE__ , __LINE__ , __PRETTY_FUNCTION__ , # condition )","title":"define Ensures"},{"location":"API-reference/hoofs/Files/requires_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_REQUIRES_HPP #define IOX_HOOFS_CXX_REQUIRES_HPP #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { namespace internal { void Require ( const bool condition , const char * file , const int line , const char * function , const char * conditionString ) noexcept ; } // namespace internal // implementing C++ Core Guideline, I.6. Prefer Expects // see: // https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-expects #define Expects(condition) internal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition) // implementing C++ Core Guideline, I.8. Prefer Ensures // see: // https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-ensures #define Ensures(condition) internal::Require(condition, __FILE__, __LINE__, __PRETTY_FUNCTION__, #condition) } // namespace cxx } // namespace iox #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/","text":"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::concurrent Classes \ud83d\udd17 Name class iox::concurrent::ResizeableLockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP #define IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP #include \"iceoryx_hoofs/concurrent/lockfree_queue.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <atomic> namespace iox { namespace concurrent { // Remark: We use protected inheritance to make the base class methods inaccessible for the user. // We cannot use virtual functions since we need to use this class in shared memory. // Some of the methods need to be rewritten specifically for this class, others simply redirect // the call to the base class. // // Since supporting the resize (setCapacity) functionality has an impact on the runtime even // if the feature is not used, we provide a queue wihout resize functionality in an additional // base class that can be used separately. template < typename ElementType , uint64_t MaxCapacity > class ResizeableLockFreeQueue : protected LockFreeQueue < ElementType , MaxCapacity > { private : using Base = LockFreeQueue < ElementType , MaxCapacity > ; public : using element_t = ElementType ; static constexpr uint64_t MAX_CAPACITY = MaxCapacity ; ResizeableLockFreeQueue () noexcept = default ; ~ ResizeableLockFreeQueue () noexcept = default ; // deleted for now, can be implemented later if needed // note: concurrent copying or moving in lockfree fashion is nontrivial ResizeableLockFreeQueue ( const ResizeableLockFreeQueue & ) = delete ; ResizeableLockFreeQueue ( ResizeableLockFreeQueue && ) = delete ; ResizeableLockFreeQueue & operator = ( const ResizeableLockFreeQueue & ) = delete ; ResizeableLockFreeQueue & operator = ( ResizeableLockFreeQueue && ) = delete ; ResizeableLockFreeQueue ( const uint64_t initialCapacity ) noexcept ; static constexpr uint64_t maxCapacity () noexcept ; using Base :: empty ; using Base :: pop ; using Base :: size ; using Base :: tryPush ; uint64_t capacity () const noexcept ; iox :: cxx :: optional < ElementType > push ( const ElementType & value ) noexcept ; iox :: cxx :: optional < ElementType > push ( ElementType && value ) noexcept ; // overloads to set the capacity // 1) The most general one allows providing a removeHandler to specify remove behavior. // This could e.g. be to store them in a container. // 2) The second overload discards removed elements. template < typename Function , typename = typename std :: enable_if < cxx :: is_invocable < Function , ElementType >:: value >:: type > bool setCapacity ( const uint64_t newCapacity , Function && removeHandler ) noexcept ; bool setCapacity ( const uint64_t newCapacity ) noexcept ; private : using BufferIndex = typename Base :: BufferIndex ; std :: atomic < uint64_t > m_capacity { MaxCapacity }; // must be operator= otherwise it is undefined, see https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT std :: atomic_flag m_resizeInProgress = ATOMIC_FLAG_INIT ; iox :: cxx :: vector < BufferIndex , MaxCapacity > m_unusedIndices ; uint64_t increaseCapacity ( const uint64_t toIncrease ) noexcept ; template < typename Function > uint64_t decreaseCapacity ( const uint64_t toDecrease , Function && removeHandler ) noexcept ; bool tryGetUsedIndex ( BufferIndex & index ) noexcept ; template < typename T > iox :: cxx :: optional < ElementType > pushImpl ( T && value ) noexcept ; }; } // namespace concurrent } // namespace iox #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/resizeable_lockfree_queue.inl\" #endif // IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#iceoryx_hoofsconcurrentresizeable_lockfree_queuehpp","text":"","title":"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::concurrent","title":"Namespaces"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#classes","text":"Name class iox::concurrent::ResizeableLockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread).","title":"Classes"},{"location":"API-reference/hoofs/Files/resizeable__lockfree__queue_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP #define IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP #include \"iceoryx_hoofs/concurrent/lockfree_queue.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <atomic> namespace iox { namespace concurrent { // Remark: We use protected inheritance to make the base class methods inaccessible for the user. // We cannot use virtual functions since we need to use this class in shared memory. // Some of the methods need to be rewritten specifically for this class, others simply redirect // the call to the base class. // // Since supporting the resize (setCapacity) functionality has an impact on the runtime even // if the feature is not used, we provide a queue wihout resize functionality in an additional // base class that can be used separately. template < typename ElementType , uint64_t MaxCapacity > class ResizeableLockFreeQueue : protected LockFreeQueue < ElementType , MaxCapacity > { private : using Base = LockFreeQueue < ElementType , MaxCapacity > ; public : using element_t = ElementType ; static constexpr uint64_t MAX_CAPACITY = MaxCapacity ; ResizeableLockFreeQueue () noexcept = default ; ~ ResizeableLockFreeQueue () noexcept = default ; // deleted for now, can be implemented later if needed // note: concurrent copying or moving in lockfree fashion is nontrivial ResizeableLockFreeQueue ( const ResizeableLockFreeQueue & ) = delete ; ResizeableLockFreeQueue ( ResizeableLockFreeQueue && ) = delete ; ResizeableLockFreeQueue & operator = ( const ResizeableLockFreeQueue & ) = delete ; ResizeableLockFreeQueue & operator = ( ResizeableLockFreeQueue && ) = delete ; ResizeableLockFreeQueue ( const uint64_t initialCapacity ) noexcept ; static constexpr uint64_t maxCapacity () noexcept ; using Base :: empty ; using Base :: pop ; using Base :: size ; using Base :: tryPush ; uint64_t capacity () const noexcept ; iox :: cxx :: optional < ElementType > push ( const ElementType & value ) noexcept ; iox :: cxx :: optional < ElementType > push ( ElementType && value ) noexcept ; // overloads to set the capacity // 1) The most general one allows providing a removeHandler to specify remove behavior. // This could e.g. be to store them in a container. // 2) The second overload discards removed elements. template < typename Function , typename = typename std :: enable_if < cxx :: is_invocable < Function , ElementType >:: value >:: type > bool setCapacity ( const uint64_t newCapacity , Function && removeHandler ) noexcept ; bool setCapacity ( const uint64_t newCapacity ) noexcept ; private : using BufferIndex = typename Base :: BufferIndex ; std :: atomic < uint64_t > m_capacity { MaxCapacity }; // must be operator= otherwise it is undefined, see https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT std :: atomic_flag m_resizeInProgress = ATOMIC_FLAG_INIT ; iox :: cxx :: vector < BufferIndex , MaxCapacity > m_unusedIndices ; uint64_t increaseCapacity ( const uint64_t toIncrease ) noexcept ; template < typename Function > uint64_t decreaseCapacity ( const uint64_t toDecrease , Function && removeHandler ) noexcept ; bool tryGetUsedIndex ( BufferIndex & index ) noexcept ; template < typename T > iox :: cxx :: optional < ElementType > pushImpl ( T && value ) noexcept ; }; } // namespace concurrent } // namespace iox #include \"iceoryx_hoofs/internal/concurrent/lockfree_queue/resizeable_lockfree_queue.inl\" #endif // IOX_HOOFS_CONCURRENT_RESIZEABLE_LOCKFREE_QUEUE_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/","text":"iceoryx_hoofs/cxx/scoped_static.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_SCOPED_STATIC_HPP #define IOX_HOOFS_CXX_SCOPED_STATIC_HPP #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" namespace iox { namespace cxx { template < typename T , typename ... CTorArgs > GenericRAII makeScopedStatic ( T & memory , CTorArgs && ... ctorArgs ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/scoped_static.inl\" #endif // IOX_HOOFS_CXX_SCOPED_STATIC_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/scoped_static.hpp"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/#iceoryx_hoofscxxscoped_statichpp","text":"","title":"iceoryx_hoofs/cxx/scoped_static.hpp"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/scoped__static_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_SCOPED_STATIC_HPP #define IOX_HOOFS_CXX_SCOPED_STATIC_HPP #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" namespace iox { namespace cxx { template < typename T , typename ... CTorArgs > GenericRAII makeScopedStatic ( T & memory , CTorArgs && ... ctorArgs ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/scoped_static.inl\" #endif // IOX_HOOFS_CXX_SCOPED_STATIC_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/","text":"iceoryx_hoofs/posix_wrapper/semaphore.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Classes \ud83d\udd17 Name struct iox::posix::CreateUnnamedSingleProcessSemaphore_t struct iox::posix::CreateUnnamedSharedMemorySemaphore_t struct iox::posix::CreateNamedSemaphore_t struct iox::posix::OpenNamedSemaphore_t class iox::posix::Semaphore Posix semaphore C++ Wrapping class. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP #define IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" #include \"iceoryx_hoofs/internal/relocatable_pointer/relative_pointer.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/platform/fcntl.hpp\" #include \"iceoryx_hoofs/platform/semaphore.hpp\" #include \"iceoryx_hoofs/platform/stat.hpp\" #include <cstring> namespace iox { namespace posix { enum class SemaphoreError { CREATION_FAILED , NAME_TOO_LONG , UNABLE_TO_OPEN_HANDLE , INVALID_SEMAPHORE_HANDLE , SEMAPHORE_OVERFLOW , INTERRUPTED_BY_SIGNAL_HANDLER , UNDEFINED }; enum class SemaphoreWaitState { TIMEOUT , NO_TIMEOUT , }; struct CreateUnnamedSingleProcessSemaphore_t { }; struct CreateUnnamedSharedMemorySemaphore_t { }; struct CreateNamedSemaphore_t { }; struct OpenNamedSemaphore_t { }; static constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore = CreateUnnamedSingleProcessSemaphore_t (); static constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore = CreateUnnamedSharedMemorySemaphore_t (); static constexpr CreateNamedSemaphore_t CreateNamedSemaphore = CreateNamedSemaphore_t (); static constexpr OpenNamedSemaphore_t OpenNamedSemaphore = OpenNamedSemaphore_t (); class Semaphore : public DesignPattern :: Creation < Semaphore , SemaphoreError > { public : Semaphore () noexcept ; Semaphore ( Semaphore && rhs ) noexcept ; Semaphore & operator = ( Semaphore && rhs ) noexcept ; Semaphore ( const Semaphore & ) = delete ; Semaphore & operator = ( const Semaphore & ) = delete ; ~ Semaphore () noexcept ; cxx :: expected < int , SemaphoreError > getValue () const noexcept ; cxx :: expected < SemaphoreError > post () noexcept ; cxx :: expected < SemaphoreWaitState , SemaphoreError > timedWait ( const units :: Duration abs_timeout ) noexcept ; cxx :: expected < bool , SemaphoreError > tryWait () noexcept ; cxx :: expected < SemaphoreError > wait () noexcept ; private : cxx :: string < 128 > m_name ; bool m_isCreated = true ; bool m_isNamedSemaphore = true ; bool m_isShared = false ; mutable iox_sem_t m_handle {}; mutable iox_sem_t * m_handlePtr = nullptr ; private : friend class DesignPattern :: Creation < Semaphore , SemaphoreError > ; Semaphore ( CreateUnnamedSingleProcessSemaphore_t , const unsigned int value ) noexcept ; Semaphore ( CreateUnnamedSharedMemorySemaphore_t , const unsigned int value ) noexcept ; Semaphore ( OpenNamedSemaphore_t , const char * name , const int oflag ) noexcept ; Semaphore ( CreateNamedSemaphore_t , const char * name , const mode_t mode , const unsigned int value ) noexcept ; bool close () noexcept ; bool destroy () noexcept ; static bool init ( iox_sem_t * handle , const int pshared , const unsigned int value ) noexcept ; bool open ( const int oflag ) noexcept ; iox_sem_t * getHandle () const noexcept ; bool open ( const int oflag , const mode_t mode , const unsigned int value ) noexcept ; static bool unlink ( const char * name ) noexcept ; bool isNamedSemaphore () const noexcept ; void closeHandle () noexcept ; static SemaphoreError errnoToEnum ( const int errnoValue ) noexcept ; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/semaphore.hpp"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#iceoryx_hoofsposix_wrappersemaphorehpp","text":"","title":"iceoryx_hoofs/posix_wrapper/semaphore.hpp"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#classes","text":"Name struct iox::posix::CreateUnnamedSingleProcessSemaphore_t struct iox::posix::CreateUnnamedSharedMemorySemaphore_t struct iox::posix::CreateNamedSemaphore_t struct iox::posix::OpenNamedSemaphore_t class iox::posix::Semaphore Posix semaphore C++ Wrapping class.","title":"Classes"},{"location":"API-reference/hoofs/Files/semaphore_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP #define IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" #include \"iceoryx_hoofs/internal/relocatable_pointer/relative_pointer.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/platform/fcntl.hpp\" #include \"iceoryx_hoofs/platform/semaphore.hpp\" #include \"iceoryx_hoofs/platform/stat.hpp\" #include <cstring> namespace iox { namespace posix { enum class SemaphoreError { CREATION_FAILED , NAME_TOO_LONG , UNABLE_TO_OPEN_HANDLE , INVALID_SEMAPHORE_HANDLE , SEMAPHORE_OVERFLOW , INTERRUPTED_BY_SIGNAL_HANDLER , UNDEFINED }; enum class SemaphoreWaitState { TIMEOUT , NO_TIMEOUT , }; struct CreateUnnamedSingleProcessSemaphore_t { }; struct CreateUnnamedSharedMemorySemaphore_t { }; struct CreateNamedSemaphore_t { }; struct OpenNamedSemaphore_t { }; static constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore = CreateUnnamedSingleProcessSemaphore_t (); static constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore = CreateUnnamedSharedMemorySemaphore_t (); static constexpr CreateNamedSemaphore_t CreateNamedSemaphore = CreateNamedSemaphore_t (); static constexpr OpenNamedSemaphore_t OpenNamedSemaphore = OpenNamedSemaphore_t (); class Semaphore : public DesignPattern :: Creation < Semaphore , SemaphoreError > { public : Semaphore () noexcept ; Semaphore ( Semaphore && rhs ) noexcept ; Semaphore & operator = ( Semaphore && rhs ) noexcept ; Semaphore ( const Semaphore & ) = delete ; Semaphore & operator = ( const Semaphore & ) = delete ; ~ Semaphore () noexcept ; cxx :: expected < int , SemaphoreError > getValue () const noexcept ; cxx :: expected < SemaphoreError > post () noexcept ; cxx :: expected < SemaphoreWaitState , SemaphoreError > timedWait ( const units :: Duration abs_timeout ) noexcept ; cxx :: expected < bool , SemaphoreError > tryWait () noexcept ; cxx :: expected < SemaphoreError > wait () noexcept ; private : cxx :: string < 128 > m_name ; bool m_isCreated = true ; bool m_isNamedSemaphore = true ; bool m_isShared = false ; mutable iox_sem_t m_handle {}; mutable iox_sem_t * m_handlePtr = nullptr ; private : friend class DesignPattern :: Creation < Semaphore , SemaphoreError > ; Semaphore ( CreateUnnamedSingleProcessSemaphore_t , const unsigned int value ) noexcept ; Semaphore ( CreateUnnamedSharedMemorySemaphore_t , const unsigned int value ) noexcept ; Semaphore ( OpenNamedSemaphore_t , const char * name , const int oflag ) noexcept ; Semaphore ( CreateNamedSemaphore_t , const char * name , const mode_t mode , const unsigned int value ) noexcept ; bool close () noexcept ; bool destroy () noexcept ; static bool init ( iox_sem_t * handle , const int pshared , const unsigned int value ) noexcept ; bool open ( const int oflag ) noexcept ; iox_sem_t * getHandle () const noexcept ; bool open ( const int oflag , const mode_t mode , const unsigned int value ) noexcept ; static bool unlink ( const char * name ) noexcept ; bool isNamedSemaphore () const noexcept ; void closeHandle () noexcept ; static SemaphoreError errnoToEnum ( const int errnoValue ) noexcept ; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_SEMAPHORE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/serialization_8hpp/","text":"iceoryx_hoofs/cxx/serialization.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::Serialization Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_SERIALIZATION_HPP #define IOX_HOOFS_CXX_SERIALIZATION_HPP #include \"iceoryx_hoofs/cxx/convert.hpp\" #include <cstdlib> #include <iostream> #include <sstream> namespace iox { namespace cxx { class Serialization { public : explicit Serialization ( const std :: string & value ) noexcept ; std :: string toString () const noexcept ; operator std :: string () const noexcept ; template < typename ... Targs > static Serialization create ( const Targs & ... args ) noexcept ; template < typename T , typename ... Targs > bool extract ( T & t , Targs & ... args ) const noexcept ; template < typename T > bool getNth ( const unsigned int index , T & t ) const noexcept ; enum class Error { DESERIALIZATION_FAILED , }; private : std :: string m_value ; static constexpr char separator = ':' ; private : static std :: string serializer () noexcept ; static bool removeFirstEntry ( std :: string & firstEntry , std :: string & remainder ) noexcept ; template < typename T > static typename std :: enable_if < std :: is_convertible < T , Serialization >:: value , std :: string >:: type getString ( const T & t ) noexcept ; template < typename T > static typename std :: enable_if <! std :: is_convertible < T , Serialization >:: value , std :: string >:: type getString ( const T & t ) noexcept ; template < typename T , typename ... Targs > static std :: string serializer ( const T & t , const Targs & ... args ) noexcept ; static bool deserialize ( const std :: string & serializedString ) noexcept ; template < typename T , typename ... Targs > static bool deserialize ( const std :: string & serializedString , T & t , Targs & ... args ) noexcept ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/serialization.inl\" #endif // IOX_HOOFS_CXX_SERIALIZATION_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/serialization.hpp"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#iceoryx_hoofscxxserializationhpp","text":"","title":"iceoryx_hoofs/cxx/serialization.hpp"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#classes","text":"Name class iox::cxx::Serialization Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01.","title":"Classes"},{"location":"API-reference/hoofs/Files/serialization_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_SERIALIZATION_HPP #define IOX_HOOFS_CXX_SERIALIZATION_HPP #include \"iceoryx_hoofs/cxx/convert.hpp\" #include <cstdlib> #include <iostream> #include <sstream> namespace iox { namespace cxx { class Serialization { public : explicit Serialization ( const std :: string & value ) noexcept ; std :: string toString () const noexcept ; operator std :: string () const noexcept ; template < typename ... Targs > static Serialization create ( const Targs & ... args ) noexcept ; template < typename T , typename ... Targs > bool extract ( T & t , Targs & ... args ) const noexcept ; template < typename T > bool getNth ( const unsigned int index , T & t ) const noexcept ; enum class Error { DESERIALIZATION_FAILED , }; private : std :: string m_value ; static constexpr char separator = ':' ; private : static std :: string serializer () noexcept ; static bool removeFirstEntry ( std :: string & firstEntry , std :: string & remainder ) noexcept ; template < typename T > static typename std :: enable_if < std :: is_convertible < T , Serialization >:: value , std :: string >:: type getString ( const T & t ) noexcept ; template < typename T > static typename std :: enable_if <! std :: is_convertible < T , Serialization >:: value , std :: string >:: type getString ( const T & t ) noexcept ; template < typename T , typename ... Targs > static std :: string serializer ( const T & t , const Targs & ... args ) noexcept ; static bool deserialize ( const std :: string & serializedString ) noexcept ; template < typename T , typename ... Targs > static bool deserialize ( const std :: string & serializedString , T & t , Targs & ... args ) noexcept ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/serialization.inl\" #endif // IOX_HOOFS_CXX_SERIALIZATION_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/","text":"iceoryx_hoofs/posix_wrapper/signal_handler.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Classes \ud83d\udd17 Name class iox::posix::SignalGuard The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_SIGNAL_HANDLER_HPP #define IOX_HOOFS_POSIX_WRAPPER_SIGNAL_HANDLER_HPP #include \"iceoryx_hoofs/platform/signal.hpp\" namespace iox { namespace posix { using SignalHandlerCallback_t = void ( * )( int ); enum class Signal : int { BUS = SIGBUS , INT = SIGINT , TERM = SIGTERM , HUP = SIGHUP , ABORT = SIGABRT , }; class SignalGuard { public : SignalGuard ( SignalGuard && rhs ) noexcept ; SignalGuard ( const SignalGuard & ) = delete ; ~ SignalGuard () noexcept ; SignalGuard & operator = ( const SignalGuard & rhs ) = delete ; SignalGuard & operator = ( SignalGuard && rhs ) = delete ; friend SignalGuard registerSignalHandler ( const Signal , const SignalHandlerCallback_t ) noexcept ; private : void restorePreviousAction () noexcept ; SignalGuard () noexcept = default ; SignalGuard ( const Signal signal , const struct sigaction & previousAction ) noexcept ; private : Signal m_signal ; struct sigaction m_previousAction = {}; bool m_doRestorePreviousAction { false }; }; SignalGuard registerSignalHandler ( const Signal signal , const SignalHandlerCallback_t callback ) noexcept ; } // namespace posix } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/signal_handler.hpp"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#iceoryx_hoofsposix_wrappersignal_handlerhpp","text":"","title":"iceoryx_hoofs/posix_wrapper/signal_handler.hpp"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#classes","text":"Name class iox::posix::SignalGuard The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call.","title":"Classes"},{"location":"API-reference/hoofs/Files/signal__handler_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_SIGNAL_HANDLER_HPP #define IOX_HOOFS_POSIX_WRAPPER_SIGNAL_HANDLER_HPP #include \"iceoryx_hoofs/platform/signal.hpp\" namespace iox { namespace posix { using SignalHandlerCallback_t = void ( * )( int ); enum class Signal : int { BUS = SIGBUS , INT = SIGINT , TERM = SIGTERM , HUP = SIGHUP , ABORT = SIGABRT , }; class SignalGuard { public : SignalGuard ( SignalGuard && rhs ) noexcept ; SignalGuard ( const SignalGuard & ) = delete ; ~ SignalGuard () noexcept ; SignalGuard & operator = ( const SignalGuard & rhs ) = delete ; SignalGuard & operator = ( SignalGuard && rhs ) = delete ; friend SignalGuard registerSignalHandler ( const Signal , const SignalHandlerCallback_t ) noexcept ; private : void restorePreviousAction () noexcept ; SignalGuard () noexcept = default ; SignalGuard ( const Signal signal , const struct sigaction & previousAction ) noexcept ; private : Signal m_signal ; struct sigaction m_previousAction = {}; bool m_doRestorePreviousAction { false }; }; SignalGuard registerSignalHandler ( const Signal signal , const SignalHandlerCallback_t callback ) noexcept ; } // namespace posix } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/","text":"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Classes \ud83d\udd17 Name class iox::posix::SignalWatcher The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_SIGNAL_WATCHER_HPP #define IOX_HOOFS_POSIX_WRAPPER_SIGNAL_WATCHER_HPP #include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_handler.hpp\" #include <atomic> namespace iox { namespace posix { class SignalWatcher { public : SignalWatcher ( const SignalWatcher & ) = delete ; SignalWatcher ( SignalWatcher && ) = delete ; ~ SignalWatcher () = default ; SignalWatcher & operator = ( const SignalWatcher & ) = delete ; SignalWatcher & operator = ( SignalWatcher && ) = delete ; static SignalWatcher & getInstance () noexcept ; void waitForSignal () const noexcept ; bool wasSignalTriggered () const noexcept ; protected : SignalWatcher () noexcept ; private : friend void internalSignalHandler ( int ) noexcept ; mutable std :: atomic < uint64_t > m_numberOfWaiters { 0U }; mutable Semaphore m_semaphore ; std :: atomic_bool m_hasSignalOccurred { false }; SignalGuard m_sigTermGuard ; SignalGuard m_sigIntGuard ; }; void waitForTerminationRequest () noexcept ; bool hasTerminationRequested () noexcept ; } // namespace posix } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#iceoryx_hoofsposix_wrappersignal_watcherhpp","text":"","title":"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#classes","text":"Name class iox::posix::SignalWatcher The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred.","title":"Classes"},{"location":"API-reference/hoofs/Files/signal__watcher_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_SIGNAL_WATCHER_HPP #define IOX_HOOFS_POSIX_WRAPPER_SIGNAL_WATCHER_HPP #include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_handler.hpp\" #include <atomic> namespace iox { namespace posix { class SignalWatcher { public : SignalWatcher ( const SignalWatcher & ) = delete ; SignalWatcher ( SignalWatcher && ) = delete ; ~ SignalWatcher () = default ; SignalWatcher & operator = ( const SignalWatcher & ) = delete ; SignalWatcher & operator = ( SignalWatcher && ) = delete ; static SignalWatcher & getInstance () noexcept ; void waitForSignal () const noexcept ; bool wasSignalTriggered () const noexcept ; protected : SignalWatcher () noexcept ; private : friend void internalSignalHandler ( int ) noexcept ; mutable std :: atomic < uint64_t > m_numberOfWaiters { 0U }; mutable Semaphore m_semaphore ; std :: atomic_bool m_hasSignalOccurred { false }; SignalGuard m_sigTermGuard ; SignalGuard m_sigIntGuard ; }; void waitForTerminationRequest () noexcept ; bool hasTerminationRequested () noexcept ; } // namespace posix } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/stack_8hpp/","text":"iceoryx_hoofs/cxx/stack.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::stack stack implementation with a simple push pop interface Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_STACK_HPP #define IOX_HOOFS_CXX_STACK_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include <cstdint> namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class stack { public : cxx :: optional < T > pop () noexcept ; template < typename ... Targs > bool push ( Targs && ... args ) noexcept ; uint64_t size () const noexcept ; static constexpr uint64_t capacity () noexcept ; private : using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; uint64_t m_size = 0U ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/stack.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/stack.hpp"},{"location":"API-reference/hoofs/Files/stack_8hpp/#iceoryx_hoofscxxstackhpp","text":"","title":"iceoryx_hoofs/cxx/stack.hpp"},{"location":"API-reference/hoofs/Files/stack_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/stack_8hpp/#classes","text":"Name class iox::cxx::stack stack implementation with a simple push pop interface","title":"Classes"},{"location":"API-reference/hoofs/Files/stack_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_STACK_HPP #define IOX_HOOFS_CXX_STACK_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include <cstdint> namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class stack { public : cxx :: optional < T > pop () noexcept ; template < typename ... Targs > bool push ( Targs && ... args ) noexcept ; uint64_t size () const noexcept ; static constexpr uint64_t capacity () noexcept ; private : using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; uint64_t m_size = 0U ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/stack.inl\" #endif Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/string_8hpp/","text":"iceoryx_hoofs/cxx/string.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name struct iox::cxx::TruncateToCapacity_t struct used to define a compile time variable which is used to distinguish between constructors with certain behavior class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_STRING_HPP #define IOX_HOOFS_CXX_STRING_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/internal/cxx/string_internal.hpp\" #include \"optional.hpp\" #include <algorithm> #include <cstdint> #include <cstring> #include <iostream> namespace iox { namespace cxx { template < typename T1 , typename T2 > typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa >>:: type concatenate ( const T1 & t1 , const T2 & t2 ) noexcept ; template < typename T1 , typename T2 , typename ... Targs > typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: SumCapa < T1 , T2 , Targs ... >:: value >>:: type concatenate ( const T1 & t1 , const T2 & t2 , const Targs & ... targs ) noexcept ; template < typename T1 , typename T2 > typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value && internal :: IsCxxString < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCharArray < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa >>:: type operator + ( const T1 & t1 , const T2 & t2 ) noexcept ; struct TruncateToCapacity_t { explicit TruncateToCapacity_t () = default ; }; constexpr TruncateToCapacity_t TruncateToCapacity {}; template < uint64_t Capacity > class string { static_assert ( Capacity > 0U , \"The capacity of the fixed string must be greater than 0!\" ); public : constexpr string () noexcept = default ; string ( const string & other ) noexcept ; string ( string && other ) noexcept ; string & operator = ( const string & rhs ) noexcept ; string & operator = ( string && rhs ) noexcept ; template < uint64_t N > string ( const string < N >& other ) noexcept ; template < uint64_t N > string ( string < N >&& other ) noexcept ; template < uint64_t N > string & operator = ( const string < N >& rhs ) noexcept ; template < uint64_t N > string & operator = ( string < N >&& rhs ) noexcept ; template < uint64_t N > string ( const char ( & other )[ N ]) noexcept ; string ( TruncateToCapacity_t , const char * const other ) noexcept ; string ( TruncateToCapacity_t , const std :: string & other ) noexcept ; string ( TruncateToCapacity_t , const char * const other , const uint64_t count ) noexcept ; template < uint64_t N > string & operator = ( const char ( & rhs )[ N ]) noexcept ; template < uint64_t N > string & assign ( const string < N >& str ) noexcept ; template < uint64_t N > string & assign ( const char ( & str )[ N ]) noexcept ; bool unsafe_assign ( const char * const str ) noexcept ; bool unsafe_assign ( const std :: string & str ) noexcept ; template < uint64_t N > int64_t compare ( const string < N >& other ) const noexcept ; template < uint64_t N > bool operator == ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator != ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator < ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator <= ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator > ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator >= ( const string < N >& rhs ) const noexcept ; bool operator == ( const char * const rhs ) const noexcept ; bool operator != ( const char * const rhs ) const noexcept ; const char * c_str () const noexcept ; constexpr uint64_t size () const noexcept ; static constexpr uint64_t capacity () noexcept ; constexpr bool empty () const noexcept ; operator std :: string () const noexcept ; template < typename T > string & operator += ( const T & ) noexcept ; template < typename T > typename std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , string &>:: type append ( TruncateToCapacity_t , const T & t ) noexcept ; template < typename T > typename std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , bool >:: type unsafe_append ( const T & t ) noexcept ; iox :: cxx :: optional < string < Capacity >> substr ( const uint64_t pos , const uint64_t count ) const noexcept ; iox :: cxx :: optional < string < Capacity >> substr ( const uint64_t pos = 0U ) const noexcept ; template < typename T > typename std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t >>:: type find ( const T & t , const uint64_t pos = 0U ) const noexcept ; template < typename T > typename std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t >>:: type find_first_of ( const T & t , const uint64_t pos = 0U ) const noexcept ; template < typename T > typename std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t >>:: type find_last_of ( const T & t , const uint64_t pos = Capacity ) const noexcept ; template < uint64_t N > friend class string ; template < typename T1 , typename T2 > friend typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa >>:: type concatenate ( const T1 & t1 , const T2 & t2 ) noexcept ; private : template < uint64_t N > string & copy ( const string < N >& rhs ) noexcept ; template < uint64_t N > string & move ( string < N >&& rhs ) noexcept ; char m_rawstring [ Capacity + 1U ]{ '\\0' }; uint64_t m_rawstringSize { 0U }; }; template < uint64_t Capacity > inline bool operator == ( const std :: string & lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline bool operator == ( const string < Capacity >& lhs , const std :: string & rhs ) noexcept ; template < uint64_t Capacity > inline bool operator != ( const std :: string & lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline bool operator != ( const string < Capacity >& lhs , const std :: string & rhs ) noexcept ; template < uint64_t Capacity > inline bool operator == ( const char * const lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline bool operator != ( const char * const lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline std :: ostream & operator << ( std :: ostream & stream , const string < Capacity >& str ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/string.inl\" #endif // IOX_HOOFS_CXX_STRING_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/string.hpp"},{"location":"API-reference/hoofs/Files/string_8hpp/#iceoryx_hoofscxxstringhpp","text":"","title":"iceoryx_hoofs/cxx/string.hpp"},{"location":"API-reference/hoofs/Files/string_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/string_8hpp/#classes","text":"Name struct iox::cxx::TruncateToCapacity_t struct used to define a compile time variable which is used to distinguish between constructors with certain behavior class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap.","title":"Classes"},{"location":"API-reference/hoofs/Files/string_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_STRING_HPP #define IOX_HOOFS_CXX_STRING_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/internal/cxx/string_internal.hpp\" #include \"optional.hpp\" #include <algorithm> #include <cstdint> #include <cstring> #include <iostream> namespace iox { namespace cxx { template < typename T1 , typename T2 > typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa >>:: type concatenate ( const T1 & t1 , const T2 & t2 ) noexcept ; template < typename T1 , typename T2 , typename ... Targs > typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: SumCapa < T1 , T2 , Targs ... >:: value >>:: type concatenate ( const T1 & t1 , const T2 & t2 , const Targs & ... targs ) noexcept ; template < typename T1 , typename T2 > typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value && internal :: IsCxxString < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCharArray < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa >>:: type operator + ( const T1 & t1 , const T2 & t2 ) noexcept ; struct TruncateToCapacity_t { explicit TruncateToCapacity_t () = default ; }; constexpr TruncateToCapacity_t TruncateToCapacity {}; template < uint64_t Capacity > class string { static_assert ( Capacity > 0U , \"The capacity of the fixed string must be greater than 0!\" ); public : constexpr string () noexcept = default ; string ( const string & other ) noexcept ; string ( string && other ) noexcept ; string & operator = ( const string & rhs ) noexcept ; string & operator = ( string && rhs ) noexcept ; template < uint64_t N > string ( const string < N >& other ) noexcept ; template < uint64_t N > string ( string < N >&& other ) noexcept ; template < uint64_t N > string & operator = ( const string < N >& rhs ) noexcept ; template < uint64_t N > string & operator = ( string < N >&& rhs ) noexcept ; template < uint64_t N > string ( const char ( & other )[ N ]) noexcept ; string ( TruncateToCapacity_t , const char * const other ) noexcept ; string ( TruncateToCapacity_t , const std :: string & other ) noexcept ; string ( TruncateToCapacity_t , const char * const other , const uint64_t count ) noexcept ; template < uint64_t N > string & operator = ( const char ( & rhs )[ N ]) noexcept ; template < uint64_t N > string & assign ( const string < N >& str ) noexcept ; template < uint64_t N > string & assign ( const char ( & str )[ N ]) noexcept ; bool unsafe_assign ( const char * const str ) noexcept ; bool unsafe_assign ( const std :: string & str ) noexcept ; template < uint64_t N > int64_t compare ( const string < N >& other ) const noexcept ; template < uint64_t N > bool operator == ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator != ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator < ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator <= ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator > ( const string < N >& rhs ) const noexcept ; template < uint64_t N > bool operator >= ( const string < N >& rhs ) const noexcept ; bool operator == ( const char * const rhs ) const noexcept ; bool operator != ( const char * const rhs ) const noexcept ; const char * c_str () const noexcept ; constexpr uint64_t size () const noexcept ; static constexpr uint64_t capacity () noexcept ; constexpr bool empty () const noexcept ; operator std :: string () const noexcept ; template < typename T > string & operator += ( const T & ) noexcept ; template < typename T > typename std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , string &>:: type append ( TruncateToCapacity_t , const T & t ) noexcept ; template < typename T > typename std :: enable_if < internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , bool >:: type unsafe_append ( const T & t ) noexcept ; iox :: cxx :: optional < string < Capacity >> substr ( const uint64_t pos , const uint64_t count ) const noexcept ; iox :: cxx :: optional < string < Capacity >> substr ( const uint64_t pos = 0U ) const noexcept ; template < typename T > typename std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t >>:: type find ( const T & t , const uint64_t pos = 0U ) const noexcept ; template < typename T > typename std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t >>:: type find_first_of ( const T & t , const uint64_t pos = 0U ) const noexcept ; template < typename T > typename std :: enable_if < std :: is_same < T , std :: string >:: value || internal :: IsCharArray < T >:: value || internal :: IsCxxString < T >:: value , iox :: cxx :: optional < uint64_t >>:: type find_last_of ( const T & t , const uint64_t pos = Capacity ) const noexcept ; template < uint64_t N > friend class string ; template < typename T1 , typename T2 > friend typename std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa >>:: type concatenate ( const T1 & t1 , const T2 & t2 ) noexcept ; private : template < uint64_t N > string & copy ( const string < N >& rhs ) noexcept ; template < uint64_t N > string & move ( string < N >&& rhs ) noexcept ; char m_rawstring [ Capacity + 1U ]{ '\\0' }; uint64_t m_rawstringSize { 0U }; }; template < uint64_t Capacity > inline bool operator == ( const std :: string & lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline bool operator == ( const string < Capacity >& lhs , const std :: string & rhs ) noexcept ; template < uint64_t Capacity > inline bool operator != ( const std :: string & lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline bool operator != ( const string < Capacity >& lhs , const std :: string & rhs ) noexcept ; template < uint64_t Capacity > inline bool operator == ( const char * const lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline bool operator != ( const char * const lhs , const string < Capacity >& rhs ) noexcept ; template < uint64_t Capacity > inline std :: ostream & operator << ( std :: ostream & stream , const string < Capacity >& str ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/string.inl\" #endif // IOX_HOOFS_CXX_STRING_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/thread_8hpp/","text":"iceoryx_hoofs/posix_wrapper/thread.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix Source code \ud83d\udd17 // Copyright (c) 2020 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP #define IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/platform/pthread.hpp\" namespace iox { namespace posix { constexpr uint64_t MAX_THREAD_NAME_LENGTH = 15U ; using ThreadName_t = cxx :: string < MAX_THREAD_NAME_LENGTH > ; void setThreadName ( pthread_t thread , const ThreadName_t & name ) noexcept ; ThreadName_t getThreadName ( pthread_t thread ) noexcept ; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/thread.hpp"},{"location":"API-reference/hoofs/Files/thread_8hpp/#iceoryx_hoofsposix_wrapperthreadhpp","text":"","title":"iceoryx_hoofs/posix_wrapper/thread.hpp"},{"location":"API-reference/hoofs/Files/thread_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Files/thread_8hpp/#source-code","text":"// Copyright (c) 2020 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP #define IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/platform/pthread.hpp\" namespace iox { namespace posix { constexpr uint64_t MAX_THREAD_NAME_LENGTH = 15U ; using ThreadName_t = cxx :: string < MAX_THREAD_NAME_LENGTH > ; void setThreadName ( pthread_t thread , const ThreadName_t & name ) noexcept ; ThreadName_t getThreadName ( pthread_t thread ) noexcept ; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_PTHREAD_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/timer_8hpp/","text":"iceoryx_hoofs/posix_wrapper/timer.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::posix iox::units::duration_literals Classes \ud83d\udd17 Name class iox::posix::Timer Interface for timers on POSIX operating systems. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP #define IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/platform/signal.hpp\" #include \"iceoryx_hoofs/platform/time.hpp\" #include <atomic> #include <condition_variable> #include <cstdint> #include <ctime> #include <functional> #include <limits> namespace iox { namespace posix { enum class TimerError { NO_ERROR , TIMER_NOT_INITIALIZED , NO_VALID_CALLBACK , KERNEL_ALLOC_FAILED , INVALID_ARGUMENTS , ALLOC_MEM_FAILED , NO_PERMISSION , INVALID_POINTER , NO_TIMER_TO_DELETE , TIMEOUT_IS_ZERO , INTERNAL_LOGIC_ERROR }; using namespace iox :: units :: duration_literals ; class Timer { public : enum class RunMode { ONCE , PERIODIC }; enum class CatchUpPolicy { SKIP_TO_NEXT_BEAT , IMMEDIATE , TERMINATE }; private : static constexpr size_t SIZE_OF_COMBINDED_INDEX_AND_DESCRIPTOR = sizeof ( uint32_t ); static constexpr size_t SIZE_OF_SIGVAL_INT = sizeof ( int ); static_assert ( SIZE_OF_SIGVAL_INT >= SIZE_OF_COMBINDED_INDEX_AND_DESCRIPTOR , \"size of sigval_int is to low\" ); static constexpr uint32_t MAX_NUMBER_OF_CALLBACK_HANDLES = 100u ; static_assert ( MAX_NUMBER_OF_CALLBACK_HANDLES <= std :: numeric_limits < uint8_t >:: max (), \"number of callback handles exceeds max index value\" ); class OsTimer ; struct OsTimerCallbackHandle { static constexpr uint32_t MAX_DESCRIPTOR_VALUE {( 1u << 24u ) - 1u }; static sigval indexAndDescriptorToSigval ( uint8_t index , uint32_t descriptor ) noexcept ; static uint8_t sigvalToIndex ( sigval intVal ) noexcept ; static uint32_t sigvalToDescriptor ( sigval intVal ) noexcept ; void incrementDescriptor () noexcept ; std :: mutex m_accessMutex ; std :: atomic < uint32_t > m_descriptor { 0u }; // must be operator= otherwise it is undefined, see https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT std :: atomic_flag m_callbackIsAboutToBeExecuted = ATOMIC_FLAG_INIT ; std :: atomic < bool > m_inUse { false }; std :: atomic < bool > m_isTimerActive { false }; std :: atomic < uint64_t > m_timerInvocationCounter { 0u }; CatchUpPolicy m_catchUpPolicy { CatchUpPolicy :: TERMINATE }; OsTimer * m_timer { nullptr }; }; class OsTimer { #ifdef __QNX__ static constexpr timer_t INVALID_TIMER_ID = 0 ; #else static constexpr timer_t INVALID_TIMER_ID = nullptr ; #endif public : static void callbackHelper ( sigval data ) noexcept ; OsTimer ( const units :: Duration timeToWait , const std :: function < void () >& callback ) noexcept ; OsTimer ( const OsTimer & ) = delete ; OsTimer ( OsTimer && ) = delete ; OsTimer & operator = ( const OsTimer & ) = delete ; OsTimer & operator = ( OsTimer && ) = delete ; virtual ~ OsTimer () noexcept ; cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; cxx :: expected < TimerError > stop () noexcept ; cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; // @brief Returns the time until the timer expires the next time cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () noexcept ; cxx :: expected < uint64_t , TimerError > getOverruns () noexcept ; bool hasError () const noexcept ; TimerError getError () const noexcept ; private : void executeCallback () noexcept ; private : units :: Duration m_timeToWait ; std :: function < void () > m_callback ; timer_t m_timerId { INVALID_TIMER_ID }; uint8_t m_callbackHandleIndex { 0u }; bool m_isInitialized { false }; TimerError m_errorValue { TimerError :: NO_ERROR }; static OsTimerCallbackHandle s_callbackHandlePool [ MAX_NUMBER_OF_CALLBACK_HANDLES ]; }; public : Timer ( const units :: Duration timeToWait ) noexcept ; Timer ( const units :: Duration timeToWait , const std :: function < void () >& callback ) noexcept ; static cxx :: expected < units :: Duration , TimerError > now () noexcept ; Timer ( const Timer & other ) = delete ; Timer ( Timer && other ) = delete ; Timer & operator = ( const Timer & other ) = delete ; Timer & operator = ( Timer && other ) = delete ; virtual ~ Timer () noexcept = default ; cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; cxx :: expected < TimerError > stop () noexcept ; cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; // @brief Returns the time until the timer expires the next time cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () noexcept ; cxx :: expected < uint64_t , TimerError > getOverruns () noexcept ; bool hasError () const noexcept ; TimerError getError () const noexcept ; private : cxx :: optional < OsTimer > m_osTimer ; static cxx :: error < TimerError > createErrorFromErrno ( const int32_t errnum ) noexcept ; units :: Duration m_timeToWait ; units :: Duration m_creationTime ; TimerError m_errorValue { TimerError :: NO_ERROR }; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_hoofs/posix_wrapper/timer.hpp"},{"location":"API-reference/hoofs/Files/timer_8hpp/#iceoryx_hoofsposix_wrappertimerhpp","text":"","title":"iceoryx_hoofs/posix_wrapper/timer.hpp"},{"location":"API-reference/hoofs/Files/timer_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::posix iox::units::duration_literals","title":"Namespaces"},{"location":"API-reference/hoofs/Files/timer_8hpp/#classes","text":"Name class iox::posix::Timer Interface for timers on POSIX operating systems.","title":"Classes"},{"location":"API-reference/hoofs/Files/timer_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP #define IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/design_pattern/creation.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/platform/signal.hpp\" #include \"iceoryx_hoofs/platform/time.hpp\" #include <atomic> #include <condition_variable> #include <cstdint> #include <ctime> #include <functional> #include <limits> namespace iox { namespace posix { enum class TimerError { NO_ERROR , TIMER_NOT_INITIALIZED , NO_VALID_CALLBACK , KERNEL_ALLOC_FAILED , INVALID_ARGUMENTS , ALLOC_MEM_FAILED , NO_PERMISSION , INVALID_POINTER , NO_TIMER_TO_DELETE , TIMEOUT_IS_ZERO , INTERNAL_LOGIC_ERROR }; using namespace iox :: units :: duration_literals ; class Timer { public : enum class RunMode { ONCE , PERIODIC }; enum class CatchUpPolicy { SKIP_TO_NEXT_BEAT , IMMEDIATE , TERMINATE }; private : static constexpr size_t SIZE_OF_COMBINDED_INDEX_AND_DESCRIPTOR = sizeof ( uint32_t ); static constexpr size_t SIZE_OF_SIGVAL_INT = sizeof ( int ); static_assert ( SIZE_OF_SIGVAL_INT >= SIZE_OF_COMBINDED_INDEX_AND_DESCRIPTOR , \"size of sigval_int is to low\" ); static constexpr uint32_t MAX_NUMBER_OF_CALLBACK_HANDLES = 100u ; static_assert ( MAX_NUMBER_OF_CALLBACK_HANDLES <= std :: numeric_limits < uint8_t >:: max (), \"number of callback handles exceeds max index value\" ); class OsTimer ; struct OsTimerCallbackHandle { static constexpr uint32_t MAX_DESCRIPTOR_VALUE {( 1u << 24u ) - 1u }; static sigval indexAndDescriptorToSigval ( uint8_t index , uint32_t descriptor ) noexcept ; static uint8_t sigvalToIndex ( sigval intVal ) noexcept ; static uint32_t sigvalToDescriptor ( sigval intVal ) noexcept ; void incrementDescriptor () noexcept ; std :: mutex m_accessMutex ; std :: atomic < uint32_t > m_descriptor { 0u }; // must be operator= otherwise it is undefined, see https://en.cppreference.com/w/cpp/atomic/ATOMIC_FLAG_INIT std :: atomic_flag m_callbackIsAboutToBeExecuted = ATOMIC_FLAG_INIT ; std :: atomic < bool > m_inUse { false }; std :: atomic < bool > m_isTimerActive { false }; std :: atomic < uint64_t > m_timerInvocationCounter { 0u }; CatchUpPolicy m_catchUpPolicy { CatchUpPolicy :: TERMINATE }; OsTimer * m_timer { nullptr }; }; class OsTimer { #ifdef __QNX__ static constexpr timer_t INVALID_TIMER_ID = 0 ; #else static constexpr timer_t INVALID_TIMER_ID = nullptr ; #endif public : static void callbackHelper ( sigval data ) noexcept ; OsTimer ( const units :: Duration timeToWait , const std :: function < void () >& callback ) noexcept ; OsTimer ( const OsTimer & ) = delete ; OsTimer ( OsTimer && ) = delete ; OsTimer & operator = ( const OsTimer & ) = delete ; OsTimer & operator = ( OsTimer && ) = delete ; virtual ~ OsTimer () noexcept ; cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; cxx :: expected < TimerError > stop () noexcept ; cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; // @brief Returns the time until the timer expires the next time cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () noexcept ; cxx :: expected < uint64_t , TimerError > getOverruns () noexcept ; bool hasError () const noexcept ; TimerError getError () const noexcept ; private : void executeCallback () noexcept ; private : units :: Duration m_timeToWait ; std :: function < void () > m_callback ; timer_t m_timerId { INVALID_TIMER_ID }; uint8_t m_callbackHandleIndex { 0u }; bool m_isInitialized { false }; TimerError m_errorValue { TimerError :: NO_ERROR }; static OsTimerCallbackHandle s_callbackHandlePool [ MAX_NUMBER_OF_CALLBACK_HANDLES ]; }; public : Timer ( const units :: Duration timeToWait ) noexcept ; Timer ( const units :: Duration timeToWait , const std :: function < void () >& callback ) noexcept ; static cxx :: expected < units :: Duration , TimerError > now () noexcept ; Timer ( const Timer & other ) = delete ; Timer ( Timer && other ) = delete ; Timer & operator = ( const Timer & other ) = delete ; Timer & operator = ( Timer && other ) = delete ; virtual ~ Timer () noexcept = default ; cxx :: expected < TimerError > start ( const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; cxx :: expected < TimerError > stop () noexcept ; cxx :: expected < TimerError > restart ( const units :: Duration timeToWait , const RunMode runMode , const CatchUpPolicy catchUpPolicy ) noexcept ; // @brief Returns the time until the timer expires the next time cxx :: expected < units :: Duration , TimerError > timeUntilExpiration () noexcept ; cxx :: expected < uint64_t , TimerError > getOverruns () noexcept ; bool hasError () const noexcept ; TimerError getError () const noexcept ; private : cxx :: optional < OsTimer > m_osTimer ; static cxx :: error < TimerError > createErrorFromErrno ( const int32_t errnum ) noexcept ; units :: Duration m_timeToWait ; units :: Duration m_creationTime ; TimerError m_errorValue { TimerError :: NO_ERROR }; }; } // namespace posix } // namespace iox #endif // IOX_HOOFS_POSIX_WRAPPER_TIMER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/","text":"iceoryx_hoofs/cxx/type_traits.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name struct iox::cxx::add_const_conditionally Conditionally add const to type T if C has the const qualifier. struct iox::cxx::add_const_conditionally< T, const C > struct iox::cxx::is_invocable Verifies whether the passed Callable type is in fact invocable with the given arguments. struct iox::cxx::is_invocable_r Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. struct iox::cxx::is_function_pointer Check whether T is a function pointer with arbitrary signature. struct iox::cxx::is_function_pointer< ReturnType(*)(ArgTypes...)> Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_TYPE_TRAITS_HPP #define IOX_HOOFS_CXX_TYPE_TRAITS_HPP #include <type_traits> namespace iox { namespace cxx { template < typename T , typename C > struct add_const_conditionally { using type = T ; }; template < typename T , typename C > struct add_const_conditionally < T , const C > { using type = const T ; }; template < typename T , typename C > using add_const_conditionally_t = typename add_const_conditionally < T , C >:: type ; template < typename > constexpr bool always_false_v = false ; // windows defines __cplusplus as 199711L #if __cplusplus < 201703L && !defined(_WIN32) template < typename C , typename ... Cargs > using invoke_result = std :: result_of < C ( Cargs ...) > ; #elif __cplusplus >= 201703L || defined(_WIN32) template < typename C , typename ... Cargs > using invoke_result = std :: invoke_result < C , Cargs ... > ; #endif template < typename Callable , typename ... ArgTypes > struct is_invocable { // This variant is chosen when Callable(ArgTypes) successfully resolves to a valid type, i.e. is invocable. template < typename C , typename ... As > static constexpr std :: true_type test ( typename cxx :: invoke_result < C , As ... >:: type * ) noexcept { return {}; } // This is chosen if Callable(ArgTypes) does not resolve to a valid type. template < typename C , typename ... As > static constexpr std :: false_type test (...) noexcept { return {}; } // Test with nullptr as this can stand in for a pointer to any type. static constexpr bool value = decltype ( test < Callable , ArgTypes ... > ( nullptr )) :: value ; }; template < typename ReturnType , typename Callable , typename ... ArgTypes > struct is_invocable_r { template < typename C , typename ... As > static constexpr std :: true_type test ( std :: enable_if_t < std :: is_convertible < typename cxx :: invoke_result < C , As ... >:: type , ReturnType >:: value >* ) noexcept { return {}; } template < typename C , typename ... As > static constexpr std :: false_type test (...) noexcept { return {}; } // Test with nullptr as this can stand in for a pointer to any type. static constexpr bool value = decltype ( test < Callable , ArgTypes ... > ( nullptr )) :: value ; }; template < typename T > struct is_function_pointer : std :: false_type { }; template < typename ReturnType , typename ... ArgTypes > struct is_function_pointer < ReturnType ( * )( ArgTypes ...) > : std :: true_type { }; template < typename ... > using void_t = void ; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_CXX_TYPE_TRAITS_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/type_traits.hpp"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#iceoryx_hoofscxxtype_traitshpp","text":"","title":"iceoryx_hoofs/cxx/type_traits.hpp"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#classes","text":"Name struct iox::cxx::add_const_conditionally Conditionally add const to type T if C has the const qualifier. struct iox::cxx::add_const_conditionally< T, const C > struct iox::cxx::is_invocable Verifies whether the passed Callable type is in fact invocable with the given arguments. struct iox::cxx::is_invocable_r Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. struct iox::cxx::is_function_pointer Check whether T is a function pointer with arbitrary signature. struct iox::cxx::is_function_pointer< ReturnType(*)(ArgTypes...)>","title":"Classes"},{"location":"API-reference/hoofs/Files/type__traits_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_TYPE_TRAITS_HPP #define IOX_HOOFS_CXX_TYPE_TRAITS_HPP #include <type_traits> namespace iox { namespace cxx { template < typename T , typename C > struct add_const_conditionally { using type = T ; }; template < typename T , typename C > struct add_const_conditionally < T , const C > { using type = const T ; }; template < typename T , typename C > using add_const_conditionally_t = typename add_const_conditionally < T , C >:: type ; template < typename > constexpr bool always_false_v = false ; // windows defines __cplusplus as 199711L #if __cplusplus < 201703L && !defined(_WIN32) template < typename C , typename ... Cargs > using invoke_result = std :: result_of < C ( Cargs ...) > ; #elif __cplusplus >= 201703L || defined(_WIN32) template < typename C , typename ... Cargs > using invoke_result = std :: invoke_result < C , Cargs ... > ; #endif template < typename Callable , typename ... ArgTypes > struct is_invocable { // This variant is chosen when Callable(ArgTypes) successfully resolves to a valid type, i.e. is invocable. template < typename C , typename ... As > static constexpr std :: true_type test ( typename cxx :: invoke_result < C , As ... >:: type * ) noexcept { return {}; } // This is chosen if Callable(ArgTypes) does not resolve to a valid type. template < typename C , typename ... As > static constexpr std :: false_type test (...) noexcept { return {}; } // Test with nullptr as this can stand in for a pointer to any type. static constexpr bool value = decltype ( test < Callable , ArgTypes ... > ( nullptr )) :: value ; }; template < typename ReturnType , typename Callable , typename ... ArgTypes > struct is_invocable_r { template < typename C , typename ... As > static constexpr std :: true_type test ( std :: enable_if_t < std :: is_convertible < typename cxx :: invoke_result < C , As ... >:: type , ReturnType >:: value >* ) noexcept { return {}; } template < typename C , typename ... As > static constexpr std :: false_type test (...) noexcept { return {}; } // Test with nullptr as this can stand in for a pointer to any type. static constexpr bool value = decltype ( test < Callable , ArgTypes ... > ( nullptr )) :: value ; }; template < typename T > struct is_function_pointer : std :: false_type { }; template < typename ReturnType , typename ... ArgTypes > struct is_function_pointer < ReturnType ( * )( ArgTypes ...) > : std :: true_type { }; template < typename ... > using void_t = void ; } // namespace cxx } // namespace iox #endif // IOX_HOOFS_CXX_TYPE_TRAITS_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/types_8hpp/","text":"iceoryx_hoofs/cxx/types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_TYPES_HPP #define IOX_HOOFS_CXX_TYPES_HPP #include <cstdint> namespace iox { namespace cxx { using byte_t = uint8_t ; } } // namespace iox #endif // IOX_HOOFS_CXX_TYPES_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/types.hpp"},{"location":"API-reference/hoofs/Files/types_8hpp/#iceoryx_hoofscxxtypeshpp","text":"","title":"iceoryx_hoofs/cxx/types.hpp"},{"location":"API-reference/hoofs/Files/types_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/types_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_TYPES_HPP #define IOX_HOOFS_CXX_TYPES_HPP #include <cstdint> namespace iox { namespace cxx { using byte_t = uint8_t ; } } // namespace iox #endif // IOX_HOOFS_CXX_TYPES_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/","text":"iceoryx_hoofs/cxx/unique_ptr.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::unique_ptr The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_UNIQUE_PTR_HPP #define IOX_HOOFS_CXX_UNIQUE_PTR_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" namespace iox { namespace cxx { template < typename T > class unique_ptr { public : unique_ptr () = delete ; unique_ptr ( function_ref < void ( T * ) >&& deleter ) noexcept ; unique_ptr ( T * const ptr , function_ref < void ( T * ) >&& deleter ) noexcept ; unique_ptr ( const unique_ptr & other ) = delete ; unique_ptr & operator = ( const unique_ptr & ) = delete ; unique_ptr ( unique_ptr && rhs ) noexcept ; unique_ptr & operator = ( unique_ptr && rhs ) noexcept ; ~ unique_ptr () noexcept ; unique_ptr < T >& operator = ( std :: nullptr_t ) noexcept ; T * operator -> () noexcept ; const T * operator -> () const noexcept ; explicit operator bool () const noexcept ; T * get () noexcept ; const T * get () const noexcept ; T * release () noexcept ; void reset ( T * const ptr = nullptr ) noexcept ; void swap ( unique_ptr & other ) noexcept ; private : T * m_ptr = nullptr ; function_ref < void ( T * const ) > m_deleter ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/unique_ptr.inl\" #endif // IOX_HOOFS_CXX_UNIQUE_PTR_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/unique_ptr.hpp"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#iceoryx_hoofscxxunique_ptrhpp","text":"","title":"iceoryx_hoofs/cxx/unique_ptr.hpp"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#classes","text":"Name class iox::cxx::unique_ptr The unique_ptr class is a heap-less unique ptr implementation, unlike the STL.","title":"Classes"},{"location":"API-reference/hoofs/Files/unique__ptr_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_UNIQUE_PTR_HPP #define IOX_HOOFS_CXX_UNIQUE_PTR_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" namespace iox { namespace cxx { template < typename T > class unique_ptr { public : unique_ptr () = delete ; unique_ptr ( function_ref < void ( T * ) >&& deleter ) noexcept ; unique_ptr ( T * const ptr , function_ref < void ( T * ) >&& deleter ) noexcept ; unique_ptr ( const unique_ptr & other ) = delete ; unique_ptr & operator = ( const unique_ptr & ) = delete ; unique_ptr ( unique_ptr && rhs ) noexcept ; unique_ptr & operator = ( unique_ptr && rhs ) noexcept ; ~ unique_ptr () noexcept ; unique_ptr < T >& operator = ( std :: nullptr_t ) noexcept ; T * operator -> () noexcept ; const T * operator -> () const noexcept ; explicit operator bool () const noexcept ; T * get () noexcept ; const T * get () const noexcept ; T * release () noexcept ; void reset ( T * const ptr = nullptr ) noexcept ; void swap ( unique_ptr & other ) noexcept ; private : T * m_ptr = nullptr ; function_ref < void ( T * const ) > m_deleter ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/unique_ptr.inl\" #endif // IOX_HOOFS_CXX_UNIQUE_PTR_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/variant_8hpp/","text":"iceoryx_hoofs/cxx/variant.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name struct iox::cxx::in_place_index helper struct to perform an emplacement at a predefined index in the constructor of a variant struct iox::cxx::in_place_type helper struct to perform an emplacement of a predefined type in in the constructor of a variant class iox::cxx::variant Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_VARIANT_HPP #define IOX_HOOFS_CXX_VARIANT_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/internal/cxx/variant_internal.hpp\" #include <cstdint> #include <iostream> #include <limits> #include <type_traits> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { template < uint64_t N > struct in_place_index { static constexpr uint64_t value = N ; }; template < typename T > struct in_place_type { using type = T ; }; static constexpr uint64_t INVALID_VARIANT_INDEX = std :: numeric_limits < uint64_t >:: max (); template < typename ... Types > class variant { private : static constexpr uint64_t TYPE_SIZE = algorithm :: max ( sizeof ( Types )...); public : constexpr variant () noexcept = default ; template < uint64_t N , typename ... CTorArguments > constexpr variant ( const in_place_index < N >& index , CTorArguments && ... args ) noexcept ; template < typename T , typename ... CTorArguments > constexpr variant ( const in_place_type < T >& type , CTorArguments && ... args ) noexcept ; template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , variant >:: value > , typename std :: enable_if_t <! internal :: is_in_place_index < std :: decay_t < T >>:: value , bool > = false , typename std :: enable_if_t <! internal :: is_in_place_type < std :: decay_t < T >>:: value , bool > = false > constexpr variant ( T && arg ) noexcept ; constexpr variant ( const variant & rhs ) noexcept ; constexpr variant & operator = ( const variant & rhs ) noexcept ; constexpr variant ( variant && rhs ) noexcept ; constexpr variant & operator = ( variant && rhs ) noexcept ; ~ variant () noexcept ; template < typename T > typename std :: enable_if <! std :: is_same < T , variant < Types ... >&>:: value , variant < Types ... >>:: type & operator = ( T && rhs ) noexcept ; template < uint64_t TypeIndex , typename ... CTorArguments > bool emplace_at_index ( CTorArguments && ... args ) noexcept ; template < typename T , typename ... CTorArguments > bool emplace ( CTorArguments && ... args ) noexcept ; template < uint64_t TypeIndex > typename internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () noexcept ; template < uint64_t TypeIndex > const typename internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () const noexcept ; template < typename T > const T * get () const noexcept ; template < typename T > T * get () noexcept ; template < typename T > T * get_if ( T * defaultValue ) noexcept ; template < typename T > const T * get_if ( const T * defaultValue ) const noexcept ; constexpr uint64_t index () const noexcept ; private : alignas ( algorithm :: max ( alignof ( Types )...)) internal :: byte_t m_storage [ TYPE_SIZE ]{ 0u }; uint64_t m_type_index = INVALID_VARIANT_INDEX ; private : template < typename T > bool has_bad_variant_element_access () const noexcept ; static void error_message ( const char * source , const char * msg ) noexcept ; void call_element_destructor () noexcept ; }; template < typename T , typename ... Types > constexpr bool holds_alternative ( const variant < Types ... >& variant ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/variant.inl\" #endif // IOX_HOOFS_CXX_VARIANT_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/variant.hpp"},{"location":"API-reference/hoofs/Files/variant_8hpp/#iceoryx_hoofscxxvarianthpp","text":"","title":"iceoryx_hoofs/cxx/variant.hpp"},{"location":"API-reference/hoofs/Files/variant_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/variant_8hpp/#classes","text":"Name struct iox::cxx::in_place_index helper struct to perform an emplacement at a predefined index in the constructor of a variant struct iox::cxx::in_place_type helper struct to perform an emplacement of a predefined type in in the constructor of a variant class iox::cxx::variant Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions.","title":"Classes"},{"location":"API-reference/hoofs/Files/variant_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_VARIANT_HPP #define IOX_HOOFS_CXX_VARIANT_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/internal/cxx/variant_internal.hpp\" #include <cstdint> #include <iostream> #include <limits> #include <type_traits> #include \"iceoryx_hoofs/platform/platform_correction.hpp\" namespace iox { namespace cxx { template < uint64_t N > struct in_place_index { static constexpr uint64_t value = N ; }; template < typename T > struct in_place_type { using type = T ; }; static constexpr uint64_t INVALID_VARIANT_INDEX = std :: numeric_limits < uint64_t >:: max (); template < typename ... Types > class variant { private : static constexpr uint64_t TYPE_SIZE = algorithm :: max ( sizeof ( Types )...); public : constexpr variant () noexcept = default ; template < uint64_t N , typename ... CTorArguments > constexpr variant ( const in_place_index < N >& index , CTorArguments && ... args ) noexcept ; template < typename T , typename ... CTorArguments > constexpr variant ( const in_place_type < T >& type , CTorArguments && ... args ) noexcept ; template < typename T , typename = std :: enable_if_t <! std :: is_same < std :: decay_t < T > , variant >:: value > , typename std :: enable_if_t <! internal :: is_in_place_index < std :: decay_t < T >>:: value , bool > = false , typename std :: enable_if_t <! internal :: is_in_place_type < std :: decay_t < T >>:: value , bool > = false > constexpr variant ( T && arg ) noexcept ; constexpr variant ( const variant & rhs ) noexcept ; constexpr variant & operator = ( const variant & rhs ) noexcept ; constexpr variant ( variant && rhs ) noexcept ; constexpr variant & operator = ( variant && rhs ) noexcept ; ~ variant () noexcept ; template < typename T > typename std :: enable_if <! std :: is_same < T , variant < Types ... >&>:: value , variant < Types ... >>:: type & operator = ( T && rhs ) noexcept ; template < uint64_t TypeIndex , typename ... CTorArguments > bool emplace_at_index ( CTorArguments && ... args ) noexcept ; template < typename T , typename ... CTorArguments > bool emplace ( CTorArguments && ... args ) noexcept ; template < uint64_t TypeIndex > typename internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () noexcept ; template < uint64_t TypeIndex > const typename internal :: get_type_at_index < 0 , TypeIndex , Types ... >:: type * get_at_index () const noexcept ; template < typename T > const T * get () const noexcept ; template < typename T > T * get () noexcept ; template < typename T > T * get_if ( T * defaultValue ) noexcept ; template < typename T > const T * get_if ( const T * defaultValue ) const noexcept ; constexpr uint64_t index () const noexcept ; private : alignas ( algorithm :: max ( alignof ( Types )...)) internal :: byte_t m_storage [ TYPE_SIZE ]{ 0u }; uint64_t m_type_index = INVALID_VARIANT_INDEX ; private : template < typename T > bool has_bad_variant_element_access () const noexcept ; static void error_message ( const char * source , const char * msg ) noexcept ; void call_element_destructor () noexcept ; }; template < typename T , typename ... Types > constexpr bool holds_alternative ( const variant < Types ... >& variant ) noexcept ; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/variant.inl\" #endif // IOX_HOOFS_CXX_VARIANT_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/","text":"iceoryx_hoofs/cxx/variant_queue.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::VariantQueue wrapper of multiple fifo's Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_VARIANT_QUEUE_HPP #define IOX_HOOFS_CXX_VARIANT_QUEUE_HPP #include \"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/variant.hpp\" #include \"iceoryx_hoofs/internal/concurrent/fifo.hpp\" #include \"iceoryx_hoofs/internal/concurrent/sofi.hpp\" #include <cstdint> namespace iox { namespace cxx { enum class VariantQueueTypes : uint64_t { FiFo_SingleProducerSingleConsumer = 0 , SoFi_SingleProducerSingleConsumer = 1 , FiFo_MultiProducerSingleConsumer = 2 , SoFi_MultiProducerSingleConsumer = 3 }; // remark: we need to consider to support the non-resizable queue as well // since it should have performance benefits if resize is not actually needed // for now we just use the most general variant, which allows resizing template < typename ValueType , uint64_t Capacity > class VariantQueue { public : using fifo_t = variant < concurrent :: FiFo < ValueType , Capacity > , concurrent :: SoFi < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity >> ; VariantQueue ( const VariantQueueTypes type ) noexcept ; optional < ValueType > push ( const ValueType & value ) noexcept ; optional < ValueType > pop () noexcept ; bool empty () const noexcept ; uint64_t size () noexcept ; bool setCapacity ( const uint64_t newCapacity ) noexcept ; uint64_t capacity () const noexcept ; fifo_t & getUnderlyingFiFo () noexcept ; private : VariantQueueTypes m_type ; fifo_t m_fifo ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/variant_queue.inl\" #endif // IOX_HOOFS_CXX_VARIANT_QUEUE_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/variant_queue.hpp"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#iceoryx_hoofscxxvariant_queuehpp","text":"","title":"iceoryx_hoofs/cxx/variant_queue.hpp"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#classes","text":"Name class iox::cxx::VariantQueue wrapper of multiple fifo's","title":"Classes"},{"location":"API-reference/hoofs/Files/variant__queue_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_VARIANT_QUEUE_HPP #define IOX_HOOFS_CXX_VARIANT_QUEUE_HPP #include \"iceoryx_hoofs/concurrent/resizeable_lockfree_queue.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/variant.hpp\" #include \"iceoryx_hoofs/internal/concurrent/fifo.hpp\" #include \"iceoryx_hoofs/internal/concurrent/sofi.hpp\" #include <cstdint> namespace iox { namespace cxx { enum class VariantQueueTypes : uint64_t { FiFo_SingleProducerSingleConsumer = 0 , SoFi_SingleProducerSingleConsumer = 1 , FiFo_MultiProducerSingleConsumer = 2 , SoFi_MultiProducerSingleConsumer = 3 }; // remark: we need to consider to support the non-resizable queue as well // since it should have performance benefits if resize is not actually needed // for now we just use the most general variant, which allows resizing template < typename ValueType , uint64_t Capacity > class VariantQueue { public : using fifo_t = variant < concurrent :: FiFo < ValueType , Capacity > , concurrent :: SoFi < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity > , concurrent :: ResizeableLockFreeQueue < ValueType , Capacity >> ; VariantQueue ( const VariantQueueTypes type ) noexcept ; optional < ValueType > push ( const ValueType & value ) noexcept ; optional < ValueType > pop () noexcept ; bool empty () const noexcept ; uint64_t size () noexcept ; bool setCapacity ( const uint64_t newCapacity ) noexcept ; uint64_t capacity () const noexcept ; fifo_t & getUnderlyingFiFo () noexcept ; private : VariantQueueTypes m_type ; fifo_t m_fifo ; }; } // namespace cxx } // namespace iox #include \"iceoryx_hoofs/internal/cxx/variant_queue.inl\" #endif // IOX_HOOFS_CXX_VARIANT_QUEUE_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Files/vector_8hpp/","text":"iceoryx_hoofs/cxx/vector.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox building block to easily create free function for logging in a library context iox::cxx Classes \ud83d\udd17 Name class iox::cxx::vector C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. Functions \ud83d\udd17 Name template <typename T ,uint64_t CapacityLeft,uint64_t CapacityRight> bool operator== (const iox::cxx::vector < T, CapacityLeft > & lhs, const iox::cxx::vector < T, CapacityRight > & rhs) template <typename T ,uint64_t CapacityLeft,uint64_t CapacityRight> bool operator!= (const iox::cxx::vector < T, CapacityLeft > & lhs, const iox::cxx::vector < T, CapacityRight > & rhs) Functions Documentation \ud83d\udd17 function operator== \ud83d\udd17 template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator == ( const iox :: cxx :: vector < T , CapacityLeft > & lhs , const iox :: cxx :: vector < T , CapacityRight > & rhs ) function operator!= \ud83d\udd17 template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator != ( const iox :: cxx :: vector < T , CapacityLeft > & lhs , const iox :: cxx :: vector < T , CapacityRight > & rhs ) Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_VECTOR_HPP #define IOX_HOOFS_CXX_VECTOR_HPP #include \"iceoryx_hoofs/cxx/requires.hpp\" #include <algorithm> #include <cstdint> #include <cstdio> #include <utility> namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class vector { public : using value_type = T ; using iterator = T * ; using const_iterator = const T * ; vector () noexcept = default ; vector ( const uint64_t count , const T & value ) noexcept ; vector ( const uint64_t count ) noexcept ; vector ( const vector & rhs ) noexcept ; vector ( vector && rhs ) noexcept ; ~ vector () noexcept ; vector & operator = ( const vector & rhs ) noexcept ; vector & operator = ( vector && rhs ) noexcept ; iterator begin () noexcept ; const_iterator begin () const noexcept ; iterator end () noexcept ; const_iterator end () const noexcept ; T * data () noexcept ; const T * data () const noexcept ; // is undefined if the element at index does not exist. T & at ( const uint64_t index ) noexcept ; const T & at ( const uint64_t index ) const noexcept ; // is undefined if the element at index does not exist. T & operator []( const uint64_t index ) noexcept ; const T & operator []( const uint64_t index ) const noexcept ; T & front () noexcept ; const T & front () const noexcept ; T & back () noexcept ; const T & back () const noexcept ; uint64_t capacity () const noexcept ; uint64_t size () const noexcept ; bool empty () const noexcept ; void clear () noexcept ; template < typename ... Targs > bool resize ( const uint64_t count , const Targs & ... args ) noexcept ; template < typename ... Targs > bool emplace ( const uint64_t position , Targs && ... args ) noexcept ; template < typename ... Targs > bool emplace_back ( Targs && ... args ) noexcept ; bool push_back ( const T & value ) noexcept ; bool push_back ( T && value ) noexcept ; bool pop_back () noexcept ; iterator erase ( iterator position ) noexcept ; private : using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; uint64_t m_size = 0u ; }; } // namespace cxx } // namespace iox template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator == ( const iox :: cxx :: vector < T , CapacityLeft >& lhs , const iox :: cxx :: vector < T , CapacityRight >& rhs ) noexcept ; template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator != ( const iox :: cxx :: vector < T , CapacityLeft >& lhs , const iox :: cxx :: vector < T , CapacityRight >& rhs ) noexcept ; #include \"iceoryx_hoofs/internal/cxx/vector.inl\" #endif // IOX_HOOFS_CXX_VECTOR_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"iceoryx_hoofs/cxx/vector.hpp"},{"location":"API-reference/hoofs/Files/vector_8hpp/#iceoryx_hoofscxxvectorhpp","text":"","title":"iceoryx_hoofs/cxx/vector.hpp"},{"location":"API-reference/hoofs/Files/vector_8hpp/#namespaces","text":"Name iox building block to easily create free function for logging in a library context iox::cxx","title":"Namespaces"},{"location":"API-reference/hoofs/Files/vector_8hpp/#classes","text":"Name class iox::cxx::vector C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory.","title":"Classes"},{"location":"API-reference/hoofs/Files/vector_8hpp/#functions","text":"Name template <typename T ,uint64_t CapacityLeft,uint64_t CapacityRight> bool operator== (const iox::cxx::vector < T, CapacityLeft > & lhs, const iox::cxx::vector < T, CapacityRight > & rhs) template <typename T ,uint64_t CapacityLeft,uint64_t CapacityRight> bool operator!= (const iox::cxx::vector < T, CapacityLeft > & lhs, const iox::cxx::vector < T, CapacityRight > & rhs)","title":"Functions"},{"location":"API-reference/hoofs/Files/vector_8hpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Files/vector_8hpp/#function-operator","text":"template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator == ( const iox :: cxx :: vector < T , CapacityLeft > & lhs , const iox :: cxx :: vector < T , CapacityRight > & rhs )","title":"function operator=="},{"location":"API-reference/hoofs/Files/vector_8hpp/#function-operator_1","text":"template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator != ( const iox :: cxx :: vector < T , CapacityLeft > & lhs , const iox :: cxx :: vector < T , CapacityRight > & rhs )","title":"function operator!="},{"location":"API-reference/hoofs/Files/vector_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_HOOFS_CXX_VECTOR_HPP #define IOX_HOOFS_CXX_VECTOR_HPP #include \"iceoryx_hoofs/cxx/requires.hpp\" #include <algorithm> #include <cstdint> #include <cstdio> #include <utility> namespace iox { namespace cxx { template < typename T , uint64_t Capacity > class vector { public : using value_type = T ; using iterator = T * ; using const_iterator = const T * ; vector () noexcept = default ; vector ( const uint64_t count , const T & value ) noexcept ; vector ( const uint64_t count ) noexcept ; vector ( const vector & rhs ) noexcept ; vector ( vector && rhs ) noexcept ; ~ vector () noexcept ; vector & operator = ( const vector & rhs ) noexcept ; vector & operator = ( vector && rhs ) noexcept ; iterator begin () noexcept ; const_iterator begin () const noexcept ; iterator end () noexcept ; const_iterator end () const noexcept ; T * data () noexcept ; const T * data () const noexcept ; // is undefined if the element at index does not exist. T & at ( const uint64_t index ) noexcept ; const T & at ( const uint64_t index ) const noexcept ; // is undefined if the element at index does not exist. T & operator []( const uint64_t index ) noexcept ; const T & operator []( const uint64_t index ) const noexcept ; T & front () noexcept ; const T & front () const noexcept ; T & back () noexcept ; const T & back () const noexcept ; uint64_t capacity () const noexcept ; uint64_t size () const noexcept ; bool empty () const noexcept ; void clear () noexcept ; template < typename ... Targs > bool resize ( const uint64_t count , const Targs & ... args ) noexcept ; template < typename ... Targs > bool emplace ( const uint64_t position , Targs && ... args ) noexcept ; template < typename ... Targs > bool emplace_back ( Targs && ... args ) noexcept ; bool push_back ( const T & value ) noexcept ; bool push_back ( T && value ) noexcept ; bool pop_back () noexcept ; iterator erase ( iterator position ) noexcept ; private : using element_t = uint8_t [ sizeof ( T )]; alignas ( T ) element_t m_data [ Capacity ]; uint64_t m_size = 0u ; }; } // namespace cxx } // namespace iox template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator == ( const iox :: cxx :: vector < T , CapacityLeft >& lhs , const iox :: cxx :: vector < T , CapacityRight >& rhs ) noexcept ; template < typename T , uint64_t CapacityLeft , uint64_t CapacityRight > bool operator != ( const iox :: cxx :: vector < T , CapacityLeft >& lhs , const iox :: cxx :: vector < T , CapacityRight >& rhs ) noexcept ; #include \"iceoryx_hoofs/internal/cxx/vector.inl\" #endif // IOX_HOOFS_CXX_VECTOR_HPP Updated on 18 December 2023 at 13:11:42 CET","title":"Source code"},{"location":"API-reference/hoofs/Namespaces/namespaceDesignPattern/","text":"DesignPattern \ud83d\udd17 Classes \ud83d\udd17 Name class DesignPattern::Creation This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. Updated on 18 December 2023 at 13:11:42 CET","title":"DesignPattern"},{"location":"API-reference/hoofs/Namespaces/namespaceDesignPattern/#designpattern","text":"","title":"DesignPattern"},{"location":"API-reference/hoofs/Namespaces/namespaceDesignPattern/#classes","text":"Name class DesignPattern::Creation This pattern can be used if you write an abstraction where you have to throw an exception in the constructor when you for instance would like to manage a resource and the constructor was unable to acquire that resource. In this case you inherit from [Creation]() and your class has three more static factory methods - create , placementCreate and verify . create forwards all arguments to the underlying class constructor and if the construction was successful an expected containing the type is returned, otherwise an error value which describes the error. Additionally, this class is providing two protected member variables m_isInitialized and m_errorValue . The user always has to set m_isInitialized to true when the object construction was successful otherwise one sets it to false and write the corresponding error cause in the provided m_errorValue variable which is then returned to the user. Updated on 18 December 2023 at 13:11:42 CET","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/","text":"iox \ud83d\udd17 building block to easily create free function for logging in a library context More... Namespaces \ud83d\udd17 Name iox::algorithm iox::concurrent iox::cxx iox::log iox::posix Classes \ud83d\udd17 Name class iox::ErrorHandler This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling. Types \ud83d\udd17 Name enum uint32_t Error { } enum uint32_t ErrorLevel { FATAL, SEVERE, MODERATE} the available error levels FATAL using std::function< void(const Error error, const std::function< void()>, const ErrorLevel )> HandlerFunction Functions \ud83d\udd17 Name std::ostream & operator<< (std::ostream & stream, Error value) Convenience stream operator to easily use the Error enum with std::ostream. void errorHandler (const Error error, const std::function< void()> & errorCallBack =std::function< void()>(), const ErrorLevel level = ErrorLevel::FATAL ) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! Detailed Description \ud83d\udd17 building block to easily create free function for logging in a library context // add this to e.g. foo_logging.hpp // the logger can then be used with e.g. foo::LogInfo() of just LogInfo() in the same namespace #ifndef FOO_LOGGING_HPP_INCLUDED #define FOO_LOGGING_HPP_INCLUDED #include \"iceoryx_hoofs/log/logging_free_function_building_block.hpp\" namespace foo { struct LoggingComponent { static constexpr char Ctx [] = \"FOO\" ; static constexpr char Description [] = \"Log context of the FOO component!\" ; }; static constexpr auto LogFatal = iox :: log :: ffbb :: LogFatal < LoggingComponent > ; static constexpr auto LogError = iox :: log :: ffbb :: LogError < LoggingComponent > ; static constexpr auto LogWarn = iox :: log :: ffbb :: LogWarn < LoggingComponent > ; static constexpr auto LogInfo = iox :: log :: ffbb :: LogInfo < LoggingComponent > ; static constexpr auto LogDebug = iox :: log :: ffbb :: LogDebug < LoggingComponent > ; static constexpr auto LogVerbose = iox :: log :: ffbb :: LogVerbose < LoggingComponent > ; } // namespace foo #endif // FOO_LOGGING_HPP_INCLUDED // this needs to be in foo_logging.cpp namespace foo { constexpr char ComponentPosh :: Ctx []; constexpr char ComponentPosh :: Description []; } // namespace foo Types Documentation \ud83d\udd17 enum Error \ud83d\udd17 Enumerator Value Description enum ErrorLevel \ud83d\udd17 Enumerator Value Description FATAL Log error entry + Assert + terminate. SEVERE warning log entry + Assert MODERATE warning log entry the available error levels FATAL Log message with FATAL RouDi cannot recover from that error. RouDi is terminated Assert (in DEBUG) and terminate Reporting code must handle this and continue or go to a save state. Error handler could return (e.g. in test) SEVERE Log message with ERROR RouDi can still run. Error is reported Assert in DEBUG, in RELEASE continue to run Reporting code must handle this and continue MODERATE Log message with ERROR RouDi can still run. Error is reported NO assert Reporting code must handle this and continue using HandlerFunction \ud83d\udd17 using iox :: HandlerFunction = typedef std :: function < void ( const Error error , const std :: function < void () > , const ErrorLevel ) > ; Functions Documentation \ud83d\udd17 function operator<< \ud83d\udd17 std :: ostream & operator << ( std :: ostream & stream , Error value ) Convenience stream operator to easily use the Error enum with std::ostream. Parameters : stream sink to write the message to value to convert to a string literal Return : the reference to stream which was provided as input parameter function errorHandler \ud83d\udd17 void errorHandler ( const Error error , const std :: function < void () > & errorCallBack = std :: function < void () > (), const ErrorLevel level = ErrorLevel :: FATAL ) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! 2.) Call errorHandler(Error::kMODULE_NAME__MY_FUNKY_ERROR); Please pay attention to the \"k\" prefix The defaults for errorCallback and ErrorLevel can also be overwritten: errorHandler( Error::kMODULE_NAME__MY_FUNKY_ERROR, []{ std::cout << \"MyCustomCallback\" << std::endl; }, ErrorLevel::MODERATE ); class PrettyClass { float division ( float a , float b ) { if ( b == 0.0f ) { errorHandler ( Error :: kPRETTY_CLASS__DIVISION_BY_ZERO ); } } }; bool called = false ; auto temporaryErrorHandler = ErrorHandler :: setTemporaryErrorHandler ( [ & ]( const Error e , std :: function < void () > , const ErrorLevel ) { called = true ; }); errorHandler ( Error :: kTEST__ASSERT_CALLED ); ASSERT_TRUE ( called ); Updated on 18 December 2023 at 13:11:42 CET","title":"iox"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#iox","text":"building block to easily create free function for logging in a library context More...","title":"iox"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#namespaces","text":"Name iox::algorithm iox::concurrent iox::cxx iox::log iox::posix","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#classes","text":"Name class iox::ErrorHandler This handler is needed for unit testing, special debugging cases and other corner cases where we'd like to explicitly suppress the error handling.","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#types","text":"Name enum uint32_t Error { } enum uint32_t ErrorLevel { FATAL, SEVERE, MODERATE} the available error levels FATAL using std::function< void(const Error error, const std::function< void()>, const ErrorLevel )> HandlerFunction","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#functions","text":"Name std::ostream & operator<< (std::ostream & stream, Error value) Convenience stream operator to easily use the Error enum with std::ostream. void errorHandler (const Error error, const std::function< void()> & errorCallBack =std::function< void()>(), const ErrorLevel level = ErrorLevel::FATAL ) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright!","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#detailed-description","text":"building block to easily create free function for logging in a library context // add this to e.g. foo_logging.hpp // the logger can then be used with e.g. foo::LogInfo() of just LogInfo() in the same namespace #ifndef FOO_LOGGING_HPP_INCLUDED #define FOO_LOGGING_HPP_INCLUDED #include \"iceoryx_hoofs/log/logging_free_function_building_block.hpp\" namespace foo { struct LoggingComponent { static constexpr char Ctx [] = \"FOO\" ; static constexpr char Description [] = \"Log context of the FOO component!\" ; }; static constexpr auto LogFatal = iox :: log :: ffbb :: LogFatal < LoggingComponent > ; static constexpr auto LogError = iox :: log :: ffbb :: LogError < LoggingComponent > ; static constexpr auto LogWarn = iox :: log :: ffbb :: LogWarn < LoggingComponent > ; static constexpr auto LogInfo = iox :: log :: ffbb :: LogInfo < LoggingComponent > ; static constexpr auto LogDebug = iox :: log :: ffbb :: LogDebug < LoggingComponent > ; static constexpr auto LogVerbose = iox :: log :: ffbb :: LogVerbose < LoggingComponent > ; } // namespace foo #endif // FOO_LOGGING_HPP_INCLUDED // this needs to be in foo_logging.cpp namespace foo { constexpr char ComponentPosh :: Ctx []; constexpr char ComponentPosh :: Description []; } // namespace foo","title":"Detailed Description"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#enum-error","text":"Enumerator Value Description","title":"enum Error"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#enum-errorlevel","text":"Enumerator Value Description FATAL Log error entry + Assert + terminate. SEVERE warning log entry + Assert MODERATE warning log entry the available error levels FATAL Log message with FATAL RouDi cannot recover from that error. RouDi is terminated Assert (in DEBUG) and terminate Reporting code must handle this and continue or go to a save state. Error handler could return (e.g. in test) SEVERE Log message with ERROR RouDi can still run. Error is reported Assert in DEBUG, in RELEASE continue to run Reporting code must handle this and continue MODERATE Log message with ERROR RouDi can still run. Error is reported NO assert Reporting code must handle this and continue","title":"enum ErrorLevel"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#using-handlerfunction","text":"using iox :: HandlerFunction = typedef std :: function < void ( const Error error , const std :: function < void () > , const ErrorLevel ) > ;","title":"using HandlerFunction"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#function-operator","text":"std :: ostream & operator << ( std :: ostream & stream , Error value ) Convenience stream operator to easily use the Error enum with std::ostream. Parameters : stream sink to write the message to value to convert to a string literal Return : the reference to stream which was provided as input parameter","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox/#function-errorhandler","text":"void errorHandler ( const Error error , const std :: function < void () > & errorCallBack = std :: function < void () > (), const ErrorLevel level = ErrorLevel :: FATAL ) Howto use the error handler correctly 1.) If the error you would like to handle is not listed in ICEORYX_ERRORS(error)... macro just add them like: error(MODULE_NAME__MY_FUNKY_ERROR) Attention: Create an error after the following convention: MODULE_NAME__A_CLEAR_BUT_SHORT_ERROR_DESCRIPTION And a long name is alright! 2.) Call errorHandler(Error::kMODULE_NAME__MY_FUNKY_ERROR); Please pay attention to the \"k\" prefix The defaults for errorCallback and ErrorLevel can also be overwritten: errorHandler( Error::kMODULE_NAME__MY_FUNKY_ERROR, []{ std::cout << \"MyCustomCallback\" << std::endl; }, ErrorLevel::MODERATE ); class PrettyClass { float division ( float a , float b ) { if ( b == 0.0f ) { errorHandler ( Error :: kPRETTY_CLASS__DIVISION_BY_ZERO ); } } }; bool called = false ; auto temporaryErrorHandler = ErrorHandler :: setTemporaryErrorHandler ( [ & ]( const Error e , std :: function < void () > , const ErrorLevel ) { called = true ; }); errorHandler ( Error :: kTEST__ASSERT_CALLED ); ASSERT_TRUE ( called ); Updated on 18 December 2023 at 13:11:42 CET","title":"function errorHandler"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/","text":"iox::algorithm \ud83d\udd17 Functions \ud83d\udd17 Name template <typename T > constexpr T max (const T & left) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. template <typename T > constexpr T max (const T & left, const T & right) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the greater one. template <typename T ,typename... Targs> constexpr T max (const T & left, const T & right, const Targs &... args) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. template <typename T > constexpr T min (const T & left) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. template <typename T > constexpr T min (const T & left, const T & right) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the smaller one. template <typename T ,typename... Targs> constexpr T min (const T & left, const T & right, const Targs &... args) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. template <typename T ,typename CompareType > constexpr bool doesContainType () Returns true if T is equal to CompareType, otherwise false. template <typename T ,typename CompareType ,typename Next ,typename... Remainder> constexpr bool doesContainType () Returns true if T is contained the provided type list. template <typename T > constexpr bool doesContainValue (const T) Finalizes the recursion of doesContainValue. template <typename T ,typename... ValueList> constexpr bool doesContainValue (const T value, const T firstValueListEntry, const ValueList... remainingValueListEntries) Returns true if value of T is found in the ValueList, otherwise false. template <typename Container > Container uniqueMergeSortedContainers (const Container & v1, const Container & v2) Merging two sorted containers so that the result is a sorted container where every element is contained only once. Functions Documentation \ud83d\udd17 function max \ud83d\udd17 template < typename T > constexpr T max ( const T & left ) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. Parameters : T type which implements operator<() left value which should be compared Return : returns the given argument left function max \ud83d\udd17 template < typename T > constexpr T max ( const T & left , const T & right ) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the greater one. Parameters : T type which implements operator<() left value which should be compared right value which should be compared Return : returns the maximum value of the set {left, right} function max \ud83d\udd17 template < typename T , typename ... Targs > constexpr T max ( const T & left , const T & right , const Targs & ... args ) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Parameters : T type which implements operator<() left value which should be compared right value which should be compared args... an arbitrary amount of values Return : returns the maximum value of the set {left, right, args...} function min \ud83d\udd17 template < typename T > constexpr T min ( const T & left ) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. Parameters : T type which implements operator<() left value which should be compared Return : returns the given argument left function min \ud83d\udd17 template < typename T > constexpr T min ( const T & left , const T & right ) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the smaller one. Parameters : T type which implements operator<() left value which should be compared right value which should be compared Return : returns the minimum of the set {left, right} function min \ud83d\udd17 template < typename T , typename ... Targs > constexpr T min ( const T & left , const T & right , const Targs & ... args ) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Parameters : T type which implements operator<() left value which should be compared right value which should be compared args... an arbitrary amount of values Return : returns the minimum of the set {left, right, args...} function doesContainType \ud83d\udd17 template < typename T , typename CompareType > constexpr bool doesContainType () Returns true if T is equal to CompareType, otherwise false. Parameters : T type to compare to CompareType the type to which T is compared Return : true if the types T and CompareType are equal, otherwise false function doesContainType \ud83d\udd17 template < typename T , typename CompareType , typename Next , typename ... Remainder > constexpr bool doesContainType () Returns true if T is contained the provided type list. Parameters : T type to compare to CompareTypeNextRemainder the type list in which T should be contained Return : true if the T is contained in the type list, otherwise false function doesContainValue \ud83d\udd17 template < typename T > inline constexpr bool doesContainValue ( const T ) Finalizes the recursion of doesContainValue. Parameters : T type of the value to check Return : always false function doesContainValue \ud83d\udd17 template < typename T , typename ... ValueList > inline constexpr bool doesContainValue ( const T value , const T firstValueListEntry , const ValueList ... remainingValueListEntries ) Returns true if value of T is found in the ValueList, otherwise false. Parameters : value to look for in the ValueList firstValueListEntry is the first variadic argument of ValueList remainingValueListEntries are the remaining variadic arguments of ValueList Template Parameters : T type of the value to check ValueList is a list of values to check for a specific value function uniqueMergeSortedContainers \ud83d\udd17 template < typename Container > Container uniqueMergeSortedContainers ( const Container & v1 , const Container & v2 ) Merging two sorted containers so that the result is a sorted container where every element is contained only once. Parameters : v1 the first sorted input container v2 the second sorted input container Template Parameters : Container container type which has to support emplace_back() and size() Return : sorted container which contains the elements of v1 and v2 and where every element is unique Updated on 18 December 2023 at 13:11:42 CET","title":"iox::algorithm"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#ioxalgorithm","text":"","title":"iox::algorithm"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#functions","text":"Name template <typename T > constexpr T max (const T & left) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. template <typename T > constexpr T max (const T & left, const T & right) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the greater one. template <typename T ,typename... Targs> constexpr T max (const T & left, const T & right, const Targs &... args) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. template <typename T > constexpr T min (const T & left) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. template <typename T > constexpr T min (const T & left, const T & right) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the smaller one. template <typename T ,typename... Targs> constexpr T min (const T & left, const T & right, const Targs &... args) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. template <typename T ,typename CompareType > constexpr bool doesContainType () Returns true if T is equal to CompareType, otherwise false. template <typename T ,typename CompareType ,typename Next ,typename... Remainder> constexpr bool doesContainType () Returns true if T is contained the provided type list. template <typename T > constexpr bool doesContainValue (const T) Finalizes the recursion of doesContainValue. template <typename T ,typename... ValueList> constexpr bool doesContainValue (const T value, const T firstValueListEntry, const ValueList... remainingValueListEntries) Returns true if value of T is found in the ValueList, otherwise false. template <typename Container > Container uniqueMergeSortedContainers (const Container & v1, const Container & v2) Merging two sorted containers so that the result is a sorted container where every element is contained only once.","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-max","text":"template < typename T > constexpr T max ( const T & left ) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. Parameters : T type which implements operator<() left value which should be compared Return : returns the given argument left","title":"function max"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-max_1","text":"template < typename T > constexpr T max ( const T & left , const T & right ) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the greater one. Parameters : T type which implements operator<() left value which should be compared right value which should be compared Return : returns the maximum value of the set {left, right}","title":"function max"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-max_2","text":"template < typename T , typename ... Targs > constexpr T max ( const T & left , const T & right , const Targs & ... args ) Returns the maximum gained with operator<() of an arbitrary amount of variables of the same type. Parameters : T type which implements operator<() left value which should be compared right value which should be compared args... an arbitrary amount of values Return : returns the maximum value of the set {left, right, args...}","title":"function max"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-min","text":"template < typename T > constexpr T min ( const T & left ) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which is required as generic recursive template endpoint. Parameters : T type which implements operator<() left value which should be compared Return : returns the given argument left","title":"function min"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-min_1","text":"template < typename T > constexpr T min ( const T & left , const T & right ) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Helper function which takes two arguments and returns the smaller one. Parameters : T type which implements operator<() left value which should be compared right value which should be compared Return : returns the minimum of the set {left, right}","title":"function min"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-min_2","text":"template < typename T , typename ... Targs > constexpr T min ( const T & left , const T & right , const Targs & ... args ) Returns the minimum gained with operator<() of an arbitrary amount of variables of the same type. Parameters : T type which implements operator<() left value which should be compared right value which should be compared args... an arbitrary amount of values Return : returns the minimum of the set {left, right, args...}","title":"function min"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontaintype","text":"template < typename T , typename CompareType > constexpr bool doesContainType () Returns true if T is equal to CompareType, otherwise false. Parameters : T type to compare to CompareType the type to which T is compared Return : true if the types T and CompareType are equal, otherwise false","title":"function doesContainType"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontaintype_1","text":"template < typename T , typename CompareType , typename Next , typename ... Remainder > constexpr bool doesContainType () Returns true if T is contained the provided type list. Parameters : T type to compare to CompareTypeNextRemainder the type list in which T should be contained Return : true if the T is contained in the type list, otherwise false","title":"function doesContainType"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontainvalue","text":"template < typename T > inline constexpr bool doesContainValue ( const T ) Finalizes the recursion of doesContainValue. Parameters : T type of the value to check Return : always false","title":"function doesContainValue"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-doescontainvalue_1","text":"template < typename T , typename ... ValueList > inline constexpr bool doesContainValue ( const T value , const T firstValueListEntry , const ValueList ... remainingValueListEntries ) Returns true if value of T is found in the ValueList, otherwise false. Parameters : value to look for in the ValueList firstValueListEntry is the first variadic argument of ValueList remainingValueListEntries are the remaining variadic arguments of ValueList Template Parameters : T type of the value to check ValueList is a list of values to check for a specific value","title":"function doesContainValue"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1algorithm/#function-uniquemergesortedcontainers","text":"template < typename Container > Container uniqueMergeSortedContainers ( const Container & v1 , const Container & v2 ) Merging two sorted containers so that the result is a sorted container where every element is contained only once. Parameters : v1 the first sorted input container v2 the second sorted input container Template Parameters : Container container type which has to support emplace_back() and size() Return : sorted container which contains the elements of v1 and v2 and where every element is unique Updated on 18 December 2023 at 13:11:42 CET","title":"function uniqueMergeSortedContainers"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1concurrent/","text":"iox::concurrent \ud83d\udd17 Classes \ud83d\udd17 Name class iox::concurrent::LockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity class iox::concurrent::ResizeableLockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). Updated on 18 December 2023 at 13:11:42 CET","title":"iox::concurrent"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1concurrent/#ioxconcurrent","text":"","title":"iox::concurrent"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1concurrent/#classes","text":"Name class iox::concurrent::LockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a fixed Capacity class iox::concurrent::ResizeableLockFreeQueue implements a lock free queue (i.e. container with FIFO order) of elements of type T with a maximum capacity MaxCapacity. The capacity can be defined to be anything between 0 and MaxCapacity at construction time or later at runtime using setCapacity. This is even possible while concurrent push and pop operations are executed, i.e. the queue does not have to be empty. Only one thread will succeed setting its desired capacity if there are more threads trying to change the capacity at the same time (it is unpredictable which thread). Updated on 18 December 2023 at 13:11:42 CET","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/","text":"iox::cxx \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::cxx::internal Classes \ud83d\udd17 Name struct iox::cxx::add_const_conditionally Conditionally add const to type T if C has the const qualifier. struct iox::cxx::add_const_conditionally< T, const C > struct iox::cxx::BestFittingType get the best fitting unsigned integer type for a given value at compile time class iox::cxx::ConstMethodCallback class iox::cxx::convert Collection of static methods for conversion from and to string. class iox::cxx::DeadlineTimer This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. struct iox::cxx::error helper struct to create an expected which is signalling an error more easily class iox::cxx::expected< ErrorType > expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. class iox::cxx::expected< ValueType, ErrorType > specialization of the expected class which can contain an error as well as a success value class iox::cxx::expected< void, ErrorType > class iox::cxx::forward_list C++11 compatible uni-directional forward list implementation. class iox::cxx::function_ref class iox::cxx::function_ref< ReturnType(ArgTypes...)> cxx::function_ref is a non-owning reference to a callable. class iox::cxx::GenericRAII The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. struct iox::cxx::greater_or_equal struct iox::cxx::in_place_index helper struct to perform an emplacement at a predefined index in the constructor of a variant struct iox::cxx::in_place_t helper struct which is used to call the in-place-construction constructor struct iox::cxx::in_place_type helper struct to perform an emplacement of a predefined type in in the constructor of a variant struct iox::cxx::is_function_pointer Check whether T is a function pointer with arbitrary signature. struct iox::cxx::is_function_pointer< ReturnType(*)(ArgTypes...)> struct iox::cxx::is_invocable Verifies whether the passed Callable type is in fact invocable with the given arguments. struct iox::cxx::is_invocable_r Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. class iox::cxx::list C++11 compatible bi-directional list implementation. class iox::cxx::MethodCallback class iox::cxx::NewType Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. struct iox::cxx::not_null struct iox::cxx::nullopt_t Helper struct which is used to signal an empty optional. It is equivalent to no value. class iox::cxx::optional Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. class iox::cxx::PoorMansHeap Reserves space on stack for placement new instatiation. class iox::cxx::PoorMansHeapType This is a proxy which must be used for the non default PoorMansHeap ctor. struct iox::cxx::range class iox::cxx::Serialization Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. class iox::cxx::stack stack implementation with a simple push pop interface class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. struct iox::cxx::success helper struct to create an expected which is signalling success more easily struct iox::cxx::success< void > helper struct to create an error only expected which is signalling success more easily struct iox::cxx::TruncateToCapacity_t struct used to define a compile time variable which is used to distinguish between constructors with certain behavior class iox::cxx::unique_ptr The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. class iox::cxx::variant Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. class iox::cxx::VariantQueue wrapper of multiple fifo's class iox::cxx::vector C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory. Types \ud83d\udd17 Name enum uint64_t perms { none = 0, owner_read = 0400, owner_write = 0200, owner_exec = 0100, owner_all = 0700, group_read = 040, group_write = 020, group_exec = 010, group_all = 070, others_read = 04, others_write = 02, others_exec = 01, others_all = 07, all = 0777, set_uid = 04000, set_gid = 02000, sticky_bit = 01000, mask = 07777, unknown = 0xFFFF} this enum class implements the filesystem perms feature of C++17. The API is identical to the C++17 one so that the class can be removed as soon as iceoryx switches to C++17. The enum satisfies also all requirements of the BitmaskType, this means the operators | , & , ^ , ~ , |= , &= and ^= are implemented as free functions as C++17 requires it. enum MethodCallbackError { UNINITIALIZED_CALLBACK} enum uint64_t VariantQueueTypes { FiFo_SingleProducerSingleConsumer = 0, SoFi_SingleProducerSingleConsumer = 1, FiFo_MultiProducerSingleConsumer = 2, SoFi_MultiProducerSingleConsumer = 3} list of the supported underlying queue types template <typename Signature ,uint64_t Capacity =128U> using storable_function< static_storage< Capacity >, Signature > function A static memory replacement for std::function Allows storing a callable with a given signature if its size does not exceed a limit. This limit can be adjusted by changing the Bytes parameter. In contrast to cxx::function_ref cxx::function objects own everything needed to invoke the underlying callable and can be safely stored. They also support copy and move semantics in natural way by copying or moving the underlying callable. template <typename Derived ,typename ValueType ,typename ErrorType > using internal::FunctionalInterfaceImpl< Derived, ValueType, ErrorType > FunctionalInterface Provides a functional interface for types which have a bool conversion operator. This provides the methods. template <uint64_t Value> using typename BestFittingType < Value >::Type_t BestFittingType_t template <typename T ,typename C > using typename add_const_conditionally < T, C >::type add_const_conditionally_t Helper type for add_const_conditionally which adds const to type T if C has the const qualifier. template <typename C ,typename... Cargs> using std::result_of< C(Cargs...)> invoke_result template <typename... > using void void_t Maps a sequence of any types to the type void. using uint8_t byte_t Functions \ud83d\udd17 Name perms **[operator perms operator& (const perms & lhs, const perms & rhs) Implements the binary and operation. perms operator^ (const perms & lhs, const perms & rhs) Implements the binary exclusive or operation. perms operator~ (const perms & value) Implements the binary complement operation. perms **[operator perms operator&= (perms & lhs, const perms & rhs) Implements the binary and assignment operation. perms operator^= (perms & lhs, const perms & rhs) Implements the binary exclusive or assignment operation. template <typename StreamType > StreamType & operator<< (StreamType & stream, perms value) The streaming operator for the perms enum. It handles the enum as if it was a bitset and always lists the values for owner, group, others, special bits. template <typename T > T align (const T value, const T alignment) void * alignedAlloc (const uint64_t alignment, const uint64_t size) allocates aligned memory which can only be free'd by alignedFree void alignedFree (void *const memory) frees aligned memory allocated with alignedAlloc template <size_t s =0> constexpr size_t maxAlignment () template recursion stopper for maximum alignment calculation template <typename T ,typename... Args> constexpr size_t maxAlignment () calculate maximum alignment of supplied types template <size_t s =0> constexpr size_t maxSize () template recursion stopper for maximum size calculation template <typename T ,typename... Args> constexpr size_t maxSize () calculate maximum size of supplied types template <typename T ,typename Enumeration > const char * convertEnumToString (T port, const Enumeration source) Convert Enum class type to string. template <typename enum_type > auto enumTypeAsUnderlyingType (enum_type const value) cast an enum to its underlying type template <typename Container ,typename Functor > void forEach (Container & c, const Functor & f) template <uint64_t SizeValue> constexpr uint64_t strlen2 (char const(&)[SizeValue]) Get the size of a string represented by a char array at compile time. constexpr bool isCompiledOn32BitSystem () Returns info whether called on a 32-bit system. template <typename T > constexpr bool isPowerOfTwo (const T n) Checks if an unsigned integer is a power of two. template <uint64_t StringCapacity> bool isValidFileName (const string < StringCapacity > & name) checks if the given string is a valid filename template <uint64_t StringCapacity> bool isValidFilePath (const string < StringCapacity > & name) verifies if the given string is a valid path to a file template <typename F ,typename T > constexpr T from (const F value) Converts a value of type F to a corresponding value of type T. This function needs to be specialized by the user for the types to be converted. template <typename T ,typename F > constexpr T into (const F value) Converts a value of type F to a corresponding value of type T. This is a convenience function which is automatically available when from is implemented. This function shall therefore not be specialized but always the from function. template <typename OptionalBaseType ,typename... Targs> optional < OptionalBaseType > make_optional (Targs &&... args) Creates an optional which contains a value by forwarding the arguments to the constructor of T. template <typename T ,typename... CTorArgs> GenericRAII makeScopedStatic (T & memory, CTorArgs &&... ctorArgs) template <typename T1 ,typename T2 > std::enable_if<(internal::IsCharArray< T1 >::value template <typename T1 ,typename T2 ,typename... Targs> std::enable_if<(internal::IsCharArray< T1 >::value template <uint64_t Capacity> bool operator== (const std::string & lhs, const string < Capacity > & rhs) checks if a rhs fixed string is equal to a lhs std::string template <uint64_t Capacity> bool operator== (const string < Capacity > & lhs, const std::string & rhs) checks if a rhs std::string is equal to a lhs fixed string template <uint64_t Capacity> bool operator!= (const std::string & lhs, const string < Capacity > & rhs) checks if a rhs fixed string is not equal to a lhs std::string template <uint64_t Capacity> bool operator!= (const string < Capacity > & lhs, const std::string & rhs) checks if a rhs std::string is not equal to a lhs fixed string template <uint64_t Capacity> bool operator== (const char const lhs, const string < Capacity > & rhs) The equality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char const other, const uint64_t count) before compare it to a fixed string. template <uint64_t Capacity> bool operator!= (const char const lhs, const string < Capacity > & rhs) The inequality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char const other, const uint64_t count) before compare it to a fixed string. template <uint64_t Capacity> std::ostream & operator<< (std::ostream & stream, const string < Capacity > & str) outputs the fixed string on stream template <typename T ,typename... Types> constexpr bool holds_alternative (const variant < Types... > & variant) returns true if the variant holds a given type T, otherwise false Attributes \ud83d\udd17 Name class IOX_NO_DISCARD expected constexpr nullopt_t nullopt constexpr in_place_t in_place std::enable_if<(internal::IsCharArray< T1 >::value &&internal::IsCxxString< T2 >::value) constexpr TruncateToCapacity_t TruncateToCapacity constexpr bool always_false_v Helper value to bind a static_assert to a type. constexpr uint64_t INVALID_VARIANT_INDEX value which an invalid variant index occupies Types Documentation \ud83d\udd17 enum perms \ud83d\udd17 Enumerator Value Description none 0 Deny everything. owner_read 0400 owner has read permission owner_write 0200 owner has write permission owner_exec 0100 owner has execution permission owner_all 0700 owner has all permissions group_read 040 group has read permission group_write 020 group has write permission group_exec 010 group has execution permission group_all 070 group has all permissions others_read 04 others have read permission others_write 02 others have write permission others_exec 01 others have execution permission others_all 07 others have all permissions all 0777 all permissions for everyone set_uid 04000 set uid bit set_gid 02000 set gid bit sticky_bit 01000 set sticky bit mask 07777 all permissions for everyone as well as uid, gid and sticky bit unknown 0xFFFF unknown permissions this enum class implements the filesystem perms feature of C++17. The API is identical to the C++17 one so that the class can be removed as soon as iceoryx switches to C++17. The enum satisfies also all requirements of the BitmaskType, this means the operators | , & , ^ , ~ , |= , &= and ^= are implemented as free functions as C++17 requires it. enum MethodCallbackError \ud83d\udd17 Enumerator Value Description UNINITIALIZED_CALLBACK enum VariantQueueTypes \ud83d\udd17 Enumerator Value Description FiFo_SingleProducerSingleConsumer 0 SoFi_SingleProducerSingleConsumer 1 FiFo_MultiProducerSingleConsumer 2 SoFi_MultiProducerSingleConsumer 3 list of the supported underlying queue types Note : if a new queue type is added the following steps have to be performed: add queue type here add queue type in m_fifo data member variant type increase numberOfQueueTypes in test_cxx_variant_queue test using function \ud83d\udd17 template < typename Signature , uint64_t Capacity = 128U > using iox :: cxx :: function = typedef storable_function < static_storage < Capacity > , Signature > ; A static memory replacement for std::function Allows storing a callable with a given signature if its size does not exceed a limit. This limit can be adjusted by changing the Bytes parameter. In contrast to cxx::function_ref cxx::function objects own everything needed to invoke the underlying callable and can be safely stored. They also support copy and move semantics in natural way by copying or moving the underlying callable. Template Parameters : Signature The signature of the callable to be stored, e.g. int (char, void*). Capacity The static storage capacity available to store a callable in bytes. Note : If the static storage is insufficient to store the callable we get a compile time error. Similarly to std::function, they cannot be stored in Shared Memory to be invoked in a different process. For the API see storable_function. using FunctionalInterface \ud83d\udd17 template < typename Derived , typename ValueType , typename ErrorType > using iox :: cxx :: FunctionalInterface = typedef internal :: FunctionalInterfaceImpl < Derived , ValueType , ErrorType > ; Provides a functional interface for types which have a bool conversion operator. This provides the methods. Note : When inheriting from this type one does not have to write additional unit tests. Instead add a factory for your class to test_cxx_functional_interface_types.hpp , add the type to the FunctionalInterfaceImplementations and all typed tests will be generated. and_then or_else expect When the class has a value method the method value_or is added and and_then provides a reference in the callback to the underlying value. When the class has a get_error method the or_else method has a parameter to access a reference to the underlying error. using BestFittingType_t \ud83d\udd17 template < uint64_t Value > using iox :: cxx :: BestFittingType_t = typedef typename BestFittingType < Value >:: Type_t ; using add_const_conditionally_t \ud83d\udd17 template < typename T , typename C > using iox :: cxx :: add_const_conditionally_t = typedef typename add_const_conditionally < T , C >:: type ; Helper type for add_const_conditionally which adds const to type T if C has the const qualifier. using invoke_result \ud83d\udd17 template < typename C , typename ... Cargs > using iox :: cxx :: invoke_result = typedef std :: result_of < C ( Cargs ...) > ; using void_t \ud83d\udd17 template < typename ... > using iox :: cxx :: void_t = typedef void ; Maps a sequence of any types to the type void. using byte_t \ud83d\udd17 using iox :: cxx :: byte_t = typedef uint8_t ; Functions Documentation \ud83d\udd17 function operator| \ud83d\udd17 perms operator | ( const perms & lhs , const perms & rhs ) Implements the binary or operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs | rhs function operator& \ud83d\udd17 perms operator & ( const perms & lhs , const perms & rhs ) Implements the binary and operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs & rhs function operator^ \ud83d\udd17 perms operator ^ ( const perms & lhs , const perms & rhs ) Implements the binary exclusive or operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs ^ rhs function operator~ \ud83d\udd17 perms operator ~ ( const perms & value ) Implements the binary complement operation. Parameters : value the value used for the operation Return : ~value function operator|= \ud83d\udd17 perms operator |= ( perms & lhs , const perms & rhs ) Implements the binary or assignment operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs = lhs | rhs function operator&= \ud83d\udd17 perms operator &= ( perms & lhs , const perms & rhs ) Implements the binary and assignment operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs = lhs & rhs function operator^= \ud83d\udd17 perms operator ^= ( perms & lhs , const perms & rhs ) Implements the binary exclusive or assignment operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs = lhs ^ rhs function operator<< \ud83d\udd17 template < typename StreamType > StreamType & operator << ( StreamType & stream , perms value ) The streaming operator for the perms enum. It handles the enum as if it was a bitset and always lists the values for owner, group, others, special bits. Parameters : stream reference to the stream value the file permission Return : the reference to the stream function align \ud83d\udd17 template < typename T > T align ( const T value , const T alignment ) function alignedAlloc \ud83d\udd17 void * alignedAlloc ( const uint64_t alignment , const uint64_t size ) allocates aligned memory which can only be free'd by alignedFree Parameters : alignmentalignment of the memory sizememory size Return : void pointer to the aligned memory function alignedFree \ud83d\udd17 void alignedFree ( void * const memory ) frees aligned memory allocated with alignedAlloc Parameters : memorypointer to the aligned memory function maxAlignment \ud83d\udd17 template < size_t s = 0 > constexpr size_t maxAlignment () template recursion stopper for maximum alignment calculation function maxAlignment \ud83d\udd17 template < typename T , typename ... Args > constexpr size_t maxAlignment () calculate maximum alignment of supplied types function maxSize \ud83d\udd17 template < size_t s = 0 > constexpr size_t maxSize () template recursion stopper for maximum size calculation function maxSize \ud83d\udd17 template < typename T , typename ... Args > constexpr size_t maxSize () calculate maximum size of supplied types function convertEnumToString \ud83d\udd17 template < typename T , typename Enumeration > const char * convertEnumToString ( T port , const Enumeration source ) Convert Enum class type to string. function enumTypeAsUnderlyingType \ud83d\udd17 template < typename enum_type > auto enumTypeAsUnderlyingType ( enum_type const value ) cast an enum to its underlying type function forEach \ud83d\udd17 template < typename Container , typename Functor > void forEach ( Container & c , const Functor & f ) Template Parameters : calls a given functor for every element in a given container function strlen2 \ud83d\udd17 template < uint64_t SizeValue > static constexpr uint64_t strlen2 ( char const ( & )[ SizeValue ] ) Get the size of a string represented by a char array at compile time. Parameters : The actual content of the char array is not of interest. Its just the size of the array that matters. Template Parameters : The size of the char array filled out by the compiler. Return : Returns the size of a char array at compile time. function isCompiledOn32BitSystem \ud83d\udd17 constexpr bool isCompiledOn32BitSystem () Returns info whether called on a 32-bit system. Return : True if called on 32-bit, false if not 32-bit system function isPowerOfTwo \ud83d\udd17 template < typename T > constexpr bool isPowerOfTwo ( const T n ) Checks if an unsigned integer is a power of two. Return : true if power of two, otherwise false function isValidFileName \ud83d\udd17 template < uint64_t StringCapacity > bool isValidFileName ( const string < StringCapacity > & name ) checks if the given string is a valid filename Return : true if the string is a filename, otherwise false function isValidFilePath \ud83d\udd17 template < uint64_t StringCapacity > bool isValidFilePath ( const string < StringCapacity > & name ) verifies if the given string is a valid path to a file Return : true if the string is a path to a file, otherwise false function from \ud83d\udd17 template < typename F , typename T > constexpr T from ( const F value ) Converts a value of type F to a corresponding value of type T. This function needs to be specialized by the user for the types to be converted. Parameters : value of type F to convert to T Template Parameters : F is the 'from' type T is the 'to' type Return : converted value of F to corresponding value of T enum class LowLevel { FileDescriptorInvalid , FileDescriptorCorrupt , Timeout }; enum class HighLevel { FileDescriptorError , Timeout }; namespace iox { namespace cxx { template <> constexpr HighLevel from < LowLevel , HighLevel > ( LowLevel e ) noexcept { switch ( e ) { case LowLevel :: FileDescriptorCorrupt : return HighLevel :: FileDescriptorError ; case LowLevel :: FileDescriptorInvalid : return HighLevel :: FileDescriptorError ; case LowLevel :: Timeout : return HighLevel :: Timeout ; } } } // namespace cxx } // namespace iox function into \ud83d\udd17 template < typename T , typename F > constexpr T into ( const F value ) Converts a value of type F to a corresponding value of type T. This is a convenience function which is automatically available when from is implemented. This function shall therefore not be specialized but always the from function. Parameters : value of type F to convert to T Template Parameters : T is the 'to' type F is the 'from' type Return : converted value of F to corresponding value of T Bar b = iox :: cxx :: into < Bar > ( Foo :: ENUM_VALUE ); function make_optional \ud83d\udd17 template < typename OptionalBaseType , typename ... Targs > optional < OptionalBaseType > make_optional ( Targs && ... args ) Creates an optional which contains a value by forwarding the arguments to the constructor of T. Parameters : args arguments which will be perfectly forwarded to the constructor of T Return : optional which contains T constructed with args function makeScopedStatic \ud83d\udd17 template < typename T , typename ... CTorArgs > GenericRAII makeScopedStatic ( T & memory , CTorArgs && ... ctorArgs ) Parameters : memory is a reference to a memory container, e.g. cxx::optional ctorArgs ctor arguments for the object to construct Template Parameters : [in] T memory container which has emplace(...) and reset [in] CTorArgs ctor types for the object to construct Return : cxx::GenericRAII Todo : better name create a GenericRAII object to cleanup a static optional object at the end of the scope function concatenate \ud83d\udd17 template < typename T1 , typename T2 > std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa > >:: type concatenate ( const T1 & t1 , const T2 & t2 ) concatenates two fixed strings/string literals Parameters : fixed strings/string literals to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings string < 5 > fuu ( \"cdefg\" ); auto bar = iox :: cxx :: concatenate ( fuu , \"ahc\" ); function concatenate \ud83d\udd17 template < typename T1 , typename T2 , typename ... Targs > std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: SumCapa < T1 , T2 , Targs ... >:: value > >:: type concatenate ( const T1 & t1 , const T2 & t2 , const Targs & ... targs ) concatenates an arbitrary number of fixed strings or string literals Parameters : fixed strings/string literals to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings string < 4 > fuu ( \"cdef\" ); auto bar = iox :: cxx :: concatenate ( fuu , \"g\" , \"ah\" , fuu ); function operator== \ud83d\udd17 template < uint64_t Capacity > inline bool operator == ( const std :: string & lhs , const string < Capacity > & rhs ) checks if a rhs fixed string is equal to a lhs std::string Parameters : lhs is the std::string rhs is the fixed string Return : true if both strings are equal, otherwise false function operator== \ud83d\udd17 template < uint64_t Capacity > inline bool operator == ( const string < Capacity > & lhs , const std :: string & rhs ) checks if a rhs std::string is equal to a lhs fixed string Parameters : lhs is the fixed string rhs is the std::string Return : true if both strings are equal, otherwise false function operator!= \ud83d\udd17 template < uint64_t Capacity > inline bool operator != ( const std :: string & lhs , const string < Capacity > & rhs ) checks if a rhs fixed string is not equal to a lhs std::string Parameters : lhs is the std::string rhs is the fixed string Return : true if both strings are not equal, otherwise false function operator!= \ud83d\udd17 template < uint64_t Capacity > inline bool operator != ( const string < Capacity > & lhs , const std :: string & rhs ) checks if a rhs std::string is not equal to a lhs fixed string Parameters : lhs is the fixed string rhs is the std::string Return : true if both strings are not equal, otherwise false function operator== \ud83d\udd17 template < uint64_t Capacity > inline bool operator == ( const char * const lhs , const string < Capacity > & rhs ) The equality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : lhs is the char pointer to the array to compare rhs is the fixed string Return : false function operator!= \ud83d\udd17 template < uint64_t Capacity > inline bool operator != ( const char * const lhs , const string < Capacity > & rhs ) The inequality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : lhs is the char pointer to the array to compare rhs is the fixed string Return : false function operator<< \ud83d\udd17 template < uint64_t Capacity > inline std :: ostream & operator << ( std :: ostream & stream , const string < Capacity > & str ) outputs the fixed string on stream Parameters : stream is the output stream str is the fixed string Return : the stream output of the fixed string function holds_alternative \ud83d\udd17 template < typename T , typename ... Types > constexpr bool holds_alternative ( const variant < Types ... > & variant ) returns true if the variant holds a given type T, otherwise false Attributes Documentation \ud83d\udd17 variable expected \ud83d\udd17 class IOX_NO_DISCARD expected ; variable nullopt \ud83d\udd17 constexpr nullopt_t nullopt = [ nullopt_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1cxx_1_1nullopt__t / )(); variable in_place \ud83d\udd17 constexpr in_place_t in_place {}; variable operator+ \ud83d\udd17 std :: enable_if < ( internal :: IsCharArray < T1 >:: value && internal :: IsCxxString < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCharArray < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa > >:: type operator + ; concatenates two fixed strings or one fixed fixed string and one string literal; concatenation of two string literals is not possible Parameters : fixed strings/string literal to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings variable TruncateToCapacity \ud83d\udd17 constexpr TruncateToCapacity_t TruncateToCapacity {}; variable always_false_v \ud83d\udd17 constexpr bool always_false_v = false ; Helper value to bind a static_assert to a type. static_assert ( always_false_v < Foo > , \"Not implemented for the given type!\" ); variable INVALID_VARIANT_INDEX \ud83d\udd17 static constexpr uint64_t INVALID_VARIANT_INDEX = std :: numeric_limits < uint64_t >:: max (); value which an invalid variant index occupies cxx :: variant < int , float > someVariant ; // every unset variant has an invalid variant in the beginning if ( someVariant . index () == INVALID_VARIANT_INDEX ) ... cxx :: variant < int , float > someVariant2 ( cxx :: in_place_type < int > , 12 ); // variant with setted value therefore the index is not invalid if ( someVariant . index () != INVALID_VARIANT_INDEX ) ... Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#ioxcxx","text":"","title":"iox::cxx"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#namespaces","text":"Name iox::cxx::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#classes","text":"Name struct iox::cxx::add_const_conditionally Conditionally add const to type T if C has the const qualifier. struct iox::cxx::add_const_conditionally< T, const C > struct iox::cxx::BestFittingType get the best fitting unsigned integer type for a given value at compile time class iox::cxx::ConstMethodCallback class iox::cxx::convert Collection of static methods for conversion from and to string. class iox::cxx::DeadlineTimer This offers the deadline timer functionality. It has user convenient methods to reset the timer [by default it uses the intialized duration], reset timer to a customized duration, check if the timer is active and user can also get to know about the remaining time before the timer goes off. struct iox::cxx::error helper struct to create an expected which is signalling an error more easily class iox::cxx::expected< ErrorType > expected implementation from the C++20 proposal with C++11. The interface is inspired by the proposal but it has changes since we are not allowed to throw an exception. class iox::cxx::expected< ValueType, ErrorType > specialization of the expected class which can contain an error as well as a success value class iox::cxx::expected< void, ErrorType > class iox::cxx::forward_list C++11 compatible uni-directional forward list implementation. class iox::cxx::function_ref class iox::cxx::function_ref< ReturnType(ArgTypes...)> cxx::function_ref is a non-owning reference to a callable. class iox::cxx::GenericRAII The GenericRAII class is a simple helper class to apply the C++ RAII idiom quickly. You set 2 functions, one which is called in the constructor and another function is called in the destructor which can be useful when handling resources. struct iox::cxx::greater_or_equal struct iox::cxx::in_place_index helper struct to perform an emplacement at a predefined index in the constructor of a variant struct iox::cxx::in_place_t helper struct which is used to call the in-place-construction constructor struct iox::cxx::in_place_type helper struct to perform an emplacement of a predefined type in in the constructor of a variant struct iox::cxx::is_function_pointer Check whether T is a function pointer with arbitrary signature. struct iox::cxx::is_function_pointer< ReturnType(*)(ArgTypes...)> struct iox::cxx::is_invocable Verifies whether the passed Callable type is in fact invocable with the given arguments. struct iox::cxx::is_invocable_r Verifies whether the passed Callable type is in fact invocable with the given arguments and the result of the invocation is convertible to ReturnType. class iox::cxx::list C++11 compatible bi-directional list implementation. class iox::cxx::MethodCallback class iox::cxx::NewType Implementation of the haskell NewType pattern: https://wiki.haskell.org/Newtype Lets say you would like to have an index which is in the end an integer but with certain restraints. The users should be forced to set it when they are creating it but afterwards it should be immutable. You would like to be able to compare the type as well as to sort it so that it can be stored in a map for instance. An example could be that you would like to have an index class with those properties and some additional methods. Then you can inherit from NewType and add your methods. struct iox::cxx::not_null struct iox::cxx::nullopt_t Helper struct which is used to signal an empty optional. It is equivalent to no value. class iox::cxx::optional Optional implementation from the C++17 standard with C++11. The interface is analog to the C++17 standard and it can be used in factory functions which can fail. class iox::cxx::PoorMansHeap Reserves space on stack for placement new instatiation. class iox::cxx::PoorMansHeapType This is a proxy which must be used for the non default PoorMansHeap ctor. struct iox::cxx::range class iox::cxx::Serialization Simple serializer which serials every given type into the following format: (The type needs to be convertable into a string via cxx::convert::toString ) LENGTH:DATALENGTH:DATA... Example: Serializes \"hello\", 123, 123.01 into 5:hello3:1236:123.01. class iox::cxx::stack stack implementation with a simple push pop interface class iox::cxx::string string implementation with some adjustments in the API, because we are not allowed to throw exceptions or use heap. struct iox::cxx::success helper struct to create an expected which is signalling success more easily struct iox::cxx::success< void > helper struct to create an error only expected which is signalling success more easily struct iox::cxx::TruncateToCapacity_t struct used to define a compile time variable which is used to distinguish between constructors with certain behavior class iox::cxx::unique_ptr The unique_ptr class is a heap-less unique ptr implementation, unlike the STL. class iox::cxx::variant Variant implementation from the C++17 standard with C++11. The interface is inspired by the C++17 standard but it has changes in get and emplace since we are not allowed to throw exceptions. class iox::cxx::VariantQueue wrapper of multiple fifo's class iox::cxx::vector C++11 compatible vector implementation. We needed to do some adjustments in the API since we do not use exceptions and we require a data structure which can be located fully in the shared memory.","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#types","text":"Name enum uint64_t perms { none = 0, owner_read = 0400, owner_write = 0200, owner_exec = 0100, owner_all = 0700, group_read = 040, group_write = 020, group_exec = 010, group_all = 070, others_read = 04, others_write = 02, others_exec = 01, others_all = 07, all = 0777, set_uid = 04000, set_gid = 02000, sticky_bit = 01000, mask = 07777, unknown = 0xFFFF} this enum class implements the filesystem perms feature of C++17. The API is identical to the C++17 one so that the class can be removed as soon as iceoryx switches to C++17. The enum satisfies also all requirements of the BitmaskType, this means the operators | , & , ^ , ~ , |= , &= and ^= are implemented as free functions as C++17 requires it. enum MethodCallbackError { UNINITIALIZED_CALLBACK} enum uint64_t VariantQueueTypes { FiFo_SingleProducerSingleConsumer = 0, SoFi_SingleProducerSingleConsumer = 1, FiFo_MultiProducerSingleConsumer = 2, SoFi_MultiProducerSingleConsumer = 3} list of the supported underlying queue types template <typename Signature ,uint64_t Capacity =128U> using storable_function< static_storage< Capacity >, Signature > function A static memory replacement for std::function Allows storing a callable with a given signature if its size does not exceed a limit. This limit can be adjusted by changing the Bytes parameter. In contrast to cxx::function_ref cxx::function objects own everything needed to invoke the underlying callable and can be safely stored. They also support copy and move semantics in natural way by copying or moving the underlying callable. template <typename Derived ,typename ValueType ,typename ErrorType > using internal::FunctionalInterfaceImpl< Derived, ValueType, ErrorType > FunctionalInterface Provides a functional interface for types which have a bool conversion operator. This provides the methods. template <uint64_t Value> using typename BestFittingType < Value >::Type_t BestFittingType_t template <typename T ,typename C > using typename add_const_conditionally < T, C >::type add_const_conditionally_t Helper type for add_const_conditionally which adds const to type T if C has the const qualifier. template <typename C ,typename... Cargs> using std::result_of< C(Cargs...)> invoke_result template <typename... > using void void_t Maps a sequence of any types to the type void. using uint8_t byte_t","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#functions","text":"Name perms **[operator perms operator& (const perms & lhs, const perms & rhs) Implements the binary and operation. perms operator^ (const perms & lhs, const perms & rhs) Implements the binary exclusive or operation. perms operator~ (const perms & value) Implements the binary complement operation. perms **[operator perms operator&= (perms & lhs, const perms & rhs) Implements the binary and assignment operation. perms operator^= (perms & lhs, const perms & rhs) Implements the binary exclusive or assignment operation. template <typename StreamType > StreamType & operator<< (StreamType & stream, perms value) The streaming operator for the perms enum. It handles the enum as if it was a bitset and always lists the values for owner, group, others, special bits. template <typename T > T align (const T value, const T alignment) void * alignedAlloc (const uint64_t alignment, const uint64_t size) allocates aligned memory which can only be free'd by alignedFree void alignedFree (void *const memory) frees aligned memory allocated with alignedAlloc template <size_t s =0> constexpr size_t maxAlignment () template recursion stopper for maximum alignment calculation template <typename T ,typename... Args> constexpr size_t maxAlignment () calculate maximum alignment of supplied types template <size_t s =0> constexpr size_t maxSize () template recursion stopper for maximum size calculation template <typename T ,typename... Args> constexpr size_t maxSize () calculate maximum size of supplied types template <typename T ,typename Enumeration > const char * convertEnumToString (T port, const Enumeration source) Convert Enum class type to string. template <typename enum_type > auto enumTypeAsUnderlyingType (enum_type const value) cast an enum to its underlying type template <typename Container ,typename Functor > void forEach (Container & c, const Functor & f) template <uint64_t SizeValue> constexpr uint64_t strlen2 (char const(&)[SizeValue]) Get the size of a string represented by a char array at compile time. constexpr bool isCompiledOn32BitSystem () Returns info whether called on a 32-bit system. template <typename T > constexpr bool isPowerOfTwo (const T n) Checks if an unsigned integer is a power of two. template <uint64_t StringCapacity> bool isValidFileName (const string < StringCapacity > & name) checks if the given string is a valid filename template <uint64_t StringCapacity> bool isValidFilePath (const string < StringCapacity > & name) verifies if the given string is a valid path to a file template <typename F ,typename T > constexpr T from (const F value) Converts a value of type F to a corresponding value of type T. This function needs to be specialized by the user for the types to be converted. template <typename T ,typename F > constexpr T into (const F value) Converts a value of type F to a corresponding value of type T. This is a convenience function which is automatically available when from is implemented. This function shall therefore not be specialized but always the from function. template <typename OptionalBaseType ,typename... Targs> optional < OptionalBaseType > make_optional (Targs &&... args) Creates an optional which contains a value by forwarding the arguments to the constructor of T. template <typename T ,typename... CTorArgs> GenericRAII makeScopedStatic (T & memory, CTorArgs &&... ctorArgs) template <typename T1 ,typename T2 > std::enable_if<(internal::IsCharArray< T1 >::value template <typename T1 ,typename T2 ,typename... Targs> std::enable_if<(internal::IsCharArray< T1 >::value template <uint64_t Capacity> bool operator== (const std::string & lhs, const string < Capacity > & rhs) checks if a rhs fixed string is equal to a lhs std::string template <uint64_t Capacity> bool operator== (const string < Capacity > & lhs, const std::string & rhs) checks if a rhs std::string is equal to a lhs fixed string template <uint64_t Capacity> bool operator!= (const std::string & lhs, const string < Capacity > & rhs) checks if a rhs fixed string is not equal to a lhs std::string template <uint64_t Capacity> bool operator!= (const string < Capacity > & lhs, const std::string & rhs) checks if a rhs std::string is not equal to a lhs fixed string template <uint64_t Capacity> bool operator== (const char const lhs, const string < Capacity > & rhs) The equality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char const other, const uint64_t count) before compare it to a fixed string. template <uint64_t Capacity> bool operator!= (const char const lhs, const string < Capacity > & rhs) The inequality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char const other, const uint64_t count) before compare it to a fixed string. template <uint64_t Capacity> std::ostream & operator<< (std::ostream & stream, const string < Capacity > & str) outputs the fixed string on stream template <typename T ,typename... Types> constexpr bool holds_alternative (const variant < Types... > & variant) returns true if the variant holds a given type T, otherwise false","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#attributes","text":"Name class IOX_NO_DISCARD expected constexpr nullopt_t nullopt constexpr in_place_t in_place std::enable_if<(internal::IsCharArray< T1 >::value &&internal::IsCxxString< T2 >::value) constexpr TruncateToCapacity_t TruncateToCapacity constexpr bool always_false_v Helper value to bind a static_assert to a type. constexpr uint64_t INVALID_VARIANT_INDEX value which an invalid variant index occupies","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#enum-perms","text":"Enumerator Value Description none 0 Deny everything. owner_read 0400 owner has read permission owner_write 0200 owner has write permission owner_exec 0100 owner has execution permission owner_all 0700 owner has all permissions group_read 040 group has read permission group_write 020 group has write permission group_exec 010 group has execution permission group_all 070 group has all permissions others_read 04 others have read permission others_write 02 others have write permission others_exec 01 others have execution permission others_all 07 others have all permissions all 0777 all permissions for everyone set_uid 04000 set uid bit set_gid 02000 set gid bit sticky_bit 01000 set sticky bit mask 07777 all permissions for everyone as well as uid, gid and sticky bit unknown 0xFFFF unknown permissions this enum class implements the filesystem perms feature of C++17. The API is identical to the C++17 one so that the class can be removed as soon as iceoryx switches to C++17. The enum satisfies also all requirements of the BitmaskType, this means the operators | , & , ^ , ~ , |= , &= and ^= are implemented as free functions as C++17 requires it.","title":"enum perms"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#enum-methodcallbackerror","text":"Enumerator Value Description UNINITIALIZED_CALLBACK","title":"enum MethodCallbackError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#enum-variantqueuetypes","text":"Enumerator Value Description FiFo_SingleProducerSingleConsumer 0 SoFi_SingleProducerSingleConsumer 1 FiFo_MultiProducerSingleConsumer 2 SoFi_MultiProducerSingleConsumer 3 list of the supported underlying queue types Note : if a new queue type is added the following steps have to be performed: add queue type here add queue type in m_fifo data member variant type increase numberOfQueueTypes in test_cxx_variant_queue test","title":"enum VariantQueueTypes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-function","text":"template < typename Signature , uint64_t Capacity = 128U > using iox :: cxx :: function = typedef storable_function < static_storage < Capacity > , Signature > ; A static memory replacement for std::function Allows storing a callable with a given signature if its size does not exceed a limit. This limit can be adjusted by changing the Bytes parameter. In contrast to cxx::function_ref cxx::function objects own everything needed to invoke the underlying callable and can be safely stored. They also support copy and move semantics in natural way by copying or moving the underlying callable. Template Parameters : Signature The signature of the callable to be stored, e.g. int (char, void*). Capacity The static storage capacity available to store a callable in bytes. Note : If the static storage is insufficient to store the callable we get a compile time error. Similarly to std::function, they cannot be stored in Shared Memory to be invoked in a different process. For the API see storable_function.","title":"using function"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-functionalinterface","text":"template < typename Derived , typename ValueType , typename ErrorType > using iox :: cxx :: FunctionalInterface = typedef internal :: FunctionalInterfaceImpl < Derived , ValueType , ErrorType > ; Provides a functional interface for types which have a bool conversion operator. This provides the methods. Note : When inheriting from this type one does not have to write additional unit tests. Instead add a factory for your class to test_cxx_functional_interface_types.hpp , add the type to the FunctionalInterfaceImplementations and all typed tests will be generated. and_then or_else expect When the class has a value method the method value_or is added and and_then provides a reference in the callback to the underlying value. When the class has a get_error method the or_else method has a parameter to access a reference to the underlying error.","title":"using FunctionalInterface"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-bestfittingtype_t","text":"template < uint64_t Value > using iox :: cxx :: BestFittingType_t = typedef typename BestFittingType < Value >:: Type_t ;","title":"using BestFittingType_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-add_const_conditionally_t","text":"template < typename T , typename C > using iox :: cxx :: add_const_conditionally_t = typedef typename add_const_conditionally < T , C >:: type ; Helper type for add_const_conditionally which adds const to type T if C has the const qualifier.","title":"using add_const_conditionally_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-invoke_result","text":"template < typename C , typename ... Cargs > using iox :: cxx :: invoke_result = typedef std :: result_of < C ( Cargs ...) > ;","title":"using invoke_result"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-void_t","text":"template < typename ... > using iox :: cxx :: void_t = typedef void ; Maps a sequence of any types to the type void.","title":"using void_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#using-byte_t","text":"using iox :: cxx :: byte_t = typedef uint8_t ;","title":"using byte_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator","text":"perms operator | ( const perms & lhs , const perms & rhs ) Implements the binary or operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs | rhs","title":"function operator|"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_1","text":"perms operator & ( const perms & lhs , const perms & rhs ) Implements the binary and operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs & rhs","title":"function operator&amp;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_2","text":"perms operator ^ ( const perms & lhs , const perms & rhs ) Implements the binary exclusive or operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs ^ rhs","title":"function operator^"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_3","text":"perms operator ~ ( const perms & value ) Implements the binary complement operation. Parameters : value the value used for the operation Return : ~value","title":"function operator~"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_4","text":"perms operator |= ( perms & lhs , const perms & rhs ) Implements the binary or assignment operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs = lhs | rhs","title":"function operator|="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_5","text":"perms operator &= ( perms & lhs , const perms & rhs ) Implements the binary and assignment operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs = lhs & rhs","title":"function operator&amp;="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_6","text":"perms operator ^= ( perms & lhs , const perms & rhs ) Implements the binary exclusive or assignment operation. Parameters : lhs left hand side of the operation rhs right hand side of the operation Return : lhs = lhs ^ rhs","title":"function operator^="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_7","text":"template < typename StreamType > StreamType & operator << ( StreamType & stream , perms value ) The streaming operator for the perms enum. It handles the enum as if it was a bitset and always lists the values for owner, group, others, special bits. Parameters : stream reference to the stream value the file permission Return : the reference to the stream","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-align","text":"template < typename T > T align ( const T value , const T alignment )","title":"function align"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-alignedalloc","text":"void * alignedAlloc ( const uint64_t alignment , const uint64_t size ) allocates aligned memory which can only be free'd by alignedFree Parameters : alignmentalignment of the memory sizememory size Return : void pointer to the aligned memory","title":"function alignedAlloc"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-alignedfree","text":"void alignedFree ( void * const memory ) frees aligned memory allocated with alignedAlloc Parameters : memorypointer to the aligned memory","title":"function alignedFree"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxalignment","text":"template < size_t s = 0 > constexpr size_t maxAlignment () template recursion stopper for maximum alignment calculation","title":"function maxAlignment"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxalignment_1","text":"template < typename T , typename ... Args > constexpr size_t maxAlignment () calculate maximum alignment of supplied types","title":"function maxAlignment"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxsize","text":"template < size_t s = 0 > constexpr size_t maxSize () template recursion stopper for maximum size calculation","title":"function maxSize"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-maxsize_1","text":"template < typename T , typename ... Args > constexpr size_t maxSize () calculate maximum size of supplied types","title":"function maxSize"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-convertenumtostring","text":"template < typename T , typename Enumeration > const char * convertEnumToString ( T port , const Enumeration source ) Convert Enum class type to string.","title":"function convertEnumToString"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-enumtypeasunderlyingtype","text":"template < typename enum_type > auto enumTypeAsUnderlyingType ( enum_type const value ) cast an enum to its underlying type","title":"function enumTypeAsUnderlyingType"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-foreach","text":"template < typename Container , typename Functor > void forEach ( Container & c , const Functor & f ) Template Parameters : calls a given functor for every element in a given container","title":"function forEach"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-strlen2","text":"template < uint64_t SizeValue > static constexpr uint64_t strlen2 ( char const ( & )[ SizeValue ] ) Get the size of a string represented by a char array at compile time. Parameters : The actual content of the char array is not of interest. Its just the size of the array that matters. Template Parameters : The size of the char array filled out by the compiler. Return : Returns the size of a char array at compile time.","title":"function strlen2"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-iscompiledon32bitsystem","text":"constexpr bool isCompiledOn32BitSystem () Returns info whether called on a 32-bit system. Return : True if called on 32-bit, false if not 32-bit system","title":"function isCompiledOn32BitSystem"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-ispoweroftwo","text":"template < typename T > constexpr bool isPowerOfTwo ( const T n ) Checks if an unsigned integer is a power of two. Return : true if power of two, otherwise false","title":"function isPowerOfTwo"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-isvalidfilename","text":"template < uint64_t StringCapacity > bool isValidFileName ( const string < StringCapacity > & name ) checks if the given string is a valid filename Return : true if the string is a filename, otherwise false","title":"function isValidFileName"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-isvalidfilepath","text":"template < uint64_t StringCapacity > bool isValidFilePath ( const string < StringCapacity > & name ) verifies if the given string is a valid path to a file Return : true if the string is a path to a file, otherwise false","title":"function isValidFilePath"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-from","text":"template < typename F , typename T > constexpr T from ( const F value ) Converts a value of type F to a corresponding value of type T. This function needs to be specialized by the user for the types to be converted. Parameters : value of type F to convert to T Template Parameters : F is the 'from' type T is the 'to' type Return : converted value of F to corresponding value of T enum class LowLevel { FileDescriptorInvalid , FileDescriptorCorrupt , Timeout }; enum class HighLevel { FileDescriptorError , Timeout }; namespace iox { namespace cxx { template <> constexpr HighLevel from < LowLevel , HighLevel > ( LowLevel e ) noexcept { switch ( e ) { case LowLevel :: FileDescriptorCorrupt : return HighLevel :: FileDescriptorError ; case LowLevel :: FileDescriptorInvalid : return HighLevel :: FileDescriptorError ; case LowLevel :: Timeout : return HighLevel :: Timeout ; } } } // namespace cxx } // namespace iox","title":"function from"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-into","text":"template < typename T , typename F > constexpr T into ( const F value ) Converts a value of type F to a corresponding value of type T. This is a convenience function which is automatically available when from is implemented. This function shall therefore not be specialized but always the from function. Parameters : value of type F to convert to T Template Parameters : T is the 'to' type F is the 'from' type Return : converted value of F to corresponding value of T Bar b = iox :: cxx :: into < Bar > ( Foo :: ENUM_VALUE );","title":"function into"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-make_optional","text":"template < typename OptionalBaseType , typename ... Targs > optional < OptionalBaseType > make_optional ( Targs && ... args ) Creates an optional which contains a value by forwarding the arguments to the constructor of T. Parameters : args arguments which will be perfectly forwarded to the constructor of T Return : optional which contains T constructed with args","title":"function make_optional"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-makescopedstatic","text":"template < typename T , typename ... CTorArgs > GenericRAII makeScopedStatic ( T & memory , CTorArgs && ... ctorArgs ) Parameters : memory is a reference to a memory container, e.g. cxx::optional ctorArgs ctor arguments for the object to construct Template Parameters : [in] T memory container which has emplace(...) and reset [in] CTorArgs ctor types for the object to construct Return : cxx::GenericRAII Todo : better name create a GenericRAII object to cleanup a static optional object at the end of the scope","title":"function makeScopedStatic"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-concatenate","text":"template < typename T1 , typename T2 > std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa > >:: type concatenate ( const T1 & t1 , const T2 & t2 ) concatenates two fixed strings/string literals Parameters : fixed strings/string literals to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings string < 5 > fuu ( \"cdefg\" ); auto bar = iox :: cxx :: concatenate ( fuu , \"ahc\" );","title":"function concatenate"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-concatenate_1","text":"template < typename T1 , typename T2 , typename ... Targs > std :: enable_if < ( internal :: IsCharArray < T1 >:: value || internal :: IsCxxString < T1 >:: value ) && ( internal :: IsCharArray < T2 >:: value || internal :: IsCxxString < T2 >:: value ), string < internal :: SumCapa < T1 , T2 , Targs ... >:: value > >:: type concatenate ( const T1 & t1 , const T2 & t2 , const Targs & ... targs ) concatenates an arbitrary number of fixed strings or string literals Parameters : fixed strings/string literals to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings string < 4 > fuu ( \"cdef\" ); auto bar = iox :: cxx :: concatenate ( fuu , \"g\" , \"ah\" , fuu );","title":"function concatenate"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_8","text":"template < uint64_t Capacity > inline bool operator == ( const std :: string & lhs , const string < Capacity > & rhs ) checks if a rhs fixed string is equal to a lhs std::string Parameters : lhs is the std::string rhs is the fixed string Return : true if both strings are equal, otherwise false","title":"function operator=="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_9","text":"template < uint64_t Capacity > inline bool operator == ( const string < Capacity > & lhs , const std :: string & rhs ) checks if a rhs std::string is equal to a lhs fixed string Parameters : lhs is the fixed string rhs is the std::string Return : true if both strings are equal, otherwise false","title":"function operator=="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_10","text":"template < uint64_t Capacity > inline bool operator != ( const std :: string & lhs , const string < Capacity > & rhs ) checks if a rhs fixed string is not equal to a lhs std::string Parameters : lhs is the std::string rhs is the fixed string Return : true if both strings are not equal, otherwise false","title":"function operator!="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_11","text":"template < uint64_t Capacity > inline bool operator != ( const string < Capacity > & lhs , const std :: string & rhs ) checks if a rhs std::string is not equal to a lhs fixed string Parameters : lhs is the fixed string rhs is the std::string Return : true if both strings are not equal, otherwise false","title":"function operator!="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_12","text":"template < uint64_t Capacity > inline bool operator == ( const char * const lhs , const string < Capacity > & rhs ) The equality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : lhs is the char pointer to the array to compare rhs is the fixed string Return : false","title":"function operator=="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_13","text":"template < uint64_t Capacity > inline bool operator != ( const char * const lhs , const string < Capacity > & rhs ) The inequality operator for char pointer and fixed string is disabled via a static_assert, because it may lead to undefined behavior if the char array is not null-terminated. Please convert the char array to a fixed string with string(TruncateToCapacity_t, const char* const other, const uint64_t count) before compare it to a fixed string. Parameters : lhs is the char pointer to the array to compare rhs is the fixed string Return : false","title":"function operator!="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-operator_14","text":"template < uint64_t Capacity > inline std :: ostream & operator << ( std :: ostream & stream , const string < Capacity > & str ) outputs the fixed string on stream Parameters : stream is the output stream str is the fixed string Return : the stream output of the fixed string","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#function-holds_alternative","text":"template < typename T , typename ... Types > constexpr bool holds_alternative ( const variant < Types ... > & variant ) returns true if the variant holds a given type T, otherwise false","title":"function holds_alternative"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-expected","text":"class IOX_NO_DISCARD expected ;","title":"variable expected"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-nullopt","text":"constexpr nullopt_t nullopt = [ nullopt_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1cxx_1_1nullopt__t / )();","title":"variable nullopt"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-in_place","text":"constexpr in_place_t in_place {};","title":"variable in_place"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-operator","text":"std :: enable_if < ( internal :: IsCharArray < T1 >:: value && internal :: IsCxxString < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCharArray < T2 >:: value ) || ( internal :: IsCxxString < T1 >:: value && internal :: IsCxxString < T2 >:: value ), string < internal :: GetCapa < T1 >:: capa + internal :: GetCapa < T2 >:: capa > >:: type operator + ; concatenates two fixed strings or one fixed fixed string and one string literal; concatenation of two string literals is not possible Parameters : fixed strings/string literal to concatenate Return : a new fixed string with capacity equal to the sum of the capacities of the concatenated strings","title":"variable operator+"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-truncatetocapacity","text":"constexpr TruncateToCapacity_t TruncateToCapacity {};","title":"variable TruncateToCapacity"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-always_false_v","text":"constexpr bool always_false_v = false ; Helper value to bind a static_assert to a type. static_assert ( always_false_v < Foo > , \"Not implemented for the given type!\" );","title":"variable always_false_v"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx/#variable-invalid_variant_index","text":"static constexpr uint64_t INVALID_VARIANT_INDEX = std :: numeric_limits < uint64_t >:: max (); value which an invalid variant index occupies cxx :: variant < int , float > someVariant ; // every unset variant has an invalid variant in the beginning if ( someVariant . index () == INVALID_VARIANT_INDEX ) ... cxx :: variant < int , float > someVariant2 ( cxx :: in_place_type < int > , 12 ); // variant with setted value therefore the index is not invalid if ( someVariant . index () != INVALID_VARIANT_INDEX ) ... Updated on 18 December 2023 at 13:11:42 CET","title":"variable INVALID_VARIANT_INDEX"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/","text":"iox::cxx::internal \ud83d\udd17 Functions \ud83d\udd17 Name void Require (const bool condition, const char * file, const int line, const char * function, const char * conditionString) Attributes \ud83d\udd17 Name constexpr char ASCII_A constexpr char ASCII_Z constexpr char ASCII_CAPITAL_A constexpr char ASCII_CAPITAL_Z constexpr char ASCII_0 constexpr char ASCII_9 constexpr char ASCII_MINUS constexpr char ASCII_DOT constexpr char ASCII_COLON constexpr char ASCII_UNDERSCORE Functions Documentation \ud83d\udd17 function Require \ud83d\udd17 void Require ( const bool condition , const char * file , const int line , const char * function , const char * conditionString ) Attributes Documentation \ud83d\udd17 variable ASCII_A \ud83d\udd17 constexpr char ASCII_A = 'a' ; variable ASCII_Z \ud83d\udd17 constexpr char ASCII_Z = 'z' ; variable ASCII_CAPITAL_A \ud83d\udd17 constexpr char ASCII_CAPITAL_A = 'A' ; variable ASCII_CAPITAL_Z \ud83d\udd17 constexpr char ASCII_CAPITAL_Z = 'Z' ; variable ASCII_0 \ud83d\udd17 constexpr char ASCII_0 = '0' ; variable ASCII_9 \ud83d\udd17 constexpr char ASCII_9 = '9' ; variable ASCII_MINUS \ud83d\udd17 constexpr char ASCII_MINUS = '-' ; variable ASCII_DOT \ud83d\udd17 constexpr char ASCII_DOT = '.' ; variable ASCII_COLON \ud83d\udd17 constexpr char ASCII_COLON = ':' ; variable ASCII_UNDERSCORE \ud83d\udd17 constexpr char ASCII_UNDERSCORE = '_' ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::cxx::internal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#ioxcxxinternal","text":"","title":"iox::cxx::internal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#functions","text":"Name void Require (const bool condition, const char * file, const int line, const char * function, const char * conditionString)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#attributes","text":"Name constexpr char ASCII_A constexpr char ASCII_Z constexpr char ASCII_CAPITAL_A constexpr char ASCII_CAPITAL_Z constexpr char ASCII_0 constexpr char ASCII_9 constexpr char ASCII_MINUS constexpr char ASCII_DOT constexpr char ASCII_COLON constexpr char ASCII_UNDERSCORE","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#function-require","text":"void Require ( const bool condition , const char * file , const int line , const char * function , const char * conditionString )","title":"function Require"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_a","text":"constexpr char ASCII_A = 'a' ;","title":"variable ASCII_A"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_z","text":"constexpr char ASCII_Z = 'z' ;","title":"variable ASCII_Z"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_capital_a","text":"constexpr char ASCII_CAPITAL_A = 'A' ;","title":"variable ASCII_CAPITAL_A"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_capital_z","text":"constexpr char ASCII_CAPITAL_Z = 'Z' ;","title":"variable ASCII_CAPITAL_Z"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_0","text":"constexpr char ASCII_0 = '0' ;","title":"variable ASCII_0"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_9","text":"constexpr char ASCII_9 = '9' ;","title":"variable ASCII_9"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_minus","text":"constexpr char ASCII_MINUS = '-' ;","title":"variable ASCII_MINUS"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_dot","text":"constexpr char ASCII_DOT = '.' ;","title":"variable ASCII_DOT"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_colon","text":"constexpr char ASCII_COLON = ':' ;","title":"variable ASCII_COLON"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1cxx_1_1internal/#variable-ascii_underscore","text":"constexpr char ASCII_UNDERSCORE = '_' ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable ASCII_UNDERSCORE"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/","text":"iox::log \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::log::ffbb Classes \ud83d\udd17 Name struct iox::log::LogBin struct iox::log::LogBin16 struct iox::log::LogBin32 struct iox::log::LogBin64 struct iox::log::LogBin8 struct iox::log::LogEntry class iox::log::Logger struct iox::log::LogHex struct iox::log::LogHex16 struct iox::log::LogHex32 struct iox::log::LogHex64 struct iox::log::LogHex8 class iox::log::LogManager struct iox::log::LogRawBuffer class iox::log::LogStream Types \ud83d\udd17 Name enum uint8_t LogLevel { kOff = 0, kFatal, kError, kWarn, kInfo, kDebug, kVerbose} enum uint8_t LogMode { kRemote = 0x01, kFile = 0x02, kConsole = 0x04} enum uint8_t LogLevelOutput { kDisplayLogLevel = 0, kHideLogLevel} Functions \ud83d\udd17 Name LogMode **[operator LogMode & **[operator LogMode operator& (LogMode lhs, LogMode rhs) LogMode & operator&= (LogMode & lhs, LogMode rhs) Logger & createLogger (const std::string & ctxId, const std::string & ctxDescription, const LogLevel appDefLogLevel =LogLevel::kWarn) constexpr LogHex8 HexFormat (uint8_t value) constexpr LogHex8 HexFormat (int8_t value) constexpr LogHex16 HexFormat (uint16_t value) constexpr LogHex16 HexFormat (int16_t value) constexpr LogHex32 HexFormat (uint32_t value) constexpr LogHex32 HexFormat (int32_t value) constexpr LogHex64 HexFormat (uint64_t value) constexpr LogHex64 HexFormat (int64_t value) constexpr LogBin8 BinFormat (uint8_t value) constexpr LogBin8 BinFormat (int8_t value) constexpr LogBin16 BinFormat (uint16_t value) constexpr LogBin16 BinFormat (int16_t value) constexpr LogBin32 BinFormat (uint32_t value) constexpr LogBin32 BinFormat (int32_t value) constexpr LogBin64 BinFormat (uint64_t value) constexpr LogBin64 BinFormat (int64_t value) template <typename T ,typename std::enable_if<!std::is_pointer< T >::value, std::nullptr_t >::type =nullptr> constexpr LogRawBuffer RawBuffer (const T & value) LogStream & operator<< ( LogStream & out, LogLevel value) Attributes \ud83d\udd17 Name constexpr const char * LogLevelColor constexpr const char * LogLevelText Types Documentation \ud83d\udd17 enum LogLevel \ud83d\udd17 Enumerator Value Description kOff 0 kFatal kError kWarn kInfo kDebug kVerbose enum LogMode \ud83d\udd17 Enumerator Value Description kRemote 0x01 kFile 0x02 kConsole 0x04 enum LogLevelOutput \ud83d\udd17 Enumerator Value Description kDisplayLogLevel 0 kHideLogLevel Functions Documentation \ud83d\udd17 function operator| \ud83d\udd17 LogMode operator | ( LogMode lhs , LogMode rhs ) function operator|= \ud83d\udd17 LogMode & operator |= ( LogMode & lhs , LogMode rhs ) function operator& \ud83d\udd17 LogMode operator & ( LogMode lhs , LogMode rhs ) function operator&= \ud83d\udd17 LogMode & operator &= ( LogMode & lhs , LogMode rhs ) function createLogger \ud83d\udd17 Logger & createLogger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel = LogLevel :: kWarn ) function HexFormat \ud83d\udd17 inline constexpr LogHex8 HexFormat ( uint8_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex8 HexFormat ( int8_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex16 HexFormat ( uint16_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex16 HexFormat ( int16_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex32 HexFormat ( uint32_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex32 HexFormat ( int32_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex64 HexFormat ( uint64_t value ) function HexFormat \ud83d\udd17 inline constexpr LogHex64 HexFormat ( int64_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin8 BinFormat ( uint8_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin8 BinFormat ( int8_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin16 BinFormat ( uint16_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin16 BinFormat ( int16_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin32 BinFormat ( uint32_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin32 BinFormat ( int32_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin64 BinFormat ( uint64_t value ) function BinFormat \ud83d\udd17 inline constexpr LogBin64 BinFormat ( int64_t value ) function RawBuffer \ud83d\udd17 template < typename T , typename std :: enable_if <! std :: is_pointer < T >:: value , std :: nullptr_t >:: type = nullptr > inline constexpr LogRawBuffer RawBuffer ( const T & value ) function operator<< \ud83d\udd17 LogStream & operator << ( LogStream & out , LogLevel value ) Attributes Documentation \ud83d\udd17 variable LogLevelColor \ud83d\udd17 constexpr const char * LogLevelColor = { \"\" , \" \\033 [0;1;97;41m\" , \" \\033 [0;1;31;103m\" , \" \\033 [0;1;93m\" , \" \\033 [0;1;92m\" , \" \\033 [0;1;96m\" , \" \\033 [0;1;36m\" , }; variable LogLevelText \ud83d\udd17 constexpr const char * LogLevelText = { \"[ Off ]\" , \"[ Fatal ]\" , \"[ Error ]\" , \"[Warning]\" , \"[ Info ]\" , \"[ Debug ]\" , \"[Verbose]\" , }; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#ioxlog","text":"","title":"iox::log"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#namespaces","text":"Name iox::log::ffbb","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#classes","text":"Name struct iox::log::LogBin struct iox::log::LogBin16 struct iox::log::LogBin32 struct iox::log::LogBin64 struct iox::log::LogBin8 struct iox::log::LogEntry class iox::log::Logger struct iox::log::LogHex struct iox::log::LogHex16 struct iox::log::LogHex32 struct iox::log::LogHex64 struct iox::log::LogHex8 class iox::log::LogManager struct iox::log::LogRawBuffer class iox::log::LogStream","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#types","text":"Name enum uint8_t LogLevel { kOff = 0, kFatal, kError, kWarn, kInfo, kDebug, kVerbose} enum uint8_t LogMode { kRemote = 0x01, kFile = 0x02, kConsole = 0x04} enum uint8_t LogLevelOutput { kDisplayLogLevel = 0, kHideLogLevel}","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#functions","text":"Name LogMode **[operator LogMode & **[operator LogMode operator& (LogMode lhs, LogMode rhs) LogMode & operator&= (LogMode & lhs, LogMode rhs) Logger & createLogger (const std::string & ctxId, const std::string & ctxDescription, const LogLevel appDefLogLevel =LogLevel::kWarn) constexpr LogHex8 HexFormat (uint8_t value) constexpr LogHex8 HexFormat (int8_t value) constexpr LogHex16 HexFormat (uint16_t value) constexpr LogHex16 HexFormat (int16_t value) constexpr LogHex32 HexFormat (uint32_t value) constexpr LogHex32 HexFormat (int32_t value) constexpr LogHex64 HexFormat (uint64_t value) constexpr LogHex64 HexFormat (int64_t value) constexpr LogBin8 BinFormat (uint8_t value) constexpr LogBin8 BinFormat (int8_t value) constexpr LogBin16 BinFormat (uint16_t value) constexpr LogBin16 BinFormat (int16_t value) constexpr LogBin32 BinFormat (uint32_t value) constexpr LogBin32 BinFormat (int32_t value) constexpr LogBin64 BinFormat (uint64_t value) constexpr LogBin64 BinFormat (int64_t value) template <typename T ,typename std::enable_if<!std::is_pointer< T >::value, std::nullptr_t >::type =nullptr> constexpr LogRawBuffer RawBuffer (const T & value) LogStream & operator<< ( LogStream & out, LogLevel value)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#attributes","text":"Name constexpr const char * LogLevelColor constexpr const char * LogLevelText","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#enum-loglevel","text":"Enumerator Value Description kOff 0 kFatal kError kWarn kInfo kDebug kVerbose","title":"enum LogLevel"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#enum-logmode","text":"Enumerator Value Description kRemote 0x01 kFile 0x02 kConsole 0x04","title":"enum LogMode"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#enum-logleveloutput","text":"Enumerator Value Description kDisplayLogLevel 0 kHideLogLevel","title":"enum LogLevelOutput"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator","text":"LogMode operator | ( LogMode lhs , LogMode rhs )","title":"function operator|"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_1","text":"LogMode & operator |= ( LogMode & lhs , LogMode rhs )","title":"function operator|="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_2","text":"LogMode operator & ( LogMode lhs , LogMode rhs )","title":"function operator&amp;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_3","text":"LogMode & operator &= ( LogMode & lhs , LogMode rhs )","title":"function operator&amp;="},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-createlogger","text":"Logger & createLogger ( const std :: string & ctxId , const std :: string & ctxDescription , const LogLevel appDefLogLevel = LogLevel :: kWarn )","title":"function createLogger"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat","text":"inline constexpr LogHex8 HexFormat ( uint8_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_1","text":"inline constexpr LogHex8 HexFormat ( int8_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_2","text":"inline constexpr LogHex16 HexFormat ( uint16_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_3","text":"inline constexpr LogHex16 HexFormat ( int16_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_4","text":"inline constexpr LogHex32 HexFormat ( uint32_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_5","text":"inline constexpr LogHex32 HexFormat ( int32_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_6","text":"inline constexpr LogHex64 HexFormat ( uint64_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-hexformat_7","text":"inline constexpr LogHex64 HexFormat ( int64_t value )","title":"function HexFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat","text":"inline constexpr LogBin8 BinFormat ( uint8_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_1","text":"inline constexpr LogBin8 BinFormat ( int8_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_2","text":"inline constexpr LogBin16 BinFormat ( uint16_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_3","text":"inline constexpr LogBin16 BinFormat ( int16_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_4","text":"inline constexpr LogBin32 BinFormat ( uint32_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_5","text":"inline constexpr LogBin32 BinFormat ( int32_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_6","text":"inline constexpr LogBin64 BinFormat ( uint64_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-binformat_7","text":"inline constexpr LogBin64 BinFormat ( int64_t value )","title":"function BinFormat"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-rawbuffer","text":"template < typename T , typename std :: enable_if <! std :: is_pointer < T >:: value , std :: nullptr_t >:: type = nullptr > inline constexpr LogRawBuffer RawBuffer ( const T & value )","title":"function RawBuffer"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#function-operator_4","text":"LogStream & operator << ( LogStream & out , LogLevel value )","title":"function operator&lt;&lt;"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#variable-loglevelcolor","text":"constexpr const char * LogLevelColor = { \"\" , \" \\033 [0;1;97;41m\" , \" \\033 [0;1;31;103m\" , \" \\033 [0;1;93m\" , \" \\033 [0;1;92m\" , \" \\033 [0;1;96m\" , \" \\033 [0;1;36m\" , };","title":"variable LogLevelColor"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log/#variable-logleveltext","text":"constexpr const char * LogLevelText = { \"[ Off ]\" , \"[ Fatal ]\" , \"[ Error ]\" , \"[Warning]\" , \"[ Info ]\" , \"[ Debug ]\" , \"[Verbose]\" , }; Updated on 18 December 2023 at 13:11:42 CET","title":"variable LogLevelText"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/","text":"iox::log::ffbb \ud83d\udd17 Functions \ud83d\udd17 Name template <typename T > Logger & ComponentLogger () template <typename T > LogStream LogFatal () template <typename T > LogStream LogError () template <typename T > LogStream LogWarn () template <typename T > LogStream LogInfo () template <typename T > LogStream LogDebug () template <typename T > LogStream LogVerbose () Functions Documentation \ud83d\udd17 function ComponentLogger \ud83d\udd17 template < typename T > static Logger & ComponentLogger () function LogFatal \ud83d\udd17 template < typename T > inline LogStream LogFatal () function LogError \ud83d\udd17 template < typename T > inline LogStream LogError () function LogWarn \ud83d\udd17 template < typename T > inline LogStream LogWarn () function LogInfo \ud83d\udd17 template < typename T > inline LogStream LogInfo () function LogDebug \ud83d\udd17 template < typename T > inline LogStream LogDebug () function LogVerbose \ud83d\udd17 template < typename T > inline LogStream LogVerbose () Updated on 18 December 2023 at 13:11:42 CET","title":"iox::log::ffbb"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#ioxlogffbb","text":"","title":"iox::log::ffbb"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#functions","text":"Name template <typename T > Logger & ComponentLogger () template <typename T > LogStream LogFatal () template <typename T > LogStream LogError () template <typename T > LogStream LogWarn () template <typename T > LogStream LogInfo () template <typename T > LogStream LogDebug () template <typename T > LogStream LogVerbose ()","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-componentlogger","text":"template < typename T > static Logger & ComponentLogger ()","title":"function ComponentLogger"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logfatal","text":"template < typename T > inline LogStream LogFatal ()","title":"function LogFatal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logerror","text":"template < typename T > inline LogStream LogError ()","title":"function LogError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logwarn","text":"template < typename T > inline LogStream LogWarn ()","title":"function LogWarn"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-loginfo","text":"template < typename T > inline LogStream LogInfo ()","title":"function LogInfo"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logdebug","text":"template < typename T > inline LogStream LogDebug ()","title":"function LogDebug"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1log_1_1ffbb/#function-logverbose","text":"template < typename T > inline LogStream LogVerbose () Updated on 18 December 2023 at 13:11:42 CET","title":"function LogVerbose"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/","text":"iox::posix \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::posix::internal Classes \ud83d\udd17 Name struct iox::posix::CreateNamedSemaphore_t struct iox::posix::CreateUnnamedSharedMemorySemaphore_t struct iox::posix::CreateUnnamedSingleProcessSemaphore_t class iox::posix::FileLock Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) class iox::posix::NamedPipe struct iox::posix::OpenNamedSemaphore_t class iox::posix::PosixCallBuilder class iox::posix::PosixCallEvaluator class which is created by the verificator to evaluate the result of a posix call struct iox::posix::PosixCallResult result of a posix call class iox::posix::PosixCallVerificator class which verifies the return value of a posix function call class iox::posix::PosixGroup struct iox::posix::PosixRights class iox::posix::PosixUser class iox::posix::Semaphore Posix semaphore C++ Wrapping class. class iox::posix::SignalGuard The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. class iox::posix::SignalWatcher The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. class iox::posix::Timer Interface for timers on POSIX operating systems. Types \ud83d\udd17 Name enum FileLockError { INVALID_FILE_NAME, LOCKED_BY_OTHER_PROCESS, ACCESS_DENIED, QUOTA_EXHAUSTED, INVALID_CHARACTERS_IN_FILE_NAME, SYSTEM_LIMIT, PROCESS_LIMIT, NO_SUCH_DIRECTORY, SPECIAL_FILE, FILE_TOO_LARGE, FILE_IN_USE, OUT_OF_MEMORY, I_O_ERROR, SYS_CALL_NOT_IMPLEMENTED, INTERNAL_LOGIC_ERROR} enum SemaphoreError { CREATION_FAILED, NAME_TOO_LONG, UNABLE_TO_OPEN_HANDLE, INVALID_SEMAPHORE_HANDLE, SEMAPHORE_OVERFLOW, INTERRUPTED_BY_SIGNAL_HANDLER, UNDEFINED} enum SemaphoreWaitState { TIMEOUT, NO_TIMEOUT} enum int Signal { BUS = SIGBUS, INT = SIGINT, TERM = SIGTERM, HUP = SIGHUP, ABORT = SIGABRT} Corresponds to the SIG* macros defined in signal.h. The integer values are equal to the corresponding macro value. enum TimerError { NO_ERROR, TIMER_NOT_INITIALIZED, NO_VALID_CALLBACK, KERNEL_ALLOC_FAILED, INVALID_ARGUMENTS, ALLOC_MEM_FAILED, NO_PERMISSION, INVALID_POINTER, NO_TIMER_TO_DELETE, TIMEOUT_IS_ZERO, INTERNAL_LOGIC_ERROR} using void(*)(int) SignalHandlerCallback_t using cxx::string < MAX_THREAD_NAME_LENGTH > ThreadName_t Functions \ud83d\udd17 Name SignalGuard registerSignalHandler * (const Signal signal, const SignalHandlerCallback_t callback) Register a callback for a specific posix signal (SIG ). void waitForTerminationRequest () convenience function, calls SignalWatcher::getInstance() .waitForSignal(); bool hasTerminationRequested () convenience function, calls SignalWatcher::getInstance() .wasSignalTriggered(); void setThreadName (pthread_t thread, const ThreadName_t & name) ThreadName_t getThreadName (pthread_t thread) Attributes \ud83d\udd17 Name constexpr int MaxNumberOfGroups constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS constexpr int32_t POSIX_CALL_INVALID_ERRNO constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore constexpr CreateNamedSemaphore_t CreateNamedSemaphore constexpr OpenNamedSemaphore_t OpenNamedSemaphore constexpr uint64_t MAX_THREAD_NAME_LENGTH Types Documentation \ud83d\udd17 enum FileLockError \ud83d\udd17 Enumerator Value Description INVALID_FILE_NAME LOCKED_BY_OTHER_PROCESS ACCESS_DENIED QUOTA_EXHAUSTED INVALID_CHARACTERS_IN_FILE_NAME SYSTEM_LIMIT PROCESS_LIMIT NO_SUCH_DIRECTORY SPECIAL_FILE FILE_TOO_LARGE FILE_IN_USE OUT_OF_MEMORY I_O_ERROR SYS_CALL_NOT_IMPLEMENTED INTERNAL_LOGIC_ERROR enum SemaphoreError \ud83d\udd17 Enumerator Value Description CREATION_FAILED NAME_TOO_LONG UNABLE_TO_OPEN_HANDLE INVALID_SEMAPHORE_HANDLE SEMAPHORE_OVERFLOW INTERRUPTED_BY_SIGNAL_HANDLER UNDEFINED enum SemaphoreWaitState \ud83d\udd17 Enumerator Value Description TIMEOUT NO_TIMEOUT enum Signal \ud83d\udd17 Enumerator Value Description BUS SIGBUS INT SIGINT TERM SIGTERM HUP SIGHUP ABORT SIGABRT Corresponds to the SIG* macros defined in signal.h. The integer values are equal to the corresponding macro value. enum TimerError \ud83d\udd17 Enumerator Value Description NO_ERROR TIMER_NOT_INITIALIZED NO_VALID_CALLBACK KERNEL_ALLOC_FAILED INVALID_ARGUMENTS ALLOC_MEM_FAILED NO_PERMISSION INVALID_POINTER NO_TIMER_TO_DELETE TIMEOUT_IS_ZERO INTERNAL_LOGIC_ERROR using SignalHandlerCallback_t \ud83d\udd17 using iox :: posix :: SignalHandlerCallback_t = typedef void ( * )( int ); using ThreadName_t \ud83d\udd17 using iox :: posix :: ThreadName_t = typedef cxx :: string < MAX_THREAD_NAME_LENGTH > ; Functions Documentation \ud83d\udd17 function registerSignalHandler \ud83d\udd17 SignalGuard registerSignalHandler ( const Signal signal , const SignalHandlerCallback_t callback ) Register a callback for a specific posix signal (SIG***). Parameters : Signal the signal to which the callback should be attached callback the callback which should be called when the signal is raised. Return : SignalGuard , when it goes out of scope the previous signal action is restored. Attention : if a signal callback was already registered for the provided signal with registerSignalHandler or with sigaction() or signal(), the signal callback is overridden until the SignalGuard goes out of scope and restores the previous callback. If you override the callbacks multiple times and the created SignalGuards goes out of scope in a different order then the callback is restored which was active when the last SignalGuard which is going out of scope was created. function waitForTerminationRequest \ud83d\udd17 void waitForTerminationRequest () convenience function, calls SignalWatcher::getInstance() .waitForSignal(); function hasTerminationRequested \ud83d\udd17 bool hasTerminationRequested () convenience function, calls SignalWatcher::getInstance() .wasSignalTriggered(); function setThreadName \ud83d\udd17 void setThreadName ( pthread_t thread , const ThreadName_t & name ) function getThreadName \ud83d\udd17 ThreadName_t getThreadName ( pthread_t thread ) Attributes Documentation \ud83d\udd17 variable MaxNumberOfGroups \ud83d\udd17 static constexpr int MaxNumberOfGroups = 888 ; variable POSIX_CALL_ERROR_STRING_SIZE \ud83d\udd17 static constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE = 128U ; variable POSIX_CALL_EINTR_REPETITIONS \ud83d\udd17 static constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS = 5U ; variable POSIX_CALL_INVALID_ERRNO \ud83d\udd17 static constexpr int32_t POSIX_CALL_INVALID_ERRNO = -1 ; variable CreateUnnamedSingleProcessSemaphore \ud83d\udd17 static constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore = [ CreateUnnamedSingleProcessSemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1CreateUnnamedSingleProcessSemaphore__t / )(); variable CreateUnnamedSharedMemorySemaphore \ud83d\udd17 static constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore = [ CreateUnnamedSharedMemorySemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1CreateUnnamedSharedMemorySemaphore__t / )(); variable CreateNamedSemaphore \ud83d\udd17 static constexpr CreateNamedSemaphore_t CreateNamedSemaphore = [ CreateNamedSemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1CreateNamedSemaphore__t / )(); variable OpenNamedSemaphore \ud83d\udd17 static constexpr OpenNamedSemaphore_t OpenNamedSemaphore = [ OpenNamedSemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1OpenNamedSemaphore__t / )(); variable MAX_THREAD_NAME_LENGTH \ud83d\udd17 constexpr uint64_t MAX_THREAD_NAME_LENGTH = 15U ; Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#ioxposix","text":"","title":"iox::posix"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#namespaces","text":"Name iox::posix::internal","title":"Namespaces"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#classes","text":"Name struct iox::posix::CreateNamedSemaphore_t struct iox::posix::CreateUnnamedSharedMemorySemaphore_t struct iox::posix::CreateUnnamedSingleProcessSemaphore_t class iox::posix::FileLock Posix file lock C++ wrapping class Following RAII, the lock is acquired on creation and released on destruction. Releasing the locks works even if the process crashes with a segfault or using SIGKILL. 'lslocks' can be used to display all system-wide locks (see man page) class iox::posix::NamedPipe struct iox::posix::OpenNamedSemaphore_t class iox::posix::PosixCallBuilder class iox::posix::PosixCallEvaluator class which is created by the verificator to evaluate the result of a posix call struct iox::posix::PosixCallResult result of a posix call class iox::posix::PosixCallVerificator class which verifies the return value of a posix function call class iox::posix::PosixGroup struct iox::posix::PosixRights class iox::posix::PosixUser class iox::posix::Semaphore Posix semaphore C++ Wrapping class. class iox::posix::SignalGuard The SignalGuard is a class returned by registerSignalHandler. When it goes out of scope it restores the previous signal action. Typical use case: One would like to override the signal action in main() or some C posix makes it necessary to override the standard signal action before and after the call. class iox::posix::SignalWatcher The SignalWatcher waits for SIGINT and SIGTERM. One can wait until the signal has occurred or ask the watcher if it has occurred. class iox::posix::Timer Interface for timers on POSIX operating systems.","title":"Classes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#types","text":"Name enum FileLockError { INVALID_FILE_NAME, LOCKED_BY_OTHER_PROCESS, ACCESS_DENIED, QUOTA_EXHAUSTED, INVALID_CHARACTERS_IN_FILE_NAME, SYSTEM_LIMIT, PROCESS_LIMIT, NO_SUCH_DIRECTORY, SPECIAL_FILE, FILE_TOO_LARGE, FILE_IN_USE, OUT_OF_MEMORY, I_O_ERROR, SYS_CALL_NOT_IMPLEMENTED, INTERNAL_LOGIC_ERROR} enum SemaphoreError { CREATION_FAILED, NAME_TOO_LONG, UNABLE_TO_OPEN_HANDLE, INVALID_SEMAPHORE_HANDLE, SEMAPHORE_OVERFLOW, INTERRUPTED_BY_SIGNAL_HANDLER, UNDEFINED} enum SemaphoreWaitState { TIMEOUT, NO_TIMEOUT} enum int Signal { BUS = SIGBUS, INT = SIGINT, TERM = SIGTERM, HUP = SIGHUP, ABORT = SIGABRT} Corresponds to the SIG* macros defined in signal.h. The integer values are equal to the corresponding macro value. enum TimerError { NO_ERROR, TIMER_NOT_INITIALIZED, NO_VALID_CALLBACK, KERNEL_ALLOC_FAILED, INVALID_ARGUMENTS, ALLOC_MEM_FAILED, NO_PERMISSION, INVALID_POINTER, NO_TIMER_TO_DELETE, TIMEOUT_IS_ZERO, INTERNAL_LOGIC_ERROR} using void(*)(int) SignalHandlerCallback_t using cxx::string < MAX_THREAD_NAME_LENGTH > ThreadName_t","title":"Types"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#functions","text":"Name SignalGuard registerSignalHandler * (const Signal signal, const SignalHandlerCallback_t callback) Register a callback for a specific posix signal (SIG ). void waitForTerminationRequest () convenience function, calls SignalWatcher::getInstance() .waitForSignal(); bool hasTerminationRequested () convenience function, calls SignalWatcher::getInstance() .wasSignalTriggered(); void setThreadName (pthread_t thread, const ThreadName_t & name) ThreadName_t getThreadName (pthread_t thread)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#attributes","text":"Name constexpr int MaxNumberOfGroups constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS constexpr int32_t POSIX_CALL_INVALID_ERRNO constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore constexpr CreateNamedSemaphore_t CreateNamedSemaphore constexpr OpenNamedSemaphore_t OpenNamedSemaphore constexpr uint64_t MAX_THREAD_NAME_LENGTH","title":"Attributes"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-filelockerror","text":"Enumerator Value Description INVALID_FILE_NAME LOCKED_BY_OTHER_PROCESS ACCESS_DENIED QUOTA_EXHAUSTED INVALID_CHARACTERS_IN_FILE_NAME SYSTEM_LIMIT PROCESS_LIMIT NO_SUCH_DIRECTORY SPECIAL_FILE FILE_TOO_LARGE FILE_IN_USE OUT_OF_MEMORY I_O_ERROR SYS_CALL_NOT_IMPLEMENTED INTERNAL_LOGIC_ERROR","title":"enum FileLockError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-semaphoreerror","text":"Enumerator Value Description CREATION_FAILED NAME_TOO_LONG UNABLE_TO_OPEN_HANDLE INVALID_SEMAPHORE_HANDLE SEMAPHORE_OVERFLOW INTERRUPTED_BY_SIGNAL_HANDLER UNDEFINED","title":"enum SemaphoreError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-semaphorewaitstate","text":"Enumerator Value Description TIMEOUT NO_TIMEOUT","title":"enum SemaphoreWaitState"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-signal","text":"Enumerator Value Description BUS SIGBUS INT SIGINT TERM SIGTERM HUP SIGHUP ABORT SIGABRT Corresponds to the SIG* macros defined in signal.h. The integer values are equal to the corresponding macro value.","title":"enum Signal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#enum-timererror","text":"Enumerator Value Description NO_ERROR TIMER_NOT_INITIALIZED NO_VALID_CALLBACK KERNEL_ALLOC_FAILED INVALID_ARGUMENTS ALLOC_MEM_FAILED NO_PERMISSION INVALID_POINTER NO_TIMER_TO_DELETE TIMEOUT_IS_ZERO INTERNAL_LOGIC_ERROR","title":"enum TimerError"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#using-signalhandlercallback_t","text":"using iox :: posix :: SignalHandlerCallback_t = typedef void ( * )( int );","title":"using SignalHandlerCallback_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#using-threadname_t","text":"using iox :: posix :: ThreadName_t = typedef cxx :: string < MAX_THREAD_NAME_LENGTH > ;","title":"using ThreadName_t"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-registersignalhandler","text":"SignalGuard registerSignalHandler ( const Signal signal , const SignalHandlerCallback_t callback ) Register a callback for a specific posix signal (SIG***). Parameters : Signal the signal to which the callback should be attached callback the callback which should be called when the signal is raised. Return : SignalGuard , when it goes out of scope the previous signal action is restored. Attention : if a signal callback was already registered for the provided signal with registerSignalHandler or with sigaction() or signal(), the signal callback is overridden until the SignalGuard goes out of scope and restores the previous callback. If you override the callbacks multiple times and the created SignalGuards goes out of scope in a different order then the callback is restored which was active when the last SignalGuard which is going out of scope was created.","title":"function registerSignalHandler"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-waitforterminationrequest","text":"void waitForTerminationRequest () convenience function, calls SignalWatcher::getInstance() .waitForSignal();","title":"function waitForTerminationRequest"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-hasterminationrequested","text":"bool hasTerminationRequested () convenience function, calls SignalWatcher::getInstance() .wasSignalTriggered();","title":"function hasTerminationRequested"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-setthreadname","text":"void setThreadName ( pthread_t thread , const ThreadName_t & name )","title":"function setThreadName"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#function-getthreadname","text":"ThreadName_t getThreadName ( pthread_t thread )","title":"function getThreadName"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-maxnumberofgroups","text":"static constexpr int MaxNumberOfGroups = 888 ;","title":"variable MaxNumberOfGroups"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-posix_call_error_string_size","text":"static constexpr uint32_t POSIX_CALL_ERROR_STRING_SIZE = 128U ;","title":"variable POSIX_CALL_ERROR_STRING_SIZE"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-posix_call_eintr_repetitions","text":"static constexpr uint64_t POSIX_CALL_EINTR_REPETITIONS = 5U ;","title":"variable POSIX_CALL_EINTR_REPETITIONS"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-posix_call_invalid_errno","text":"static constexpr int32_t POSIX_CALL_INVALID_ERRNO = -1 ;","title":"variable POSIX_CALL_INVALID_ERRNO"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-createunnamedsingleprocesssemaphore","text":"static constexpr CreateUnnamedSingleProcessSemaphore_t CreateUnnamedSingleProcessSemaphore = [ CreateUnnamedSingleProcessSemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1CreateUnnamedSingleProcessSemaphore__t / )();","title":"variable CreateUnnamedSingleProcessSemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-createunnamedsharedmemorysemaphore","text":"static constexpr CreateUnnamedSharedMemorySemaphore_t CreateUnnamedSharedMemorySemaphore = [ CreateUnnamedSharedMemorySemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1CreateUnnamedSharedMemorySemaphore__t / )();","title":"variable CreateUnnamedSharedMemorySemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-createnamedsemaphore","text":"static constexpr CreateNamedSemaphore_t CreateNamedSemaphore = [ CreateNamedSemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1CreateNamedSemaphore__t / )();","title":"variable CreateNamedSemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-opennamedsemaphore","text":"static constexpr OpenNamedSemaphore_t OpenNamedSemaphore = [ OpenNamedSemaphore_t ]( / v2 .0.5 / API - reference / hoofs / Classes / structiox_1_1posix_1_1OpenNamedSemaphore__t / )();","title":"variable OpenNamedSemaphore"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix/#variable-max_thread_name_length","text":"constexpr uint64_t MAX_THREAD_NAME_LENGTH = 15U ; Updated on 18 December 2023 at 13:11:42 CET","title":"variable MAX_THREAD_NAME_LENGTH"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/","text":"iox::posix::internal \ud83d\udd17 Functions \ud83d\udd17 Name template <typename ReturnType ,typename... FunctionArguments> PosixCallBuilder < ReturnType, FunctionArguments... > createPosixCallBuilder (ReturnType(*)(FunctionArguments...) posixCall, const char * posixFunctionName, const char * file, const int32_t line, const char * callingFunction) Functions Documentation \ud83d\udd17 function createPosixCallBuilder \ud83d\udd17 template < typename ReturnType , typename ... FunctionArguments > PosixCallBuilder < ReturnType , FunctionArguments ... > createPosixCallBuilder ( ReturnType ( * )( FunctionArguments ...) posixCall , const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) Updated on 18 December 2023 at 13:11:42 CET","title":"iox::posix::internal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#ioxposixinternal","text":"","title":"iox::posix::internal"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#functions","text":"Name template <typename ReturnType ,typename... FunctionArguments> PosixCallBuilder < ReturnType, FunctionArguments... > createPosixCallBuilder (ReturnType(*)(FunctionArguments...) posixCall, const char * posixFunctionName, const char * file, const int32_t line, const char * callingFunction)","title":"Functions"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1posix_1_1internal/#function-createposixcallbuilder","text":"template < typename ReturnType , typename ... FunctionArguments > PosixCallBuilder < ReturnType , FunctionArguments ... > createPosixCallBuilder ( ReturnType ( * )( FunctionArguments ...) posixCall , const char * posixFunctionName , const char * file , const int32_t line , const char * callingFunction ) Updated on 18 December 2023 at 13:11:42 CET","title":"function createPosixCallBuilder"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1units_1_1duration__literals/","text":"iox::units::duration_literals \ud83d\udd17 Updated on 18 December 2023 at 13:11:42 CET","title":"iox::units::duration_literals"},{"location":"API-reference/hoofs/Namespaces/namespaceiox_1_1units_1_1duration__literals/#ioxunitsduration_literals","text":"Updated on 18 December 2023 at 13:11:42 CET","title":"iox::units::duration_literals"},{"location":"API-reference/hoofs/Pages/concurrent/","text":"Concurrency \ud83d\udd17 Member iox::cxx::VariantQueue< ValueType, Capacity >::setCapacity (const uint64_t newCapacity) noexcept not thread safe Class iox::posix::Timer not thread safe Updated on 18 December 2023 at 13:11:43 CET","title":"Concurrency"},{"location":"API-reference/hoofs/Pages/concurrent/#concurrency","text":"Member iox::cxx::VariantQueue< ValueType, Capacity >::setCapacity (const uint64_t newCapacity) noexcept not thread safe Class iox::posix::Timer not thread safe Updated on 18 December 2023 at 13:11:43 CET","title":"Concurrency"},{"location":"API-reference/hoofs/Pages/todo/","text":"Todo List \ud83d\udd17 Member iox::cxx::string< Capacity >::operator!= (const char *const rhs) const noexcept consider implementing the inequality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator!=(const char (&rhs)[N]) const noexcept Member iox::cxx::string< Capacity >::operator== (const char *const rhs) const noexcept consider implementing the equality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator==(const char (&rhs)[N]) const noexcept Class iox::log::Logger for asynchronous logging, make the logger an active object according to Herb Sutter https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/ Member iox::log::Logger::LogStream LogStream needs to call Log(); do we want to make Log() public? Member iox::posix::Timer::now () noexcept maybe move this to a clock implementation? Member iox::posix::Timer::Timer (const units::Duration timeToWait) noexcept refactor this cTor and its functionality to a class called StopWatch Updated on 18 December 2023 at 13:11:43 CET","title":"Todo List"},{"location":"API-reference/hoofs/Pages/todo/#todo-list","text":"Member iox::cxx::string< Capacity >::operator!= (const char *const rhs) const noexcept consider implementing the inequality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator!=(const char (&rhs)[N]) const noexcept Member iox::cxx::string< Capacity >::operator== (const char *const rhs) const noexcept consider implementing the equality operator for a char array for which the size is known at compile time; it could have the following signature template bool operator==(const char (&rhs)[N]) const noexcept Class iox::log::Logger for asynchronous logging, make the logger an active object according to Herb Sutter https://herbsutter.com/2010/07/12/effective-concurrency-prefer-using-active-objects-instead-of-naked-threads/ Member iox::log::Logger::LogStream LogStream needs to call Log(); do we want to make Log() public? Member iox::posix::Timer::now () noexcept maybe move this to a clock implementation? Member iox::posix::Timer::Timer (const units::Duration timeToWait) noexcept refactor this cTor and its functionality to a class called StopWatch Updated on 18 December 2023 at 13:11:43 CET","title":"Todo List"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/","text":"iox::client::introspection::IceOryxIntrospectionApp \ud83d\udd17 Inherits from iox::client::introspection::IntrospectionApp Public Functions \ud83d\udd17 Name IceOryxIntrospectionApp (int argc, char * argv[]) constructor to create the introspection virtual void run () override starts the execution of introspection Additional inherited members \ud83d\udd17 Protected Types inherited from iox::client::introspection::IntrospectionApp Name enum CmdLineArgumentParsingMode { ALL, ONE} Public Functions inherited from iox::client::introspection::IntrospectionApp Name IntrospectionApp (int argc, char * argv[]) constructor to create a introspection virtual ~IntrospectionApp () Protected Functions inherited from iox::client::introspection::IntrospectionApp Name IntrospectionApp () this is needed for the child classes to extend the parseCmdLineArguments function void parseCmdLineArguments (int argc, char ** argv, CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) void runIntrospection (const iox::units::Duration updatePeriodMs, const IntrospectionSelection introspectionSelection) Protected Attributes inherited from iox::client::introspection::IntrospectionApp Name IntrospectionSelection introspectionSelection bool doIntrospection Public Functions Documentation \ud83d\udd17 function IceOryxIntrospectionApp \ud83d\udd17 IceOryxIntrospectionApp ( int argc , char * argv [] ) constructor to create the introspection Parameters : argc forwarding of command line arguments argv forwarding of command line arguments function run \ud83d\udd17 virtual void run () override starts the execution of introspection Reimplements : iox::client::introspection::IntrospectionApp::run Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client::introspection::IceOryxIntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#ioxclientintrospectioniceoryxintrospectionapp","text":"Inherits from iox::client::introspection::IntrospectionApp","title":"iox::client::introspection::IceOryxIntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#public-functions","text":"Name IceOryxIntrospectionApp (int argc, char * argv[]) constructor to create the introspection virtual void run () override starts the execution of introspection","title":"Public Functions"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#additional-inherited-members","text":"Protected Types inherited from iox::client::introspection::IntrospectionApp Name enum CmdLineArgumentParsingMode { ALL, ONE} Public Functions inherited from iox::client::introspection::IntrospectionApp Name IntrospectionApp (int argc, char * argv[]) constructor to create a introspection virtual ~IntrospectionApp () Protected Functions inherited from iox::client::introspection::IntrospectionApp Name IntrospectionApp () this is needed for the child classes to extend the parseCmdLineArguments function void parseCmdLineArguments (int argc, char ** argv, CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) void runIntrospection (const iox::units::Duration updatePeriodMs, const IntrospectionSelection introspectionSelection) Protected Attributes inherited from iox::client::introspection::IntrospectionApp Name IntrospectionSelection introspectionSelection bool doIntrospection","title":"Additional inherited members"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#function-iceoryxintrospectionapp","text":"IceOryxIntrospectionApp ( int argc , char * argv [] ) constructor to create the introspection Parameters : argc forwarding of command line arguments argv forwarding of command line arguments","title":"function IceOryxIntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IceOryxIntrospectionApp/#function-run","text":"virtual void run () override starts the execution of introspection Reimplements : iox::client::introspection::IntrospectionApp::run Updated on 18 December 2023 at 13:11:43 CET","title":"function run"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/","text":"iox::client::introspection::IntrospectionApp \ud83d\udd17 base class for introspection More... #include <iceoryx_introspection/introspection_app.hpp> Inherited by iox::client::introspection::IceOryxIntrospectionApp Protected Types \ud83d\udd17 Name enum CmdLineArgumentParsingMode { ALL, ONE} Public Functions \ud83d\udd17 Name IntrospectionApp (int argc, char * argv[]) constructor to create a introspection virtual ~IntrospectionApp () virtual void run () =0 interface to start the execution of the introspection Protected Functions \ud83d\udd17 Name IntrospectionApp () this is needed for the child classes to extend the parseCmdLineArguments function void parseCmdLineArguments (int argc, char ** argv, CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) void runIntrospection (const iox::units::Duration updatePeriodMs, const IntrospectionSelection introspectionSelection) Protected Attributes \ud83d\udd17 Name IntrospectionSelection introspectionSelection bool doIntrospection Detailed Description \ud83d\udd17 class iox :: client :: introspection :: IntrospectionApp ; base class for introspection Todo : Wrap all C calls with posixCall Protected Types Documentation \ud83d\udd17 enum CmdLineArgumentParsingMode \ud83d\udd17 Enumerator Value Description ALL ONE Public Functions Documentation \ud83d\udd17 function IntrospectionApp \ud83d\udd17 IntrospectionApp ( int argc , char * argv [] ) constructor to create a introspection Parameters : argc forwarding of command line arguments argv forwarding of command line arguments function ~IntrospectionApp \ud83d\udd17 inline virtual ~ IntrospectionApp () function run \ud83d\udd17 virtual void run () = 0 interface to start the execution of the introspection Reimplemented by : iox::client::introspection::IceOryxIntrospectionApp::run Protected Functions Documentation \ud83d\udd17 function IntrospectionApp \ud83d\udd17 IntrospectionApp () this is needed for the child classes to extend the parseCmdLineArguments function function parseCmdLineArguments \ud83d\udd17 void parseCmdLineArguments ( int argc , char ** argv , CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) function runIntrospection \ud83d\udd17 void runIntrospection ( const iox :: units :: Duration updatePeriodMs , const IntrospectionSelection introspectionSelection ) Protected Attributes Documentation \ud83d\udd17 variable introspectionSelection \ud83d\udd17 IntrospectionSelection introspectionSelection ; variable doIntrospection \ud83d\udd17 bool doIntrospection = false ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client::introspection::IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#ioxclientintrospectionintrospectionapp","text":"base class for introspection More... #include <iceoryx_introspection/introspection_app.hpp> Inherited by iox::client::introspection::IceOryxIntrospectionApp","title":"iox::client::introspection::IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-types","text":"Name enum CmdLineArgumentParsingMode { ALL, ONE}","title":"Protected Types"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#public-functions","text":"Name IntrospectionApp (int argc, char * argv[]) constructor to create a introspection virtual ~IntrospectionApp () virtual void run () =0 interface to start the execution of the introspection","title":"Public Functions"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-functions","text":"Name IntrospectionApp () this is needed for the child classes to extend the parseCmdLineArguments function void parseCmdLineArguments (int argc, char ** argv, CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) void runIntrospection (const iox::units::Duration updatePeriodMs, const IntrospectionSelection introspectionSelection)","title":"Protected Functions"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-attributes","text":"Name IntrospectionSelection introspectionSelection bool doIntrospection","title":"Protected Attributes"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#detailed-description","text":"class iox :: client :: introspection :: IntrospectionApp ; base class for introspection Todo : Wrap all C calls with posixCall","title":"Detailed Description"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#enum-cmdlineargumentparsingmode","text":"Enumerator Value Description ALL ONE","title":"enum CmdLineArgumentParsingMode"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-introspectionapp","text":"IntrospectionApp ( int argc , char * argv [] ) constructor to create a introspection Parameters : argc forwarding of command line arguments argv forwarding of command line arguments","title":"function IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-introspectionapp_1","text":"inline virtual ~ IntrospectionApp ()","title":"function ~IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-run","text":"virtual void run () = 0 interface to start the execution of the introspection Reimplemented by : iox::client::introspection::IceOryxIntrospectionApp::run","title":"function run"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-introspectionapp_2","text":"IntrospectionApp () this is needed for the child classes to extend the parseCmdLineArguments function","title":"function IntrospectionApp"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-parsecmdlinearguments","text":"void parseCmdLineArguments ( int argc , char ** argv , CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL )","title":"function parseCmdLineArguments"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#function-runintrospection","text":"void runIntrospection ( const iox :: units :: Duration updatePeriodMs , const IntrospectionSelection introspectionSelection )","title":"function runIntrospection"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#variable-introspectionselection","text":"IntrospectionSelection introspectionSelection ;","title":"variable introspectionSelection"},{"location":"API-reference/introspection/Classes/classiox_1_1client_1_1introspection_1_1IntrospectionApp/#variable-dointrospection","text":"bool doIntrospection = false ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable doIntrospection"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/","text":"iox::client::introspection::ComposedPublisherPortData \ud83d\udd17 More... #include <iceoryx_introspection/introspection_types.hpp> Public Functions \ud83d\udd17 Name ComposedPublisherPortData (const PublisherPortData & portData, const PortThroughputData & throughputData) Public Attributes \ud83d\udd17 Name const PublisherPortData * portData const PortThroughputData * throughputData Detailed Description \ud83d\udd17 struct iox :: client :: introspection :: ComposedPublisherPortData ; Note : this contains just pointer to the real data, therefore pay attention to the lifetime of the original data Public Functions Documentation \ud83d\udd17 function ComposedPublisherPortData \ud83d\udd17 inline ComposedPublisherPortData ( const PublisherPortData & portData , const PortThroughputData & throughputData ) Public Attributes Documentation \ud83d\udd17 variable portData \ud83d\udd17 const PublisherPortData * portData ; variable throughputData \ud83d\udd17 const PortThroughputData * throughputData ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client::introspection::ComposedPublisherPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#ioxclientintrospectioncomposedpublisherportdata","text":"More... #include <iceoryx_introspection/introspection_types.hpp>","title":"iox::client::introspection::ComposedPublisherPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-functions","text":"Name ComposedPublisherPortData (const PublisherPortData & portData, const PortThroughputData & throughputData)","title":"Public Functions"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-attributes","text":"Name const PublisherPortData * portData const PortThroughputData * throughputData","title":"Public Attributes"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#detailed-description","text":"struct iox :: client :: introspection :: ComposedPublisherPortData ; Note : this contains just pointer to the real data, therefore pay attention to the lifetime of the original data","title":"Detailed Description"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#function-composedpublisherportdata","text":"inline ComposedPublisherPortData ( const PublisherPortData & portData , const PortThroughputData & throughputData )","title":"function ComposedPublisherPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#variable-portdata","text":"const PublisherPortData * portData ;","title":"variable portData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedPublisherPortData/#variable-throughputdata","text":"const PortThroughputData * throughputData ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable throughputData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/","text":"iox::client::introspection::ComposedSubscriberPortData \ud83d\udd17 Public Functions \ud83d\udd17 Name ComposedSubscriberPortData (const SubscriberPortData & portData, const SubscriberPortChangingData & subscriberPortChangingData) Public Attributes \ud83d\udd17 Name const SubscriberPortData * portData const SubscriberPortChangingData * subscriberPortChangingData Public Functions Documentation \ud83d\udd17 function ComposedSubscriberPortData \ud83d\udd17 inline ComposedSubscriberPortData ( const SubscriberPortData & portData , const SubscriberPortChangingData & subscriberPortChangingData ) Public Attributes Documentation \ud83d\udd17 variable portData \ud83d\udd17 const SubscriberPortData * portData ; variable subscriberPortChangingData \ud83d\udd17 const SubscriberPortChangingData * subscriberPortChangingData ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client::introspection::ComposedSubscriberPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#ioxclientintrospectioncomposedsubscriberportdata","text":"","title":"iox::client::introspection::ComposedSubscriberPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-functions","text":"Name ComposedSubscriberPortData (const SubscriberPortData & portData, const SubscriberPortChangingData & subscriberPortChangingData)","title":"Public Functions"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-attributes","text":"Name const SubscriberPortData * portData const SubscriberPortChangingData * subscriberPortChangingData","title":"Public Attributes"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#function-composedsubscriberportdata","text":"inline ComposedSubscriberPortData ( const SubscriberPortData & portData , const SubscriberPortChangingData & subscriberPortChangingData )","title":"function ComposedSubscriberPortData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#variable-portdata","text":"const SubscriberPortData * portData ;","title":"variable portData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1ComposedSubscriberPortData/#variable-subscriberportchangingdata","text":"const SubscriberPortChangingData * subscriberPortChangingData ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable subscriberPortChangingData"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/","text":"iox::client::introspection::IntrospectionSelection \ud83d\udd17 Public Attributes \ud83d\udd17 Name bool mempool bool process bool port Public Attributes Documentation \ud83d\udd17 variable mempool \ud83d\udd17 bool mempool { false }; variable process \ud83d\udd17 bool process { false }; variable port \ud83d\udd17 bool port { false }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client::introspection::IntrospectionSelection"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#ioxclientintrospectionintrospectionselection","text":"","title":"iox::client::introspection::IntrospectionSelection"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#public-attributes","text":"Name bool mempool bool process bool port","title":"Public Attributes"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#variable-mempool","text":"bool mempool { false };","title":"variable mempool"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#variable-process","text":"bool process { false };","title":"variable process"},{"location":"API-reference/introspection/Classes/structiox_1_1client_1_1introspection_1_1IntrospectionSelection/#variable-port","text":"bool port { false }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable port"},{"location":"API-reference/introspection/Files/dir_18f66dcf58fe6b827bdb3fbbb3336743/","text":"iceoryx_introspection \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_introspection/iceoryx_introspection_app.hpp iceoryx_introspection/introspection_app.hpp iceoryx_introspection/introspection_types.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_introspection"},{"location":"API-reference/introspection/Files/dir_18f66dcf58fe6b827bdb3fbbb3336743/#iceoryx_introspection","text":"","title":"iceoryx_introspection"},{"location":"API-reference/introspection/Files/dir_18f66dcf58fe6b827bdb3fbbb3336743/#files","text":"Name iceoryx_introspection/iceoryx_introspection_app.hpp iceoryx_introspection/introspection_app.hpp iceoryx_introspection/introspection_types.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/","text":"iceoryx_introspection/iceoryx_introspection_app.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::client iox::client::introspection Classes \ud83d\udd17 Name class iox::client::introspection::IceOryxIntrospectionApp Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP #define IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP #include \"iceoryx_introspection/introspection_app.hpp\" namespace iox { namespace client { namespace introspection { class IceOryxIntrospectionApp : public IntrospectionApp { public : IceOryxIntrospectionApp ( int argc , char * argv []) noexcept ; void run () noexcept override ; }; } // namespace introspection } // namespace client } // namespace iox #endif // IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_introspection/iceoryx_introspection_app.hpp"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#iceoryx_introspectioniceoryx_introspection_apphpp","text":"","title":"iceoryx_introspection/iceoryx_introspection_app.hpp"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#namespaces","text":"Name iox iox::client iox::client::introspection","title":"Namespaces"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#classes","text":"Name class iox::client::introspection::IceOryxIntrospectionApp","title":"Classes"},{"location":"API-reference/introspection/Files/iceoryx__introspection__app_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP #define IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP #include \"iceoryx_introspection/introspection_app.hpp\" namespace iox { namespace client { namespace introspection { class IceOryxIntrospectionApp : public IntrospectionApp { public : IceOryxIntrospectionApp ( int argc , char * argv []) noexcept ; void run () noexcept override ; }; } // namespace introspection } // namespace client } // namespace iox #endif // IOX_TOOLS_ICEORYX_INTROSPECTION_ICEORYX_INTROSPECTION_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/","text":"iceoryx_introspection/introspection_app.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::client iox::client::introspection Classes \ud83d\udd17 Name class iox::client::introspection::IntrospectionApp base class for introspection Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP #define IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP #include \"iceoryx_hoofs/platform/getopt.hpp\" #include \"iceoryx_introspection/introspection_types.hpp\" #include \"iceoryx_posh/popo/subscriber.hpp\" #include <map> #include <ncurses.h> #include <vector> namespace iox { namespace client { namespace introspection { static constexpr option longOptions [] = {{ \"help\" , no_argument , nullptr , 'h' }, { \"version\" , no_argument , nullptr , 'v' }, { \"time\" , required_argument , nullptr , 't' }, { \"mempool\" , no_argument , nullptr , 0 }, { \"port\" , no_argument , nullptr , 0 }, { \"process\" , no_argument , nullptr , 0 }, { \"all\" , no_argument , nullptr , 0 }, { nullptr , 0 , nullptr , 0 }}; static constexpr const char * shortOptions = \"hvt:\" ; static constexpr iox :: units :: Duration MIN_UPDATE_PERIOD = 500 _ms ; static constexpr iox :: units :: Duration DEFAULT_UPDATE_PERIOD = 1000 _ms ; static constexpr iox :: units :: Duration MAX_UPDATE_PERIOD = 10000 _ms ; enum class ColorPairs : uint8_t { redOnBlack = 1 , whiteOnRed }; static const std :: map < PrettyOptions , uint32_t > prettyMap = { { PrettyOptions :: title , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: redOnBlack ))}, { PrettyOptions :: highlight , A_BOLD | A_UNDERLINE }, { PrettyOptions :: error , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: whiteOnRed ))}, { PrettyOptions :: bold , A_BOLD }, { PrettyOptions :: normal , A_NORMAL }}; class IntrospectionApp { public : IntrospectionApp ( int argc , char * argv []) noexcept ; virtual ~ IntrospectionApp () noexcept {}; virtual void run () noexcept = 0 ; protected : enum class CmdLineArgumentParsingMode { ALL , ONE }; IntrospectionSelection introspectionSelection ; bool doIntrospection = false ; IntrospectionApp () noexcept ; void parseCmdLineArguments ( int argc , char ** argv , CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) noexcept ; void runIntrospection ( const iox :: units :: Duration updatePeriodMs , const IntrospectionSelection introspectionSelection ); private : void initTerminal (); void clearToBottom (); void closeTerminal (); void refreshTerminal (); void updateDisplayYX (); void waitForUserInput ( int32_t timeoutMs ); void printShortInfo ( const std :: string & binaryName ) noexcept ; void prettyPrint ( const std :: string & str , const PrettyOptions pr = PrettyOptions :: normal ); void printProcessIntrospectionData ( const ProcessIntrospectionFieldTopic * processIntrospectionField ); void printMemPoolInfo ( const MemPoolIntrospectionInfo & introspectionInfo ); template < typename Subscriber > bool waitForSubscription ( Subscriber & port ); std :: vector < ComposedPublisherPortData > composePublisherPortData ( const PortIntrospectionFieldTopic * portData , const PortThroughputIntrospectionFieldTopic * throughputData ); std :: vector < ComposedSubscriberPortData > composeSubscriberPortData ( const PortIntrospectionFieldTopic * portData , const SubscriberPortChangingIntrospectionFieldTopic * subscriberPortChangingData ); void printPortIntrospectionData ( const std :: vector < ComposedPublisherPortData >& publisherPortData , const std :: vector < ComposedSubscriberPortData >& subscriberPortData ); void printHelp () noexcept ; template < typename T > T bounded ( T input , T min , T max ) noexcept { return (( input >= min ) ? (( input <= max ) ? input : max ) : min ); } iox :: units :: Duration updatePeriodMs = DEFAULT_UPDATE_PERIOD ; WINDOW * pad ; int32_t yPad { 0 }; int32_t xPad { 0 }; }; } // namespace introspection } // namespace client } // namespace iox #endif // IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_introspection/introspection_app.hpp"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#iceoryx_introspectionintrospection_apphpp","text":"","title":"iceoryx_introspection/introspection_app.hpp"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#namespaces","text":"Name iox iox::client iox::client::introspection","title":"Namespaces"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#classes","text":"Name class iox::client::introspection::IntrospectionApp base class for introspection","title":"Classes"},{"location":"API-reference/introspection/Files/introspection__app_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP #define IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP #include \"iceoryx_hoofs/platform/getopt.hpp\" #include \"iceoryx_introspection/introspection_types.hpp\" #include \"iceoryx_posh/popo/subscriber.hpp\" #include <map> #include <ncurses.h> #include <vector> namespace iox { namespace client { namespace introspection { static constexpr option longOptions [] = {{ \"help\" , no_argument , nullptr , 'h' }, { \"version\" , no_argument , nullptr , 'v' }, { \"time\" , required_argument , nullptr , 't' }, { \"mempool\" , no_argument , nullptr , 0 }, { \"port\" , no_argument , nullptr , 0 }, { \"process\" , no_argument , nullptr , 0 }, { \"all\" , no_argument , nullptr , 0 }, { nullptr , 0 , nullptr , 0 }}; static constexpr const char * shortOptions = \"hvt:\" ; static constexpr iox :: units :: Duration MIN_UPDATE_PERIOD = 500 _ms ; static constexpr iox :: units :: Duration DEFAULT_UPDATE_PERIOD = 1000 _ms ; static constexpr iox :: units :: Duration MAX_UPDATE_PERIOD = 10000 _ms ; enum class ColorPairs : uint8_t { redOnBlack = 1 , whiteOnRed }; static const std :: map < PrettyOptions , uint32_t > prettyMap = { { PrettyOptions :: title , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: redOnBlack ))}, { PrettyOptions :: highlight , A_BOLD | A_UNDERLINE }, { PrettyOptions :: error , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: whiteOnRed ))}, { PrettyOptions :: bold , A_BOLD }, { PrettyOptions :: normal , A_NORMAL }}; class IntrospectionApp { public : IntrospectionApp ( int argc , char * argv []) noexcept ; virtual ~ IntrospectionApp () noexcept {}; virtual void run () noexcept = 0 ; protected : enum class CmdLineArgumentParsingMode { ALL , ONE }; IntrospectionSelection introspectionSelection ; bool doIntrospection = false ; IntrospectionApp () noexcept ; void parseCmdLineArguments ( int argc , char ** argv , CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) noexcept ; void runIntrospection ( const iox :: units :: Duration updatePeriodMs , const IntrospectionSelection introspectionSelection ); private : void initTerminal (); void clearToBottom (); void closeTerminal (); void refreshTerminal (); void updateDisplayYX (); void waitForUserInput ( int32_t timeoutMs ); void printShortInfo ( const std :: string & binaryName ) noexcept ; void prettyPrint ( const std :: string & str , const PrettyOptions pr = PrettyOptions :: normal ); void printProcessIntrospectionData ( const ProcessIntrospectionFieldTopic * processIntrospectionField ); void printMemPoolInfo ( const MemPoolIntrospectionInfo & introspectionInfo ); template < typename Subscriber > bool waitForSubscription ( Subscriber & port ); std :: vector < ComposedPublisherPortData > composePublisherPortData ( const PortIntrospectionFieldTopic * portData , const PortThroughputIntrospectionFieldTopic * throughputData ); std :: vector < ComposedSubscriberPortData > composeSubscriberPortData ( const PortIntrospectionFieldTopic * portData , const SubscriberPortChangingIntrospectionFieldTopic * subscriberPortChangingData ); void printPortIntrospectionData ( const std :: vector < ComposedPublisherPortData >& publisherPortData , const std :: vector < ComposedSubscriberPortData >& subscriberPortData ); void printHelp () noexcept ; template < typename T > T bounded ( T input , T min , T max ) noexcept { return (( input >= min ) ? (( input <= max ) ? input : max ) : min ); } iox :: units :: Duration updatePeriodMs = DEFAULT_UPDATE_PERIOD ; WINDOW * pad ; int32_t yPad { 0 }; int32_t xPad { 0 }; }; } // namespace introspection } // namespace client } // namespace iox #endif // IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/","text":"iceoryx_introspection/introspection_types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::client iox::client::introspection iox::roudi Classes \ud83d\udd17 Name struct iox::client::introspection::IntrospectionSelection struct iox::client::introspection::ComposedPublisherPortData struct iox::client::introspection::ComposedSubscriberPortData Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP #define IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP #include \"iceoryx_posh/roudi/introspection_types.hpp\" namespace iox { namespace client { namespace introspection { using namespace iox :: roudi ; constexpr units :: Duration WAIT_INTERVAL = 10 _ms ; enum class PrettyOptions { title , highlight , error , bold , normal }; struct IntrospectionSelection { bool mempool { false }; bool process { false }; bool port { false }; }; struct ComposedPublisherPortData { ComposedPublisherPortData ( const PublisherPortData & portData , const PortThroughputData & throughputData ) : portData ( & portData ) , throughputData ( & throughputData ) { } const PublisherPortData * portData ; const PortThroughputData * throughputData ; }; struct ComposedSubscriberPortData { ComposedSubscriberPortData ( const SubscriberPortData & portData , const SubscriberPortChangingData & subscriberPortChangingData ) : portData ( & portData ) , subscriberPortChangingData ( & subscriberPortChangingData ) { } const SubscriberPortData * portData ; const SubscriberPortChangingData * subscriberPortChangingData ; }; } // namespace introspection } // namespace client } // namespace iox #endif // IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_introspection/introspection_types.hpp"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#iceoryx_introspectionintrospection_typeshpp","text":"","title":"iceoryx_introspection/introspection_types.hpp"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#namespaces","text":"Name iox iox::client iox::client::introspection iox::roudi","title":"Namespaces"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#classes","text":"Name struct iox::client::introspection::IntrospectionSelection struct iox::client::introspection::ComposedPublisherPortData struct iox::client::introspection::ComposedSubscriberPortData","title":"Classes"},{"location":"API-reference/introspection/Files/introspection__types_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP #define IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP #include \"iceoryx_posh/roudi/introspection_types.hpp\" namespace iox { namespace client { namespace introspection { using namespace iox :: roudi ; constexpr units :: Duration WAIT_INTERVAL = 10 _ms ; enum class PrettyOptions { title , highlight , error , bold , normal }; struct IntrospectionSelection { bool mempool { false }; bool process { false }; bool port { false }; }; struct ComposedPublisherPortData { ComposedPublisherPortData ( const PublisherPortData & portData , const PortThroughputData & throughputData ) : portData ( & portData ) , throughputData ( & throughputData ) { } const PublisherPortData * portData ; const PortThroughputData * throughputData ; }; struct ComposedSubscriberPortData { ComposedSubscriberPortData ( const SubscriberPortData & portData , const SubscriberPortChangingData & subscriberPortChangingData ) : portData ( & portData ) , subscriberPortChangingData ( & subscriberPortChangingData ) { } const SubscriberPortData * portData ; const SubscriberPortChangingData * subscriberPortChangingData ; }; } // namespace introspection } // namespace client } // namespace iox #endif // IOX_TOOLS_ICEORYX_INTROSPECTION_INTROSPECTION_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/introspection/Namespaces/namespaceiox/","text":"iox \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::client Updated on 18 December 2023 at 13:11:43 CET","title":"iox"},{"location":"API-reference/introspection/Namespaces/namespaceiox/#iox","text":"","title":"iox"},{"location":"API-reference/introspection/Namespaces/namespaceiox/#namespaces","text":"Name iox::client Updated on 18 December 2023 at 13:11:43 CET","title":"Namespaces"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client/","text":"iox::client \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::client::introspection Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client/#ioxclient","text":"","title":"iox::client"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client/#namespaces","text":"Name iox::client::introspection Updated on 18 December 2023 at 13:11:43 CET","title":"Namespaces"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/","text":"iox::client::introspection \ud83d\udd17 Classes \ud83d\udd17 Name struct iox::client::introspection::ComposedPublisherPortData struct iox::client::introspection::ComposedSubscriberPortData class iox::client::introspection::IceOryxIntrospectionApp class iox::client::introspection::IntrospectionApp base class for introspection struct iox::client::introspection::IntrospectionSelection Types \ud83d\udd17 Name enum uint8_t ColorPairs { redOnBlack = 1, whiteOnRed} color pairs for terminal printing enum PrettyOptions { title, highlight, error, bold, normal} Attributes \ud83d\udd17 Name constexpr option longOptions constexpr const char * shortOptions constexpr iox::units::Duration MIN_UPDATE_PERIOD constexpr iox::units::Duration DEFAULT_UPDATE_PERIOD constexpr iox::units::Duration MAX_UPDATE_PERIOD const std::map< PrettyOptions, uint32_t > prettyMap formatting options for terminal printing constexpr units::Duration WAIT_INTERVAL Types Documentation \ud83d\udd17 enum ColorPairs \ud83d\udd17 Enumerator Value Description redOnBlack 1 whiteOnRed color pairs for terminal printing enum PrettyOptions \ud83d\udd17 Enumerator Value Description title highlight error bold normal Attributes Documentation \ud83d\udd17 variable longOptions \ud83d\udd17 static constexpr option longOptions = {{ \"help\" , no_argument , nullptr , 'h' }, { \"version\" , no_argument , nullptr , 'v' }, { \"time\" , required_argument , nullptr , 't' }, { \"mempool\" , no_argument , nullptr , 0 }, { \"port\" , no_argument , nullptr , 0 }, { \"process\" , no_argument , nullptr , 0 }, { \"all\" , no_argument , nullptr , 0 }, { nullptr , 0 , nullptr , 0 }}; variable shortOptions \ud83d\udd17 static constexpr const char * shortOptions = \"hvt:\" ; variable MIN_UPDATE_PERIOD \ud83d\udd17 static constexpr iox :: units :: Duration MIN_UPDATE_PERIOD = 500 _ms ; variable DEFAULT_UPDATE_PERIOD \ud83d\udd17 static constexpr iox :: units :: Duration DEFAULT_UPDATE_PERIOD = 1000 _ms ; variable MAX_UPDATE_PERIOD \ud83d\udd17 static constexpr iox :: units :: Duration MAX_UPDATE_PERIOD = 10000 _ms ; variable prettyMap \ud83d\udd17 static const std :: map < PrettyOptions , uint32_t > prettyMap = { { PrettyOptions :: title , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: redOnBlack ))}, { PrettyOptions :: highlight , A_BOLD | A_UNDERLINE }, { PrettyOptions :: error , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: whiteOnRed ))}, { PrettyOptions :: bold , A_BOLD }, { PrettyOptions :: normal , A_NORMAL }}; formatting options for terminal printing variable WAIT_INTERVAL \ud83d\udd17 constexpr units :: Duration WAIT_INTERVAL = 10 _ms ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::client::introspection"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#ioxclientintrospection","text":"","title":"iox::client::introspection"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#classes","text":"Name struct iox::client::introspection::ComposedPublisherPortData struct iox::client::introspection::ComposedSubscriberPortData class iox::client::introspection::IceOryxIntrospectionApp class iox::client::introspection::IntrospectionApp base class for introspection struct iox::client::introspection::IntrospectionSelection","title":"Classes"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#types","text":"Name enum uint8_t ColorPairs { redOnBlack = 1, whiteOnRed} color pairs for terminal printing enum PrettyOptions { title, highlight, error, bold, normal}","title":"Types"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#attributes","text":"Name constexpr option longOptions constexpr const char * shortOptions constexpr iox::units::Duration MIN_UPDATE_PERIOD constexpr iox::units::Duration DEFAULT_UPDATE_PERIOD constexpr iox::units::Duration MAX_UPDATE_PERIOD const std::map< PrettyOptions, uint32_t > prettyMap formatting options for terminal printing constexpr units::Duration WAIT_INTERVAL","title":"Attributes"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#enum-colorpairs","text":"Enumerator Value Description redOnBlack 1 whiteOnRed color pairs for terminal printing","title":"enum ColorPairs"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#enum-prettyoptions","text":"Enumerator Value Description title highlight error bold normal","title":"enum PrettyOptions"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-longoptions","text":"static constexpr option longOptions = {{ \"help\" , no_argument , nullptr , 'h' }, { \"version\" , no_argument , nullptr , 'v' }, { \"time\" , required_argument , nullptr , 't' }, { \"mempool\" , no_argument , nullptr , 0 }, { \"port\" , no_argument , nullptr , 0 }, { \"process\" , no_argument , nullptr , 0 }, { \"all\" , no_argument , nullptr , 0 }, { nullptr , 0 , nullptr , 0 }};","title":"variable longOptions"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-shortoptions","text":"static constexpr const char * shortOptions = \"hvt:\" ;","title":"variable shortOptions"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-min_update_period","text":"static constexpr iox :: units :: Duration MIN_UPDATE_PERIOD = 500 _ms ;","title":"variable MIN_UPDATE_PERIOD"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-default_update_period","text":"static constexpr iox :: units :: Duration DEFAULT_UPDATE_PERIOD = 1000 _ms ;","title":"variable DEFAULT_UPDATE_PERIOD"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-max_update_period","text":"static constexpr iox :: units :: Duration MAX_UPDATE_PERIOD = 10000 _ms ;","title":"variable MAX_UPDATE_PERIOD"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-prettymap","text":"static const std :: map < PrettyOptions , uint32_t > prettyMap = { { PrettyOptions :: title , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: redOnBlack ))}, { PrettyOptions :: highlight , A_BOLD | A_UNDERLINE }, { PrettyOptions :: error , A_BOLD | COLOR_PAIR ( static_cast < uint8_t > ( ColorPairs :: whiteOnRed ))}, { PrettyOptions :: bold , A_BOLD }, { PrettyOptions :: normal , A_NORMAL }}; formatting options for terminal printing","title":"variable prettyMap"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1client_1_1introspection/#variable-wait_interval","text":"constexpr units :: Duration WAIT_INTERVAL = 10 _ms ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable WAIT_INTERVAL"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1roudi/","text":"iox::roudi \ud83d\udd17 Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi"},{"location":"API-reference/introspection/Namespaces/namespaceiox_1_1roudi/#ioxroudi","text":"Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi"},{"location":"API-reference/introspection/Pages/todo/","text":"Todo List \ud83d\udd17 Class iox::client::introspection::IntrospectionApp Wrap all C calls with posixCall Updated on 18 December 2023 at 13:11:43 CET","title":"Todo List"},{"location":"API-reference/introspection/Pages/todo/#todo-list","text":"Class iox::client::introspection::IntrospectionApp Wrap all C calls with posixCall Updated on 18 December 2023 at 13:11:43 CET","title":"Todo List"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/","text":"iox::capro::ServiceDescription \ud83d\udd17 class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel. #include <iceoryx_posh/capro/service_description.hpp> Public Classes \ud83d\udd17 Name struct ClassHash Public Functions \ud83d\udd17 Name const IdString_t & getServiceIDString () const const IdString_t & getInstanceIDString () const const IdString_t & getEventIDString () const ClassHash getClassHash () const ServiceDescription () default C'tor ServiceDescription (const ServiceDescription & ) =default ServiceDescription ( ServiceDescription && ) =default ~ServiceDescription () =default ServiceDescription (const IdString_t & service, const IdString_t & instance, const IdString_t & event, ClassHash m_classHash ={0U, 0U, 0U, 0U}, Interfaces interfaceSource =Interfaces::INTERNAL) construction of the capro service description using fixed strings to create an event service description bool operator== (const ServiceDescription & rhs) const compare operator. bool operator!= (const ServiceDescription & rhs) const negation of compare operator. bool operator< (const ServiceDescription & rhs) const Uses the underlying m_**String compare method to provide an order. This is needed to use ServiceDescription in sorted containers like map or set. ServiceDescription & operator= (const ServiceDescription & ) =default ServiceDescription & operator= ( ServiceDescription && ) =default operator cxx::Serialization () const serialization of the capro description. bool isLocal () const void setLocal () Scope getScope () const Returns the scope of a ServiceDescription . Interfaces getSourceInterface () const Returns the interface form where the service is coming from. cxx::expected< ServiceDescription , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) de-serialization of a ServiceDescription . Public Functions Documentation \ud83d\udd17 function getServiceIDString \ud83d\udd17 const IdString_t & getServiceIDString () const Getters for the string IDs function getInstanceIDString \ud83d\udd17 const IdString_t & getInstanceIDString () const function getEventIDString \ud83d\udd17 const IdString_t & getEventIDString () const function getClassHash \ud83d\udd17 ClassHash getClassHash () const Getter for class hash function ServiceDescription \ud83d\udd17 ServiceDescription () default C'tor function ServiceDescription \ud83d\udd17 ServiceDescription ( const ServiceDescription & ) = default function ServiceDescription \ud83d\udd17 ServiceDescription ( ServiceDescription && ) = default function ~ServiceDescription \ud83d\udd17 ~ ServiceDescription () = default function ServiceDescription \ud83d\udd17 ServiceDescription ( const IdString_t & service , const IdString_t & instance , const IdString_t & event , ClassHash m_classHash = { 0U , 0U , 0U , 0U }, Interfaces interfaceSource = Interfaces :: INTERNAL ) construction of the capro service description using fixed strings to create an event service description function operator== \ud83d\udd17 bool operator == ( const ServiceDescription & rhs ) const compare operator. function operator!= \ud83d\udd17 bool operator != ( const ServiceDescription & rhs ) const negation of compare operator. function operator< \ud83d\udd17 bool operator < ( const ServiceDescription & rhs ) const Uses the underlying m_**String compare method to provide an order. This is needed to use ServiceDescription in sorted containers like map or set. function operator= \ud83d\udd17 ServiceDescription & operator = ( const ServiceDescription & ) = default function operator= \ud83d\udd17 ServiceDescription & operator = ( ServiceDescription && ) = default function operator cxx::Serialization \ud83d\udd17 explicit operator cxx :: Serialization () const serialization of the capro description. function isLocal \ud83d\udd17 bool isLocal () const function setLocal \ud83d\udd17 void setLocal () function getScope \ud83d\udd17 Scope getScope () const Returns the scope of a ServiceDescription . function getSourceInterface \ud83d\udd17 Interfaces getSourceInterface () const Returns the interface form where the service is coming from. function deserialize \ud83d\udd17 static cxx :: expected < ServiceDescription , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) de-serialization of a ServiceDescription . Parameters : serializedSerialization object from which the ServiceDescription shall be created Return : cxx::expected that either has a ServiceDescription or cxx::Serialization::Error stored inside Updated on 18 December 2023 at 13:11:43 CET","title":"iox::capro::ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#ioxcaproservicedescription","text":"class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel. #include <iceoryx_posh/capro/service_description.hpp>","title":"iox::capro::ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#public-classes","text":"Name struct ClassHash","title":"Public Classes"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#public-functions","text":"Name const IdString_t & getServiceIDString () const const IdString_t & getInstanceIDString () const const IdString_t & getEventIDString () const ClassHash getClassHash () const ServiceDescription () default C'tor ServiceDescription (const ServiceDescription & ) =default ServiceDescription ( ServiceDescription && ) =default ~ServiceDescription () =default ServiceDescription (const IdString_t & service, const IdString_t & instance, const IdString_t & event, ClassHash m_classHash ={0U, 0U, 0U, 0U}, Interfaces interfaceSource =Interfaces::INTERNAL) construction of the capro service description using fixed strings to create an event service description bool operator== (const ServiceDescription & rhs) const compare operator. bool operator!= (const ServiceDescription & rhs) const negation of compare operator. bool operator< (const ServiceDescription & rhs) const Uses the underlying m_**String compare method to provide an order. This is needed to use ServiceDescription in sorted containers like map or set. ServiceDescription & operator= (const ServiceDescription & ) =default ServiceDescription & operator= ( ServiceDescription && ) =default operator cxx::Serialization () const serialization of the capro description. bool isLocal () const void setLocal () Scope getScope () const Returns the scope of a ServiceDescription . Interfaces getSourceInterface () const Returns the interface form where the service is coming from. cxx::expected< ServiceDescription , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) de-serialization of a ServiceDescription .","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getserviceidstring","text":"const IdString_t & getServiceIDString () const Getters for the string IDs","title":"function getServiceIDString"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getinstanceidstring","text":"const IdString_t & getInstanceIDString () const","title":"function getInstanceIDString"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-geteventidstring","text":"const IdString_t & getEventIDString () const","title":"function getEventIDString"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getclasshash","text":"ClassHash getClassHash () const Getter for class hash","title":"function getClassHash"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription","text":"ServiceDescription () default C'tor","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_1","text":"ServiceDescription ( const ServiceDescription & ) = default","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_2","text":"ServiceDescription ( ServiceDescription && ) = default","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_3","text":"~ ServiceDescription () = default","title":"function ~ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-servicedescription_4","text":"ServiceDescription ( const IdString_t & service , const IdString_t & instance , const IdString_t & event , ClassHash m_classHash = { 0U , 0U , 0U , 0U }, Interfaces interfaceSource = Interfaces :: INTERNAL ) construction of the capro service description using fixed strings to create an event service description","title":"function ServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator","text":"bool operator == ( const ServiceDescription & rhs ) const compare operator.","title":"function operator=="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_1","text":"bool operator != ( const ServiceDescription & rhs ) const negation of compare operator.","title":"function operator!="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_2","text":"bool operator < ( const ServiceDescription & rhs ) const Uses the underlying m_**String compare method to provide an order. This is needed to use ServiceDescription in sorted containers like map or set.","title":"function operator&lt;"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_3","text":"ServiceDescription & operator = ( const ServiceDescription & ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator_4","text":"ServiceDescription & operator = ( ServiceDescription && ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-operator-cxxserialization","text":"explicit operator cxx :: Serialization () const serialization of the capro description.","title":"function operator cxx::Serialization"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-islocal","text":"bool isLocal () const","title":"function isLocal"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-setlocal","text":"void setLocal ()","title":"function setLocal"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getscope","text":"Scope getScope () const Returns the scope of a ServiceDescription .","title":"function getScope"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-getsourceinterface","text":"Interfaces getSourceInterface () const Returns the interface form where the service is coming from.","title":"function getSourceInterface"},{"location":"API-reference/posh/Classes/classiox_1_1capro_1_1ServiceDescription/#function-deserialize","text":"static cxx :: expected < ServiceDescription , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) de-serialization of a ServiceDescription . Parameters : serializedSerialization object from which the ServiceDescription shall be created Return : cxx::expected that either has a ServiceDescription or cxx::Serialization::Error stored inside Updated on 18 December 2023 at 13:11:43 CET","title":"function deserialize"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/","text":"iox::config::CmdLineParser \ud83d\udd17 Inherited by iox::config::CmdLineParserConfigFileOption Public Types \ud83d\udd17 Name enum CmdLineArgumentParsingMode { ALL, ONE} Public Functions \ud83d\udd17 Name CmdLineParser () =default virtual ~CmdLineParser () =default CmdLineParser & operator= (const CmdLineParser & other) CmdLineParser (const CmdLineParser & other) CmdLineParser & operator= ( CmdLineParser && ) CmdLineParser ( CmdLineParser && other) virtual cxx::expected< CmdLineArgs_t , CmdLineParserResult > parse (int argc, char * argv[], const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) process the passed command line arguments Protected Attributes \ud83d\udd17 Name bool m_run iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode version::CompatibilityCheckLevel m_compatibilityCheckLevel cxx::optional< uint16_t > m_uniqueRouDiId units::Duration m_processKillDelay Public Types Documentation \ud83d\udd17 enum CmdLineArgumentParsingMode \ud83d\udd17 Enumerator Value Description ALL ONE Public Functions Documentation \ud83d\udd17 function CmdLineParser \ud83d\udd17 CmdLineParser () = default function ~CmdLineParser \ud83d\udd17 virtual ~ CmdLineParser () = default function operator= \ud83d\udd17 CmdLineParser & operator = ( const CmdLineParser & other ) function CmdLineParser \ud83d\udd17 CmdLineParser ( const CmdLineParser & other ) function operator= \ud83d\udd17 CmdLineParser & operator = ( CmdLineParser && ) function CmdLineParser \ud83d\udd17 CmdLineParser ( CmdLineParser && other ) function parse \ud83d\udd17 virtual cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) process the passed command line arguments Parameters : argc forwarding of command line arguments argv forwarding of command line arguments cmdLineParsingMode selects to parse a single option or all options Result wrapped in an cxx::expected, either the parsed arguments as CmdLineArgs_t struct or CmdLineParserResult Reimplemented by : iox::config::CmdLineParserConfigFileOption::parse Protected Attributes Documentation \ud83d\udd17 variable m_run \ud83d\udd17 bool m_run { true }; variable m_logLevel \ud83d\udd17 iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn }; variable m_monitoringMode \ud83d\udd17 roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON }; variable m_compatibilityCheckLevel \ud83d\udd17 version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; variable m_uniqueRouDiId \ud83d\udd17 cxx :: optional < uint16_t > m_uniqueRouDiId ; variable m_processKillDelay \ud83d\udd17 units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#ioxconfigcmdlineparser","text":"Inherited by iox::config::CmdLineParserConfigFileOption","title":"iox::config::CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-types","text":"Name enum CmdLineArgumentParsingMode { ALL, ONE}","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-functions","text":"Name CmdLineParser () =default virtual ~CmdLineParser () =default CmdLineParser & operator= (const CmdLineParser & other) CmdLineParser (const CmdLineParser & other) CmdLineParser & operator= ( CmdLineParser && ) CmdLineParser ( CmdLineParser && other) virtual cxx::expected< CmdLineArgs_t , CmdLineParserResult > parse (int argc, char * argv[], const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) process the passed command line arguments","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#protected-attributes","text":"Name bool m_run iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode version::CompatibilityCheckLevel m_compatibilityCheckLevel cxx::optional< uint16_t > m_uniqueRouDiId units::Duration m_processKillDelay","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#enum-cmdlineargumentparsingmode","text":"Enumerator Value Description ALL ONE","title":"enum CmdLineArgumentParsingMode"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser","text":"CmdLineParser () = default","title":"function CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser_1","text":"virtual ~ CmdLineParser () = default","title":"function ~CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-operator","text":"CmdLineParser & operator = ( const CmdLineParser & other )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser_2","text":"CmdLineParser ( const CmdLineParser & other )","title":"function CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-operator_1","text":"CmdLineParser & operator = ( CmdLineParser && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-cmdlineparser_3","text":"CmdLineParser ( CmdLineParser && other )","title":"function CmdLineParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#function-parse","text":"virtual cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) process the passed command line arguments Parameters : argc forwarding of command line arguments argv forwarding of command line arguments cmdLineParsingMode selects to parse a single option or all options Result wrapped in an cxx::expected, either the parsed arguments as CmdLineArgs_t struct or CmdLineParserResult Reimplemented by : iox::config::CmdLineParserConfigFileOption::parse","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_run","text":"bool m_run { true };","title":"variable m_run"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_loglevel","text":"iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn };","title":"variable m_logLevel"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_monitoringmode","text":"roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON };","title":"variable m_monitoringMode"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_compatibilitychecklevel","text":"version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH };","title":"variable m_compatibilityCheckLevel"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_uniqueroudiid","text":"cxx :: optional < uint16_t > m_uniqueRouDiId ;","title":"variable m_uniqueRouDiId"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParser/#variable-m_processkilldelay","text":"units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_processKillDelay"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/","text":"iox::config::CmdLineParserConfigFileOption \ud83d\udd17 Inherits from iox::config::CmdLineParser Public Functions \ud83d\udd17 Name CmdLineParserConfigFileOption () =default virtual ~CmdLineParserConfigFileOption () =default CmdLineParserConfigFileOption & operator= (const CmdLineParserConfigFileOption & other) CmdLineParserConfigFileOption (const CmdLineParserConfigFileOption & other) CmdLineParserConfigFileOption & operator= ( CmdLineParserConfigFileOption && ) CmdLineParserConfigFileOption ( CmdLineParserConfigFileOption && other) virtual cxx::expected< CmdLineArgs_t , CmdLineParserResult > parse (int argc, char * argv[], const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) override process the passed command line arguments Protected Attributes \ud83d\udd17 Name roudi::ConfigFilePathString_t m_customConfigFilePath Additional inherited members \ud83d\udd17 Public Types inherited from iox::config::CmdLineParser Name enum CmdLineArgumentParsingMode { ALL, ONE} Public Functions inherited from iox::config::CmdLineParser Name CmdLineParser () =default virtual ~CmdLineParser () =default CmdLineParser (const CmdLineParser & other) CmdLineParser ( CmdLineParser && other) Protected Attributes inherited from iox::config::CmdLineParser Name bool m_run iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode version::CompatibilityCheckLevel m_compatibilityCheckLevel cxx::optional< uint16_t > m_uniqueRouDiId units::Duration m_processKillDelay Public Functions Documentation \ud83d\udd17 function CmdLineParserConfigFileOption \ud83d\udd17 CmdLineParserConfigFileOption () = default function ~CmdLineParserConfigFileOption \ud83d\udd17 virtual ~ CmdLineParserConfigFileOption () = default function operator= \ud83d\udd17 CmdLineParserConfigFileOption & operator = ( const CmdLineParserConfigFileOption & other ) function CmdLineParserConfigFileOption \ud83d\udd17 CmdLineParserConfigFileOption ( const CmdLineParserConfigFileOption & other ) function operator= \ud83d\udd17 CmdLineParserConfigFileOption & operator = ( CmdLineParserConfigFileOption && ) function CmdLineParserConfigFileOption \ud83d\udd17 CmdLineParserConfigFileOption ( CmdLineParserConfigFileOption && other ) function parse \ud83d\udd17 virtual cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) override process the passed command line arguments Parameters : argc forwarding of command line arguments argv forwarding of command line arguments cmdLineParsingMode selects to parse a single option or all options Result wrapped in an cxx::expected, either the parsed arguments as CmdLineArgs_t struct or CmdLineParserResult Reimplements : iox::config::CmdLineParser::parse Protected Attributes Documentation \ud83d\udd17 variable m_customConfigFilePath \ud83d\udd17 roudi :: ConfigFilePathString_t m_customConfigFilePath ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#ioxconfigcmdlineparserconfigfileoption","text":"Inherits from iox::config::CmdLineParser","title":"iox::config::CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#public-functions","text":"Name CmdLineParserConfigFileOption () =default virtual ~CmdLineParserConfigFileOption () =default CmdLineParserConfigFileOption & operator= (const CmdLineParserConfigFileOption & other) CmdLineParserConfigFileOption (const CmdLineParserConfigFileOption & other) CmdLineParserConfigFileOption & operator= ( CmdLineParserConfigFileOption && ) CmdLineParserConfigFileOption ( CmdLineParserConfigFileOption && other) virtual cxx::expected< CmdLineArgs_t , CmdLineParserResult > parse (int argc, char * argv[], const CmdLineArgumentParsingMode cmdLineParsingMode =CmdLineArgumentParsingMode::ALL) override process the passed command line arguments","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#protected-attributes","text":"Name roudi::ConfigFilePathString_t m_customConfigFilePath","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#additional-inherited-members","text":"Public Types inherited from iox::config::CmdLineParser Name enum CmdLineArgumentParsingMode { ALL, ONE} Public Functions inherited from iox::config::CmdLineParser Name CmdLineParser () =default virtual ~CmdLineParser () =default CmdLineParser (const CmdLineParser & other) CmdLineParser ( CmdLineParser && other) Protected Attributes inherited from iox::config::CmdLineParser Name bool m_run iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode version::CompatibilityCheckLevel m_compatibilityCheckLevel cxx::optional< uint16_t > m_uniqueRouDiId units::Duration m_processKillDelay","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption","text":"CmdLineParserConfigFileOption () = default","title":"function CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption_1","text":"virtual ~ CmdLineParserConfigFileOption () = default","title":"function ~CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-operator","text":"CmdLineParserConfigFileOption & operator = ( const CmdLineParserConfigFileOption & other )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption_2","text":"CmdLineParserConfigFileOption ( const CmdLineParserConfigFileOption & other )","title":"function CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-operator_1","text":"CmdLineParserConfigFileOption & operator = ( CmdLineParserConfigFileOption && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-cmdlineparserconfigfileoption_3","text":"CmdLineParserConfigFileOption ( CmdLineParserConfigFileOption && other )","title":"function CmdLineParserConfigFileOption"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#function-parse","text":"virtual cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) override process the passed command line arguments Parameters : argc forwarding of command line arguments argv forwarding of command line arguments cmdLineParsingMode selects to parse a single option or all options Result wrapped in an cxx::expected, either the parsed arguments as CmdLineArgs_t struct or CmdLineParserResult Reimplements : iox::config::CmdLineParser::parse","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1CmdLineParserConfigFileOption/#variable-m_customconfigfilepath","text":"roudi :: ConfigFilePathString_t m_customConfigFilePath ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_customConfigFilePath"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/","text":"iox::config::TomlGatewayConfigParser \ud83d\udd17 The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files. #include <iceoryx_posh/gateway/toml_gateway_config_parser.hpp> Public Functions \ud83d\udd17 Name cxx::expected< GatewayConfig , TomlGatewayConfigParseError > parse (const roudi::ConfigFilePathString_t & path =roudi::ConfigFilePathString_t(DEFAULT_CONFIG_FILE_PATH)) Protected Functions \ud83d\udd17 Name cxx::expected< TomlGatewayConfigParseError > validate (const cpptoml::table & parsedToml) Public Functions Documentation \ud83d\udd17 function parse \ud83d\udd17 static cxx :: expected < GatewayConfig , TomlGatewayConfigParseError > parse ( const roudi :: ConfigFilePathString_t & path = roudi :: ConfigFilePathString_t ( DEFAULT_CONFIG_FILE_PATH ) ) Protected Functions Documentation \ud83d\udd17 function validate \ud83d\udd17 static cxx :: expected < TomlGatewayConfigParseError > validate ( const cpptoml :: table & parsedToml ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::TomlGatewayConfigParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#ioxconfigtomlgatewayconfigparser","text":"The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files. #include <iceoryx_posh/gateway/toml_gateway_config_parser.hpp>","title":"iox::config::TomlGatewayConfigParser"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#public-functions","text":"Name cxx::expected< GatewayConfig , TomlGatewayConfigParseError > parse (const roudi::ConfigFilePathString_t & path =roudi::ConfigFilePathString_t(DEFAULT_CONFIG_FILE_PATH))","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#protected-functions","text":"Name cxx::expected< TomlGatewayConfigParseError > validate (const cpptoml::table & parsedToml)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#function-parse","text":"static cxx :: expected < GatewayConfig , TomlGatewayConfigParseError > parse ( const roudi :: ConfigFilePathString_t & path = roudi :: ConfigFilePathString_t ( DEFAULT_CONFIG_FILE_PATH ) )","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlGatewayConfigParser/#function-validate","text":"static cxx :: expected < TomlGatewayConfigParseError > validate ( const cpptoml :: table & parsedToml ) Updated on 18 December 2023 at 13:11:43 CET","title":"function validate"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/","text":"iox::config::TomlRouDiConfigFileProvider \ud83d\udd17 Inherits from iox::roudi::RouDiConfigFileProvider Public Functions \ud83d\udd17 Name TomlRouDiConfigFileProvider ( iox::config::CmdLineArgs_t & cmdLineArgs) virtual iox::cxx::expected< iox::RouDiConfig_t , iox::roudi::RouDiConfigFileParseError > parse () override interface to parse a config file which needs to be implemented for a custom parser Additional inherited members \ud83d\udd17 Protected Attributes inherited from iox::roudi::RouDiConfigFileProvider Name ConfigFilePathString_t m_customConfigFilePath Public Functions Documentation \ud83d\udd17 function TomlRouDiConfigFileProvider \ud83d\udd17 TomlRouDiConfigFileProvider ( iox :: config :: CmdLineArgs_t & cmdLineArgs ) function parse \ud83d\udd17 virtual iox :: cxx :: expected < iox :: RouDiConfig_t , iox :: roudi :: RouDiConfigFileParseError > parse () override interface to parse a config file which needs to be implemented for a custom parser Parameters : configFilePath to the custom RouDi config file Return : a cxx::expected with either the parsed RouDiConfig_t if the parsing was successful or a parsing error Reimplements : iox::roudi::RouDiConfigFileProvider::parse Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::TomlRouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#ioxconfigtomlroudiconfigfileprovider","text":"Inherits from iox::roudi::RouDiConfigFileProvider","title":"iox::config::TomlRouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#public-functions","text":"Name TomlRouDiConfigFileProvider ( iox::config::CmdLineArgs_t & cmdLineArgs) virtual iox::cxx::expected< iox::RouDiConfig_t , iox::roudi::RouDiConfigFileParseError > parse () override interface to parse a config file which needs to be implemented for a custom parser","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#additional-inherited-members","text":"Protected Attributes inherited from iox::roudi::RouDiConfigFileProvider Name ConfigFilePathString_t m_customConfigFilePath","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#function-tomlroudiconfigfileprovider","text":"TomlRouDiConfigFileProvider ( iox :: config :: CmdLineArgs_t & cmdLineArgs )","title":"function TomlRouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1config_1_1TomlRouDiConfigFileProvider/#function-parse","text":"virtual iox :: cxx :: expected < iox :: RouDiConfig_t , iox :: roudi :: RouDiConfigFileParseError > parse () override interface to parse a config file which needs to be implemented for a custom parser Parameters : configFilePath to the custom RouDi config file Return : a cxx::expected with either the parsed RouDiConfig_t if the parsing was successful or a parsing error Reimplements : iox::roudi::RouDiConfigFileProvider::parse Updated on 18 December 2023 at 13:11:43 CET","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/","text":"iox: :Channel \ud83d\udd17 A data structure representing a channel between Iceoryx and an external system. More... #include <iceoryx_posh/gateway/channel.hpp> Public Functions \ud83d\udd17 Name constexpr Channel (const capro::ServiceDescription & service, const IceoryxTerminalPtr iceoryxTerminal, const ExternalTerminalPtr externalTerminal) constexpr bool operator== (const Channel < IceoryxTerminal, ExternalTerminal > & rhs) const capro::ServiceDescription getServiceDescription () const IceoryxTerminalPtr getIceoryxTerminal () const ExternalTerminalPtr getExternalTerminal () const template <typename IceoryxPubSubOptions > cxx::expected< Channel , ChannelError > create (const capro::ServiceDescription & service, const IceoryxPubSubOptions & options) create Creates a channel for the given service whose terminals reside in a static object pool. Detailed Description \ud83d\udd17 template < typename IceoryxTerminal , typename ExternalTerminal > class iox :: gw :: Channel ; A data structure representing a channel between Iceoryx and an external system. The class couples related iceoryx and external interfaces that communicate with eachother to form the communication channel. These interfaces are conceptualized as channel \"Terminals\". The structure holds pointers to the instances of the terminals. The terminals can be created and managed externally, in which case the structure only serves as a means of coupling the two. This can be achieved by simply calling the constructor with pointers to them. Alternatively, the class can manage the terminals internally in a static object pool, automatically cleaning them up when the channel is discarded. This can be achieved via the Channel::create method. Public Functions Documentation \ud83d\udd17 function Channel \ud83d\udd17 constexpr Channel ( const capro :: ServiceDescription & service , const IceoryxTerminalPtr iceoryxTerminal , const ExternalTerminalPtr externalTerminal ) function operator== \ud83d\udd17 constexpr bool operator == ( const Channel < IceoryxTerminal , ExternalTerminal > & rhs ) const function getServiceDescription \ud83d\udd17 capro :: ServiceDescription getServiceDescription () const function getIceoryxTerminal \ud83d\udd17 IceoryxTerminalPtr getIceoryxTerminal () const function getExternalTerminal \ud83d\udd17 ExternalTerminalPtr getExternalTerminal () const function create \ud83d\udd17 template < typename IceoryxPubSubOptions > static cxx :: expected < Channel , ChannelError > create ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) create Creates a channel for the given service whose terminals reside in a static object pool. Parameters : service The service to create the channel for. options The PublisherOptions or SubscriberOptions with historyCapacity and queueCapacity. Return : A copy of the created channel, if successful. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::gw::Channel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#ioxchannel","text":"A data structure representing a channel between Iceoryx and an external system. More... #include <iceoryx_posh/gateway/channel.hpp>","title":"iox::Channel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#public-functions","text":"Name constexpr Channel (const capro::ServiceDescription & service, const IceoryxTerminalPtr iceoryxTerminal, const ExternalTerminalPtr externalTerminal) constexpr bool operator== (const Channel < IceoryxTerminal, ExternalTerminal > & rhs) const capro::ServiceDescription getServiceDescription () const IceoryxTerminalPtr getIceoryxTerminal () const ExternalTerminalPtr getExternalTerminal () const template <typename IceoryxPubSubOptions > cxx::expected< Channel , ChannelError > create (const capro::ServiceDescription & service, const IceoryxPubSubOptions & options) create Creates a channel for the given service whose terminals reside in a static object pool.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#detailed-description","text":"template < typename IceoryxTerminal , typename ExternalTerminal > class iox :: gw :: Channel ; A data structure representing a channel between Iceoryx and an external system. The class couples related iceoryx and external interfaces that communicate with eachother to form the communication channel. These interfaces are conceptualized as channel \"Terminals\". The structure holds pointers to the instances of the terminals. The terminals can be created and managed externally, in which case the structure only serves as a means of coupling the two. This can be achieved by simply calling the constructor with pointers to them. Alternatively, the class can manage the terminals internally in a static object pool, automatically cleaning them up when the channel is discarded. This can be achieved via the Channel::create method.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-channel","text":"constexpr Channel ( const capro :: ServiceDescription & service , const IceoryxTerminalPtr iceoryxTerminal , const ExternalTerminalPtr externalTerminal )","title":"function Channel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-operator","text":"constexpr bool operator == ( const Channel < IceoryxTerminal , ExternalTerminal > & rhs ) const","title":"function operator=="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-getservicedescription","text":"capro :: ServiceDescription getServiceDescription () const","title":"function getServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-geticeoryxterminal","text":"IceoryxTerminalPtr getIceoryxTerminal () const","title":"function getIceoryxTerminal"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-getexternalterminal","text":"ExternalTerminalPtr getExternalTerminal () const","title":"function getExternalTerminal"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1Channel/#function-create","text":"template < typename IceoryxPubSubOptions > static cxx :: expected < Channel , ChannelError > create ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) create Creates a channel for the given service whose terminals reside in a static object pool. Parameters : service The service to create the channel for. options The PublisherOptions or SubscriberOptions with historyCapacity and queueCapacity. Return : A copy of the created channel, if successful. Updated on 18 December 2023 at 13:11:43 CET","title":"function create"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/","text":"iox: :GatewayBase \ud83d\udd17 Generic gateway for communication events. #include <iceoryx_posh/gateway/gateway_base.hpp> Inherited by iox: :GatewayGeneric< channel_t, gateway_t > Public Types \ud83d\udd17 Name using capro::CaproMessage CaproMessage Public Functions \ud83d\udd17 Name GatewayBase (const capro::Interfaces f_interface) Constructor for creating generic gateway based on type of interface. GatewayBase & operator= (const GatewayBase & other) GatewayBase (const GatewayBase & other) GatewayBase ( GatewayBase && other) =default GatewayBase & operator= ( GatewayBase && ) =default virtual ~GatewayBase () bool getCaProMessage (CaproMessage & msg) Get function for type of capro message - service or event or field. Protected Functions \ud83d\udd17 Name GatewayBase () =default capro::Interfaces getInterface () const Protected Attributes \ud83d\udd17 Name popo::InterfacePort m_interfaceImpl Public Types Documentation \ud83d\udd17 using CaproMessage \ud83d\udd17 using iox :: gw :: GatewayBase :: CaproMessage = capro :: CaproMessage ; Public Functions Documentation \ud83d\udd17 function GatewayBase \ud83d\udd17 GatewayBase ( const capro :: Interfaces f_interface ) Constructor for creating generic gateway based on type of interface. Parameters : f_interface Type of interface function operator= \ud83d\udd17 GatewayBase & operator = ( const GatewayBase & other ) function GatewayBase \ud83d\udd17 GatewayBase ( const GatewayBase & other ) function GatewayBase \ud83d\udd17 GatewayBase ( GatewayBase && other ) = default function operator= \ud83d\udd17 GatewayBase & operator = ( GatewayBase && ) = default function ~GatewayBase \ud83d\udd17 virtual ~ GatewayBase () function getCaProMessage \ud83d\udd17 bool getCaProMessage ( CaproMessage & msg ) Get function for type of capro message - service or event or field. Parameters : msg Type of caro message Protected Functions Documentation \ud83d\udd17 function GatewayBase \ud83d\udd17 GatewayBase () = default function getInterface \ud83d\udd17 capro :: Interfaces getInterface () const Protected Attributes Documentation \ud83d\udd17 variable m_interfaceImpl \ud83d\udd17 popo :: InterfacePort m_interfaceImpl { nullptr }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::gw::GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#ioxgatewaybase","text":"Generic gateway for communication events. #include <iceoryx_posh/gateway/gateway_base.hpp> Inherited by iox: :GatewayGeneric< channel_t, gateway_t >","title":"iox::GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-types","text":"Name using capro::CaproMessage CaproMessage","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-functions","text":"Name GatewayBase (const capro::Interfaces f_interface) Constructor for creating generic gateway based on type of interface. GatewayBase & operator= (const GatewayBase & other) GatewayBase (const GatewayBase & other) GatewayBase ( GatewayBase && other) =default GatewayBase & operator= ( GatewayBase && ) =default virtual ~GatewayBase () bool getCaProMessage (CaproMessage & msg) Get function for type of capro message - service or event or field.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-functions","text":"Name GatewayBase () =default capro::Interfaces getInterface () const","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-attributes","text":"Name popo::InterfacePort m_interfaceImpl","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#using-capromessage","text":"using iox :: gw :: GatewayBase :: CaproMessage = capro :: CaproMessage ;","title":"using CaproMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase","text":"GatewayBase ( const capro :: Interfaces f_interface ) Constructor for creating generic gateway based on type of interface. Parameters : f_interface Type of interface","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-operator","text":"GatewayBase & operator = ( const GatewayBase & other )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_1","text":"GatewayBase ( const GatewayBase & other )","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_2","text":"GatewayBase ( GatewayBase && other ) = default","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-operator_1","text":"GatewayBase & operator = ( GatewayBase && ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_3","text":"virtual ~ GatewayBase ()","title":"function ~GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-getcapromessage","text":"bool getCaProMessage ( CaproMessage & msg ) Get function for type of capro message - service or event or field. Parameters : msg Type of caro message","title":"function getCaProMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-gatewaybase_4","text":"GatewayBase () = default","title":"function GatewayBase"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#function-getinterface","text":"capro :: Interfaces getInterface () const","title":"function getInterface"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayBase/#variable-m_interfaceimpl","text":"popo :: InterfacePort m_interfaceImpl { nullptr }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_interfaceImpl"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/","text":"iox: :GatewayDiscovery \ud83d\udd17 Discover the gateway. More... #include <iceoryx_posh/gateway/gateway_discovery.hpp> Public Types \ud83d\udd17 Name using capro::CaproMessage CaproMessage Public Functions \ud83d\udd17 Name GatewayDiscovery (const capro::Interfaces f_interface) Constructor for discovering gateway based on type of interface. bool getCaproMessage (CaproMessage & msg) Get function for type of capro message - service or event or field. Protected Functions \ud83d\udd17 Name GatewayDiscovery (Impl_T interfacePortImpl) Detailed Description \ud83d\udd17 template < typename Impl_T = GatewayBase > class iox :: gw :: GatewayDiscovery ; Discover the gateway. Public Types Documentation \ud83d\udd17 using CaproMessage \ud83d\udd17 using iox :: gw :: GatewayDiscovery < Impl_T >:: CaproMessage = capro :: CaproMessage ; Public Functions Documentation \ud83d\udd17 function GatewayDiscovery \ud83d\udd17 inline explicit GatewayDiscovery ( const capro :: Interfaces f_interface ) Constructor for discovering gateway based on type of interface. Parameters : f_interface Type of interface function getCaproMessage \ud83d\udd17 inline bool getCaproMessage ( CaproMessage & msg ) Get function for type of capro message - service or event or field. Parameters : msg Type of capro message Protected Functions Documentation \ud83d\udd17 function GatewayDiscovery \ud83d\udd17 inline explicit GatewayDiscovery ( Impl_T interfacePortImpl ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::gw::GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#ioxgatewaydiscovery","text":"Discover the gateway. More... #include <iceoryx_posh/gateway/gateway_discovery.hpp>","title":"iox::GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-types","text":"Name using capro::CaproMessage CaproMessage","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-functions","text":"Name GatewayDiscovery (const capro::Interfaces f_interface) Constructor for discovering gateway based on type of interface. bool getCaproMessage (CaproMessage & msg) Get function for type of capro message - service or event or field.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#protected-functions","text":"Name GatewayDiscovery (Impl_T interfacePortImpl)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#detailed-description","text":"template < typename Impl_T = GatewayBase > class iox :: gw :: GatewayDiscovery ; Discover the gateway.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#using-capromessage","text":"using iox :: gw :: GatewayDiscovery < Impl_T >:: CaproMessage = capro :: CaproMessage ;","title":"using CaproMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#function-gatewaydiscovery","text":"inline explicit GatewayDiscovery ( const capro :: Interfaces f_interface ) Constructor for discovering gateway based on type of interface. Parameters : f_interface Type of interface","title":"function GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#function-getcapromessage","text":"inline bool getCaproMessage ( CaproMessage & msg ) Get function for type of capro message - service or event or field. Parameters : msg Type of capro message","title":"function getCaproMessage"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayDiscovery/#function-gatewaydiscovery_1","text":"inline explicit GatewayDiscovery ( Impl_T interfacePortImpl ) Updated on 18 December 2023 at 13:11:43 CET","title":"function GatewayDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/","text":"iox: :GatewayGeneric \ud83d\udd17 A reference generic gateway implementation. More... #include <iceoryx_posh/gateway/gateway_generic.hpp> Inherits from iox: :GatewayBase Public Functions \ud83d\udd17 Name virtual ~GatewayGeneric () GatewayGeneric (const GatewayGeneric & ) GatewayGeneric & operator= (const GatewayGeneric & ) GatewayGeneric ( GatewayGeneric && ) GatewayGeneric & operator= ( GatewayGeneric && ) void runMultithreaded () void shutdown () virtual void loadConfiguration (const config::GatewayConfig & config) =0 loadConfiguration Load the provided configuration. virtual void discover (const capro::CaproMessage & msg) =0 discover Process discovery messages coming from iceoryx. virtual void forward (const channel_t & channel) =0 forward Forward data between the two terminals of the channel used by the implementation. uint64_t getNumberOfChannels () const Protected Functions \ud83d\udd17 Name GatewayGeneric (capro::Interfaces interface, units::Duration discoveryPeriod =1000_ms, units::Duration forwardingPeriod =50_ms) template <typename IceoryxPubSubOptions > cxx::expected< channel_t, GatewayError > addChannel (const capro::ServiceDescription & service, const IceoryxPubSubOptions & options) addChannel Creates a channel for the given service and stores a copy of it in an internal collection for later access. cxx::optional< channel_t > findChannel (const capro::ServiceDescription & service) const findChannel Searches for a channel for the given service in the internally stored collection and returns it one exists. void forEachChannel (const cxx::function_ref< void(channel_t &)> f) const forEachChannel Executs the given function for each channel in the internally stored collection. cxx::expected< GatewayError > discardChannel (const capro::ServiceDescription & service) discardChannel Discard the channel for the given service in the internal collection if one exists. Additional inherited members \ud83d\udd17 Public Types inherited from iox: :GatewayBase Name using capro::CaproMessage CaproMessage Public Functions inherited from iox: :GatewayBase Name GatewayBase (const capro::Interfaces f_interface) Constructor for creating generic gateway based on type of interface. GatewayBase (const GatewayBase & other) GatewayBase ( GatewayBase && other) =default virtual ~GatewayBase () bool getCaProMessage (CaproMessage & msg) Get function for type of capro message - service or event or field. Protected Functions inherited from iox: :GatewayBase Name GatewayBase () =default capro::Interfaces getInterface () const Protected Attributes inherited from iox: :GatewayBase Name popo::InterfacePort m_interfaceImpl Detailed Description \ud83d\udd17 template < typename channel_t , typename gateway_t = GatewayBase > class iox :: gw :: GatewayGeneric ; A reference generic gateway implementation. This class can be extended to quickly implement any type of gateway, only custom initialization, configuration, discovery and forwarding logic needs to be provided. When run, the gateway will automatically call the respective methods when required. Public Functions Documentation \ud83d\udd17 function ~GatewayGeneric \ud83d\udd17 virtual ~ GatewayGeneric () function GatewayGeneric \ud83d\udd17 GatewayGeneric ( const GatewayGeneric & ) function operator= \ud83d\udd17 GatewayGeneric & operator = ( const GatewayGeneric & ) function GatewayGeneric \ud83d\udd17 GatewayGeneric ( GatewayGeneric && ) function operator= \ud83d\udd17 GatewayGeneric & operator = ( GatewayGeneric && ) function runMultithreaded \ud83d\udd17 void runMultithreaded () function shutdown \ud83d\udd17 void shutdown () function loadConfiguration \ud83d\udd17 virtual void loadConfiguration ( const config :: GatewayConfig & config ) = 0 loadConfiguration Load the provided configuration. Parameters : config A generic gateway implementation. function discover \ud83d\udd17 virtual void discover ( const capro :: CaproMessage & msg ) = 0 discover Process discovery messages coming from iceoryx. Parameters : msg The discovery message. function forward \ud83d\udd17 virtual void forward ( const channel_t & channel ) = 0 forward Forward data between the two terminals of the channel used by the implementation. Parameters : channel The channel to propogate data across. function getNumberOfChannels \ud83d\udd17 uint64_t getNumberOfChannels () const Protected Functions Documentation \ud83d\udd17 function GatewayGeneric \ud83d\udd17 GatewayGeneric ( capro :: Interfaces interface , units :: Duration discoveryPeriod = 1000 _ms , units :: Duration forwardingPeriod = 50 _ms ) function addChannel \ud83d\udd17 template < typename IceoryxPubSubOptions > cxx :: expected < channel_t , GatewayError > addChannel ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) addChannel Creates a channel for the given service and stores a copy of it in an internal collection for later access. Parameters : service The service to create a channel for. options The PublisherOptions or SubscriberOptions with historyCapacity and queueCapacity. Return : an expected containing a copy of the added channel, otherwise an error Note : Wildcard services are not allowed and will be ignored. Channels are supposed to be lightweight, consisting only of pointers to the terminals and a copy of the service description, therefore a copy is provided to any entity that requires them. When no more copies of a channel exists in the system, the terminals will automatically be cleaned up via the custom deleters included in their pointers. The service description is perhaps too large for copying since they contain strings, however this should be addressed with a service description repository feature. function findChannel \ud83d\udd17 cxx :: optional < channel_t > findChannel ( const capro :: ServiceDescription & service ) const findChannel Searches for a channel for the given service in the internally stored collection and returns it one exists. Parameters : service The service to find a channel for. Return : An optional containining the matching channel if one exists, otherwise an empty optional. function forEachChannel \ud83d\udd17 void forEachChannel ( const cxx :: function_ref < void ( channel_t & ) > f ) const forEachChannel Executs the given function for each channel in the internally stored collection. Parameters : f The function to execute. Note : This operation allows thread-safe access to the internal collection. function discardChannel \ud83d\udd17 cxx :: expected < GatewayError > discardChannel ( const capro :: ServiceDescription & service ) discardChannel Discard the channel for the given service in the internal collection if one exists. Parameters : service The service whose channels hiould be discarded. Return : an empty expected on success, otherwise an error Updated on 18 December 2023 at 13:11:43 CET","title":"iox::gw::GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#ioxgatewaygeneric","text":"A reference generic gateway implementation. More... #include <iceoryx_posh/gateway/gateway_generic.hpp> Inherits from iox: :GatewayBase","title":"iox::GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#public-functions","text":"Name virtual ~GatewayGeneric () GatewayGeneric (const GatewayGeneric & ) GatewayGeneric & operator= (const GatewayGeneric & ) GatewayGeneric ( GatewayGeneric && ) GatewayGeneric & operator= ( GatewayGeneric && ) void runMultithreaded () void shutdown () virtual void loadConfiguration (const config::GatewayConfig & config) =0 loadConfiguration Load the provided configuration. virtual void discover (const capro::CaproMessage & msg) =0 discover Process discovery messages coming from iceoryx. virtual void forward (const channel_t & channel) =0 forward Forward data between the two terminals of the channel used by the implementation. uint64_t getNumberOfChannels () const","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#protected-functions","text":"Name GatewayGeneric (capro::Interfaces interface, units::Duration discoveryPeriod =1000_ms, units::Duration forwardingPeriod =50_ms) template <typename IceoryxPubSubOptions > cxx::expected< channel_t, GatewayError > addChannel (const capro::ServiceDescription & service, const IceoryxPubSubOptions & options) addChannel Creates a channel for the given service and stores a copy of it in an internal collection for later access. cxx::optional< channel_t > findChannel (const capro::ServiceDescription & service) const findChannel Searches for a channel for the given service in the internally stored collection and returns it one exists. void forEachChannel (const cxx::function_ref< void(channel_t &)> f) const forEachChannel Executs the given function for each channel in the internally stored collection. cxx::expected< GatewayError > discardChannel (const capro::ServiceDescription & service) discardChannel Discard the channel for the given service in the internal collection if one exists.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#additional-inherited-members","text":"Public Types inherited from iox: :GatewayBase Name using capro::CaproMessage CaproMessage Public Functions inherited from iox: :GatewayBase Name GatewayBase (const capro::Interfaces f_interface) Constructor for creating generic gateway based on type of interface. GatewayBase (const GatewayBase & other) GatewayBase ( GatewayBase && other) =default virtual ~GatewayBase () bool getCaProMessage (CaproMessage & msg) Get function for type of capro message - service or event or field. Protected Functions inherited from iox: :GatewayBase Name GatewayBase () =default capro::Interfaces getInterface () const Protected Attributes inherited from iox: :GatewayBase Name popo::InterfacePort m_interfaceImpl","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#detailed-description","text":"template < typename channel_t , typename gateway_t = GatewayBase > class iox :: gw :: GatewayGeneric ; A reference generic gateway implementation. This class can be extended to quickly implement any type of gateway, only custom initialization, configuration, discovery and forwarding logic needs to be provided. When run, the gateway will automatically call the respective methods when required.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric","text":"virtual ~ GatewayGeneric ()","title":"function ~GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric_1","text":"GatewayGeneric ( const GatewayGeneric & )","title":"function GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-operator","text":"GatewayGeneric & operator = ( const GatewayGeneric & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric_2","text":"GatewayGeneric ( GatewayGeneric && )","title":"function GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-operator_1","text":"GatewayGeneric & operator = ( GatewayGeneric && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-runmultithreaded","text":"void runMultithreaded ()","title":"function runMultithreaded"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-shutdown","text":"void shutdown ()","title":"function shutdown"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-loadconfiguration","text":"virtual void loadConfiguration ( const config :: GatewayConfig & config ) = 0 loadConfiguration Load the provided configuration. Parameters : config A generic gateway implementation.","title":"function loadConfiguration"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-discover","text":"virtual void discover ( const capro :: CaproMessage & msg ) = 0 discover Process discovery messages coming from iceoryx. Parameters : msg The discovery message.","title":"function discover"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-forward","text":"virtual void forward ( const channel_t & channel ) = 0 forward Forward data between the two terminals of the channel used by the implementation. Parameters : channel The channel to propogate data across.","title":"function forward"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-getnumberofchannels","text":"uint64_t getNumberOfChannels () const","title":"function getNumberOfChannels"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-gatewaygeneric_3","text":"GatewayGeneric ( capro :: Interfaces interface , units :: Duration discoveryPeriod = 1000 _ms , units :: Duration forwardingPeriod = 50 _ms )","title":"function GatewayGeneric"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-addchannel","text":"template < typename IceoryxPubSubOptions > cxx :: expected < channel_t , GatewayError > addChannel ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) addChannel Creates a channel for the given service and stores a copy of it in an internal collection for later access. Parameters : service The service to create a channel for. options The PublisherOptions or SubscriberOptions with historyCapacity and queueCapacity. Return : an expected containing a copy of the added channel, otherwise an error Note : Wildcard services are not allowed and will be ignored. Channels are supposed to be lightweight, consisting only of pointers to the terminals and a copy of the service description, therefore a copy is provided to any entity that requires them. When no more copies of a channel exists in the system, the terminals will automatically be cleaned up via the custom deleters included in their pointers. The service description is perhaps too large for copying since they contain strings, however this should be addressed with a service description repository feature.","title":"function addChannel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-findchannel","text":"cxx :: optional < channel_t > findChannel ( const capro :: ServiceDescription & service ) const findChannel Searches for a channel for the given service in the internally stored collection and returns it one exists. Parameters : service The service to find a channel for. Return : An optional containining the matching channel if one exists, otherwise an empty optional.","title":"function findChannel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-foreachchannel","text":"void forEachChannel ( const cxx :: function_ref < void ( channel_t & ) > f ) const forEachChannel Executs the given function for each channel in the internally stored collection. Parameters : f The function to execute. Note : This operation allows thread-safe access to the internal collection.","title":"function forEachChannel"},{"location":"API-reference/posh/Classes/classiox_1_1gw_1_1GatewayGeneric/#function-discardchannel","text":"cxx :: expected < GatewayError > discardChannel ( const capro :: ServiceDescription & service ) discardChannel Discard the channel for the given service in the internal collection if one exists. Parameters : service The service whose channels hiould be discarded. Return : an empty expected on success, otherwise an error Updated on 18 December 2023 at 13:11:43 CET","title":"function discardChannel"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/","text":"iox::mepoo::ChunkSettings \ud83d\udd17 Public Types \ud83d\udd17 Name enum Error { ALIGNMENT_NOT_POWER_OF_TWO, USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT, USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT, REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE} Public Functions \ud83d\udd17 Name cxx::expected< ChunkSettings , ChunkSettings::Error > create (const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT) constructs and initializes a ChunkSettings uint32_t requiredChunkSize () const getter method for the chunk size fulfilling the user-payload and user-header requirements uint32_t userPayloadSize () const getter method for the user-payload size uint32_t userPayloadAlignment () const getter method for the user-payload alignment uint32_t userHeaderSize () const getter method for the user-header size uint32_t userHeaderAlignment () const getter method for the user-header alignment Public Types Documentation \ud83d\udd17 enum Error \ud83d\udd17 Enumerator Value Description ALIGNMENT_NOT_POWER_OF_TWO USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE Public Functions Documentation \ud83d\udd17 function create \ud83d\udd17 static cxx :: expected < ChunkSettings , ChunkSettings :: Error > create ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) constructs and initializes a ChunkSettings Parameters : chunkSize is the size of the chunk fulfilling the user-payload and user-header requirements userPayloadSize is the size of the user-payload userPayloadAlignment is the alignment of the user-payload userHeaderSize is the size of the user-header userHeaderAlignment is the alignment for the user-header function requiredChunkSize \ud83d\udd17 uint32_t requiredChunkSize () const getter method for the chunk size fulfilling the user-payload and user-header requirements Return : the chunk size function userPayloadSize \ud83d\udd17 uint32_t userPayloadSize () const getter method for the user-payload size Return : the user-payload size function userPayloadAlignment \ud83d\udd17 uint32_t userPayloadAlignment () const getter method for the user-payload alignment Return : the user-payload alignment function userHeaderSize \ud83d\udd17 uint32_t userHeaderSize () const getter method for the user-header size Return : the user-header size function userHeaderAlignment \ud83d\udd17 uint32_t userHeaderAlignment () const getter method for the user-header alignment Return : the user-header alignment Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::ChunkSettings"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#ioxmepoochunksettings","text":"","title":"iox::mepoo::ChunkSettings"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-types","text":"Name enum Error { ALIGNMENT_NOT_POWER_OF_TWO, USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT, USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT, REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE}","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-functions","text":"Name cxx::expected< ChunkSettings , ChunkSettings::Error > create (const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT) constructs and initializes a ChunkSettings uint32_t requiredChunkSize () const getter method for the chunk size fulfilling the user-payload and user-header requirements uint32_t userPayloadSize () const getter method for the user-payload size uint32_t userPayloadAlignment () const getter method for the user-payload alignment uint32_t userHeaderSize () const getter method for the user-header size uint32_t userHeaderAlignment () const getter method for the user-header alignment","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#enum-error","text":"Enumerator Value Description ALIGNMENT_NOT_POWER_OF_TWO USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE","title":"enum Error"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-create","text":"static cxx :: expected < ChunkSettings , ChunkSettings :: Error > create ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) constructs and initializes a ChunkSettings Parameters : chunkSize is the size of the chunk fulfilling the user-payload and user-header requirements userPayloadSize is the size of the user-payload userPayloadAlignment is the alignment of the user-payload userHeaderSize is the size of the user-header userHeaderAlignment is the alignment for the user-header","title":"function create"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-requiredchunksize","text":"uint32_t requiredChunkSize () const getter method for the chunk size fulfilling the user-payload and user-header requirements Return : the chunk size","title":"function requiredChunkSize"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userpayloadsize","text":"uint32_t userPayloadSize () const getter method for the user-payload size Return : the user-payload size","title":"function userPayloadSize"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userpayloadalignment","text":"uint32_t userPayloadAlignment () const getter method for the user-payload alignment Return : the user-payload alignment","title":"function userPayloadAlignment"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userheadersize","text":"uint32_t userHeaderSize () const getter method for the user-header size Return : the user-header size","title":"function userHeaderSize"},{"location":"API-reference/posh/Classes/classiox_1_1mepoo_1_1ChunkSettings/#function-userheaderalignment","text":"uint32_t userHeaderAlignment () const getter method for the user-header alignment Return : the user-header alignment Updated on 18 December 2023 at 13:11:43 CET","title":"function userHeaderAlignment"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/","text":"iox::popo::BaseClient \ud83d\udd17 The BaseClient class contains the common implementation for the different clients. More... #include <iceoryx_posh/internal/popo/base_client.hpp> Protected Types \ud83d\udd17 Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions \ud83d\udd17 Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient & operator= (const BaseClient & ) BaseClient ( BaseClient && rhs) BaseClient & operator= ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions \ud83d\udd17 Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes \ud83d\udd17 Name PortT m_port TriggerHandleT m_trigger Friends \ud83d\udd17 Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename PortT = ClientPortUser , typename TriggerHandleT = TriggerHandle > class iox :: popo :: BaseClient ; The BaseClient class contains the common implementation for the different clients. Parameters : PortT type of the underlying port, required for testing TriggerHandleT type of the underlying trigger handle, required for testing Note : Not intended for public usage! Use the [Client](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Client/) or [UntypedClient](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/) instead! Protected Types Documentation \ud83d\udd17 using SelfType \ud83d\udd17 using iox :: popo :: BaseClient < PortT , TriggerHandleT >:: SelfType = BaseClient < PortT , TriggerHandleT > ; using PortType \ud83d\udd17 using iox :: popo :: BaseClient < PortT , TriggerHandleT >:: PortType = PortT ; Public Functions Documentation \ud83d\udd17 function ~BaseClient \ud83d\udd17 virtual ~ BaseClient () function BaseClient \ud83d\udd17 BaseClient ( const BaseClient & other ) function operator= \ud83d\udd17 BaseClient & operator = ( const BaseClient & ) function BaseClient \ud83d\udd17 BaseClient ( BaseClient && rhs ) function operator= \ud83d\udd17 BaseClient & operator = ( BaseClient && rhs ) function getUid \ud83d\udd17 uid_t getUid () const Get the unique ID of the client. Return : The client's unique ID. function getServiceDescription \ud83d\udd17 const capro :: ServiceDescription & getServiceDescription () const Get the service description of the client. Return : A reference to the service description. function connect \ud83d\udd17 void connect () Initiate connection to server when not already connected, otherwise nothing. function getConnectionState \ud83d\udd17 ConnectionState getConnectionState () const Get current connection state. Return : The current connection state. function disconnect \ud83d\udd17 void disconnect () Disconnects when already connected, otherwise nothing. function hasResponses \ud83d\udd17 bool hasResponses () const Check if response are available. Return : True if responses are available. function hasMissedResponses \ud83d\udd17 bool hasMissedResponses () Check if response has been missed since the last call of this method. Return : True if response has been missed. Response may be missed due to overflowing receive queue. function releaseQueuedResponses \ud83d\udd17 void releaseQueuedResponses () Releases any unread queued response. Protected Functions Documentation \ud83d\udd17 function BaseClient \ud83d\udd17 BaseClient ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions ) function invalidateTrigger \ud83d\udd17 void invalidateTrigger ( const uint64_t uniqueTriggerId ) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. Parameters : uniqueTriggerId the id of the corresponding trigger function enableState \ud83d\udd17 void enableState ( TriggerHandleT && triggerHandle , const ClientState clientState ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. clientState the state which should be attached function getCallbackForIsStateConditionSatisfied \ud83d\udd17 WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ClientState clientState ) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. Parameters : clientState the state to which the hasTriggeredCallback is required function disableState \ud83d\udd17 void disableState ( const ClientState clientState ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : clientState the state which should be detached function enableEvent \ud83d\udd17 void enableEvent ( TriggerHandleT && triggerHandle , const ClientEvent clientEvent ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. clientEvent the event which should be attached function disableEvent \ud83d\udd17 void disableEvent ( const ClientEvent clientEvent ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : clientEvent the event which should be detached function port \ud83d\udd17 const PortT & port () const const accessor of the underlying port function port \ud83d\udd17 PortT & port () accessor of the underlying port Protected Attributes Documentation \ud83d\udd17 variable m_port \ud83d\udd17 PortT m_port ; variable m_trigger \ud83d\udd17 TriggerHandleT m_trigger ; Friends \ud83d\udd17 friend NotificationAttorney \ud83d\udd17 friend class NotificationAttorney ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::BaseClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#ioxpopobaseclient","text":"The BaseClient class contains the common implementation for the different clients. More... #include <iceoryx_posh/internal/popo/base_client.hpp>","title":"iox::popo::BaseClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#protected-types","text":"Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType","title":"Protected Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#public-functions","text":"Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient & operator= (const BaseClient & ) BaseClient ( BaseClient && rhs) BaseClient & operator= ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#protected-functions","text":"Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#protected-attributes","text":"Name PortT m_port TriggerHandleT m_trigger","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#friends","text":"Name class NotificationAttorney","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#detailed-description","text":"template < typename PortT = ClientPortUser , typename TriggerHandleT = TriggerHandle > class iox :: popo :: BaseClient ; The BaseClient class contains the common implementation for the different clients. Parameters : PortT type of the underlying port, required for testing TriggerHandleT type of the underlying trigger handle, required for testing Note : Not intended for public usage! Use the [Client](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Client/) or [UntypedClient](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#using-selftype","text":"using iox :: popo :: BaseClient < PortT , TriggerHandleT >:: SelfType = BaseClient < PortT , TriggerHandleT > ;","title":"using SelfType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#using-porttype","text":"using iox :: popo :: BaseClient < PortT , TriggerHandleT >:: PortType = PortT ;","title":"using PortType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-baseclient","text":"virtual ~ BaseClient ()","title":"function ~BaseClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-baseclient_1","text":"BaseClient ( const BaseClient & other )","title":"function BaseClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-operator","text":"BaseClient & operator = ( const BaseClient & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-baseclient_2","text":"BaseClient ( BaseClient && rhs )","title":"function BaseClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-operator_1","text":"BaseClient & operator = ( BaseClient && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-getuid","text":"uid_t getUid () const Get the unique ID of the client. Return : The client's unique ID.","title":"function getUid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-getservicedescription","text":"const capro :: ServiceDescription & getServiceDescription () const Get the service description of the client. Return : A reference to the service description.","title":"function getServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-connect","text":"void connect () Initiate connection to server when not already connected, otherwise nothing.","title":"function connect"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-getconnectionstate","text":"ConnectionState getConnectionState () const Get current connection state. Return : The current connection state.","title":"function getConnectionState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-disconnect","text":"void disconnect () Disconnects when already connected, otherwise nothing.","title":"function disconnect"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-hasresponses","text":"bool hasResponses () const Check if response are available. Return : True if responses are available.","title":"function hasResponses"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-hasmissedresponses","text":"bool hasMissedResponses () Check if response has been missed since the last call of this method. Return : True if response has been missed. Response may be missed due to overflowing receive queue.","title":"function hasMissedResponses"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-releasequeuedresponses","text":"void releaseQueuedResponses () Releases any unread queued response.","title":"function releaseQueuedResponses"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-baseclient_3","text":"BaseClient ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions )","title":"function BaseClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-invalidatetrigger","text":"void invalidateTrigger ( const uint64_t uniqueTriggerId ) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. Parameters : uniqueTriggerId the id of the corresponding trigger","title":"function invalidateTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-enablestate","text":"void enableState ( TriggerHandleT && triggerHandle , const ClientState clientState ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. clientState the state which should be attached","title":"function enableState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-getcallbackforisstateconditionsatisfied","text":"WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ClientState clientState ) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. Parameters : clientState the state to which the hasTriggeredCallback is required","title":"function getCallbackForIsStateConditionSatisfied"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-disablestate","text":"void disableState ( const ClientState clientState ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : clientState the state which should be detached","title":"function disableState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-enableevent","text":"void enableEvent ( TriggerHandleT && triggerHandle , const ClientEvent clientEvent ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. clientEvent the event which should be attached","title":"function enableEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-disableevent","text":"void disableEvent ( const ClientEvent clientEvent ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : clientEvent the event which should be detached","title":"function disableEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-port","text":"const PortT & port () const const accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#function-port_1","text":"PortT & port () accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#variable-m_port","text":"PortT m_port ;","title":"variable m_port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#variable-m_trigger","text":"TriggerHandleT m_trigger ;","title":"variable m_trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseClient/#friend-notificationattorney","text":"friend class NotificationAttorney ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/","text":"iox::popo::BasePublisher \ud83d\udd17 The BasePublisher class contains the common implementation for the different publisher specializations. More... #include <iceoryx_posh/internal/popo/base_publisher.hpp> Public Types \ud83d\udd17 Name using port_t PortType Public Functions \ud83d\udd17 Name BasePublisher (const BasePublisher & other) BasePublisher & operator= (const BasePublisher & ) BasePublisher ( BasePublisher && rhs) BasePublisher & operator= ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions \ud83d\udd17 Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes \ud83d\udd17 Name port_t m_port Detailed Description \ud83d\udd17 template < typename port_t = iox :: PublisherPortUserType > class iox :: popo :: BasePublisher ; The BasePublisher class contains the common implementation for the different publisher specializations. Note : Not intended for public usage! Use the [Publisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/) or [UntypedPublisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/) instead! Public Types Documentation \ud83d\udd17 using PortType \ud83d\udd17 using iox :: popo :: BasePublisher < port_t >:: PortType = port_t ; Public Functions Documentation \ud83d\udd17 function BasePublisher \ud83d\udd17 BasePublisher ( const BasePublisher & other ) function operator= \ud83d\udd17 BasePublisher & operator = ( const BasePublisher & ) function BasePublisher \ud83d\udd17 BasePublisher ( BasePublisher && rhs ) function operator= \ud83d\udd17 BasePublisher & operator = ( BasePublisher && rhs ) function ~BasePublisher \ud83d\udd17 virtual ~ BasePublisher () function getUid \ud83d\udd17 uid_t getUid () const uid Get the UID of the publisher. Return : The publisher's UID. function getServiceDescription \ud83d\udd17 capro :: ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. Return : The service description. function offer \ud83d\udd17 void offer () offer Offer the service to be subscribed to. function stopOffer \ud83d\udd17 void stopOffer () stopOffer Stop offering the service. function isOffered \ud83d\udd17 bool isOffered () const isOffered Return : True if service is currently being offered. function hasSubscribers \ud83d\udd17 bool hasSubscribers () const hasSubscribers Return : True if currently has subscribers to the service. Protected Functions Documentation \ud83d\udd17 function BasePublisher \ud83d\udd17 BasePublisher () = default function BasePublisher \ud83d\udd17 BasePublisher ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions ) function port \ud83d\udd17 const port_t & port () const port Return : const accessor of the underlying port function port \ud83d\udd17 port_t & port () port Return : accessor of the underlying port Protected Attributes Documentation \ud83d\udd17 variable m_port \ud83d\udd17 port_t m_port { nullptr }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#ioxpopobasepublisher","text":"The BasePublisher class contains the common implementation for the different publisher specializations. More... #include <iceoryx_posh/internal/popo/base_publisher.hpp>","title":"iox::popo::BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#public-types","text":"Name using port_t PortType","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#public-functions","text":"Name BasePublisher (const BasePublisher & other) BasePublisher & operator= (const BasePublisher & ) BasePublisher ( BasePublisher && rhs) BasePublisher & operator= ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#protected-functions","text":"Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#protected-attributes","text":"Name port_t m_port","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#detailed-description","text":"template < typename port_t = iox :: PublisherPortUserType > class iox :: popo :: BasePublisher ; The BasePublisher class contains the common implementation for the different publisher specializations. Note : Not intended for public usage! Use the [Publisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/) or [UntypedPublisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#using-porttype","text":"using iox :: popo :: BasePublisher < port_t >:: PortType = port_t ;","title":"using PortType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-basepublisher","text":"BasePublisher ( const BasePublisher & other )","title":"function BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-operator","text":"BasePublisher & operator = ( const BasePublisher & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-basepublisher_1","text":"BasePublisher ( BasePublisher && rhs )","title":"function BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-operator_1","text":"BasePublisher & operator = ( BasePublisher && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-basepublisher_2","text":"virtual ~ BasePublisher ()","title":"function ~BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-getuid","text":"uid_t getUid () const uid Get the UID of the publisher. Return : The publisher's UID.","title":"function getUid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-getservicedescription","text":"capro :: ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. Return : The service description.","title":"function getServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-offer","text":"void offer () offer Offer the service to be subscribed to.","title":"function offer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-stopoffer","text":"void stopOffer () stopOffer Stop offering the service.","title":"function stopOffer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-isoffered","text":"bool isOffered () const isOffered Return : True if service is currently being offered.","title":"function isOffered"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-hassubscribers","text":"bool hasSubscribers () const hasSubscribers Return : True if currently has subscribers to the service.","title":"function hasSubscribers"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-basepublisher_3","text":"BasePublisher () = default","title":"function BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-basepublisher_4","text":"BasePublisher ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions )","title":"function BasePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-port","text":"const port_t & port () const port Return : const accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#function-port_1","text":"port_t & port () port Return : accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BasePublisher/#variable-m_port","text":"port_t m_port { nullptr }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/","text":"iox::popo::BaseServer \ud83d\udd17 The BaseServer class contains the common implementation for the different server. More... #include <iceoryx_posh/internal/popo/base_server.hpp> Protected Types \ud83d\udd17 Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions \ud83d\udd17 Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer & operator= (const BaseServer & ) BaseServer ( BaseServer && rhs) BaseServer & operator= ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions \ud83d\udd17 Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes \ud83d\udd17 Name PortT m_port TriggerHandleT m_trigger Friends \ud83d\udd17 Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename PortT = ServerPortUser , typename TriggerHandleT = TriggerHandle > class iox :: popo :: BaseServer ; The BaseServer class contains the common implementation for the different server. Parameters : PortT type of the underlying port, required for testing specializations. TriggerHandleT type of the underlying trigger handle, required for testing Note : Not intended for public usage! Use the [Server](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Server/) or [UntypedServer](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/) instead! Protected Types Documentation \ud83d\udd17 using SelfType \ud83d\udd17 using iox :: popo :: BaseServer < PortT , TriggerHandleT >:: SelfType = BaseServer < PortT , TriggerHandleT > ; using PortType \ud83d\udd17 using iox :: popo :: BaseServer < PortT , TriggerHandleT >:: PortType = PortT ; Public Functions Documentation \ud83d\udd17 function ~BaseServer \ud83d\udd17 virtual ~ BaseServer () function BaseServer \ud83d\udd17 BaseServer ( const BaseServer & other ) function operator= \ud83d\udd17 BaseServer & operator = ( const BaseServer & ) function BaseServer \ud83d\udd17 BaseServer ( BaseServer && rhs ) function operator= \ud83d\udd17 BaseServer & operator = ( BaseServer && rhs ) function getUid \ud83d\udd17 uid_t getUid () const Get the UID of the server. Return : The server's UID. function getServiceDescription \ud83d\udd17 const capro :: ServiceDescription & getServiceDescription () const Get the service description of the server. Return : A reference to the service description. function offer \ud83d\udd17 void offer () Offer the service to be connected to when not already offering, otherwise nothing. function stopOffer \ud83d\udd17 void stopOffer () Stop offering the service when already offering, otherwise nothing. function isOffered \ud83d\udd17 bool isOffered () const Check if the server is offering. Return : True if service is currently being offered. function hasClients \ud83d\udd17 bool hasClients () const Check if the server has clients. Return : True if currently has subscribers to the service. function hasRequests \ud83d\udd17 bool hasRequests () const Check if requests are available. Return : True if requests are available. function hasMissedRequests \ud83d\udd17 bool hasMissedRequests () Check if requests has been missed since the last call of this method. Return : True if requests has been missed. Requests may be missed due to overflowing receive queue. function releaseQueuedRequests \ud83d\udd17 void releaseQueuedRequests () Releases any unread queued requests. Protected Functions Documentation \ud83d\udd17 function BaseServer \ud83d\udd17 BaseServer ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions ) function invalidateTrigger \ud83d\udd17 void invalidateTrigger ( const uint64_t uniqueTriggerId ) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. Parameters : uniqueTriggerId the id of the corresponding trigger function enableState \ud83d\udd17 void enableState ( TriggerHandleT && triggerHandle , const ServerState serverState ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. serverState the state which should be attached function getCallbackForIsStateConditionSatisfied \ud83d\udd17 WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ServerState serverState ) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. Parameters : serverState the state to which the hasTriggeredCallback is required function disableState \ud83d\udd17 void disableState ( const ServerState serverState ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : serverState the state which should be detached function enableEvent \ud83d\udd17 void enableEvent ( TriggerHandleT && triggerHandle , const ServerEvent serverEvent ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. serverEvent the event which should be attached function disableEvent \ud83d\udd17 void disableEvent ( const ServerEvent serverEvent ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : serverEvent the event which should be detached function port \ud83d\udd17 const PortT & port () const port Return : const accessor of the underlying port function port \ud83d\udd17 PortT & port () port Return : accessor of the underlying port Protected Attributes Documentation \ud83d\udd17 variable m_port \ud83d\udd17 PortT m_port ; variable m_trigger \ud83d\udd17 TriggerHandleT m_trigger ; Friends \ud83d\udd17 friend NotificationAttorney \ud83d\udd17 friend class NotificationAttorney ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::BaseServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#ioxpopobaseserver","text":"The BaseServer class contains the common implementation for the different server. More... #include <iceoryx_posh/internal/popo/base_server.hpp>","title":"iox::popo::BaseServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#protected-types","text":"Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType","title":"Protected Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#public-functions","text":"Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer & operator= (const BaseServer & ) BaseServer ( BaseServer && rhs) BaseServer & operator= ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#protected-functions","text":"Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#protected-attributes","text":"Name PortT m_port TriggerHandleT m_trigger","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#friends","text":"Name class NotificationAttorney","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#detailed-description","text":"template < typename PortT = ServerPortUser , typename TriggerHandleT = TriggerHandle > class iox :: popo :: BaseServer ; The BaseServer class contains the common implementation for the different server. Parameters : PortT type of the underlying port, required for testing specializations. TriggerHandleT type of the underlying trigger handle, required for testing Note : Not intended for public usage! Use the [Server](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Server/) or [UntypedServer](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#using-selftype","text":"using iox :: popo :: BaseServer < PortT , TriggerHandleT >:: SelfType = BaseServer < PortT , TriggerHandleT > ;","title":"using SelfType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#using-porttype","text":"using iox :: popo :: BaseServer < PortT , TriggerHandleT >:: PortType = PortT ;","title":"using PortType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-baseserver","text":"virtual ~ BaseServer ()","title":"function ~BaseServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-baseserver_1","text":"BaseServer ( const BaseServer & other )","title":"function BaseServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-operator","text":"BaseServer & operator = ( const BaseServer & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-baseserver_2","text":"BaseServer ( BaseServer && rhs )","title":"function BaseServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-operator_1","text":"BaseServer & operator = ( BaseServer && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-getuid","text":"uid_t getUid () const Get the UID of the server. Return : The server's UID.","title":"function getUid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-getservicedescription","text":"const capro :: ServiceDescription & getServiceDescription () const Get the service description of the server. Return : A reference to the service description.","title":"function getServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-offer","text":"void offer () Offer the service to be connected to when not already offering, otherwise nothing.","title":"function offer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-stopoffer","text":"void stopOffer () Stop offering the service when already offering, otherwise nothing.","title":"function stopOffer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-isoffered","text":"bool isOffered () const Check if the server is offering. Return : True if service is currently being offered.","title":"function isOffered"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-hasclients","text":"bool hasClients () const Check if the server has clients. Return : True if currently has subscribers to the service.","title":"function hasClients"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-hasrequests","text":"bool hasRequests () const Check if requests are available. Return : True if requests are available.","title":"function hasRequests"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-hasmissedrequests","text":"bool hasMissedRequests () Check if requests has been missed since the last call of this method. Return : True if requests has been missed. Requests may be missed due to overflowing receive queue.","title":"function hasMissedRequests"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-releasequeuedrequests","text":"void releaseQueuedRequests () Releases any unread queued requests.","title":"function releaseQueuedRequests"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-baseserver_3","text":"BaseServer ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions )","title":"function BaseServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-invalidatetrigger","text":"void invalidateTrigger ( const uint64_t uniqueTriggerId ) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. Parameters : uniqueTriggerId the id of the corresponding trigger","title":"function invalidateTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-enablestate","text":"void enableState ( TriggerHandleT && triggerHandle , const ServerState serverState ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. serverState the state which should be attached","title":"function enableState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-getcallbackforisstateconditionsatisfied","text":"WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ServerState serverState ) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. Parameters : serverState the state to which the hasTriggeredCallback is required","title":"function getCallbackForIsStateConditionSatisfied"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-disablestate","text":"void disableState ( const ServerState serverState ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : serverState the state which should be detached","title":"function disableState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-enableevent","text":"void enableEvent ( TriggerHandleT && triggerHandle , const ServerEvent serverEvent ) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. serverEvent the event which should be attached","title":"function enableEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-disableevent","text":"void disableEvent ( const ServerEvent serverEvent ) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. Parameters : serverEvent the event which should be detached","title":"function disableEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-port","text":"const PortT & port () const port Return : const accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#function-port_1","text":"PortT & port () port Return : accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#variable-m_port","text":"PortT m_port ;","title":"variable m_port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#variable-m_trigger","text":"TriggerHandleT m_trigger ;","title":"variable m_trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseServer/#friend-notificationattorney","text":"friend class NotificationAttorney ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/","text":"iox::popo::BaseSubscriber \ud83d\udd17 base class for all types of subscriber More... #include <iceoryx_posh/internal/popo/base_subscriber.hpp> Protected Types \ud83d\udd17 Name using BaseSubscriber < port_t > SelfType Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. using port_t PortType Public Functions \ud83d\udd17 Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions \ud83d\udd17 Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber & operator= (const BaseSubscriber & ) BaseSubscriber ( BaseSubscriber && rhs) BaseSubscriber & operator= ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes \ud83d\udd17 Name port_t m_port TriggerHandle m_trigger Friends \ud83d\udd17 Name class NotificationAttorney class iox::runtime::ServiceDiscovery Detailed Description \ud83d\udd17 template < typename port_t = iox :: SubscriberPortUserType > class iox :: popo :: BaseSubscriber ; base class for all types of subscriber Parameters : port_t type of the underlying port, required for testing Note : Not intended for public usage! Use the [Subscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/) or [UntypedSubscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/) instead! Protected Types Documentation \ud83d\udd17 using SelfType \ud83d\udd17 using iox :: popo :: BaseSubscriber < port_t >:: SelfType = BaseSubscriber < port_t > ; Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. Parameters : uniqueTriggerId the id of the corresponding trigger Only usable by the WaitSet , not for public use using PortType \ud83d\udd17 using iox :: popo :: BaseSubscriber < port_t >:: PortType = port_t ; Public Functions Documentation \ud83d\udd17 function ~BaseSubscriber \ud83d\udd17 virtual ~ BaseSubscriber () function getUid \ud83d\udd17 uid_t getUid () const uid Get the unique ID of the subscriber. Return : The subscriber's unique ID. function getServiceDescription \ud83d\udd17 capro :: ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. Return : The service description. function subscribe \ud83d\udd17 void subscribe () subscribe Initiate subscription. Return : function getSubscriptionState \ud83d\udd17 SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. Return : The current subscription state. function unsubscribe \ud83d\udd17 void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. function hasData \ud83d\udd17 bool hasData () const Check if data is available. Return : True if data is available. function hasMissedData \ud83d\udd17 bool hasMissedData () Check if data has been missed since the last call of this method. Return : True if data has been missed. Data may be missed due to overflowing receive queue. function releaseQueuedData \ud83d\udd17 void releaseQueuedData () Releases any unread queued data. Protected Functions Documentation \ud83d\udd17 function BaseSubscriber \ud83d\udd17 BaseSubscriber () function BaseSubscriber \ud83d\udd17 BaseSubscriber ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions ) function BaseSubscriber \ud83d\udd17 BaseSubscriber ( const BaseSubscriber & other ) function operator= \ud83d\udd17 BaseSubscriber & operator = ( const BaseSubscriber & ) function BaseSubscriber \ud83d\udd17 BaseSubscriber ( BaseSubscriber && rhs ) function operator= \ud83d\udd17 BaseSubscriber & operator = ( BaseSubscriber && rhs ) function takeChunk \ud83d\udd17 cxx :: expected < const mepoo :: ChunkHeader * , ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port function invalidateTrigger \ud83d\udd17 void invalidateTrigger ( const uint64_t trigger ) function enableState \ud83d\udd17 void enableState ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberState subscriberState ) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. subscriberState the state which should be attached function getCallbackForIsStateConditionSatisfied \ud83d\udd17 WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const SubscriberState subscriberState ) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. Parameters : subscriberState the state to which the hasTriggeredCallback is required function disableState \ud83d\udd17 void disableState ( const SubscriberState subscriberState ) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. Parameters : subscriberState the state which should be detached function enableEvent \ud83d\udd17 void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberEvent subscriberState ) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. subscriberEvent the event which should be attached function disableEvent \ud83d\udd17 void disableEvent ( const SubscriberEvent subscriberEvent ) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. Parameters : subscriberEvent the event which should be detached function port \ud83d\udd17 const port_t & port () const const accessor of the underlying port function port \ud83d\udd17 port_t & port () accessor of the underlying port Protected Attributes Documentation \ud83d\udd17 variable m_port \ud83d\udd17 port_t m_port { nullptr }; variable m_trigger \ud83d\udd17 TriggerHandle m_trigger ; Friends \ud83d\udd17 friend NotificationAttorney \ud83d\udd17 friend class NotificationAttorney ; friend iox::runtime::ServiceDiscovery \ud83d\udd17 friend class iox :: runtime :: ServiceDiscovery ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#ioxpopobasesubscriber","text":"base class for all types of subscriber More... #include <iceoryx_posh/internal/popo/base_subscriber.hpp>","title":"iox::popo::BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#protected-types","text":"Name using BaseSubscriber < port_t > SelfType Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. using port_t PortType","title":"Protected Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#public-functions","text":"Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#protected-functions","text":"Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber & operator= (const BaseSubscriber & ) BaseSubscriber ( BaseSubscriber && rhs) BaseSubscriber & operator= ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#protected-attributes","text":"Name port_t m_port TriggerHandle m_trigger","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#friends","text":"Name class NotificationAttorney class iox::runtime::ServiceDiscovery","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#detailed-description","text":"template < typename port_t = iox :: SubscriberPortUserType > class iox :: popo :: BaseSubscriber ; base class for all types of subscriber Parameters : port_t type of the underlying port, required for testing Note : Not intended for public usage! Use the [Subscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/) or [UntypedSubscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#using-selftype","text":"using iox :: popo :: BaseSubscriber < port_t >:: SelfType = BaseSubscriber < port_t > ; Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. Parameters : uniqueTriggerId the id of the corresponding trigger Only usable by the WaitSet , not for public use","title":"using SelfType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#using-porttype","text":"using iox :: popo :: BaseSubscriber < port_t >:: PortType = port_t ;","title":"using PortType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-basesubscriber","text":"virtual ~ BaseSubscriber ()","title":"function ~BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-getuid","text":"uid_t getUid () const uid Get the unique ID of the subscriber. Return : The subscriber's unique ID.","title":"function getUid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-getservicedescription","text":"capro :: ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. Return : The service description.","title":"function getServiceDescription"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-subscribe","text":"void subscribe () subscribe Initiate subscription. Return :","title":"function subscribe"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-getsubscriptionstate","text":"SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. Return : The current subscription state.","title":"function getSubscriptionState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-unsubscribe","text":"void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing.","title":"function unsubscribe"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-hasdata","text":"bool hasData () const Check if data is available. Return : True if data is available.","title":"function hasData"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-hasmisseddata","text":"bool hasMissedData () Check if data has been missed since the last call of this method. Return : True if data has been missed. Data may be missed due to overflowing receive queue.","title":"function hasMissedData"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-releasequeueddata","text":"void releaseQueuedData () Releases any unread queued data.","title":"function releaseQueuedData"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-basesubscriber_1","text":"BaseSubscriber ()","title":"function BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-basesubscriber_2","text":"BaseSubscriber ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions )","title":"function BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-basesubscriber_3","text":"BaseSubscriber ( const BaseSubscriber & other )","title":"function BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-operator","text":"BaseSubscriber & operator = ( const BaseSubscriber & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-basesubscriber_4","text":"BaseSubscriber ( BaseSubscriber && rhs )","title":"function BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-operator_1","text":"BaseSubscriber & operator = ( BaseSubscriber && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-takechunk","text":"cxx :: expected < const mepoo :: ChunkHeader * , ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port","title":"function takeChunk"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-invalidatetrigger","text":"void invalidateTrigger ( const uint64_t trigger )","title":"function invalidateTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-enablestate","text":"void enableState ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberState subscriberState ) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. subscriberState the state which should be attached","title":"function enableState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-getcallbackforisstateconditionsatisfied","text":"WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const SubscriberState subscriberState ) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. Parameters : subscriberState the state to which the hasTriggeredCallback is required","title":"function getCallbackForIsStateConditionSatisfied"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-disablestate","text":"void disableState ( const SubscriberState subscriberState ) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. Parameters : subscriberState the state which should be detached","title":"function disableState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-enableevent","text":"void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberEvent subscriberState ) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. Parameters : triggerHandle rvalue reference to the triggerHandle. This class takes the ownership of that handle. subscriberEvent the event which should be attached","title":"function enableEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-disableevent","text":"void disableEvent ( const SubscriberEvent subscriberEvent ) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. Parameters : subscriberEvent the event which should be detached","title":"function disableEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-port","text":"const port_t & port () const const accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#function-port_1","text":"port_t & port () accessor of the underlying port","title":"function port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#variable-m_port","text":"port_t m_port { nullptr };","title":"variable m_port"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#variable-m_trigger","text":"TriggerHandle m_trigger ;","title":"variable m_trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#friend-notificationattorney","text":"friend class NotificationAttorney ;","title":"friend NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1BaseSubscriber/#friend-ioxruntimeservicediscovery","text":"friend class iox :: runtime :: ServiceDiscovery ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend iox::runtime::ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ChunkSender/","text":"iox::popo::ChunkSender \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename T > class iox :: popo :: ChunkSender ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ChunkSender"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ChunkSender/#ioxpopochunksender","text":"More...","title":"iox::popo::ChunkSender"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ChunkSender/#detailed-description","text":"template < typename T > class iox :: popo :: ChunkSender ; Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/","text":"iox::popo::Client \ud83d\udd17 The Client class for the request-response messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/client.hpp> Inherits from iox::popo::ClientImpl< Req, Res > , iox::popo::BaseClient<> , iox::popo::RpcInterface< Request< Req >, ClientSendError > Public Functions \ud83d\udd17 Name virtual ~Client () Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::ClientImpl< Req, Res > Name ClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) Constructor for a client. virtual ~ClientImpl () ClientImpl (const ClientImpl & ) ClientImpl ( ClientImpl && ) ClientImpl & operator= (const ClientImpl & ) ClientImpl & operator= ( ClientImpl && ) template <typename... Args> cxx::expected< Request < Req >, AllocationError > loan (Args &&... args) Get a Request from loaned shared memory and construct the data with the given arguments. cxx::expected< ClientSendError > send ( Request < Req > && request) override Sends the given Request and then releases its loan. cxx::expected< Response < const Res >, ChunkReceiveResult > take () Take the Response from the top of the receive queue. Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient & operator= (const BaseClient & ) BaseClient ( BaseClient && rhs) BaseClient & operator= ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename Req , typename Res > class iox :: popo :: Client ; The Client class for the request-response messaging pattern in iceoryx. Parameters : Req type of request data Res type of response data Public Functions Documentation \ud83d\udd17 function ~Client \ud83d\udd17 inline virtual ~ Client () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Client"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#ioxpopoclient","text":"The Client class for the request-response messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/client.hpp> Inherits from iox::popo::ClientImpl< Req, Res > , iox::popo::BaseClient<> , iox::popo::RpcInterface< Request< Req >, ClientSendError >","title":"iox::popo::Client"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#public-functions","text":"Name virtual ~Client ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#additional-inherited-members","text":"Public Functions inherited from iox::popo::ClientImpl< Req, Res > Name ClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) Constructor for a client. virtual ~ClientImpl () ClientImpl (const ClientImpl & ) ClientImpl ( ClientImpl && ) ClientImpl & operator= (const ClientImpl & ) ClientImpl & operator= ( ClientImpl && ) template <typename... Args> cxx::expected< Request < Req >, AllocationError > loan (Args &&... args) Get a Request from loaned shared memory and construct the data with the given arguments. cxx::expected< ClientSendError > send ( Request < Req > && request) override Sends the given Request and then releases its loan. cxx::expected< Response < const Res >, ChunkReceiveResult > take () Take the Response from the top of the receive queue. Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient & operator= (const BaseClient & ) BaseClient ( BaseClient && rhs) BaseClient & operator= ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#detailed-description","text":"template < typename Req , typename Res > class iox :: popo :: Client ; The Client class for the request-response messaging pattern in iceoryx. Parameters : Req type of request data Res type of response data","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Client/#function-client","text":"inline virtual ~ Client () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~Client"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/","text":"iox::popo::ClientImpl \ud83d\udd17 The ClientImpl class implements the typed client API. More... #include <iceoryx_posh/internal/popo/client_impl.hpp> Inherits from iox::popo::BaseClient<> , iox::popo::RpcInterface< Request< Req >, ClientSendError > Public Functions \ud83d\udd17 Name ClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) Constructor for a client. virtual ~ClientImpl () ClientImpl (const ClientImpl & ) ClientImpl ( ClientImpl && ) ClientImpl & operator= (const ClientImpl & ) ClientImpl & operator= ( ClientImpl && ) template <typename... Args> cxx::expected< Request < Req >, AllocationError > loan (Args &&... args) Get a Request from loaned shared memory and construct the data with the given arguments. cxx::expected< ClientSendError > send ( Request < Req > && request) override Sends the given Request and then releases its loan. cxx::expected< Response < const Res >, ChunkReceiveResult > take () Take the Response from the top of the receive queue. Additional inherited members \ud83d\udd17 Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename Req , typename Res , typename BaseClientT = BaseClient <>> class iox :: popo :: ClientImpl ; The ClientImpl class implements the typed client API. Note : Not intended for public usage! Use the [Client](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Client/) instead! Public Functions Documentation \ud83d\udd17 function ClientImpl \ud83d\udd17 explicit ClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {} ) Constructor for a client. Parameters : service is the ServiceDescription for the new client clientOptions like the queue capacity and queue full policy by a client function ~ClientImpl \ud83d\udd17 virtual ~ ClientImpl () function ClientImpl \ud83d\udd17 ClientImpl ( const ClientImpl & ) function ClientImpl \ud83d\udd17 ClientImpl ( ClientImpl && ) function operator= \ud83d\udd17 ClientImpl & operator = ( const ClientImpl & ) function operator= \ud83d\udd17 ClientImpl & operator = ( ClientImpl && ) function loan \ud83d\udd17 template < typename ... Args > cxx :: expected < Request < Req > , AllocationError > loan ( Args && ... args ) Get a Request from loaned shared memory and construct the data with the given arguments. Parameters : args Arguments used to construct the data. Return : An instance of the Request that resides in shared memory or an error if unable to allocate memory to loan. The loaned Request is automatically released when it goes out of scope. function send \ud83d\udd17 cxx :: expected < ClientSendError > send ( Request < Req > && request ) override Sends the given Request and then releases its loan. Parameters : request to send. Return : Error if sending was not successful function take \ud83d\udd17 cxx :: expected < Response < const Res > , ChunkReceiveResult > take () Take the Response from the top of the receive queue. Return : Either a Response or a ChunkReceiveResult. The Response takes care of the cleanup. Don't store the raw pointer to the content of the Response , but always the whole Response . Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#ioxpopoclientimpl","text":"The ClientImpl class implements the typed client API. More... #include <iceoryx_posh/internal/popo/client_impl.hpp> Inherits from iox::popo::BaseClient<> , iox::popo::RpcInterface< Request< Req >, ClientSendError >","title":"iox::popo::ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#public-functions","text":"Name ClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) Constructor for a client. virtual ~ClientImpl () ClientImpl (const ClientImpl & ) ClientImpl ( ClientImpl && ) ClientImpl & operator= (const ClientImpl & ) ClientImpl & operator= ( ClientImpl && ) template <typename... Args> cxx::expected< Request < Req >, AllocationError > loan (Args &&... args) Get a Request from loaned shared memory and construct the data with the given arguments. cxx::expected< ClientSendError > send ( Request < Req > && request) override Sends the given Request and then releases its loan. cxx::expected< Response < const Res >, ChunkReceiveResult > take () Take the Response from the top of the receive queue.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#additional-inherited-members","text":"Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#detailed-description","text":"template < typename Req , typename Res , typename BaseClientT = BaseClient <>> class iox :: popo :: ClientImpl ; The ClientImpl class implements the typed client API. Note : Not intended for public usage! Use the [Client](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Client/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-clientimpl","text":"explicit ClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {} ) Constructor for a client. Parameters : service is the ServiceDescription for the new client clientOptions like the queue capacity and queue full policy by a client","title":"function ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-clientimpl_1","text":"virtual ~ ClientImpl ()","title":"function ~ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-clientimpl_2","text":"ClientImpl ( const ClientImpl & )","title":"function ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-clientimpl_3","text":"ClientImpl ( ClientImpl && )","title":"function ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-operator","text":"ClientImpl & operator = ( const ClientImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-operator_1","text":"ClientImpl & operator = ( ClientImpl && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-loan","text":"template < typename ... Args > cxx :: expected < Request < Req > , AllocationError > loan ( Args && ... args ) Get a Request from loaned shared memory and construct the data with the given arguments. Parameters : args Arguments used to construct the data. Return : An instance of the Request that resides in shared memory or an error if unable to allocate memory to loan. The loaned Request is automatically released when it goes out of scope.","title":"function loan"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-send","text":"cxx :: expected < ClientSendError > send ( Request < Req > && request ) override Sends the given Request and then releases its loan. Parameters : request to send. Return : Error if sending was not successful","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ClientImpl/#function-take","text":"cxx :: expected < Response < const Res > , ChunkReceiveResult > take () Take the Response from the top of the receive queue. Return : Either a Response or a ChunkReceiveResult. The Response takes care of the cleanup. Don't store the raw pointer to the content of the Response , but always the whole Response . Updated on 18 December 2023 at 13:11:43 CET","title":"function take"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/","text":"iox::popo::Listener \ud83d\udd17 Inherits from iox::popo::ListenerImpl< MAX_NUMBER_OF_EVENTS_PER_LISTENER > Public Types \ud83d\udd17 Name using ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > Parent Public Functions \ud83d\udd17 Name Listener () Protected Functions \ud83d\udd17 Name Listener (ConditionVariableData & conditionVariableData) Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::ListenerImpl< MAX_NUMBER_OF_EVENTS_PER_LISTENER > Name ListenerImpl () ListenerImpl (const ListenerImpl & ) ListenerImpl ( ListenerImpl && ) ~ListenerImpl () ListenerImpl & operator= (const ListenerImpl & ) ListenerImpl & operator= ( ListenerImpl && ) template <typename T ,typename EventType ,typename ContextDataType ,typename =std::enable_if_t ::value>> cxx::expected< ListenerError > attachEvent (T & eventOrigin, const EventType eventType, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. template <typename T ,typename ContextDataType > cxx::expected< ListenerError > attachEvent (T & eventOrigin, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. template <typename T ,typename EventType ,typename =std::enable_if_t ::value>> void detachEvent (T & eventOrigin, const EventType eventType) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. template <typename T > void detachEvent (T & eventOrigin) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. uint64_t size () const Returns the size of the Listener . constexpr uint64_t capacity () Returns the capacity of the Listener . Protected Functions inherited from iox::popo::ListenerImpl< MAX_NUMBER_OF_EVENTS_PER_LISTENER > Name ListenerImpl (ConditionVariableData & conditionVariableData) Public Types Documentation \ud83d\udd17 using Parent \ud83d\udd17 using iox :: popo :: Listener :: Parent = ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > ; Public Functions Documentation \ud83d\udd17 function Listener \ud83d\udd17 Listener () Protected Functions Documentation \ud83d\udd17 function Listener \ud83d\udd17 Listener ( ConditionVariableData & conditionVariableData ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#ioxpopolistener","text":"Inherits from iox::popo::ListenerImpl< MAX_NUMBER_OF_EVENTS_PER_LISTENER >","title":"iox::popo::Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-types","text":"Name using ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > Parent","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-functions","text":"Name Listener ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#protected-functions","text":"Name Listener (ConditionVariableData & conditionVariableData)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#additional-inherited-members","text":"Public Functions inherited from iox::popo::ListenerImpl< MAX_NUMBER_OF_EVENTS_PER_LISTENER > Name ListenerImpl () ListenerImpl (const ListenerImpl & ) ListenerImpl ( ListenerImpl && ) ~ListenerImpl () ListenerImpl & operator= (const ListenerImpl & ) ListenerImpl & operator= ( ListenerImpl && ) template <typename T ,typename EventType ,typename ContextDataType ,typename =std::enable_if_t ::value>> cxx::expected< ListenerError > attachEvent (T & eventOrigin, const EventType eventType, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. template <typename T ,typename ContextDataType > cxx::expected< ListenerError > attachEvent (T & eventOrigin, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. template <typename T ,typename EventType ,typename =std::enable_if_t ::value>> void detachEvent (T & eventOrigin, const EventType eventType) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. template <typename T > void detachEvent (T & eventOrigin) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. uint64_t size () const Returns the size of the Listener . constexpr uint64_t capacity () Returns the capacity of the Listener . Protected Functions inherited from iox::popo::ListenerImpl< MAX_NUMBER_OF_EVENTS_PER_LISTENER > Name ListenerImpl (ConditionVariableData & conditionVariableData)","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#using-parent","text":"using iox :: popo :: Listener :: Parent = ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > ;","title":"using Parent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#function-listener","text":"Listener ()","title":"function Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Listener/#function-listener_1","text":"Listener ( ConditionVariableData & conditionVariableData ) Updated on 18 December 2023 at 13:11:43 CET","title":"function Listener"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/","text":"iox::popo::ListenerImpl \ud83d\udd17 The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. More... #include <iceoryx_posh/popo/listener.hpp> Public Functions \ud83d\udd17 Name ListenerImpl () ListenerImpl (const ListenerImpl & ) ListenerImpl ( ListenerImpl && ) ~ListenerImpl () ListenerImpl & operator= (const ListenerImpl & ) ListenerImpl & operator= ( ListenerImpl && ) template <typename T ,typename EventType ,typename ContextDataType ,typename =std::enable_if_t ::value>> cxx::expected< ListenerError > attachEvent (T & eventOrigin, const EventType eventType, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. template <typename T ,typename ContextDataType > cxx::expected< ListenerError > attachEvent (T & eventOrigin, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. template <typename T ,typename EventType ,typename =std::enable_if_t ::value>> void detachEvent (T & eventOrigin, const EventType eventType) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. template <typename T > void detachEvent (T & eventOrigin) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. uint64_t size () const Returns the size of the Listener . constexpr uint64_t capacity () Returns the capacity of the Listener . Protected Functions \ud83d\udd17 Name ListenerImpl (ConditionVariableData & conditionVariableData) Detailed Description \ud83d\udd17 template < uint64_t Capacity > class iox :: popo :: ListenerImpl ; The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. Note : The Listener is threadsafe and can be used without any restrictions concurrently. Attention : Calling detachEvent for the same event from multiple threads is supported but can cause a race condition if you attach the same event again concurrently from another thread. Example: One calls detachEvent [1] from thread A, B and C thread B wins and detaches event [1] A new thread D spawns and would like to attach event [1] again while thread A and C are still waiting to detach [1]. Thread A wins but cannot detach event [1] since it is not attached. Thread D wins and attaches event [1]. Finally thread C can continue and detaches event [1] again. If thread D is executed last then the event is attached. So depending on the operating system defined execution order the event is either attached or detached. Best practice: Detach a specific event only from one specific thread and not from multiple contexts. Public Functions Documentation \ud83d\udd17 function ListenerImpl \ud83d\udd17 ListenerImpl () function ListenerImpl \ud83d\udd17 ListenerImpl ( const ListenerImpl & ) function ListenerImpl \ud83d\udd17 ListenerImpl ( ListenerImpl && ) function ~ListenerImpl \ud83d\udd17 ~ ListenerImpl () function operator= \ud83d\udd17 ListenerImpl & operator = ( const ListenerImpl & ) function operator= \ud83d\udd17 ListenerImpl & operator = ( ListenerImpl && ) function attachEvent \ud83d\udd17 template < typename T , typename EventType , typename ContextDataType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType > & eventCallback ) Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions! Furthermore, attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. function attachEvent \ud83d\udd17 template < typename T , typename ContextDataType > cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType > & eventCallback ) Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions! Furthermore, attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. function detachEvent \ud83d\udd17 template < typename T , typename EventType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> void detachEvent ( T & eventOrigin , const EventType eventType ) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions! function detachEvent \ud83d\udd17 template < typename T > void detachEvent ( T & eventOrigin ) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions! function size \ud83d\udd17 uint64_t size () const Returns the size of the Listener . Return : size of the Listener function capacity \ud83d\udd17 static constexpr uint64_t capacity () Returns the capacity of the Listener . Return : capacity of the Listener Protected Functions Documentation \ud83d\udd17 function ListenerImpl \ud83d\udd17 ListenerImpl ( ConditionVariableData & conditionVariableData ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#ioxpopolistenerimpl","text":"The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. More... #include <iceoryx_posh/popo/listener.hpp>","title":"iox::popo::ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#public-functions","text":"Name ListenerImpl () ListenerImpl (const ListenerImpl & ) ListenerImpl ( ListenerImpl && ) ~ListenerImpl () ListenerImpl & operator= (const ListenerImpl & ) ListenerImpl & operator= ( ListenerImpl && ) template <typename T ,typename EventType ,typename ContextDataType ,typename =std::enable_if_t ::value>> cxx::expected< ListenerError > attachEvent (T & eventOrigin, const EventType eventType, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. template <typename T ,typename ContextDataType > cxx::expected< ListenerError > attachEvent (T & eventOrigin, const NotificationCallback < T, ContextDataType > & eventCallback) Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. template <typename T ,typename EventType ,typename =std::enable_if_t ::value>> void detachEvent (T & eventOrigin, const EventType eventType) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. template <typename T > void detachEvent (T & eventOrigin) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. uint64_t size () const Returns the size of the Listener . constexpr uint64_t capacity () Returns the capacity of the Listener .","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#protected-functions","text":"Name ListenerImpl (ConditionVariableData & conditionVariableData)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#detailed-description","text":"template < uint64_t Capacity > class iox :: popo :: ListenerImpl ; The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. Note : The Listener is threadsafe and can be used without any restrictions concurrently. Attention : Calling detachEvent for the same event from multiple threads is supported but can cause a race condition if you attach the same event again concurrently from another thread. Example: One calls detachEvent [1] from thread A, B and C thread B wins and detaches event [1] A new thread D spawns and would like to attach event [1] again while thread A and C are still waiting to detach [1]. Thread A wins but cannot detach event [1] since it is not attached. Thread D wins and attaches event [1]. Finally thread C can continue and detaches event [1] again. If thread D is executed last then the event is attached. So depending on the operating system defined execution order the event is either attached or detached. Best practice: Detach a specific event only from one specific thread and not from multiple contexts.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl","text":"ListenerImpl ()","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_1","text":"ListenerImpl ( const ListenerImpl & )","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_2","text":"ListenerImpl ( ListenerImpl && )","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_3","text":"~ ListenerImpl ()","title":"function ~ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-operator","text":"ListenerImpl & operator = ( const ListenerImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-operator_1","text":"ListenerImpl & operator = ( ListenerImpl && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-attachevent","text":"template < typename T , typename EventType , typename ContextDataType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType > & eventCallback ) Attaches an event. Hereby the event is defined as a class T, the eventOrigin, an enum which further defines the event inside the class and the corresponding callback which will be called when the event occurs. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions! Furthermore, attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached.","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-attachevent_1","text":"template < typename T , typename ContextDataType > cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType > & eventCallback ) Attaches an event. Hereby the event is defined as a class T, the eventOrigin and the corresponding callback which will be called when the event occurs. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions! Furthermore, attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached.","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-detachevent","text":"template < typename T , typename EventType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> void detachEvent ( T & eventOrigin , const EventType eventType ) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin and the eventType with further specifies the event inside of eventOrigin. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions!","title":"function detachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-detachevent_1","text":"template < typename T > void detachEvent ( T & eventOrigin ) Detaches an event. Hereby, the event is defined as a class T, the eventOrigin. Template Parameters : Note : This method can be called from any thread concurrently without any restrictions!","title":"function detachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-size","text":"uint64_t size () const Returns the size of the Listener . Return : size of the Listener","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-capacity","text":"static constexpr uint64_t capacity () Returns the capacity of the Listener . Return : capacity of the Listener","title":"function capacity"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl/#function-listenerimpl_4","text":"ListenerImpl ( ConditionVariableData & conditionVariableData ) Updated on 18 December 2023 at 13:11:43 CET","title":"function ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/","text":"iox::popo::ListenerImpl::IndexManager_t \ud83d\udd17 Public Types \ud83d\udd17 Name using concurrent::LoFFLi LoFFLi Public Functions \ud83d\udd17 Name IndexManager_t () bool pop (uint32_t & index) void push (const uint32_t index) uint64_t indicesInUse () const Public Attributes \ud83d\udd17 Name LoFFLi::Index_t m_loffliStorage LoFFLi m_loffli std::atomic< uint64_t > m_indicesInUse Public Types Documentation \ud83d\udd17 using LoFFLi \ud83d\udd17 using iox :: popo :: ListenerImpl < Capacity >:: IndexManager_t :: LoFFLi = concurrent :: LoFFLi ; Public Functions Documentation \ud83d\udd17 function IndexManager_t \ud83d\udd17 IndexManager_t () function pop \ud83d\udd17 bool pop ( uint32_t & index ) function push \ud83d\udd17 void push ( const uint32_t index ) function indicesInUse \ud83d\udd17 uint64_t indicesInUse () const Public Attributes Documentation \ud83d\udd17 variable m_loffliStorage \ud83d\udd17 LoFFLi :: Index_t m_loffliStorage ; variable m_loffli \ud83d\udd17 LoFFLi m_loffli ; variable m_indicesInUse \ud83d\udd17 std :: atomic < uint64_t > m_indicesInUse { 0U }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ListenerImpl::IndexManager_t"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#ioxpopolistenerimplindexmanager_t","text":"","title":"iox::popo::ListenerImpl::IndexManager_t"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-types","text":"Name using concurrent::LoFFLi LoFFLi","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-functions","text":"Name IndexManager_t () bool pop (uint32_t & index) void push (const uint32_t index) uint64_t indicesInUse () const","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-attributes","text":"Name LoFFLi::Index_t m_loffliStorage LoFFLi m_loffli std::atomic< uint64_t > m_indicesInUse","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#using-loffli","text":"using iox :: popo :: ListenerImpl < Capacity >:: IndexManager_t :: LoFFLi = concurrent :: LoFFLi ;","title":"using LoFFLi"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-indexmanager_t","text":"IndexManager_t ()","title":"function IndexManager_t"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-pop","text":"bool pop ( uint32_t & index )","title":"function pop"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-push","text":"void push ( const uint32_t index )","title":"function push"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#function-indicesinuse","text":"uint64_t indicesInUse () const","title":"function indicesInUse"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#variable-m_lofflistorage","text":"LoFFLi :: Index_t m_loffliStorage ;","title":"variable m_loffliStorage"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#variable-m_loffli","text":"LoFFLi m_loffli ;","title":"variable m_loffli"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ListenerImpl_1_1IndexManager__t/#variable-m_indicesinuse","text":"std :: atomic < uint64_t > m_indicesInUse { 0U }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_indicesInUse"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/","text":"iox::popo::NotificationAttorney \ud83d\udd17 Class which allows accessing private methods to friends of NotificationAttorney . Used for example by the WaitSet . Implements the Client-Attorney Pattern. #include <iceoryx_posh/popo/notification_attorney.hpp> Friends \ud83d\udd17 Name class WaitSet class ListenerImpl Friends \ud83d\udd17 friend WaitSet \ud83d\udd17 friend class WaitSet ; friend ListenerImpl \ud83d\udd17 friend class ListenerImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#ioxpoponotificationattorney","text":"Class which allows accessing private methods to friends of NotificationAttorney . Used for example by the WaitSet . Implements the Client-Attorney Pattern. #include <iceoryx_posh/popo/notification_attorney.hpp>","title":"iox::popo::NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friends","text":"Name class WaitSet class ListenerImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friend-waitset","text":"friend class WaitSet ;","title":"friend WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationAttorney/#friend-listenerimpl","text":"friend class ListenerImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend ListenerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/","text":"iox::popo::NotificationInfo \ud83d\udd17 NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback. #include <iceoryx_posh/popo/notification_info.hpp> Public Functions \ud83d\udd17 Name NotificationInfo () =default constructs an empty NotificationInfo virtual ~NotificationInfo () =default template <typename T ,typename ContextDataType > NotificationInfo (T *const notificationOrigin, const uint64_t notificationId, const NotificationCallback < T, ContextDataType > & callback) constructs a NotificationInfo object uint64_t getNotificationId () const returns the notification id template <typename T > bool doesOriginateFrom (T *const notificationOrigin) const confirms the notificationOrigin template <typename T > T * getOrigin () const returns the pointer to the notificationOrigin. bool operator() () const If a callback is set it executes the callback. Public Attributes \ud83d\udd17 Name constexpr uint64_t INVALID_ID Protected Attributes \ud83d\udd17 Name void * m_notificationOrigin void * m_userValue uint64_t m_notificationOriginTypeHash uint64_t m_notificationId internal::GenericCallbackPtr_t m_callbackPtr internal::TranslationCallbackPtr_t m_callback Friends \ud83d\udd17 Name class Trigger Public Functions Documentation \ud83d\udd17 function NotificationInfo \ud83d\udd17 NotificationInfo () = default constructs an empty NotificationInfo function ~NotificationInfo \ud83d\udd17 virtual ~ NotificationInfo () = default function NotificationInfo \ud83d\udd17 template < typename T , typename ContextDataType > NotificationInfo ( T * const notificationOrigin , const uint64_t notificationId , const NotificationCallback < T , ContextDataType > & callback ) constructs a NotificationInfo object Parameters : notificationOrigin the origin of the event notificationId id of the event callback the callback of the event function getNotificationId \ud83d\udd17 uint64_t getNotificationId () const returns the notification id Return : the empty NotificationInfo always returns INVALID_ID, otherwise the actual notificationId is returned which can also be INVALID_ID function doesOriginateFrom \ud83d\udd17 template < typename T > bool doesOriginateFrom ( T * const notificationOrigin ) const confirms the notificationOrigin Parameters : notificationOrigin the possible notificationOrigin Return : true if the address is equal to the notificationOrigin, otherwise false. The empty NotificationInfo returns always false. function getOrigin \ud83d\udd17 template < typename T > T * getOrigin () const returns the pointer to the notificationOrigin. Return : If T equals the Triggerable type it returns the notificationOrigin. Otherwise it calls the errorHandler with a moderate error of kPOPO__EVENT_INFO_TYPE_INCONSISTENCY_IN_GET_ORIGIN and returns nullptr. function operator() \ud83d\udd17 bool operator ()() const If a callback is set it executes the callback. Return : true if the callback was called, otherwise false Public Attributes Documentation \ud83d\udd17 variable INVALID_ID \ud83d\udd17 static constexpr uint64_t INVALID_ID = std :: numeric_limits < uint64_t >:: max (); Protected Attributes Documentation \ud83d\udd17 variable m_notificationOrigin \ud83d\udd17 void * m_notificationOrigin = nullptr ; variable m_userValue \ud83d\udd17 void * m_userValue = nullptr ; variable m_notificationOriginTypeHash \ud83d\udd17 uint64_t m_notificationOriginTypeHash = 0U ; variable m_notificationId \ud83d\udd17 uint64_t m_notificationId = INVALID_ID ; variable m_callbackPtr \ud83d\udd17 internal :: GenericCallbackPtr_t m_callbackPtr = nullptr ; variable m_callback \ud83d\udd17 internal :: TranslationCallbackPtr_t m_callback = nullptr ; Friends \ud83d\udd17 friend Trigger \ud83d\udd17 friend class Trigger ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#ioxpoponotificationinfo","text":"NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback. #include <iceoryx_posh/popo/notification_info.hpp>","title":"iox::popo::NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-functions","text":"Name NotificationInfo () =default constructs an empty NotificationInfo virtual ~NotificationInfo () =default template <typename T ,typename ContextDataType > NotificationInfo (T *const notificationOrigin, const uint64_t notificationId, const NotificationCallback < T, ContextDataType > & callback) constructs a NotificationInfo object uint64_t getNotificationId () const returns the notification id template <typename T > bool doesOriginateFrom (T *const notificationOrigin) const confirms the notificationOrigin template <typename T > T * getOrigin () const returns the pointer to the notificationOrigin. bool operator() () const If a callback is set it executes the callback.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-attributes","text":"Name constexpr uint64_t INVALID_ID","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#protected-attributes","text":"Name void * m_notificationOrigin void * m_userValue uint64_t m_notificationOriginTypeHash uint64_t m_notificationId internal::GenericCallbackPtr_t m_callbackPtr internal::TranslationCallbackPtr_t m_callback","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#friends","text":"Name class Trigger","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-notificationinfo","text":"NotificationInfo () = default constructs an empty NotificationInfo","title":"function NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-notificationinfo_1","text":"virtual ~ NotificationInfo () = default","title":"function ~NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-notificationinfo_2","text":"template < typename T , typename ContextDataType > NotificationInfo ( T * const notificationOrigin , const uint64_t notificationId , const NotificationCallback < T , ContextDataType > & callback ) constructs a NotificationInfo object Parameters : notificationOrigin the origin of the event notificationId id of the event callback the callback of the event","title":"function NotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-getnotificationid","text":"uint64_t getNotificationId () const returns the notification id Return : the empty NotificationInfo always returns INVALID_ID, otherwise the actual notificationId is returned which can also be INVALID_ID","title":"function getNotificationId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-doesoriginatefrom","text":"template < typename T > bool doesOriginateFrom ( T * const notificationOrigin ) const confirms the notificationOrigin Parameters : notificationOrigin the possible notificationOrigin Return : true if the address is equal to the notificationOrigin, otherwise false. The empty NotificationInfo returns always false.","title":"function doesOriginateFrom"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-getorigin","text":"template < typename T > T * getOrigin () const returns the pointer to the notificationOrigin. Return : If T equals the Triggerable type it returns the notificationOrigin. Otherwise it calls the errorHandler with a moderate error of kPOPO__EVENT_INFO_TYPE_INCONSISTENCY_IN_GET_ORIGIN and returns nullptr.","title":"function getOrigin"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#function-operator","text":"bool operator ()() const If a callback is set it executes the callback. Return : true if the callback was called, otherwise false","title":"function operator()"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-invalid_id","text":"static constexpr uint64_t INVALID_ID = std :: numeric_limits < uint64_t >:: max ();","title":"variable INVALID_ID"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_notificationorigin","text":"void * m_notificationOrigin = nullptr ;","title":"variable m_notificationOrigin"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_uservalue","text":"void * m_userValue = nullptr ;","title":"variable m_userValue"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_notificationorigintypehash","text":"uint64_t m_notificationOriginTypeHash = 0U ;","title":"variable m_notificationOriginTypeHash"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_notificationid","text":"uint64_t m_notificationId = INVALID_ID ;","title":"variable m_notificationId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_callbackptr","text":"internal :: GenericCallbackPtr_t m_callbackPtr = nullptr ;","title":"variable m_callbackPtr"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#variable-m_callback","text":"internal :: TranslationCallbackPtr_t m_callback = nullptr ;","title":"variable m_callback"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1NotificationInfo/#friend-trigger","text":"friend class Trigger ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/","text":"iox::popo::Publisher \ud83d\udd17 The Publisher class for the publish-subscribe messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/publisher.hpp> Inherits from iox::popo::PublisherImpl< T, mepoo::NoUserHeader > , iox::popo::BasePublisher<> , iox::popo::PublisherInterface< T, mepoo::NoUserHeader > Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::PublisherImpl< T, mepoo::NoUserHeader > Name PublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) PublisherImpl (const PublisherImpl & other) PublisherImpl & operator= (const PublisherImpl & ) PublisherImpl ( PublisherImpl && rhs) PublisherImpl & operator= ( PublisherImpl && rhs) virtual ~PublisherImpl () =default template <typename... Args> cxx::expected< Sample < T, H >, AllocationError > loan (Args &&... args) loan Get a sample from loaned shared memory and consctruct the data with the given arguments. void publish ( Sample < T, H > && sample) override publish Publishes the given sample and then releases its loan. cxx::expected< AllocationError > publishCopyOf (const T & val) publishCopyOf Copy the provided value into a loaned shared memory chunk and publish it. template <typename Callable ,typename... ArgTypes> cxx::expected< AllocationError > publishResultOf (Callable c, ArgTypes... args) publishResultOf Loan a sample from memory, execute the provided callable to write to it, then publish it. Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher & operator= (const BasePublisher & ) BasePublisher ( BasePublisher && rhs) BasePublisher & operator= ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port Detailed Description \ud83d\udd17 template < typename T , typename H = mepoo :: NoUserHeader > class iox :: popo :: Publisher ; The Publisher class for the publish-subscribe messaging pattern in iceoryx. Parameters : T user payload type H user header type Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Publisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/#ioxpopopublisher","text":"The Publisher class for the publish-subscribe messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/publisher.hpp> Inherits from iox::popo::PublisherImpl< T, mepoo::NoUserHeader > , iox::popo::BasePublisher<> , iox::popo::PublisherInterface< T, mepoo::NoUserHeader >","title":"iox::popo::Publisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/#additional-inherited-members","text":"Public Functions inherited from iox::popo::PublisherImpl< T, mepoo::NoUserHeader > Name PublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) PublisherImpl (const PublisherImpl & other) PublisherImpl & operator= (const PublisherImpl & ) PublisherImpl ( PublisherImpl && rhs) PublisherImpl & operator= ( PublisherImpl && rhs) virtual ~PublisherImpl () =default template <typename... Args> cxx::expected< Sample < T, H >, AllocationError > loan (Args &&... args) loan Get a sample from loaned shared memory and consctruct the data with the given arguments. void publish ( Sample < T, H > && sample) override publish Publishes the given sample and then releases its loan. cxx::expected< AllocationError > publishCopyOf (const T & val) publishCopyOf Copy the provided value into a loaned shared memory chunk and publish it. template <typename Callable ,typename... ArgTypes> cxx::expected< AllocationError > publishResultOf (Callable c, ArgTypes... args) publishResultOf Loan a sample from memory, execute the provided callable to write to it, then publish it. Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher & operator= (const BasePublisher & ) BasePublisher ( BasePublisher && rhs) BasePublisher & operator= ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/#detailed-description","text":"template < typename T , typename H = mepoo :: NoUserHeader > class iox :: popo :: Publisher ; The Publisher class for the publish-subscribe messaging pattern in iceoryx. Parameters : T user payload type H user header type Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/","text":"iox::popo::PublisherImpl \ud83d\udd17 The PublisherImpl class implements the typed publisher API. More... #include <iceoryx_posh/internal/popo/publisher_impl.hpp> Inherits from iox::popo::BasePublisher<> , iox::popo::PublisherInterface< T, mepoo::NoUserHeader > Public Functions \ud83d\udd17 Name PublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) PublisherImpl (const PublisherImpl & other) PublisherImpl & operator= (const PublisherImpl & ) PublisherImpl ( PublisherImpl && rhs) PublisherImpl & operator= ( PublisherImpl && rhs) virtual ~PublisherImpl () =default template <typename... Args> cxx::expected< Sample < T, H >, AllocationError > loan (Args &&... args) loan Get a sample from loaned shared memory and consctruct the data with the given arguments. void publish ( Sample < T, H > && sample) override publish Publishes the given sample and then releases its loan. cxx::expected< AllocationError > publishCopyOf (const T & val) publishCopyOf Copy the provided value into a loaned shared memory chunk and publish it. template <typename Callable ,typename... ArgTypes> cxx::expected< AllocationError > publishResultOf (Callable c, ArgTypes... args) publishResultOf Loan a sample from memory, execute the provided callable to write to it, then publish it. Additional inherited members \ud83d\udd17 Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port Detailed Description \ud83d\udd17 template < typename T , typename H = mepoo :: NoUserHeader , typename BasePublisherType = BasePublisher <>> class iox :: popo :: PublisherImpl ; The PublisherImpl class implements the typed publisher API. Note : Not intended for public usage! Use the [Publisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/) instead! Public Functions Documentation \ud83d\udd17 function PublisherImpl \ud83d\udd17 explicit PublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions () ) function PublisherImpl \ud83d\udd17 PublisherImpl ( const PublisherImpl & other ) function operator= \ud83d\udd17 PublisherImpl & operator = ( const PublisherImpl & ) function PublisherImpl \ud83d\udd17 PublisherImpl ( PublisherImpl && rhs ) function operator= \ud83d\udd17 PublisherImpl & operator = ( PublisherImpl && rhs ) function ~PublisherImpl \ud83d\udd17 virtual ~ PublisherImpl () = default function loan \ud83d\udd17 template < typename ... Args > cxx :: expected < Sample < T , H > , AllocationError > loan ( Args && ... args ) loan Get a sample from loaned shared memory and consctruct the data with the given arguments. Parameters : args Arguments used to construct the data. Return : An instance of the sample that resides in shared memory or an error if unable ot allocate memory to loan. The loaned sample is automatically released when it goes out of scope. function publish \ud83d\udd17 void publish ( Sample < T , H > && sample ) override publish Publishes the given sample and then releases its loan. Parameters : sample The sample to publish. function publishCopyOf \ud83d\udd17 cxx :: expected < AllocationError > publishCopyOf ( const T & val ) publishCopyOf Copy the provided value into a loaned shared memory chunk and publish it. Parameters : val Value to copy. Return : Error if unable to allocate memory to loan. function publishResultOf \ud83d\udd17 template < typename Callable , typename ... ArgTypes > cxx :: expected < AllocationError > publishResultOf ( Callable c , ArgTypes ... args ) publishResultOf Loan a sample from memory, execute the provided callable to write to it, then publish it. Parameters : c Callable with the signature void(T , ArgTypes...) that write's it's result to T . args The arguments of the callable. Return : Error if unable to allocate memory to loan. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#ioxpopopublisherimpl","text":"The PublisherImpl class implements the typed publisher API. More... #include <iceoryx_posh/internal/popo/publisher_impl.hpp> Inherits from iox::popo::BasePublisher<> , iox::popo::PublisherInterface< T, mepoo::NoUserHeader >","title":"iox::popo::PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#public-functions","text":"Name PublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) PublisherImpl (const PublisherImpl & other) PublisherImpl & operator= (const PublisherImpl & ) PublisherImpl ( PublisherImpl && rhs) PublisherImpl & operator= ( PublisherImpl && rhs) virtual ~PublisherImpl () =default template <typename... Args> cxx::expected< Sample < T, H >, AllocationError > loan (Args &&... args) loan Get a sample from loaned shared memory and consctruct the data with the given arguments. void publish ( Sample < T, H > && sample) override publish Publishes the given sample and then releases its loan. cxx::expected< AllocationError > publishCopyOf (const T & val) publishCopyOf Copy the provided value into a loaned shared memory chunk and publish it. template <typename Callable ,typename... ArgTypes> cxx::expected< AllocationError > publishResultOf (Callable c, ArgTypes... args) publishResultOf Loan a sample from memory, execute the provided callable to write to it, then publish it.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#additional-inherited-members","text":"Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#detailed-description","text":"template < typename T , typename H = mepoo :: NoUserHeader , typename BasePublisherType = BasePublisher <>> class iox :: popo :: PublisherImpl ; The PublisherImpl class implements the typed publisher API. Note : Not intended for public usage! Use the [Publisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Publisher/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publisherimpl","text":"explicit PublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions () )","title":"function PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publisherimpl_1","text":"PublisherImpl ( const PublisherImpl & other )","title":"function PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-operator","text":"PublisherImpl & operator = ( const PublisherImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publisherimpl_2","text":"PublisherImpl ( PublisherImpl && rhs )","title":"function PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-operator_1","text":"PublisherImpl & operator = ( PublisherImpl && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publisherimpl_3","text":"virtual ~ PublisherImpl () = default","title":"function ~PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-loan","text":"template < typename ... Args > cxx :: expected < Sample < T , H > , AllocationError > loan ( Args && ... args ) loan Get a sample from loaned shared memory and consctruct the data with the given arguments. Parameters : args Arguments used to construct the data. Return : An instance of the sample that resides in shared memory or an error if unable ot allocate memory to loan. The loaned sample is automatically released when it goes out of scope.","title":"function loan"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publish","text":"void publish ( Sample < T , H > && sample ) override publish Publishes the given sample and then releases its loan. Parameters : sample The sample to publish.","title":"function publish"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publishcopyof","text":"cxx :: expected < AllocationError > publishCopyOf ( const T & val ) publishCopyOf Copy the provided value into a loaned shared memory chunk and publish it. Parameters : val Value to copy. Return : Error if unable to allocate memory to loan.","title":"function publishCopyOf"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherImpl/#function-publishresultof","text":"template < typename Callable , typename ... ArgTypes > cxx :: expected < AllocationError > publishResultOf ( Callable c , ArgTypes ... args ) publishResultOf Loan a sample from memory, execute the provided callable to write to it, then publish it. Parameters : c Callable with the signature void(T , ArgTypes...) that write's it's result to T . args The arguments of the callable. Return : Error if unable to allocate memory to loan. Updated on 18 December 2023 at 13:11:43 CET","title":"function publishResultOf"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherInterface/","text":"iox::popo::PublisherInterface \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename T , typename H > class iox :: popo :: PublisherInterface ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::PublisherInterface"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherInterface/#ioxpopopublisherinterface","text":"More...","title":"iox::popo::PublisherInterface"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1PublisherInterface/#detailed-description","text":"template < typename T , typename H > class iox :: popo :: PublisherInterface ; Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/","text":"iox::popo::Request \ud83d\udd17 The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. More... #include <iceoryx_posh/popo/request.hpp> Inherits from SmartChunk< RpcInterface< Request< T >, ClientSendError >, T, cxx::add_const_conditionally_t< RequestHeader, T > > Public Functions \ud83d\udd17 Name template <typename S =T,typename =ForClientOnly > cxx::expected< ClientSendError > send () Sends the request via the client from which it was loaned and automatically release ownership to it. cxx::add_const_conditionally_t< RequestHeader , T > & getRequestHeader () Retrieve the request-header of the underlying memory chunk loaned to the sample. const RequestHeader & getRequestHeader () const Retrieve the request-header of the underlying memory chunk loaned to the sample. Friends \ud83d\udd17 Name class ClientImpl class ServerImpl Detailed Description \ud83d\udd17 template < typename T > class iox :: popo :: Request ; The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. Public Functions Documentation \ud83d\udd17 function send \ud83d\udd17 template < typename S = T , typename = ForClientOnly < S , T >> cxx :: expected < ClientSendError > send () Sends the request via the client from which it was loaned and automatically release ownership to it. Only available for client (non-const type T) function getRequestHeader \ud83d\udd17 cxx :: add_const_conditionally_t < RequestHeader , T > & getRequestHeader () Retrieve the request-header of the underlying memory chunk loaned to the sample. Return : The request-header of the underlying memory chunk. function getRequestHeader \ud83d\udd17 const RequestHeader & getRequestHeader () const Retrieve the request-header of the underlying memory chunk loaned to the sample. Return : The request-header of the underlying memory chunk. Friends \ud83d\udd17 friend ClientImpl \ud83d\udd17 friend class ClientImpl ; friend ServerImpl \ud83d\udd17 friend class ServerImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Request"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#ioxpoporequest","text":"The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. More... #include <iceoryx_posh/popo/request.hpp> Inherits from SmartChunk< RpcInterface< Request< T >, ClientSendError >, T, cxx::add_const_conditionally_t< RequestHeader, T > >","title":"iox::popo::Request"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#public-functions","text":"Name template <typename S =T,typename =ForClientOnly > cxx::expected< ClientSendError > send () Sends the request via the client from which it was loaned and automatically release ownership to it. cxx::add_const_conditionally_t< RequestHeader , T > & getRequestHeader () Retrieve the request-header of the underlying memory chunk loaned to the sample. const RequestHeader & getRequestHeader () const Retrieve the request-header of the underlying memory chunk loaned to the sample.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friends","text":"Name class ClientImpl class ServerImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#detailed-description","text":"template < typename T > class iox :: popo :: Request ; The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#function-send","text":"template < typename S = T , typename = ForClientOnly < S , T >> cxx :: expected < ClientSendError > send () Sends the request via the client from which it was loaned and automatically release ownership to it. Only available for client (non-const type T)","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#function-getrequestheader","text":"cxx :: add_const_conditionally_t < RequestHeader , T > & getRequestHeader () Retrieve the request-header of the underlying memory chunk loaned to the sample. Return : The request-header of the underlying memory chunk.","title":"function getRequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#function-getrequestheader_1","text":"const RequestHeader & getRequestHeader () const Retrieve the request-header of the underlying memory chunk loaned to the sample. Return : The request-header of the underlying memory chunk.","title":"function getRequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friend-clientimpl","text":"friend class ClientImpl ;","title":"friend ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Request/#friend-serverimpl","text":"friend class ServerImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/","text":"iox::popo::RequestHeader \ud83d\udd17 Inherits from iox::popo::RpcBaseHeader Public Functions \ud83d\udd17 Name RequestHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex) Constructs and initializes a RpcBaseHeader . RequestHeader (const RequestHeader & other) RequestHeader & operator= (const RequestHeader & ) RequestHeader ( RequestHeader && rhs) =default RequestHeader & operator= ( RequestHeader && rhs) =default ~RequestHeader () =default void setSequenceId (const int64_t sequenceId) Sets the sequence ID which is used to match a response to a request. RequestHeader * fromPayload (void *const payload) const RequestHeader * fromPayload (const void *const payload) Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::RpcBaseHeader Name RpcBaseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion) Constructs and initializes a RpcBaseHeader . RpcBaseHeader (const RpcBaseHeader & other) RpcBaseHeader ( RpcBaseHeader && rhs) =default ~RpcBaseHeader () =default uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. int64_t getSequenceId () const mepoo::ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. const mepoo::ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. void * getUserPayload () Get the pointer to the user-payload. const void * getUserPayload () const Get the const pointer to the user-payload. Public Attributes inherited from iox::popo::RpcBaseHeader Name constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX constexpr int64_t START_SEQUENCE_ID Protected Attributes inherited from iox::popo::RpcBaseHeader Name uint8_t m_rpcHeaderVersion uint32_t m_lastKnownClientQueueIndex cxx::UniqueId m_uniqueClientQueueId int64_t m_sequenceId Friends inherited from iox::popo::RpcBaseHeader Name class ServerPortUser Public Functions Documentation \ud83d\udd17 function RequestHeader \ud83d\udd17 explicit RequestHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex ) Constructs and initializes a RpcBaseHeader . Parameters : uniqueClientQueueId is the cxx::UniqueId of the client queue to which the response shall be delivered lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup function RequestHeader \ud83d\udd17 RequestHeader ( const RequestHeader & other ) function operator= \ud83d\udd17 RequestHeader & operator = ( const RequestHeader & ) function RequestHeader \ud83d\udd17 RequestHeader ( RequestHeader && rhs ) = default function operator= \ud83d\udd17 RequestHeader & operator = ( RequestHeader && rhs ) = default function ~RequestHeader \ud83d\udd17 ~ RequestHeader () = default function setSequenceId \ud83d\udd17 void setSequenceId ( const int64_t sequenceId ) Sets the sequence ID which is used to match a response to a request. Parameters : sequenceId is a consecutive number set by the user Note : The user has to set this manually if multiple requests are sent before a response is read since a server might drop a requests or process the requests out of order and therefore the responses might also be out of order function fromPayload \ud83d\udd17 static RequestHeader * fromPayload ( void * const payload ) function fromPayload \ud83d\udd17 static const RequestHeader * fromPayload ( const void * const payload ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#ioxpoporequestheader","text":"Inherits from iox::popo::RpcBaseHeader","title":"iox::popo::RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#public-functions","text":"Name RequestHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex) Constructs and initializes a RpcBaseHeader . RequestHeader (const RequestHeader & other) RequestHeader & operator= (const RequestHeader & ) RequestHeader ( RequestHeader && rhs) =default RequestHeader & operator= ( RequestHeader && rhs) =default ~RequestHeader () =default void setSequenceId (const int64_t sequenceId) Sets the sequence ID which is used to match a response to a request. RequestHeader * fromPayload (void *const payload) const RequestHeader * fromPayload (const void *const payload)","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#additional-inherited-members","text":"Public Functions inherited from iox::popo::RpcBaseHeader Name RpcBaseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion) Constructs and initializes a RpcBaseHeader . RpcBaseHeader (const RpcBaseHeader & other) RpcBaseHeader ( RpcBaseHeader && rhs) =default ~RpcBaseHeader () =default uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. int64_t getSequenceId () const mepoo::ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. const mepoo::ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. void * getUserPayload () Get the pointer to the user-payload. const void * getUserPayload () const Get the const pointer to the user-payload. Public Attributes inherited from iox::popo::RpcBaseHeader Name constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX constexpr int64_t START_SEQUENCE_ID Protected Attributes inherited from iox::popo::RpcBaseHeader Name uint8_t m_rpcHeaderVersion uint32_t m_lastKnownClientQueueIndex cxx::UniqueId m_uniqueClientQueueId int64_t m_sequenceId Friends inherited from iox::popo::RpcBaseHeader Name class ServerPortUser","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader","text":"explicit RequestHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex ) Constructs and initializes a RpcBaseHeader . Parameters : uniqueClientQueueId is the cxx::UniqueId of the client queue to which the response shall be delivered lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup","title":"function RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader_1","text":"RequestHeader ( const RequestHeader & other )","title":"function RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-operator","text":"RequestHeader & operator = ( const RequestHeader & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader_2","text":"RequestHeader ( RequestHeader && rhs ) = default","title":"function RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-operator_1","text":"RequestHeader & operator = ( RequestHeader && rhs ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-requestheader_3","text":"~ RequestHeader () = default","title":"function ~RequestHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-setsequenceid","text":"void setSequenceId ( const int64_t sequenceId ) Sets the sequence ID which is used to match a response to a request. Parameters : sequenceId is a consecutive number set by the user Note : The user has to set this manually if multiple requests are sent before a response is read since a server might drop a requests or process the requests out of order and therefore the responses might also be out of order","title":"function setSequenceId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-frompayload","text":"static RequestHeader * fromPayload ( void * const payload )","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RequestHeader/#function-frompayload_1","text":"static const RequestHeader * fromPayload ( const void * const payload ) Updated on 18 December 2023 at 13:11:43 CET","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/","text":"iox::popo::Response \ud83d\udd17 The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. More... #include <iceoryx_posh/popo/response.hpp> Inherits from SmartChunk< RpcInterface< Response< T >, ServerSendError >, T, cxx::add_const_conditionally_t< ResponseHeader, T > > Public Functions \ud83d\udd17 Name template <typename S =T,typename =ForServerOnly > cxx::expected< ServerSendError > send () Sends the response via the server from which it was loaned and automatically release ownership to it. cxx::add_const_conditionally_t< ResponseHeader , T > & getResponseHeader () Retrieve the response-header of the underlying memory chunk loaned to the sample. const ResponseHeader & getResponseHeader () const Retrieve the response-header of the underlying memory chunk loaned to the sample. Friends \ud83d\udd17 Name class ClientImpl class ServerImpl Detailed Description \ud83d\udd17 template < typename T > class iox :: popo :: Response ; The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. Public Functions Documentation \ud83d\udd17 function send \ud83d\udd17 template < typename S = T , typename = ForServerOnly < S , T >> cxx :: expected < ServerSendError > send () Sends the response via the server from which it was loaned and automatically release ownership to it. Only available for server (non-const type T) function getResponseHeader \ud83d\udd17 cxx :: add_const_conditionally_t < ResponseHeader , T > & getResponseHeader () Retrieve the response-header of the underlying memory chunk loaned to the sample. Return : The response-header of the underlying memory chunk. function getResponseHeader \ud83d\udd17 const ResponseHeader & getResponseHeader () const Retrieve the response-header of the underlying memory chunk loaned to the sample. Return : The response-header of the underlying memory chunk. Friends \ud83d\udd17 friend ClientImpl \ud83d\udd17 friend class ClientImpl ; friend ServerImpl \ud83d\udd17 friend class ServerImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Response"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#ioxpoporesponse","text":"The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. More... #include <iceoryx_posh/popo/response.hpp> Inherits from SmartChunk< RpcInterface< Response< T >, ServerSendError >, T, cxx::add_const_conditionally_t< ResponseHeader, T > >","title":"iox::popo::Response"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#public-functions","text":"Name template <typename S =T,typename =ForServerOnly > cxx::expected< ServerSendError > send () Sends the response via the server from which it was loaned and automatically release ownership to it. cxx::add_const_conditionally_t< ResponseHeader , T > & getResponseHeader () Retrieve the response-header of the underlying memory chunk loaned to the sample. const ResponseHeader & getResponseHeader () const Retrieve the response-header of the underlying memory chunk loaned to the sample.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friends","text":"Name class ClientImpl class ServerImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#detailed-description","text":"template < typename T > class iox :: popo :: Response ; The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#function-send","text":"template < typename S = T , typename = ForServerOnly < S , T >> cxx :: expected < ServerSendError > send () Sends the response via the server from which it was loaned and automatically release ownership to it. Only available for server (non-const type T)","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#function-getresponseheader","text":"cxx :: add_const_conditionally_t < ResponseHeader , T > & getResponseHeader () Retrieve the response-header of the underlying memory chunk loaned to the sample. Return : The response-header of the underlying memory chunk.","title":"function getResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#function-getresponseheader_1","text":"const ResponseHeader & getResponseHeader () const Retrieve the response-header of the underlying memory chunk loaned to the sample. Return : The response-header of the underlying memory chunk.","title":"function getResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friend-clientimpl","text":"friend class ClientImpl ;","title":"friend ClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Response/#friend-serverimpl","text":"friend class ServerImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/","text":"iox::popo::ResponseHeader \ud83d\udd17 Inherits from iox::popo::RpcBaseHeader Public Functions \ud83d\udd17 Name ResponseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId) Constructs and initializes a RpcBaseHeader . ResponseHeader (const ResponseHeader & other) ResponseHeader & operator= (const ResponseHeader & ) ResponseHeader ( ResponseHeader && rhs) =default ResponseHeader & operator= ( ResponseHeader && rhs) =default ~ResponseHeader () =default void setServerError () Sets the server error flag. bool hasServerError () const Obtains the server error flag. ResponseHeader * fromPayload (void *const payload) const ResponseHeader * fromPayload (const void *const payload) Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::RpcBaseHeader Name RpcBaseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion) Constructs and initializes a RpcBaseHeader . RpcBaseHeader (const RpcBaseHeader & other) RpcBaseHeader ( RpcBaseHeader && rhs) =default ~RpcBaseHeader () =default uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. int64_t getSequenceId () const mepoo::ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. const mepoo::ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. void * getUserPayload () Get the pointer to the user-payload. const void * getUserPayload () const Get the const pointer to the user-payload. Public Attributes inherited from iox::popo::RpcBaseHeader Name constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX constexpr int64_t START_SEQUENCE_ID Protected Attributes inherited from iox::popo::RpcBaseHeader Name uint8_t m_rpcHeaderVersion uint32_t m_lastKnownClientQueueIndex cxx::UniqueId m_uniqueClientQueueId int64_t m_sequenceId Friends inherited from iox::popo::RpcBaseHeader Name class ServerPortUser Public Functions Documentation \ud83d\udd17 function ResponseHeader \ud83d\udd17 explicit ResponseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId ) Constructs and initializes a RpcBaseHeader . Parameters : uniqueClientQueueId is the cxx::UniqueId of the client queue to which the response shall be delivered lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup sequenceId is a custom ID to map a response to a request function ResponseHeader \ud83d\udd17 ResponseHeader ( const ResponseHeader & other ) function operator= \ud83d\udd17 ResponseHeader & operator = ( const ResponseHeader & ) function ResponseHeader \ud83d\udd17 ResponseHeader ( ResponseHeader && rhs ) = default function operator= \ud83d\udd17 ResponseHeader & operator = ( ResponseHeader && rhs ) = default function ~ResponseHeader \ud83d\udd17 ~ ResponseHeader () = default function setServerError \ud83d\udd17 void setServerError () Sets the server error flag. function hasServerError \ud83d\udd17 bool hasServerError () const Obtains the server error flag. Return : true if there is an error, false otherwise function fromPayload \ud83d\udd17 static ResponseHeader * fromPayload ( void * const payload ) function fromPayload \ud83d\udd17 static const ResponseHeader * fromPayload ( const void * const payload ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#ioxpoporesponseheader","text":"Inherits from iox::popo::RpcBaseHeader","title":"iox::popo::ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#public-functions","text":"Name ResponseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId) Constructs and initializes a RpcBaseHeader . ResponseHeader (const ResponseHeader & other) ResponseHeader & operator= (const ResponseHeader & ) ResponseHeader ( ResponseHeader && rhs) =default ResponseHeader & operator= ( ResponseHeader && rhs) =default ~ResponseHeader () =default void setServerError () Sets the server error flag. bool hasServerError () const Obtains the server error flag. ResponseHeader * fromPayload (void *const payload) const ResponseHeader * fromPayload (const void *const payload)","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#additional-inherited-members","text":"Public Functions inherited from iox::popo::RpcBaseHeader Name RpcBaseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion) Constructs and initializes a RpcBaseHeader . RpcBaseHeader (const RpcBaseHeader & other) RpcBaseHeader ( RpcBaseHeader && rhs) =default ~RpcBaseHeader () =default uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. int64_t getSequenceId () const mepoo::ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. const mepoo::ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. void * getUserPayload () Get the pointer to the user-payload. const void * getUserPayload () const Get the const pointer to the user-payload. Public Attributes inherited from iox::popo::RpcBaseHeader Name constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX constexpr int64_t START_SEQUENCE_ID Protected Attributes inherited from iox::popo::RpcBaseHeader Name uint8_t m_rpcHeaderVersion uint32_t m_lastKnownClientQueueIndex cxx::UniqueId m_uniqueClientQueueId int64_t m_sequenceId Friends inherited from iox::popo::RpcBaseHeader Name class ServerPortUser","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader","text":"explicit ResponseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId ) Constructs and initializes a RpcBaseHeader . Parameters : uniqueClientQueueId is the cxx::UniqueId of the client queue to which the response shall be delivered lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup sequenceId is a custom ID to map a response to a request","title":"function ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader_1","text":"ResponseHeader ( const ResponseHeader & other )","title":"function ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-operator","text":"ResponseHeader & operator = ( const ResponseHeader & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader_2","text":"ResponseHeader ( ResponseHeader && rhs ) = default","title":"function ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-operator_1","text":"ResponseHeader & operator = ( ResponseHeader && rhs ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-responseheader_3","text":"~ ResponseHeader () = default","title":"function ~ResponseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-setservererror","text":"void setServerError () Sets the server error flag.","title":"function setServerError"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-hasservererror","text":"bool hasServerError () const Obtains the server error flag. Return : true if there is an error, false otherwise","title":"function hasServerError"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-frompayload","text":"static ResponseHeader * fromPayload ( void * const payload )","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ResponseHeader/#function-frompayload_1","text":"static const ResponseHeader * fromPayload ( const void * const payload ) Updated on 18 December 2023 at 13:11:43 CET","title":"function fromPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/","text":"iox::popo::RpcBaseHeader \ud83d\udd17 Inherited by iox::popo::RequestHeader , iox::popo::ResponseHeader Public Functions \ud83d\udd17 Name RpcBaseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion) Constructs and initializes a RpcBaseHeader . RpcBaseHeader (const RpcBaseHeader & other) RpcBaseHeader & operator= (const RpcBaseHeader & ) RpcBaseHeader ( RpcBaseHeader && rhs) =default RpcBaseHeader & operator= ( RpcBaseHeader && rhs) =default ~RpcBaseHeader () =default uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. int64_t getSequenceId () const mepoo::ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. const mepoo::ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. void * getUserPayload () Get the pointer to the user-payload. const void * getUserPayload () const Get the const pointer to the user-payload. Public Attributes \ud83d\udd17 Name constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX constexpr int64_t START_SEQUENCE_ID Protected Attributes \ud83d\udd17 Name uint8_t m_rpcHeaderVersion uint32_t m_lastKnownClientQueueIndex cxx::UniqueId m_uniqueClientQueueId int64_t m_sequenceId Friends \ud83d\udd17 Name class ServerPortUser Public Functions Documentation \ud83d\udd17 function RpcBaseHeader \ud83d\udd17 explicit RpcBaseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId , const uint8_t rpcHeaderVersion ) Constructs and initializes a RpcBaseHeader . Parameters : uniqueClientQueueId is the cxx::UniqueId of the client queue where the response shall be delivered lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup sequenceId is a custom ID to map a response to a request rpcHeaderVersion is set by RequestHeader/ResponseHeader and should be RPC_HEADER_VERSION function RpcBaseHeader \ud83d\udd17 RpcBaseHeader ( const RpcBaseHeader & other ) function operator= \ud83d\udd17 RpcBaseHeader & operator = ( const RpcBaseHeader & ) function RpcBaseHeader \ud83d\udd17 RpcBaseHeader ( RpcBaseHeader && rhs ) = default function operator= \ud83d\udd17 RpcBaseHeader & operator = ( RpcBaseHeader && rhs ) = default function ~RpcBaseHeader \ud83d\udd17 ~ RpcBaseHeader () = default function getRpcHeaderVersion \ud83d\udd17 uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. Return : the RpcBaseHeader version function getSequenceId \ud83d\udd17 int64_t getSequenceId () const Return : the sequenceId of the RPC message @briet Obtains the sequence ID of the RPC message function getChunkHeader \ud83d\udd17 mepoo :: ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. Return : the pointer to the ChunkHeader function getChunkHeader \ud83d\udd17 const mepoo :: ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. Return : the const pointer to the ChunkHeader function getUserPayload \ud83d\udd17 void * getUserPayload () Get the pointer to the user-payload. Return : the pointer to the user-payload function getUserPayload \ud83d\udd17 const void * getUserPayload () const Get the const pointer to the user-payload. Return : the const pointer to the user-payload Public Attributes Documentation \ud83d\udd17 variable RPC_HEADER_VERSION \ud83d\udd17 static constexpr uint8_t RPC_HEADER_VERSION { 1U }; From the 2.0 release onward, this must be incremented for each incompatible change, e.g. data width of members changes members are rearranged semantic meaning of a member changes in any of RpcBaseHeader , RequestHeader or ResponseHeader! variable UNKNOWN_CLIENT_QUEUE_INDEX \ud83d\udd17 static constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX { std :: numeric_limits < uint32_t >:: max ()}; variable START_SEQUENCE_ID \ud83d\udd17 static constexpr int64_t START_SEQUENCE_ID { 0 }; Protected Attributes Documentation \ud83d\udd17 variable m_rpcHeaderVersion \ud83d\udd17 uint8_t m_rpcHeaderVersion {[ RPC_HEADER_VERSION ]( / v2 .0.5 / API - reference / posh / Classes / classiox_1_1popo_1_1RpcBaseHeader / # variable - rpc_header_version )}; variable m_lastKnownClientQueueIndex \ud83d\udd17 uint32_t m_lastKnownClientQueueIndex { UNKNOWN_CLIENT_QUEUE_INDEX }; variable m_uniqueClientQueueId \ud83d\udd17 cxx :: UniqueId m_uniqueClientQueueId ; variable m_sequenceId \ud83d\udd17 int64_t m_sequenceId { 0 }; Friends \ud83d\udd17 friend ServerPortUser \ud83d\udd17 friend class ServerPortUser ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#ioxpoporpcbaseheader","text":"Inherited by iox::popo::RequestHeader , iox::popo::ResponseHeader","title":"iox::popo::RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-functions","text":"Name RpcBaseHeader (const cxx::UniqueId & uniqueClientQueueId, const uint32_t lastKnownClientQueueIndex, const int64_t sequenceId, const uint8_t rpcHeaderVersion) Constructs and initializes a RpcBaseHeader . RpcBaseHeader (const RpcBaseHeader & other) RpcBaseHeader & operator= (const RpcBaseHeader & ) RpcBaseHeader ( RpcBaseHeader && rhs) =default RpcBaseHeader & operator= ( RpcBaseHeader && rhs) =default ~RpcBaseHeader () =default uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. int64_t getSequenceId () const mepoo::ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. const mepoo::ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. void * getUserPayload () Get the pointer to the user-payload. const void * getUserPayload () const Get the const pointer to the user-payload.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-attributes","text":"Name constexpr uint8_t RPC_HEADER_VERSION From the 2.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX constexpr int64_t START_SEQUENCE_ID","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#protected-attributes","text":"Name uint8_t m_rpcHeaderVersion uint32_t m_lastKnownClientQueueIndex cxx::UniqueId m_uniqueClientQueueId int64_t m_sequenceId","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#friends","text":"Name class ServerPortUser","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader","text":"explicit RpcBaseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId , const uint8_t rpcHeaderVersion ) Constructs and initializes a RpcBaseHeader . Parameters : uniqueClientQueueId is the cxx::UniqueId of the client queue where the response shall be delivered lastKnownClientQueueIndex is the last know index of the client queue in the ChunkDistributor for fast lookup sequenceId is a custom ID to map a response to a request rpcHeaderVersion is set by RequestHeader/ResponseHeader and should be RPC_HEADER_VERSION","title":"function RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader_1","text":"RpcBaseHeader ( const RpcBaseHeader & other )","title":"function RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-operator","text":"RpcBaseHeader & operator = ( const RpcBaseHeader & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader_2","text":"RpcBaseHeader ( RpcBaseHeader && rhs ) = default","title":"function RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-operator_1","text":"RpcBaseHeader & operator = ( RpcBaseHeader && rhs ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-rpcbaseheader_3","text":"~ RpcBaseHeader () = default","title":"function ~RpcBaseHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getrpcheaderversion","text":"uint8_t getRpcHeaderVersion () const The RpcBaseHeader version is used to detect incompatibilities for record&replay functionality. Return : the RpcBaseHeader version","title":"function getRpcHeaderVersion"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getsequenceid","text":"int64_t getSequenceId () const Return : the sequenceId of the RPC message @briet Obtains the sequence ID of the RPC message","title":"function getSequenceId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getchunkheader","text":"mepoo :: ChunkHeader * getChunkHeader () Get the pointer to the ChunkHeader. Return : the pointer to the ChunkHeader","title":"function getChunkHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getchunkheader_1","text":"const mepoo :: ChunkHeader * getChunkHeader () const Get the const pointer to the ChunkHeader. Return : the const pointer to the ChunkHeader","title":"function getChunkHeader"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getuserpayload","text":"void * getUserPayload () Get the pointer to the user-payload. Return : the pointer to the user-payload","title":"function getUserPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#function-getuserpayload_1","text":"const void * getUserPayload () const Get the const pointer to the user-payload. Return : the const pointer to the user-payload","title":"function getUserPayload"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-rpc_header_version","text":"static constexpr uint8_t RPC_HEADER_VERSION { 1U }; From the 2.0 release onward, this must be incremented for each incompatible change, e.g. data width of members changes members are rearranged semantic meaning of a member changes in any of RpcBaseHeader , RequestHeader or ResponseHeader!","title":"variable RPC_HEADER_VERSION"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-unknown_client_queue_index","text":"static constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX { std :: numeric_limits < uint32_t >:: max ()};","title":"variable UNKNOWN_CLIENT_QUEUE_INDEX"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-start_sequence_id","text":"static constexpr int64_t START_SEQUENCE_ID { 0 };","title":"variable START_SEQUENCE_ID"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_rpcheaderversion","text":"uint8_t m_rpcHeaderVersion {[ RPC_HEADER_VERSION ]( / v2 .0.5 / API - reference / posh / Classes / classiox_1_1popo_1_1RpcBaseHeader / # variable - rpc_header_version )};","title":"variable m_rpcHeaderVersion"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_lastknownclientqueueindex","text":"uint32_t m_lastKnownClientQueueIndex { UNKNOWN_CLIENT_QUEUE_INDEX };","title":"variable m_lastKnownClientQueueIndex"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_uniqueclientqueueid","text":"cxx :: UniqueId m_uniqueClientQueueId ;","title":"variable m_uniqueClientQueueId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#variable-m_sequenceid","text":"int64_t m_sequenceId { 0 };","title":"variable m_sequenceId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcBaseHeader/#friend-serverportuser","text":"friend class ServerPortUser ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend ServerPortUser"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcInterface/","text":"iox::popo::RpcInterface \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename RpcType , typename SendErrorEnum > class iox :: popo :: RpcInterface ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::RpcInterface"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcInterface/#ioxpoporpcinterface","text":"More...","title":"iox::popo::RpcInterface"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1RpcInterface/#detailed-description","text":"template < typename RpcType , typename SendErrorEnum > class iox :: popo :: RpcInterface ; Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/","text":"iox::popo::Sample \ud83d\udd17 The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. More... #include <iceoryx_posh/popo/sample.hpp> Inherits from SmartChunk< PublisherInterface< T, cxx::add_const_conditionally_t< mepoo::NoUserHeader, T > >, T, cxx::add_const_conditionally_t< mepoo::NoUserHeader, T > > Public Types \ud83d\udd17 Name template <typename T1 ,typename T2 > using typename BaseType::template ForProducerOnly< T1, T2 > ForPublisherOnly Public Functions \ud83d\udd17 Name template <typename S =T,typename =ForPublisherOnly > void publish () Publish the sample via the publisher from which it was loaned and automatically release ownership to it. Friends \ud83d\udd17 Name class PublisherImpl Detailed Description \ud83d\udd17 template < typename T , typename H = cxx :: add_const_conditionally_t < mepoo :: NoUserHeader , T >> class iox :: popo :: Sample ; The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. Public Types Documentation \ud83d\udd17 using ForPublisherOnly \ud83d\udd17 template < typename T1 , typename T2 > using iox :: popo :: Sample < T , H >:: ForPublisherOnly = typename BaseType :: template ForProducerOnly < T1 , T2 > ; Public Functions Documentation \ud83d\udd17 function publish \ud83d\udd17 template < typename S = T , typename = ForPublisherOnly < S , T >> void publish () Publish the sample via the publisher from which it was loaned and automatically release ownership to it. Only available for non-const type T. Friends \ud83d\udd17 friend PublisherImpl \ud83d\udd17 friend class PublisherImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Sample"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#ioxpoposample","text":"The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. More... #include <iceoryx_posh/popo/sample.hpp> Inherits from SmartChunk< PublisherInterface< T, cxx::add_const_conditionally_t< mepoo::NoUserHeader, T > >, T, cxx::add_const_conditionally_t< mepoo::NoUserHeader, T > >","title":"iox::popo::Sample"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-types","text":"Name template <typename T1 ,typename T2 > using typename BaseType::template ForProducerOnly< T1, T2 > ForPublisherOnly","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-functions","text":"Name template <typename S =T,typename =ForPublisherOnly > void publish () Publish the sample via the publisher from which it was loaned and automatically release ownership to it.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#friends","text":"Name class PublisherImpl","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#detailed-description","text":"template < typename T , typename H = cxx :: add_const_conditionally_t < mepoo :: NoUserHeader , T >> class iox :: popo :: Sample ; The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#using-forpublisheronly","text":"template < typename T1 , typename T2 > using iox :: popo :: Sample < T , H >:: ForPublisherOnly = typename BaseType :: template ForProducerOnly < T1 , T2 > ;","title":"using ForPublisherOnly"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#function-publish","text":"template < typename S = T , typename = ForPublisherOnly < S , T >> void publish () Publish the sample via the publisher from which it was loaned and automatically release ownership to it. Only available for non-const type T.","title":"function publish"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Sample/#friend-publisherimpl","text":"friend class PublisherImpl ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend PublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/","text":"iox::popo::Server \ud83d\udd17 The Server class for the request-response messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/server.hpp> Inherits from iox::popo::ServerImpl< Req, Res > , iox::popo::BaseServer<> , iox::popo::RpcInterface< Response< Res >, ServerSendError > Public Functions \ud83d\udd17 Name virtual ~Server () Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::ServerImpl< Req, Res > Name ServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) Constructor for a sserver. virtual ~ServerImpl () ServerImpl (const ServerImpl & ) ServerImpl ( ServerImpl && ) ServerImpl & operator= (const ServerImpl & ) ServerImpl & operator= ( ServerImpl && ) cxx::expected< Request < const Req >, ServerRequestResult > take () Take the Request from the top of the receive queue. template <typename... Args> cxx::expected< Response < Res >, AllocationError > loan (const Request < const Req > & request, Args &&... args) Get a Response from loaned shared memory and construct the data with the given arguments. cxx::expected< ServerSendError > send ( Response < Res > && response) override Sends the given Response and then releases its loan. Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer & operator= (const BaseServer & ) BaseServer ( BaseServer && rhs) BaseServer & operator= ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename Req , typename Res > class iox :: popo :: Server ; The Server class for the request-response messaging pattern in iceoryx. Parameters : Req type of request data Res type of response data Public Functions Documentation \ud83d\udd17 function ~Server \ud83d\udd17 inline virtual ~ Server () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Server"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#ioxpoposerver","text":"The Server class for the request-response messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/server.hpp> Inherits from iox::popo::ServerImpl< Req, Res > , iox::popo::BaseServer<> , iox::popo::RpcInterface< Response< Res >, ServerSendError >","title":"iox::popo::Server"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#public-functions","text":"Name virtual ~Server ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#additional-inherited-members","text":"Public Functions inherited from iox::popo::ServerImpl< Req, Res > Name ServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) Constructor for a sserver. virtual ~ServerImpl () ServerImpl (const ServerImpl & ) ServerImpl ( ServerImpl && ) ServerImpl & operator= (const ServerImpl & ) ServerImpl & operator= ( ServerImpl && ) cxx::expected< Request < const Req >, ServerRequestResult > take () Take the Request from the top of the receive queue. template <typename... Args> cxx::expected< Response < Res >, AllocationError > loan (const Request < const Req > & request, Args &&... args) Get a Response from loaned shared memory and construct the data with the given arguments. cxx::expected< ServerSendError > send ( Response < Res > && response) override Sends the given Response and then releases its loan. Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer & operator= (const BaseServer & ) BaseServer ( BaseServer && rhs) BaseServer & operator= ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#detailed-description","text":"template < typename Req , typename Res > class iox :: popo :: Server ; The Server class for the request-response messaging pattern in iceoryx. Parameters : Req type of request data Res type of response data","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Server/#function-server","text":"inline virtual ~ Server () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~Server"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/","text":"iox::popo::ServerImpl \ud83d\udd17 The ServerImpl class implements the typed server API. More... #include <iceoryx_posh/internal/popo/server_impl.hpp> Inherits from iox::popo::BaseServer<> , iox::popo::RpcInterface< Response< Res >, ServerSendError > Public Functions \ud83d\udd17 Name ServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) Constructor for a sserver. virtual ~ServerImpl () ServerImpl (const ServerImpl & ) ServerImpl ( ServerImpl && ) ServerImpl & operator= (const ServerImpl & ) ServerImpl & operator= ( ServerImpl && ) cxx::expected< Request < const Req >, ServerRequestResult > take () Take the Request from the top of the receive queue. template <typename... Args> cxx::expected< Response < Res >, AllocationError > loan (const Request < const Req > & request, Args &&... args) Get a Response from loaned shared memory and construct the data with the given arguments. cxx::expected< ServerSendError > send ( Response < Res > && response) override Sends the given Response and then releases its loan. Additional inherited members \ud83d\udd17 Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename Req , typename Res , typename BaseServerT = BaseServer <>> class iox :: popo :: ServerImpl ; The ServerImpl class implements the typed server API. Note : Not intended for public usage! Use the [Server](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Server/) instead! Public Functions Documentation \ud83d\udd17 function ServerImpl \ud83d\udd17 explicit ServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {} ) Constructor for a sserver. Parameters : service is the ServiceDescription for the new server serverOptions like the queue capacity and queue full policy by a server function ~ServerImpl \ud83d\udd17 virtual ~ ServerImpl () function ServerImpl \ud83d\udd17 ServerImpl ( const ServerImpl & ) function ServerImpl \ud83d\udd17 ServerImpl ( ServerImpl && ) function operator= \ud83d\udd17 ServerImpl & operator = ( const ServerImpl & ) function operator= \ud83d\udd17 ServerImpl & operator = ( ServerImpl && ) function take \ud83d\udd17 cxx :: expected < Request < const Req > , ServerRequestResult > take () Take the Request from the top of the receive queue. Return : Either a Request or a ServerRequestResult. The Request takes care of the cleanup. Don't store the raw pointer to the content of the Request , but always the whole Request . function loan \ud83d\udd17 template < typename ... Args > cxx :: expected < Response < Res > , AllocationError > loan ( const Request < const Req > & request , Args && ... args ) Get a Response from loaned shared memory and construct the data with the given arguments. Parameters : request The request to which the Response belongs to, to determine where to send the response args Arguments used to construct the data. Return : An instance of the Response that resides in shared memory or an error if unable to allocate memory to loan. The loaned Response is automatically released when it goes out of scope. function send \ud83d\udd17 cxx :: expected < ServerSendError > send ( Response < Res > && response ) override Sends the given Response and then releases its loan. Parameters : response to send. Return : Error if sending was not successful Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#ioxpoposerverimpl","text":"The ServerImpl class implements the typed server API. More... #include <iceoryx_posh/internal/popo/server_impl.hpp> Inherits from iox::popo::BaseServer<> , iox::popo::RpcInterface< Response< Res >, ServerSendError >","title":"iox::popo::ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#public-functions","text":"Name ServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) Constructor for a sserver. virtual ~ServerImpl () ServerImpl (const ServerImpl & ) ServerImpl ( ServerImpl && ) ServerImpl & operator= (const ServerImpl & ) ServerImpl & operator= ( ServerImpl && ) cxx::expected< Request < const Req >, ServerRequestResult > take () Take the Request from the top of the receive queue. template <typename... Args> cxx::expected< Response < Res >, AllocationError > loan (const Request < const Req > & request, Args &&... args) Get a Response from loaned shared memory and construct the data with the given arguments. cxx::expected< ServerSendError > send ( Response < Res > && response) override Sends the given Response and then releases its loan.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#additional-inherited-members","text":"Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#detailed-description","text":"template < typename Req , typename Res , typename BaseServerT = BaseServer <>> class iox :: popo :: ServerImpl ; The ServerImpl class implements the typed server API. Note : Not intended for public usage! Use the [Server](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Server/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-serverimpl","text":"explicit ServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {} ) Constructor for a sserver. Parameters : service is the ServiceDescription for the new server serverOptions like the queue capacity and queue full policy by a server","title":"function ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-serverimpl_1","text":"virtual ~ ServerImpl ()","title":"function ~ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-serverimpl_2","text":"ServerImpl ( const ServerImpl & )","title":"function ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-serverimpl_3","text":"ServerImpl ( ServerImpl && )","title":"function ServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-operator","text":"ServerImpl & operator = ( const ServerImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-operator_1","text":"ServerImpl & operator = ( ServerImpl && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-take","text":"cxx :: expected < Request < const Req > , ServerRequestResult > take () Take the Request from the top of the receive queue. Return : Either a Request or a ServerRequestResult. The Request takes care of the cleanup. Don't store the raw pointer to the content of the Request , but always the whole Request .","title":"function take"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-loan","text":"template < typename ... Args > cxx :: expected < Response < Res > , AllocationError > loan ( const Request < const Req > & request , Args && ... args ) Get a Response from loaned shared memory and construct the data with the given arguments. Parameters : request The request to which the Response belongs to, to determine where to send the response args Arguments used to construct the data. Return : An instance of the Response that resides in shared memory or an error if unable to allocate memory to loan. The loaned Response is automatically released when it goes out of scope.","title":"function loan"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1ServerImpl/#function-send","text":"cxx :: expected < ServerSendError > send ( Response < Res > && response ) override Sends the given Response and then releases its loan. Parameters : response to send. Return : Error if sending was not successful Updated on 18 December 2023 at 13:11:43 CET","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/","text":"iox::popo::Subscriber \ud83d\udd17 The Subscriber class for the publish-subscribe messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/subscriber.hpp> Inherits from iox::popo::SubscriberImpl< T, mepoo::NoUserHeader > , iox::popo::BaseSubscriber<> Public Functions \ud83d\udd17 Name virtual ~Subscriber () Additional inherited members \ud83d\udd17 Public Types inherited from iox::popo::SubscriberImpl< T, mepoo::NoUserHeader > Name using typename BaseSubscriberType::PortType PortType using SampleDeleter< PortType > SubscriberSampleDeleter Public Functions inherited from iox::popo::SubscriberImpl< T, mepoo::NoUserHeader > Name SubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) SubscriberImpl (const SubscriberImpl & other) SubscriberImpl & operator= (const SubscriberImpl & ) SubscriberImpl ( SubscriberImpl && rhs) SubscriberImpl & operator= ( SubscriberImpl && rhs) virtual ~SubscriberImpl () cxx::expected< Sample < const T, const H >, ChunkReceiveResult > take () Take the samples from the top of the receive queue. Protected Types inherited from iox::popo::BaseSubscriber<> Name using BaseSubscriber < port_t > SelfType Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. using port_t PortType Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber & operator= (const BaseSubscriber & ) BaseSubscriber ( BaseSubscriber && rhs) BaseSubscriber & operator= ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery Detailed Description \ud83d\udd17 template < typename T , typename H = mepoo :: NoUserHeader > class iox :: popo :: Subscriber ; The Subscriber class for the publish-subscribe messaging pattern in iceoryx. Parameters : T user payload type H user header type Public Functions Documentation \ud83d\udd17 function ~Subscriber \ud83d\udd17 inline virtual ~ Subscriber () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Subscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#ioxpoposubscriber","text":"The Subscriber class for the publish-subscribe messaging pattern in iceoryx. More... #include <iceoryx_posh/popo/subscriber.hpp> Inherits from iox::popo::SubscriberImpl< T, mepoo::NoUserHeader > , iox::popo::BaseSubscriber<>","title":"iox::popo::Subscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#public-functions","text":"Name virtual ~Subscriber ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#additional-inherited-members","text":"Public Types inherited from iox::popo::SubscriberImpl< T, mepoo::NoUserHeader > Name using typename BaseSubscriberType::PortType PortType using SampleDeleter< PortType > SubscriberSampleDeleter Public Functions inherited from iox::popo::SubscriberImpl< T, mepoo::NoUserHeader > Name SubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) SubscriberImpl (const SubscriberImpl & other) SubscriberImpl & operator= (const SubscriberImpl & ) SubscriberImpl ( SubscriberImpl && rhs) SubscriberImpl & operator= ( SubscriberImpl && rhs) virtual ~SubscriberImpl () cxx::expected< Sample < const T, const H >, ChunkReceiveResult > take () Take the samples from the top of the receive queue. Protected Types inherited from iox::popo::BaseSubscriber<> Name using BaseSubscriber < port_t > SelfType Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. using port_t PortType Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber & operator= (const BaseSubscriber & ) BaseSubscriber ( BaseSubscriber && rhs) BaseSubscriber & operator= ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#detailed-description","text":"template < typename T , typename H = mepoo :: NoUserHeader > class iox :: popo :: Subscriber ; The Subscriber class for the publish-subscribe messaging pattern in iceoryx. Parameters : T user payload type H user header type","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/#function-subscriber","text":"inline virtual ~ Subscriber () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~Subscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/","text":"iox::popo::SubscriberImpl \ud83d\udd17 The SubscriberImpl class implements the typed subscriber API. More... #include <iceoryx_posh/internal/popo/subscriber_impl.hpp> Inherits from iox::popo::BaseSubscriber<> Public Types \ud83d\udd17 Name using typename BaseSubscriberType::PortType PortType using SampleDeleter< PortType > SubscriberSampleDeleter Public Functions \ud83d\udd17 Name SubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) SubscriberImpl (const SubscriberImpl & other) SubscriberImpl & operator= (const SubscriberImpl & ) SubscriberImpl ( SubscriberImpl && rhs) SubscriberImpl & operator= ( SubscriberImpl && rhs) virtual ~SubscriberImpl () cxx::expected< Sample < const T, const H >, ChunkReceiveResult > take () Take the samples from the top of the receive queue. Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery Detailed Description \ud83d\udd17 template < typename T , typename H = iox :: mepoo :: NoUserHeader , typename BaseSubscriberType = BaseSubscriber <>> class iox :: popo :: SubscriberImpl ; The SubscriberImpl class implements the typed subscriber API. Note : Not intended for public usage! Use the [Subscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/) instead! Public Types Documentation \ud83d\udd17 using PortType \ud83d\udd17 using iox :: popo :: SubscriberImpl < T , H , BaseSubscriberType >:: PortType = typename BaseSubscriberType :: PortType ; using SubscriberSampleDeleter \ud83d\udd17 using iox :: popo :: SubscriberImpl < T , H , BaseSubscriberType >:: SubscriberSampleDeleter = SampleDeleter < PortType > ; Public Functions Documentation \ud83d\udd17 function SubscriberImpl \ud83d\udd17 explicit SubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions () ) function SubscriberImpl \ud83d\udd17 SubscriberImpl ( const SubscriberImpl & other ) function operator= \ud83d\udd17 SubscriberImpl & operator = ( const SubscriberImpl & ) function SubscriberImpl \ud83d\udd17 SubscriberImpl ( SubscriberImpl && rhs ) function operator= \ud83d\udd17 SubscriberImpl & operator = ( SubscriberImpl && rhs ) function ~SubscriberImpl \ud83d\udd17 virtual ~ SubscriberImpl () function take \ud83d\udd17 cxx :: expected < Sample < const T , const H > , ChunkReceiveResult > take () Take the samples from the top of the receive queue. Return : Either a sample or a ChunkReceiveResult. The sample takes care of the cleanup. Don't store the raw pointer to the content of the sample, but always the whole sample. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::SubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#ioxpoposubscriberimpl","text":"The SubscriberImpl class implements the typed subscriber API. More... #include <iceoryx_posh/internal/popo/subscriber_impl.hpp> Inherits from iox::popo::BaseSubscriber<>","title":"iox::popo::SubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#public-types","text":"Name using typename BaseSubscriberType::PortType PortType using SampleDeleter< PortType > SubscriberSampleDeleter","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#public-functions","text":"Name SubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) SubscriberImpl (const SubscriberImpl & other) SubscriberImpl & operator= (const SubscriberImpl & ) SubscriberImpl ( SubscriberImpl && rhs) SubscriberImpl & operator= ( SubscriberImpl && rhs) virtual ~SubscriberImpl () cxx::expected< Sample < const T, const H >, ChunkReceiveResult > take () Take the samples from the top of the receive queue.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#additional-inherited-members","text":"Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#detailed-description","text":"template < typename T , typename H = iox :: mepoo :: NoUserHeader , typename BaseSubscriberType = BaseSubscriber <>> class iox :: popo :: SubscriberImpl ; The SubscriberImpl class implements the typed subscriber API. Note : Not intended for public usage! Use the [Subscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1Subscriber/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#using-porttype","text":"using iox :: popo :: SubscriberImpl < T , H , BaseSubscriberType >:: PortType = typename BaseSubscriberType :: PortType ;","title":"using PortType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#using-subscribersampledeleter","text":"using iox :: popo :: SubscriberImpl < T , H , BaseSubscriberType >:: SubscriberSampleDeleter = SampleDeleter < PortType > ;","title":"using SubscriberSampleDeleter"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-subscriberimpl","text":"explicit SubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions () )","title":"function SubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-subscriberimpl_1","text":"SubscriberImpl ( const SubscriberImpl & other )","title":"function SubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-operator","text":"SubscriberImpl & operator = ( const SubscriberImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-subscriberimpl_2","text":"SubscriberImpl ( SubscriberImpl && rhs )","title":"function SubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-operator_1","text":"SubscriberImpl & operator = ( SubscriberImpl && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-subscriberimpl_3","text":"virtual ~ SubscriberImpl ()","title":"function ~SubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1SubscriberImpl/#function-take","text":"cxx :: expected < Sample < const T , const H > , ChunkReceiveResult > take () Take the samples from the top of the receive queue. Return : Either a sample or a ChunkReceiveResult. The sample takes care of the cleanup. Don't store the raw pointer to the content of the sample, but always the whole sample. Updated on 18 December 2023 at 13:11:43 CET","title":"function take"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/","text":"iox::popo::Trigger \ud83d\udd17 The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance. #include <iceoryx_posh/popo/trigger.hpp> Public Functions \ud83d\udd17 Name Trigger () Trigger (const Trigger & ) Trigger & operator= (const Trigger & ) template <typename T ,typename UserType > Trigger ( StateBasedTrigger_t , T *const stateOrigin, const cxx::ConstMethodCallback< bool > & hasTriggeredCallback, const cxx::MethodCallback< void, uint64_t > & resetCallback, const uint64_t notificationId, const NotificationCallback < T, UserType > & callback, const uint64_t uniqueId, const uint64_t stateType, const uint64_t stateTypeHash) Creates a state based Trigger . template <typename T ,typename UserType > Trigger ( EventBasedTrigger_t , T *const notificationOrigin, const cxx::MethodCallback< void, uint64_t > & resetCallback, const uint64_t notificationId, const NotificationCallback < T, UserType > & callback, const uint64_t uniqueId, const uint64_t notificationType, const uint64_t notificationTypeHash) Creates an event based Trigger . Trigger ( Trigger && rhs) Trigger & operator= ( Trigger && rhs) ~Trigger () calls reset on destruction operator bool () const returns true if the Trigger is valid otherwise false A trigger is valid when: bool isValid () const returns true if the trigger is valid otherwise false bool isStateConditionSatisfied () const returns the result of the provided hasTriggeredCallback void reset () resets and invalidates the Trigger void invalidate () invalidates the Trigger without calling the reset callback uint64_t getUniqueId () const returns the internal unique id of the trigger bool isLogicalEqualTo (const void *const notificationOrigin, const uint64_t originTriggerType, const uint64_t originTriggerTypeHash) const returns true if the Triggers are logical equal otherwise false. Two Triggers are logical equal when template <typename T > void updateOrigin (T & newOrigin) sets a new origin of the trigger const NotificationInfo & getNotificationInfo () const returns the NotificationInfo TriggerType getTriggerType () const returns the type of trigger Public Attributes \ud83d\udd17 Name constexpr uint64_t INVALID_TRIGGER_ID Public Functions Documentation \ud83d\udd17 function Trigger \ud83d\udd17 Trigger () function Trigger \ud83d\udd17 Trigger ( const Trigger & ) function operator= \ud83d\udd17 Trigger & operator = ( const Trigger & ) function Trigger \ud83d\udd17 template < typename T , typename UserType > Trigger ( StateBasedTrigger_t , T * const stateOrigin , const cxx :: ConstMethodCallback < bool > & hasTriggeredCallback , const cxx :: MethodCallback < void , uint64_t > & resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType > & callback , const uint64_t uniqueId , const uint64_t stateType , const uint64_t stateTypeHash ) Creates a state based Trigger . Parameters : StateBasedTrigger_t signals that we are creating a state based trigger stateOrigin pointer to the class where the signal originates from, if it's set to nullptr the Trigger is in a defined but invalid state hasTriggeredCallback callback to a method which informs the trigger if it was triggered or not. If an empty callback is set the trigger is in a defined but invalid state. resetCallback callback which is called when the trigger goes out of scope. notificationId id of the corresponding event/state callback function pointer of type void(*)(T * const) to a callback which can be called by the trigger. uniqueId a context wide unique id to identify the trigger stateType the uint64_t value of the state origins state enum stateTypeHash the uint64_t type hash of the state enum function Trigger \ud83d\udd17 template < typename T , typename UserType > Trigger ( EventBasedTrigger_t , T * const notificationOrigin , const cxx :: MethodCallback < void , uint64_t > & resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType > & callback , const uint64_t uniqueId , const uint64_t notificationType , const uint64_t notificationTypeHash ) Creates an event based Trigger . Parameters : EventBasedTrigger_t signals that we are creating an event based trigger notificationOrigin pointer to the class where the signal originates from, if it's set to nullptr the Trigger is in a defined but invalid state resetCallback callback which is called when the trigger goes out of scope. notificationId id of the corresponding event callback function pointer of type void(*)(T * const) to a callback which can be called by the trigger. uniqueId a context wide unique id to identify the trigger notificationType the uint64_t value of the events origins event enum notificationTypeHash the uint64_t type hash of the event enum function Trigger \ud83d\udd17 Trigger ( Trigger && rhs ) function operator= \ud83d\udd17 Trigger & operator = ( Trigger && rhs ) function ~Trigger \ud83d\udd17 ~ Trigger () calls reset on destruction function operator bool \ud83d\udd17 explicit operator bool () const returns true if the Trigger is valid otherwise false A trigger is valid when: origin != nullptr hasTriggeredCallback is set function isValid \ud83d\udd17 bool isValid () const returns true if the trigger is valid otherwise false function isStateConditionSatisfied \ud83d\udd17 bool isStateConditionSatisfied () const returns the result of the provided hasTriggeredCallback Note : an event based trigger returns always true when it's valid function reset \ud83d\udd17 void reset () resets and invalidates the Trigger function invalidate \ud83d\udd17 void invalidate () invalidates the Trigger without calling the reset callback function getUniqueId \ud83d\udd17 uint64_t getUniqueId () const returns the internal unique id of the trigger function isLogicalEqualTo \ud83d\udd17 bool isLogicalEqualTo ( const void * const notificationOrigin , const uint64_t originTriggerType , const uint64_t originTriggerTypeHash ) const returns true if the Triggers are logical equal otherwise false. Two Triggers are logical equal when both Trigger are valid origin == rhs.origin originTriggerType == rhs.originTriggerType originTriggerTypeHash == rhs.originTriggerTypeHash function updateOrigin \ud83d\udd17 template < typename T > void updateOrigin ( T & newOrigin ) sets a new origin of the trigger Parameters : newOrigin reference to the new origin function getNotificationInfo \ud83d\udd17 const NotificationInfo & getNotificationInfo () const returns the NotificationInfo function getTriggerType \ud83d\udd17 TriggerType getTriggerType () const returns the type of trigger Public Attributes Documentation \ud83d\udd17 variable INVALID_TRIGGER_ID \ud83d\udd17 static constexpr uint64_t INVALID_TRIGGER_ID = std :: numeric_limits < uint64_t >:: max (); Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#ioxpopotrigger","text":"The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance. #include <iceoryx_posh/popo/trigger.hpp>","title":"iox::popo::Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-functions","text":"Name Trigger () Trigger (const Trigger & ) Trigger & operator= (const Trigger & ) template <typename T ,typename UserType > Trigger ( StateBasedTrigger_t , T *const stateOrigin, const cxx::ConstMethodCallback< bool > & hasTriggeredCallback, const cxx::MethodCallback< void, uint64_t > & resetCallback, const uint64_t notificationId, const NotificationCallback < T, UserType > & callback, const uint64_t uniqueId, const uint64_t stateType, const uint64_t stateTypeHash) Creates a state based Trigger . template <typename T ,typename UserType > Trigger ( EventBasedTrigger_t , T *const notificationOrigin, const cxx::MethodCallback< void, uint64_t > & resetCallback, const uint64_t notificationId, const NotificationCallback < T, UserType > & callback, const uint64_t uniqueId, const uint64_t notificationType, const uint64_t notificationTypeHash) Creates an event based Trigger . Trigger ( Trigger && rhs) Trigger & operator= ( Trigger && rhs) ~Trigger () calls reset on destruction operator bool () const returns true if the Trigger is valid otherwise false A trigger is valid when: bool isValid () const returns true if the trigger is valid otherwise false bool isStateConditionSatisfied () const returns the result of the provided hasTriggeredCallback void reset () resets and invalidates the Trigger void invalidate () invalidates the Trigger without calling the reset callback uint64_t getUniqueId () const returns the internal unique id of the trigger bool isLogicalEqualTo (const void *const notificationOrigin, const uint64_t originTriggerType, const uint64_t originTriggerTypeHash) const returns true if the Triggers are logical equal otherwise false. Two Triggers are logical equal when template <typename T > void updateOrigin (T & newOrigin) sets a new origin of the trigger const NotificationInfo & getNotificationInfo () const returns the NotificationInfo TriggerType getTriggerType () const returns the type of trigger","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-attributes","text":"Name constexpr uint64_t INVALID_TRIGGER_ID","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger","text":"Trigger ()","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_1","text":"Trigger ( const Trigger & )","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-operator","text":"Trigger & operator = ( const Trigger & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_2","text":"template < typename T , typename UserType > Trigger ( StateBasedTrigger_t , T * const stateOrigin , const cxx :: ConstMethodCallback < bool > & hasTriggeredCallback , const cxx :: MethodCallback < void , uint64_t > & resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType > & callback , const uint64_t uniqueId , const uint64_t stateType , const uint64_t stateTypeHash ) Creates a state based Trigger . Parameters : StateBasedTrigger_t signals that we are creating a state based trigger stateOrigin pointer to the class where the signal originates from, if it's set to nullptr the Trigger is in a defined but invalid state hasTriggeredCallback callback to a method which informs the trigger if it was triggered or not. If an empty callback is set the trigger is in a defined but invalid state. resetCallback callback which is called when the trigger goes out of scope. notificationId id of the corresponding event/state callback function pointer of type void(*)(T * const) to a callback which can be called by the trigger. uniqueId a context wide unique id to identify the trigger stateType the uint64_t value of the state origins state enum stateTypeHash the uint64_t type hash of the state enum","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_3","text":"template < typename T , typename UserType > Trigger ( EventBasedTrigger_t , T * const notificationOrigin , const cxx :: MethodCallback < void , uint64_t > & resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType > & callback , const uint64_t uniqueId , const uint64_t notificationType , const uint64_t notificationTypeHash ) Creates an event based Trigger . Parameters : EventBasedTrigger_t signals that we are creating an event based trigger notificationOrigin pointer to the class where the signal originates from, if it's set to nullptr the Trigger is in a defined but invalid state resetCallback callback which is called when the trigger goes out of scope. notificationId id of the corresponding event callback function pointer of type void(*)(T * const) to a callback which can be called by the trigger. uniqueId a context wide unique id to identify the trigger notificationType the uint64_t value of the events origins event enum notificationTypeHash the uint64_t type hash of the event enum","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_4","text":"Trigger ( Trigger && rhs )","title":"function Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-operator_1","text":"Trigger & operator = ( Trigger && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-trigger_5","text":"~ Trigger () calls reset on destruction","title":"function ~Trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-operator-bool","text":"explicit operator bool () const returns true if the Trigger is valid otherwise false A trigger is valid when: origin != nullptr hasTriggeredCallback is set","title":"function operator bool"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-isvalid","text":"bool isValid () const returns true if the trigger is valid otherwise false","title":"function isValid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-isstateconditionsatisfied","text":"bool isStateConditionSatisfied () const returns the result of the provided hasTriggeredCallback Note : an event based trigger returns always true when it's valid","title":"function isStateConditionSatisfied"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-reset","text":"void reset () resets and invalidates the Trigger","title":"function reset"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-invalidate","text":"void invalidate () invalidates the Trigger without calling the reset callback","title":"function invalidate"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-getuniqueid","text":"uint64_t getUniqueId () const returns the internal unique id of the trigger","title":"function getUniqueId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-islogicalequalto","text":"bool isLogicalEqualTo ( const void * const notificationOrigin , const uint64_t originTriggerType , const uint64_t originTriggerTypeHash ) const returns true if the Triggers are logical equal otherwise false. Two Triggers are logical equal when both Trigger are valid origin == rhs.origin originTriggerType == rhs.originTriggerType originTriggerTypeHash == rhs.originTriggerTypeHash","title":"function isLogicalEqualTo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-updateorigin","text":"template < typename T > void updateOrigin ( T & newOrigin ) sets a new origin of the trigger Parameters : newOrigin reference to the new origin","title":"function updateOrigin"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-getnotificationinfo","text":"const NotificationInfo & getNotificationInfo () const returns the NotificationInfo","title":"function getNotificationInfo"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#function-gettriggertype","text":"TriggerType getTriggerType () const returns the type of trigger","title":"function getTriggerType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Trigger/#variable-invalid_trigger_id","text":"static constexpr uint64_t INVALID_TRIGGER_ID = std :: numeric_limits < uint64_t >:: max (); Updated on 18 December 2023 at 13:11:43 CET","title":"variable INVALID_TRIGGER_ID"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/","text":"iox::popo::TriggerHandle \ud83d\udd17 TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable. #include <iceoryx_posh/popo/trigger_handle.hpp> Public Functions \ud83d\udd17 Name TriggerHandle () TriggerHandle (ConditionVariableData & conditionVariableData, const cxx::MethodCallback< void, uint64_t > resetCallback, const uint64_t uniqueTriggerId) Creates a TriggerHandle . TriggerHandle (const TriggerHandle & ) TriggerHandle & operator= (const TriggerHandle & ) TriggerHandle ( TriggerHandle && rhs) TriggerHandle & operator= ( TriggerHandle && rhs) ~TriggerHandle () operator bool () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. bool isValid () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. bool wasTriggered () const Returns true when the TriggerHandle was triggered. void trigger () triggers the Trigger and informs the Notifyable which verifies that the Trigger was triggered by calling the hasTriggeredCallback void reset () calls the resetCallback and invalidates the TriggerHandle void invalidate () invalidates the TriggerHandle without calling the reset callback uint64_t getUniqueId () const returns the uniqueTriggerId ConditionVariableData * getConditionVariableData () returns the pointer to the ConditionVariableData Public Functions Documentation \ud83d\udd17 function TriggerHandle \ud83d\udd17 TriggerHandle () Note : explicitly implemented for MSVC and QNX function TriggerHandle \ud83d\udd17 TriggerHandle ( ConditionVariableData & conditionVariableData , const cxx :: MethodCallback < void , uint64_t > resetCallback , const uint64_t uniqueTriggerId ) Creates a TriggerHandle . Parameters : conditionVariableDataRef reference to a condition variable data struct resetCallback callback which will be called it goes out of scope or reset is called uniqueTriggerId the unique trigger id of the Trigger which corresponds to the TriggerHandle . Usually stored in a Notifyable. It is required for the resetCallback function TriggerHandle \ud83d\udd17 TriggerHandle ( const TriggerHandle & ) function operator= \ud83d\udd17 TriggerHandle & operator = ( const TriggerHandle & ) function TriggerHandle \ud83d\udd17 TriggerHandle ( TriggerHandle && rhs ) function operator= \ud83d\udd17 TriggerHandle & operator = ( TriggerHandle && rhs ) function ~TriggerHandle \ud83d\udd17 ~ TriggerHandle () function operator bool \ud83d\udd17 explicit operator bool () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. function isValid \ud83d\udd17 bool isValid () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. function wasTriggered \ud83d\udd17 bool wasTriggered () const Returns true when the TriggerHandle was triggered. Note : The TriggerHandle wasTriggered state is set to false again after the underlying ConditionListener gathered all events. function trigger \ud83d\udd17 void trigger () triggers the Trigger and informs the Notifyable which verifies that the Trigger was triggered by calling the hasTriggeredCallback function reset \ud83d\udd17 void reset () calls the resetCallback and invalidates the TriggerHandle function invalidate \ud83d\udd17 void invalidate () invalidates the TriggerHandle without calling the reset callback function getUniqueId \ud83d\udd17 uint64_t getUniqueId () const returns the uniqueTriggerId function getConditionVariableData \ud83d\udd17 ConditionVariableData * getConditionVariableData () returns the pointer to the ConditionVariableData Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#ioxpopotriggerhandle","text":"TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable. #include <iceoryx_posh/popo/trigger_handle.hpp>","title":"iox::popo::TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#public-functions","text":"Name TriggerHandle () TriggerHandle (ConditionVariableData & conditionVariableData, const cxx::MethodCallback< void, uint64_t > resetCallback, const uint64_t uniqueTriggerId) Creates a TriggerHandle . TriggerHandle (const TriggerHandle & ) TriggerHandle & operator= (const TriggerHandle & ) TriggerHandle ( TriggerHandle && rhs) TriggerHandle & operator= ( TriggerHandle && rhs) ~TriggerHandle () operator bool () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. bool isValid () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr. bool wasTriggered () const Returns true when the TriggerHandle was triggered. void trigger () triggers the Trigger and informs the Notifyable which verifies that the Trigger was triggered by calling the hasTriggeredCallback void reset () calls the resetCallback and invalidates the TriggerHandle void invalidate () invalidates the TriggerHandle without calling the reset callback uint64_t getUniqueId () const returns the uniqueTriggerId ConditionVariableData * getConditionVariableData () returns the pointer to the ConditionVariableData","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle","text":"TriggerHandle () Note : explicitly implemented for MSVC and QNX","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_1","text":"TriggerHandle ( ConditionVariableData & conditionVariableData , const cxx :: MethodCallback < void , uint64_t > resetCallback , const uint64_t uniqueTriggerId ) Creates a TriggerHandle . Parameters : conditionVariableDataRef reference to a condition variable data struct resetCallback callback which will be called it goes out of scope or reset is called uniqueTriggerId the unique trigger id of the Trigger which corresponds to the TriggerHandle . Usually stored in a Notifyable. It is required for the resetCallback","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_2","text":"TriggerHandle ( const TriggerHandle & )","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-operator","text":"TriggerHandle & operator = ( const TriggerHandle & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_3","text":"TriggerHandle ( TriggerHandle && rhs )","title":"function TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-operator_1","text":"TriggerHandle & operator = ( TriggerHandle && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-triggerhandle_4","text":"~ TriggerHandle ()","title":"function ~TriggerHandle"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-operator-bool","text":"explicit operator bool () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr.","title":"function operator bool"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-isvalid","text":"bool isValid () const returns true if the TriggerHandle is valid otherwise false. A TriggerHandle is valid if m_conditionVariableDataPtr != nullptr.","title":"function isValid"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-wastriggered","text":"bool wasTriggered () const Returns true when the TriggerHandle was triggered. Note : The TriggerHandle wasTriggered state is set to false again after the underlying ConditionListener gathered all events.","title":"function wasTriggered"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-trigger","text":"void trigger () triggers the Trigger and informs the Notifyable which verifies that the Trigger was triggered by calling the hasTriggeredCallback","title":"function trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-reset","text":"void reset () calls the resetCallback and invalidates the TriggerHandle","title":"function reset"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-invalidate","text":"void invalidate () invalidates the TriggerHandle without calling the reset callback","title":"function invalidate"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-getuniqueid","text":"uint64_t getUniqueId () const returns the uniqueTriggerId","title":"function getUniqueId"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1TriggerHandle/#function-getconditionvariabledata","text":"ConditionVariableData * getConditionVariableData () returns the pointer to the ConditionVariableData Updated on 18 December 2023 at 13:11:43 CET","title":"function getConditionVariableData"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/","text":"iox::popo::UntypedClient \ud83d\udd17 Inherits from iox::popo::UntypedClientImpl<> , iox::popo::BaseClient<> Public Functions \ud83d\udd17 Name virtual ~UntypedClient () Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::UntypedClientImpl<> Name UntypedClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) virtual ~UntypedClientImpl () UntypedClientImpl (const UntypedClientImpl & ) UntypedClientImpl ( UntypedClientImpl && ) UntypedClientImpl & operator= (const UntypedClientImpl & ) UntypedClientImpl & operator= ( UntypedClientImpl && ) cxx::expected< void *, AllocationError > loan (const uint32_t payloadSize, const uint32_t payloadAlignment) Get a request chunk from loaned shared memory. void releaseRequest (void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< ClientSendError > send (void *const requestPayload) Sends the provided memory chunk as request to the server. cxx::expected< const void *, ChunkReceiveResult > take () Take the response chunk from the top of the receive queue. void releaseResponse (const void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer. Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient & operator= (const BaseClient & ) BaseClient ( BaseClient && rhs) BaseClient & operator= ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney Public Functions Documentation \ud83d\udd17 function ~UntypedClient \ud83d\udd17 inline virtual ~ UntypedClient () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#ioxpopountypedclient","text":"Inherits from iox::popo::UntypedClientImpl<> , iox::popo::BaseClient<>","title":"iox::popo::UntypedClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#public-functions","text":"Name virtual ~UntypedClient ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#additional-inherited-members","text":"Public Functions inherited from iox::popo::UntypedClientImpl<> Name UntypedClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) virtual ~UntypedClientImpl () UntypedClientImpl (const UntypedClientImpl & ) UntypedClientImpl ( UntypedClientImpl && ) UntypedClientImpl & operator= (const UntypedClientImpl & ) UntypedClientImpl & operator= ( UntypedClientImpl && ) cxx::expected< void *, AllocationError > loan (const uint32_t payloadSize, const uint32_t payloadAlignment) Get a request chunk from loaned shared memory. void releaseRequest (void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< ClientSendError > send (void *const requestPayload) Sends the provided memory chunk as request to the server. cxx::expected< const void *, ChunkReceiveResult > take () Take the response chunk from the top of the receive queue. void releaseResponse (const void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer. Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient & operator= (const BaseClient & ) BaseClient ( BaseClient && rhs) BaseClient & operator= ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/#function-untypedclient","text":"inline virtual ~ UntypedClient () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~UntypedClient"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/","text":"iox::popo::UntypedClientImpl \ud83d\udd17 The UntypedClientImpl class implements the untyped client API. More... #include <iceoryx_posh/internal/popo/untyped_client_impl.hpp> Inherits from iox::popo::BaseClient<> Public Functions \ud83d\udd17 Name UntypedClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) virtual ~UntypedClientImpl () UntypedClientImpl (const UntypedClientImpl & ) UntypedClientImpl ( UntypedClientImpl && ) UntypedClientImpl & operator= (const UntypedClientImpl & ) UntypedClientImpl & operator= ( UntypedClientImpl && ) cxx::expected< void *, AllocationError > loan (const uint32_t payloadSize, const uint32_t payloadAlignment) Get a request chunk from loaned shared memory. void releaseRequest (void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< ClientSendError > send (void *const requestPayload) Sends the provided memory chunk as request to the server. cxx::expected< const void *, ChunkReceiveResult > take () Take the response chunk from the top of the receive queue. void releaseResponse (const void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer. Additional inherited members \ud83d\udd17 Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename BaseClientT = BaseClient <>> class iox :: popo :: UntypedClientImpl ; The UntypedClientImpl class implements the untyped client API. Note : Not intended for public usage! Use the [UntypedClient](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/) instead! Public Functions Documentation \ud83d\udd17 function UntypedClientImpl \ud83d\udd17 explicit UntypedClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {} ) function ~UntypedClientImpl \ud83d\udd17 virtual ~ UntypedClientImpl () function UntypedClientImpl \ud83d\udd17 UntypedClientImpl ( const UntypedClientImpl & ) function UntypedClientImpl \ud83d\udd17 UntypedClientImpl ( UntypedClientImpl && ) function operator= \ud83d\udd17 UntypedClientImpl & operator = ( const UntypedClientImpl & ) function operator= \ud83d\udd17 UntypedClientImpl & operator = ( UntypedClientImpl && ) function loan \ud83d\udd17 cxx :: expected < void * , AllocationError > loan ( const uint32_t payloadSize , const uint32_t payloadAlignment ) Get a request chunk from loaned shared memory. Parameters : payloadSize The expected payload size of the chunk. payloadAlignment The expected payload alignment of the chunk. Return : A pointer to the payload of a chunk of memory with the requested size or an AllocationError if no chunk could be loaned. Note : An AllocationError occurs if no chunk is available in the shared memory. function releaseRequest \ud83d\udd17 void releaseRequest ( void * const requestPayload ) Releases the ownership of the request chunk provided by the payload pointer. Parameters : requestPayload pointer to the payload of the chunk to be released The requestPayload pointer must have been previously provided by loan and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. function send \ud83d\udd17 cxx :: expected < ClientSendError > send ( void * const requestPayload ) Sends the provided memory chunk as request to the server. Parameters : requestPayload Pointer to the payload of the allocated shared memory chunk. Return : Error if sending was not successful function take \ud83d\udd17 cxx :: expected < const void * , ChunkReceiveResult > take () Take the response chunk from the top of the receive queue. Return : The payload pointer of the request chunk taken. No automatic cleanup of the associated chunk is performed and must be manually done by calling releaseResponse function releaseResponse \ud83d\udd17 void releaseResponse ( const void * const responsePayload ) Releases the ownership of the response chunk provided by the payload pointer. Parameters : responsePayload pointer to the payload of the chunk to be released The responsePayload pointer must have been previously provided by take and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#ioxpopountypedclientimpl","text":"The UntypedClientImpl class implements the untyped client API. More... #include <iceoryx_posh/internal/popo/untyped_client_impl.hpp> Inherits from iox::popo::BaseClient<>","title":"iox::popo::UntypedClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#public-functions","text":"Name UntypedClientImpl (const capro::ServiceDescription & service, const ClientOptions & clientOptions ={}) virtual ~UntypedClientImpl () UntypedClientImpl (const UntypedClientImpl & ) UntypedClientImpl ( UntypedClientImpl && ) UntypedClientImpl & operator= (const UntypedClientImpl & ) UntypedClientImpl & operator= ( UntypedClientImpl && ) cxx::expected< void *, AllocationError > loan (const uint32_t payloadSize, const uint32_t payloadAlignment) Get a request chunk from loaned shared memory. void releaseRequest (void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< ClientSendError > send (void *const requestPayload) Sends the provided memory chunk as request to the server. cxx::expected< const void *, ChunkReceiveResult > take () Take the response chunk from the top of the receive queue. void releaseResponse (const void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#additional-inherited-members","text":"Protected Types inherited from iox::popo::BaseClient<> Name using BaseClient < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseClient<> Name virtual ~BaseClient () BaseClient (const BaseClient & other) BaseClient ( BaseClient && rhs) uid_t getUid () const Get the unique ID of the client. const capro::ServiceDescription & getServiceDescription () const Get the service description of the client. void connect () Initiate connection to server when not already connected, otherwise nothing. ConnectionState getConnectionState () const Get current connection state. void disconnect () Disconnects when already connected, otherwise nothing. bool hasResponses () const Check if response are available. bool hasMissedResponses () Check if response has been missed since the last call of this method. void releaseQueuedResponses () Releases any unread queued response. Protected Functions inherited from iox::popo::BaseClient<> Name BaseClient (const capro::ServiceDescription & service, const ClientOptions & clientOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ClientState clientState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ClientState clientState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ClientEvent clientEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const const accessor of the underlying port PortT & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseClient<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseClient<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#detailed-description","text":"template < typename BaseClientT = BaseClient <>> class iox :: popo :: UntypedClientImpl ; The UntypedClientImpl class implements the untyped client API. Note : Not intended for public usage! Use the [UntypedClient](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClient/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-untypedclientimpl","text":"explicit UntypedClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {} )","title":"function UntypedClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-untypedclientimpl_1","text":"virtual ~ UntypedClientImpl ()","title":"function ~UntypedClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-untypedclientimpl_2","text":"UntypedClientImpl ( const UntypedClientImpl & )","title":"function UntypedClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-untypedclientimpl_3","text":"UntypedClientImpl ( UntypedClientImpl && )","title":"function UntypedClientImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-operator","text":"UntypedClientImpl & operator = ( const UntypedClientImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-operator_1","text":"UntypedClientImpl & operator = ( UntypedClientImpl && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-loan","text":"cxx :: expected < void * , AllocationError > loan ( const uint32_t payloadSize , const uint32_t payloadAlignment ) Get a request chunk from loaned shared memory. Parameters : payloadSize The expected payload size of the chunk. payloadAlignment The expected payload alignment of the chunk. Return : A pointer to the payload of a chunk of memory with the requested size or an AllocationError if no chunk could be loaned. Note : An AllocationError occurs if no chunk is available in the shared memory.","title":"function loan"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-releaserequest","text":"void releaseRequest ( void * const requestPayload ) Releases the ownership of the request chunk provided by the payload pointer. Parameters : requestPayload pointer to the payload of the chunk to be released The requestPayload pointer must have been previously provided by loan and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed.","title":"function releaseRequest"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-send","text":"cxx :: expected < ClientSendError > send ( void * const requestPayload ) Sends the provided memory chunk as request to the server. Parameters : requestPayload Pointer to the payload of the allocated shared memory chunk. Return : Error if sending was not successful","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-take","text":"cxx :: expected < const void * , ChunkReceiveResult > take () Take the response chunk from the top of the receive queue. Return : The payload pointer of the request chunk taken. No automatic cleanup of the associated chunk is performed and must be manually done by calling releaseResponse","title":"function take"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedClientImpl/#function-releaseresponse","text":"void releaseResponse ( const void * const responsePayload ) Releases the ownership of the response chunk provided by the payload pointer. Parameters : responsePayload pointer to the payload of the chunk to be released The responsePayload pointer must have been previously provided by take and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"function releaseResponse"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/","text":"iox::popo::UntypedPublisher \ud83d\udd17 The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx. #include <iceoryx_posh/popo/untyped_publisher.hpp> Inherits from iox::popo::UntypedPublisherImpl<> , iox::popo::BasePublisher<> Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::UntypedPublisherImpl<> Name UntypedPublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) UntypedPublisherImpl (const UntypedPublisherImpl & other) UntypedPublisherImpl & operator= (const UntypedPublisherImpl & ) UntypedPublisherImpl ( UntypedPublisherImpl && rhs) UntypedPublisherImpl & operator= ( UntypedPublisherImpl && rhs) virtual ~UntypedPublisherImpl () =default cxx::expected< void *, AllocationError > loan (const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT) Get a chunk from loaned shared memory. void publish (void *const userPayload) Publish the provided memory chunk. void release (void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer. Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher & operator= (const BasePublisher & ) BasePublisher ( BasePublisher && rhs) BasePublisher & operator= ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedPublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/#ioxpopountypedpublisher","text":"The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx. #include <iceoryx_posh/popo/untyped_publisher.hpp> Inherits from iox::popo::UntypedPublisherImpl<> , iox::popo::BasePublisher<>","title":"iox::popo::UntypedPublisher"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/#additional-inherited-members","text":"Public Functions inherited from iox::popo::UntypedPublisherImpl<> Name UntypedPublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) UntypedPublisherImpl (const UntypedPublisherImpl & other) UntypedPublisherImpl & operator= (const UntypedPublisherImpl & ) UntypedPublisherImpl ( UntypedPublisherImpl && rhs) UntypedPublisherImpl & operator= ( UntypedPublisherImpl && rhs) virtual ~UntypedPublisherImpl () =default cxx::expected< void *, AllocationError > loan (const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT) Get a chunk from loaned shared memory. void publish (void *const userPayload) Publish the provided memory chunk. void release (void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer. Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher & operator= (const BasePublisher & ) BasePublisher ( BasePublisher && rhs) BasePublisher & operator= ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port Updated on 18 December 2023 at 13:11:43 CET","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/","text":"iox::popo::UntypedPublisherImpl \ud83d\udd17 The UntypedPublisherImpl class implements the untyped publisher API. More... #include <iceoryx_posh/internal/popo/untyped_publisher_impl.hpp> Inherits from iox::popo::BasePublisher<> Public Functions \ud83d\udd17 Name UntypedPublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) UntypedPublisherImpl (const UntypedPublisherImpl & other) UntypedPublisherImpl & operator= (const UntypedPublisherImpl & ) UntypedPublisherImpl ( UntypedPublisherImpl && rhs) UntypedPublisherImpl & operator= ( UntypedPublisherImpl && rhs) virtual ~UntypedPublisherImpl () =default cxx::expected< void *, AllocationError > loan (const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT) Get a chunk from loaned shared memory. void publish (void *const userPayload) Publish the provided memory chunk. void release (void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer. Additional inherited members \ud83d\udd17 Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port Detailed Description \ud83d\udd17 template < typename BasePublisherType = BasePublisher <>> class iox :: popo :: UntypedPublisherImpl ; The UntypedPublisherImpl class implements the untyped publisher API. Note : Not intended for public usage! Use the [UntypedPublisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/) instead! Public Functions Documentation \ud83d\udd17 function UntypedPublisherImpl \ud83d\udd17 explicit UntypedPublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions () ) function UntypedPublisherImpl \ud83d\udd17 UntypedPublisherImpl ( const UntypedPublisherImpl & other ) function operator= \ud83d\udd17 UntypedPublisherImpl & operator = ( const UntypedPublisherImpl & ) function UntypedPublisherImpl \ud83d\udd17 UntypedPublisherImpl ( UntypedPublisherImpl && rhs ) function operator= \ud83d\udd17 UntypedPublisherImpl & operator = ( UntypedPublisherImpl && rhs ) function ~UntypedPublisherImpl \ud83d\udd17 virtual ~ UntypedPublisherImpl () = default function loan \ud83d\udd17 cxx :: expected < void * , AllocationError > loan ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) Get a chunk from loaned shared memory. Parameters : usePayloadSize The expected user-payload size of the chunk. userPayloadAlignment The expected user-payload alignment of the chunk. Return : A pointer to the user-payload of a chunk of memory with the requested size or an AllocationError if no chunk could be loaned. Note : An AllocationError occurs if no chunk is available in the shared memory. function publish \ud83d\udd17 void publish ( void * const userPayload ) Publish the provided memory chunk. Parameters : userPayload Pointer to the user-payload of the allocated shared memory chunk. Return : Error if provided pointer is not a user-payload of a valid memory chunk. function release \ud83d\udd17 void release ( void * const userPayload ) Releases the ownership of the chunk provided by the user-payload pointer. Parameters : userPayload pointer to the user-payload of the chunk to be released The userPayload pointer must have been previously provided by loan and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedPublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#ioxpopountypedpublisherimpl","text":"The UntypedPublisherImpl class implements the untyped publisher API. More... #include <iceoryx_posh/internal/popo/untyped_publisher_impl.hpp> Inherits from iox::popo::BasePublisher<>","title":"iox::popo::UntypedPublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#public-functions","text":"Name UntypedPublisherImpl (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions = PublisherOptions ()) UntypedPublisherImpl (const UntypedPublisherImpl & other) UntypedPublisherImpl & operator= (const UntypedPublisherImpl & ) UntypedPublisherImpl ( UntypedPublisherImpl && rhs) UntypedPublisherImpl & operator= ( UntypedPublisherImpl && rhs) virtual ~UntypedPublisherImpl () =default cxx::expected< void *, AllocationError > loan (const uint32_t userPayloadSize, const uint32_t userPayloadAlignment =iox::CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT, const uint32_t userHeaderSize =iox::CHUNK_NO_USER_HEADER_SIZE, const uint32_t userHeaderAlignment =iox::CHUNK_NO_USER_HEADER_ALIGNMENT) Get a chunk from loaned shared memory. void publish (void *const userPayload) Publish the provided memory chunk. void release (void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#additional-inherited-members","text":"Public Types inherited from iox::popo::BasePublisher<> Name using port_t PortType Public Functions inherited from iox::popo::BasePublisher<> Name BasePublisher (const BasePublisher & other) BasePublisher ( BasePublisher && rhs) virtual ~BasePublisher () uid_t getUid () const uid Get the UID of the publisher. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the publisher. void offer () offer Offer the service to be subscribed to. void stopOffer () stopOffer Stop offering the service. bool isOffered () const isOffered bool hasSubscribers () const hasSubscribers Protected Functions inherited from iox::popo::BasePublisher<> Name BasePublisher () =default BasePublisher (const capro::ServiceDescription & service, const PublisherOptions & publisherOptions) const port_t & port () const port port_t & port () port Protected Attributes inherited from iox::popo::BasePublisher<> Name port_t m_port","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#detailed-description","text":"template < typename BasePublisherType = BasePublisher <>> class iox :: popo :: UntypedPublisherImpl ; The UntypedPublisherImpl class implements the untyped publisher API. Note : Not intended for public usage! Use the [UntypedPublisher](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisher/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-untypedpublisherimpl","text":"explicit UntypedPublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions () )","title":"function UntypedPublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-untypedpublisherimpl_1","text":"UntypedPublisherImpl ( const UntypedPublisherImpl & other )","title":"function UntypedPublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-operator","text":"UntypedPublisherImpl & operator = ( const UntypedPublisherImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-untypedpublisherimpl_2","text":"UntypedPublisherImpl ( UntypedPublisherImpl && rhs )","title":"function UntypedPublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-operator_1","text":"UntypedPublisherImpl & operator = ( UntypedPublisherImpl && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-untypedpublisherimpl_3","text":"virtual ~ UntypedPublisherImpl () = default","title":"function ~UntypedPublisherImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-loan","text":"cxx :: expected < void * , AllocationError > loan ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) Get a chunk from loaned shared memory. Parameters : usePayloadSize The expected user-payload size of the chunk. userPayloadAlignment The expected user-payload alignment of the chunk. Return : A pointer to the user-payload of a chunk of memory with the requested size or an AllocationError if no chunk could be loaned. Note : An AllocationError occurs if no chunk is available in the shared memory.","title":"function loan"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-publish","text":"void publish ( void * const userPayload ) Publish the provided memory chunk. Parameters : userPayload Pointer to the user-payload of the allocated shared memory chunk. Return : Error if provided pointer is not a user-payload of a valid memory chunk.","title":"function publish"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedPublisherImpl/#function-release","text":"void release ( void * const userPayload ) Releases the ownership of the chunk provided by the user-payload pointer. Parameters : userPayload pointer to the user-payload of the chunk to be released The userPayload pointer must have been previously provided by loan and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"function release"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/","text":"iox::popo::UntypedServer \ud83d\udd17 Inherits from iox::popo::UntypedServerImpl<> , iox::popo::BaseServer<> Public Functions \ud83d\udd17 Name virtual ~UntypedServer () Additional inherited members \ud83d\udd17 Public Functions inherited from iox::popo::UntypedServerImpl<> Name UntypedServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) virtual ~UntypedServerImpl () UntypedServerImpl (const UntypedServerImpl & ) UntypedServerImpl ( UntypedServerImpl && ) UntypedServerImpl & operator= (const UntypedServerImpl & ) UntypedServerImpl & operator= ( UntypedServerImpl && ) cxx::expected< const void *, ServerRequestResult > take () Take the request chunk from the top of the receive queue. void releaseRequest (const void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< void *, AllocationError > loan (const RequestHeader *const requestHeader, const uint32_t payloadSize, const uint32_t payloadAlignment) Get a response chunk from loaned shared memory. cxx::expected< ServerSendError > send (void *const responsePayload) Sends the provided memory chunk as response to the client. void releaseResponse (void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer. Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer & operator= (const BaseServer & ) BaseServer ( BaseServer && rhs) BaseServer & operator= ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney Public Functions Documentation \ud83d\udd17 function ~UntypedServer \ud83d\udd17 inline virtual ~ UntypedServer () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#ioxpopountypedserver","text":"Inherits from iox::popo::UntypedServerImpl<> , iox::popo::BaseServer<>","title":"iox::popo::UntypedServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#public-functions","text":"Name virtual ~UntypedServer ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#additional-inherited-members","text":"Public Functions inherited from iox::popo::UntypedServerImpl<> Name UntypedServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) virtual ~UntypedServerImpl () UntypedServerImpl (const UntypedServerImpl & ) UntypedServerImpl ( UntypedServerImpl && ) UntypedServerImpl & operator= (const UntypedServerImpl & ) UntypedServerImpl & operator= ( UntypedServerImpl && ) cxx::expected< const void *, ServerRequestResult > take () Take the request chunk from the top of the receive queue. void releaseRequest (const void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< void *, AllocationError > loan (const RequestHeader *const requestHeader, const uint32_t payloadSize, const uint32_t payloadAlignment) Get a response chunk from loaned shared memory. cxx::expected< ServerSendError > send (void *const responsePayload) Sends the provided memory chunk as response to the client. void releaseResponse (void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer. Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer & operator= (const BaseServer & ) BaseServer ( BaseServer && rhs) BaseServer & operator= ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/#function-untypedserver","text":"inline virtual ~ UntypedServer () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~UntypedServer"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/","text":"iox::popo::UntypedServerImpl \ud83d\udd17 The UntypedServerImpl class implements the untyped server API. More... #include <iceoryx_posh/internal/popo/untyped_server_impl.hpp> Inherits from iox::popo::BaseServer<> Public Functions \ud83d\udd17 Name UntypedServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) virtual ~UntypedServerImpl () UntypedServerImpl (const UntypedServerImpl & ) UntypedServerImpl ( UntypedServerImpl && ) UntypedServerImpl & operator= (const UntypedServerImpl & ) UntypedServerImpl & operator= ( UntypedServerImpl && ) cxx::expected< const void *, ServerRequestResult > take () Take the request chunk from the top of the receive queue. void releaseRequest (const void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< void *, AllocationError > loan (const RequestHeader *const requestHeader, const uint32_t payloadSize, const uint32_t payloadAlignment) Get a response chunk from loaned shared memory. cxx::expected< ServerSendError > send (void *const responsePayload) Sends the provided memory chunk as response to the client. void releaseResponse (void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer. Additional inherited members \ud83d\udd17 Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney Detailed Description \ud83d\udd17 template < typename BaseServerT = BaseServer <>> class iox :: popo :: UntypedServerImpl ; The UntypedServerImpl class implements the untyped server API. Note : Not intended for public usage! Use the [UntypedServer](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/) instead! Public Functions Documentation \ud83d\udd17 function UntypedServerImpl \ud83d\udd17 explicit UntypedServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {} ) function ~UntypedServerImpl \ud83d\udd17 virtual ~ UntypedServerImpl () function UntypedServerImpl \ud83d\udd17 UntypedServerImpl ( const UntypedServerImpl & ) function UntypedServerImpl \ud83d\udd17 UntypedServerImpl ( UntypedServerImpl && ) function operator= \ud83d\udd17 UntypedServerImpl & operator = ( const UntypedServerImpl & ) function operator= \ud83d\udd17 UntypedServerImpl & operator = ( UntypedServerImpl && ) function take \ud83d\udd17 cxx :: expected < const void * , ServerRequestResult > take () Take the request chunk from the top of the receive queue. Return : The payload pointer of the request chunk taken. No automatic cleanup of the associated chunk is performed and must be manually done by calling releaseRequest function releaseRequest \ud83d\udd17 void releaseRequest ( const void * const requestPayload ) Releases the ownership of the request chunk provided by the payload pointer. Parameters : requestPayload pointer to the payload of the chunk to be released The requestPayload pointer must have been previously provided by take and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. function loan \ud83d\udd17 cxx :: expected < void * , AllocationError > loan ( const RequestHeader * const requestHeader , const uint32_t payloadSize , const uint32_t payloadAlignment ) Get a response chunk from loaned shared memory. Parameters : requestHeader The requestHeader to which the response belongs to, to determine where to send the response payloadSize The expected payload size of the chunk. payloadAlignment The expected payload alignment of the chunk. Return : A pointer to the payload of a chunk of memory with the requested size or an AllocationError if no chunk could be loaned. Note : An AllocationError occurs if no chunk is available in the shared memory. function send \ud83d\udd17 cxx :: expected < ServerSendError > send ( void * const responsePayload ) Sends the provided memory chunk as response to the client. Parameters : responsePayload Pointer to the payload of the allocated shared memory chunk. Return : Error if sending was not successful function releaseResponse \ud83d\udd17 void releaseResponse ( void * const responsePayload ) Releases the ownership of the response chunk provided by the payload pointer. Parameters : responsePayload pointer to the payload of the chunk to be released The responsePayload pointer must have been previously provided by loan and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#ioxpopountypedserverimpl","text":"The UntypedServerImpl class implements the untyped server API. More... #include <iceoryx_posh/internal/popo/untyped_server_impl.hpp> Inherits from iox::popo::BaseServer<>","title":"iox::popo::UntypedServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#public-functions","text":"Name UntypedServerImpl (const capro::ServiceDescription & service, const ServerOptions & serverOptions ={}) virtual ~UntypedServerImpl () UntypedServerImpl (const UntypedServerImpl & ) UntypedServerImpl ( UntypedServerImpl && ) UntypedServerImpl & operator= (const UntypedServerImpl & ) UntypedServerImpl & operator= ( UntypedServerImpl && ) cxx::expected< const void *, ServerRequestResult > take () Take the request chunk from the top of the receive queue. void releaseRequest (const void *const requestPayload) Releases the ownership of the request chunk provided by the payload pointer. cxx::expected< void *, AllocationError > loan (const RequestHeader *const requestHeader, const uint32_t payloadSize, const uint32_t payloadAlignment) Get a response chunk from loaned shared memory. cxx::expected< ServerSendError > send (void *const responsePayload) Sends the provided memory chunk as response to the client. void releaseResponse (void *const responsePayload) Releases the ownership of the response chunk provided by the payload pointer.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#additional-inherited-members","text":"Protected Types inherited from iox::popo::BaseServer<> Name using BaseServer < PortT, TriggerHandleT > SelfType using PortT PortType Public Functions inherited from iox::popo::BaseServer<> Name virtual ~BaseServer () BaseServer (const BaseServer & other) BaseServer ( BaseServer && rhs) uid_t getUid () const Get the UID of the server. const capro::ServiceDescription & getServiceDescription () const Get the service description of the server. void offer () Offer the service to be connected to when not already offering, otherwise nothing. void stopOffer () Stop offering the service when already offering, otherwise nothing. bool isOffered () const Check if the server is offering. bool hasClients () const Check if the server has clients. bool hasRequests () const Check if requests are available. bool hasMissedRequests () Check if requests has been missed since the last call of this method. void releaseQueuedRequests () Releases any unread queued requests. Protected Functions inherited from iox::popo::BaseServer<> Name BaseServer (const capro::ServiceDescription & service, const ServerOptions & serverOptions) void invalidateTrigger (const uint64_t uniqueTriggerId) Only usable by the WaitSet/Listener, not for public use. Invalidates the internal triggerHandle. void enableState (TriggerHandleT && triggerHandle, const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const ServerState serverState) const Only usable by the WaitSet/Listener, not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const ServerState serverState) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. void enableEvent (TriggerHandleT && triggerHandle, const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const ServerEvent serverEvent) Only usable by the WaitSet/Listener, not for public use. Resets the internal triggerHandle. const PortT & port () const port PortT & port () port Protected Attributes inherited from iox::popo::BaseServer<> Name PortT m_port TriggerHandleT m_trigger Friends inherited from iox::popo::BaseServer<> Name class NotificationAttorney","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#detailed-description","text":"template < typename BaseServerT = BaseServer <>> class iox :: popo :: UntypedServerImpl ; The UntypedServerImpl class implements the untyped server API. Note : Not intended for public usage! Use the [UntypedServer](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServer/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-untypedserverimpl","text":"explicit UntypedServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {} )","title":"function UntypedServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-untypedserverimpl_1","text":"virtual ~ UntypedServerImpl ()","title":"function ~UntypedServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-untypedserverimpl_2","text":"UntypedServerImpl ( const UntypedServerImpl & )","title":"function UntypedServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-untypedserverimpl_3","text":"UntypedServerImpl ( UntypedServerImpl && )","title":"function UntypedServerImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-operator","text":"UntypedServerImpl & operator = ( const UntypedServerImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-operator_1","text":"UntypedServerImpl & operator = ( UntypedServerImpl && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-take","text":"cxx :: expected < const void * , ServerRequestResult > take () Take the request chunk from the top of the receive queue. Return : The payload pointer of the request chunk taken. No automatic cleanup of the associated chunk is performed and must be manually done by calling releaseRequest","title":"function take"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-releaserequest","text":"void releaseRequest ( const void * const requestPayload ) Releases the ownership of the request chunk provided by the payload pointer. Parameters : requestPayload pointer to the payload of the chunk to be released The requestPayload pointer must have been previously provided by take and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed.","title":"function releaseRequest"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-loan","text":"cxx :: expected < void * , AllocationError > loan ( const RequestHeader * const requestHeader , const uint32_t payloadSize , const uint32_t payloadAlignment ) Get a response chunk from loaned shared memory. Parameters : requestHeader The requestHeader to which the response belongs to, to determine where to send the response payloadSize The expected payload size of the chunk. payloadAlignment The expected payload alignment of the chunk. Return : A pointer to the payload of a chunk of memory with the requested size or an AllocationError if no chunk could be loaned. Note : An AllocationError occurs if no chunk is available in the shared memory.","title":"function loan"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-send","text":"cxx :: expected < ServerSendError > send ( void * const responsePayload ) Sends the provided memory chunk as response to the client. Parameters : responsePayload Pointer to the payload of the allocated shared memory chunk. Return : Error if sending was not successful","title":"function send"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedServerImpl/#function-releaseresponse","text":"void releaseResponse ( void * const responsePayload ) Releases the ownership of the response chunk provided by the payload pointer. Parameters : responsePayload pointer to the payload of the chunk to be released The responsePayload pointer must have been previously provided by loan and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"function releaseResponse"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/","text":"iox::popo::UntypedSubscriber \ud83d\udd17 The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx. #include <iceoryx_posh/popo/untyped_subscriber.hpp> Inherits from iox::popo::UntypedSubscriberImpl<> , iox::popo::BaseSubscriber<> Public Functions \ud83d\udd17 Name virtual ~UntypedSubscriber () Additional inherited members \ud83d\udd17 Public Types inherited from iox::popo::UntypedSubscriberImpl<> Name using BaseSubscriberType BaseSubscriber using UntypedSubscriberImpl < BaseSubscriberType > SelfType Public Functions inherited from iox::popo::UntypedSubscriberImpl<> Name UntypedSubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) UntypedSubscriberImpl (const UntypedSubscriberImpl & other) UntypedSubscriberImpl & operator= (const UntypedSubscriberImpl & ) UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs) UntypedSubscriberImpl & operator= ( UntypedSubscriberImpl && rhs) virtual ~UntypedSubscriberImpl () cxx::expected< const void *, ChunkReceiveResult > take () Take the chunk from the top of the receive queue. void release (const void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer. Protected Types inherited from iox::popo::BaseSubscriber<> Name using BaseSubscriber < port_t > SelfType Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. using port_t PortType Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber & operator= (const BaseSubscriber & ) BaseSubscriber ( BaseSubscriber && rhs) BaseSubscriber & operator= ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery Public Functions Documentation \ud83d\udd17 function ~UntypedSubscriber \ud83d\udd17 inline virtual ~ UntypedSubscriber () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#ioxpopountypedsubscriber","text":"The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx. #include <iceoryx_posh/popo/untyped_subscriber.hpp> Inherits from iox::popo::UntypedSubscriberImpl<> , iox::popo::BaseSubscriber<>","title":"iox::popo::UntypedSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#public-functions","text":"Name virtual ~UntypedSubscriber ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#additional-inherited-members","text":"Public Types inherited from iox::popo::UntypedSubscriberImpl<> Name using BaseSubscriberType BaseSubscriber using UntypedSubscriberImpl < BaseSubscriberType > SelfType Public Functions inherited from iox::popo::UntypedSubscriberImpl<> Name UntypedSubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) UntypedSubscriberImpl (const UntypedSubscriberImpl & other) UntypedSubscriberImpl & operator= (const UntypedSubscriberImpl & ) UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs) UntypedSubscriberImpl & operator= ( UntypedSubscriberImpl && rhs) virtual ~UntypedSubscriberImpl () cxx::expected< const void *, ChunkReceiveResult > take () Take the chunk from the top of the receive queue. void release (const void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer. Protected Types inherited from iox::popo::BaseSubscriber<> Name using BaseSubscriber < port_t > SelfType Only usable by the WaitSet , not for public use. Invalidates the internal triggerHandle. using port_t PortType Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name BaseSubscriber () BaseSubscriber (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions) BaseSubscriber (const BaseSubscriber & other) BaseSubscriber & operator= (const BaseSubscriber & ) BaseSubscriber ( BaseSubscriber && rhs) BaseSubscriber & operator= ( BaseSubscriber && rhs) cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/#function-untypedsubscriber","text":"inline virtual ~ UntypedSubscriber () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~UntypedSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/","text":"iox::popo::UntypedSubscriberImpl \ud83d\udd17 The UntypedSubscriberImpl class implements the untyped subscriber API. More... #include <iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp> Inherits from iox::popo::BaseSubscriber<> Public Types \ud83d\udd17 Name using BaseSubscriberType BaseSubscriber using UntypedSubscriberImpl < BaseSubscriberType > SelfType Public Functions \ud83d\udd17 Name UntypedSubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) UntypedSubscriberImpl (const UntypedSubscriberImpl & other) UntypedSubscriberImpl & operator= (const UntypedSubscriberImpl & ) UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs) UntypedSubscriberImpl & operator= ( UntypedSubscriberImpl && rhs) virtual ~UntypedSubscriberImpl () cxx::expected< const void *, ChunkReceiveResult > take () Take the chunk from the top of the receive queue. void release (const void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer. Additional inherited members \ud83d\udd17 Protected Types inherited from iox::popo::BaseSubscriber<> Name using port_t PortType Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery Detailed Description \ud83d\udd17 template < typename BaseSubscriberType = BaseSubscriber <>> class iox :: popo :: UntypedSubscriberImpl ; The UntypedSubscriberImpl class implements the untyped subscriber API. Note : Not intended for public usage! Use the [UntypedSubscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/) instead! Public Types Documentation \ud83d\udd17 using BaseSubscriber \ud83d\udd17 using iox :: popo :: UntypedSubscriberImpl < BaseSubscriberType >:: BaseSubscriber = BaseSubscriberType ; using SelfType \ud83d\udd17 using iox :: popo :: UntypedSubscriberImpl < BaseSubscriberType >:: SelfType = UntypedSubscriberImpl < BaseSubscriberType > ; Public Functions Documentation \ud83d\udd17 function UntypedSubscriberImpl \ud83d\udd17 explicit UntypedSubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions () ) function UntypedSubscriberImpl \ud83d\udd17 UntypedSubscriberImpl ( const UntypedSubscriberImpl & other ) function operator= \ud83d\udd17 UntypedSubscriberImpl & operator = ( const UntypedSubscriberImpl & ) function UntypedSubscriberImpl \ud83d\udd17 UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs ) function operator= \ud83d\udd17 UntypedSubscriberImpl & operator = ( UntypedSubscriberImpl && rhs ) function ~UntypedSubscriberImpl \ud83d\udd17 virtual ~ UntypedSubscriberImpl () function take \ud83d\udd17 cxx :: expected < const void * , ChunkReceiveResult > take () Take the chunk from the top of the receive queue. Return : The user-payload pointer of the chunk taken. No automatic cleanup of the associated chunk is performed and must be manually done by calling release function release \ud83d\udd17 void release ( const void * const userPayload ) Releases the ownership of the chunk provided by the user-payload pointer. Parameters : userPayload pointer to the user-payload of the chunk to be released The userPayload pointer must have been previously provided by take and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UntypedSubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#ioxpopountypedsubscriberimpl","text":"The UntypedSubscriberImpl class implements the untyped subscriber API. More... #include <iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp> Inherits from iox::popo::BaseSubscriber<>","title":"iox::popo::UntypedSubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#public-types","text":"Name using BaseSubscriberType BaseSubscriber using UntypedSubscriberImpl < BaseSubscriberType > SelfType","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#public-functions","text":"Name UntypedSubscriberImpl (const capro::ServiceDescription & service, const SubscriberOptions & subscriberOptions = SubscriberOptions ()) UntypedSubscriberImpl (const UntypedSubscriberImpl & other) UntypedSubscriberImpl & operator= (const UntypedSubscriberImpl & ) UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs) UntypedSubscriberImpl & operator= ( UntypedSubscriberImpl && rhs) virtual ~UntypedSubscriberImpl () cxx::expected< const void *, ChunkReceiveResult > take () Take the chunk from the top of the receive queue. void release (const void *const userPayload) Releases the ownership of the chunk provided by the user-payload pointer.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#additional-inherited-members","text":"Protected Types inherited from iox::popo::BaseSubscriber<> Name using port_t PortType Public Functions inherited from iox::popo::BaseSubscriber<> Name virtual ~BaseSubscriber () uid_t getUid () const uid Get the unique ID of the subscriber. capro::ServiceDescription getServiceDescription () const getServiceDescription Get the service description of the subscriber. void subscribe () subscribe Initiate subscription. SubscribeState getSubscriptionState () const getSubscriptionState Get current subscription state. void unsubscribe () unsubscribe Unsubscribes if currently subscribed, otherwise do nothing. bool hasData () const Check if data is available. bool hasMissedData () Check if data has been missed since the last call of this method. void releaseQueuedData () Releases any unread queued data. Protected Functions inherited from iox::popo::BaseSubscriber<> Name cxx::expected< const mepoo::ChunkHeader *, ChunkReceiveResult > takeChunk () small helper method to unwrap the expected<optional<ChunkHeader*>> from the tryGetChunk method of the port void invalidateTrigger (const uint64_t trigger) void enableState ( iox::popo::TriggerHandle && triggerHandle, const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied (const SubscriberState subscriberState) const Only usable by the WaitSet , not for public use. Returns method pointer to the event corresponding hasTriggered method callback. void disableState (const SubscriberState subscriberState) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. void enableEvent ( iox::popo::TriggerHandle && triggerHandle, const SubscriberEvent subscriberState) Only usable by the WaitSet , not for public use. Attaches the triggerHandle to the internal trigger. void disableEvent (const SubscriberEvent subscriberEvent) Only usable by the WaitSet , not for public use. Resets the internal triggerHandle. const port_t & port () const const accessor of the underlying port port_t & port () accessor of the underlying port Protected Attributes inherited from iox::popo::BaseSubscriber<> Name port_t m_port TriggerHandle m_trigger Friends inherited from iox::popo::BaseSubscriber<> Name class NotificationAttorney class iox::runtime::ServiceDiscovery","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#detailed-description","text":"template < typename BaseSubscriberType = BaseSubscriber <>> class iox :: popo :: UntypedSubscriberImpl ; The UntypedSubscriberImpl class implements the untyped subscriber API. Note : Not intended for public usage! Use the [UntypedSubscriber](/v2.0.5/API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriber/) instead!","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#using-basesubscriber","text":"using iox :: popo :: UntypedSubscriberImpl < BaseSubscriberType >:: BaseSubscriber = BaseSubscriberType ;","title":"using BaseSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#using-selftype","text":"using iox :: popo :: UntypedSubscriberImpl < BaseSubscriberType >:: SelfType = UntypedSubscriberImpl < BaseSubscriberType > ;","title":"using SelfType"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-untypedsubscriberimpl","text":"explicit UntypedSubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions () )","title":"function UntypedSubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-untypedsubscriberimpl_1","text":"UntypedSubscriberImpl ( const UntypedSubscriberImpl & other )","title":"function UntypedSubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-operator","text":"UntypedSubscriberImpl & operator = ( const UntypedSubscriberImpl & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-untypedsubscriberimpl_2","text":"UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs )","title":"function UntypedSubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-operator_1","text":"UntypedSubscriberImpl & operator = ( UntypedSubscriberImpl && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-untypedsubscriberimpl_3","text":"virtual ~ UntypedSubscriberImpl ()","title":"function ~UntypedSubscriberImpl"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-take","text":"cxx :: expected < const void * , ChunkReceiveResult > take () Take the chunk from the top of the receive queue. Return : The user-payload pointer of the chunk taken. No automatic cleanup of the associated chunk is performed and must be manually done by calling release","title":"function take"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UntypedSubscriberImpl/#function-release","text":"void release ( const void * const userPayload ) Releases the ownership of the chunk provided by the user-payload pointer. Parameters : userPayload pointer to the user-payload of the chunk to be released The userPayload pointer must have been previously provided by take and not have been already released. The chunk must not be accessed afterwards as its memory may have been reclaimed. Updated on 18 December 2023 at 13:11:43 CET","title":"function release"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/","text":"iox::popo::UserTrigger \ud83d\udd17 An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class. #include <iceoryx_posh/popo/user_trigger.hpp> Public Functions \ud83d\udd17 Name UserTrigger () UserTrigger (const UserTrigger & rhs) UserTrigger ( UserTrigger && rhs) UserTrigger & operator= (const UserTrigger & rhs) UserTrigger & operator= ( UserTrigger && rhs) void trigger () If it is attached it will trigger otherwise it will do nothing. bool hasTriggered () const Checks if the UserTrigger was triggered. Friends \ud83d\udd17 Name class NotificationAttorney Public Functions Documentation \ud83d\udd17 function UserTrigger \ud83d\udd17 UserTrigger () function UserTrigger \ud83d\udd17 UserTrigger ( const UserTrigger & rhs ) function UserTrigger \ud83d\udd17 UserTrigger ( UserTrigger && rhs ) function operator= \ud83d\udd17 UserTrigger & operator = ( const UserTrigger & rhs ) function operator= \ud83d\udd17 UserTrigger & operator = ( UserTrigger && rhs ) function trigger \ud83d\udd17 void trigger () If it is attached it will trigger otherwise it will do nothing. Note : a user trigger cannot be triggered when it is not attached function hasTriggered \ud83d\udd17 bool hasTriggered () const Checks if the UserTrigger was triggered. Return : true if the UserTrigger is trigger, otherwise false. Note : The hasTrigger state will be reset after it was handled by a WaitSet/Listener Friends \ud83d\udd17 friend NotificationAttorney \ud83d\udd17 friend class NotificationAttorney ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#ioxpopousertrigger","text":"An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class. #include <iceoryx_posh/popo/user_trigger.hpp>","title":"iox::popo::UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#public-functions","text":"Name UserTrigger () UserTrigger (const UserTrigger & rhs) UserTrigger ( UserTrigger && rhs) UserTrigger & operator= (const UserTrigger & rhs) UserTrigger & operator= ( UserTrigger && rhs) void trigger () If it is attached it will trigger otherwise it will do nothing. bool hasTriggered () const Checks if the UserTrigger was triggered.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#friends","text":"Name class NotificationAttorney","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-usertrigger","text":"UserTrigger ()","title":"function UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-usertrigger_1","text":"UserTrigger ( const UserTrigger & rhs )","title":"function UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-usertrigger_2","text":"UserTrigger ( UserTrigger && rhs )","title":"function UserTrigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-operator","text":"UserTrigger & operator = ( const UserTrigger & rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-operator_1","text":"UserTrigger & operator = ( UserTrigger && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-trigger","text":"void trigger () If it is attached it will trigger otherwise it will do nothing. Note : a user trigger cannot be triggered when it is not attached","title":"function trigger"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#function-hastriggered","text":"bool hasTriggered () const Checks if the UserTrigger was triggered. Return : true if the UserTrigger is trigger, otherwise false. Note : The hasTrigger state will be reset after it was handled by a WaitSet/Listener","title":"function hasTriggered"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1UserTrigger/#friend-notificationattorney","text":"friend class NotificationAttorney ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend NotificationAttorney"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Void/","text":"iox::popo::Void \ud83d\udd17 Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Void"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1Void/#ioxpopovoid","text":"Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::Void"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/","text":"iox::popo::WaitSet \ud83d\udd17 Logical disjunction of a certain number of Triggers. More... #include <iceoryx_posh/popo/wait_set.hpp> Public Types \ud83d\udd17 Name using cxx::optional< Trigger >[Capacity] TriggerArray using cxx::vector< const NotificationInfo *, CAPACITY > NotificationInfoVector Public Functions \ud83d\udd17 Name WaitSet () ~WaitSet () WaitSet (const WaitSet & rhs) all the Trigger have a pointer pointing to this waitset for cleanup calls, therefore the WaitSet cannot be moved WaitSet ( WaitSet && rhs) WaitSet & operator= (const WaitSet & rhs) WaitSet & operator= ( WaitSet && rhs) void markForDestruction () Non-reversible call. After this call wait() and timedWait() do not block any longer and never return triggered events/states. This method can be used to manually initialize destruction and to wakeup any thread which is waiting in wait() or timedWait() . template <typename T ,typename EventType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value>> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const EventType eventType, const uint64_t notificationId =0U, const NotificationCallback < T, ContextDataType > & eventCallback ={}) attaches an event of a given class to the WaitSet . template <typename T ,typename EventType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value, void>> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const EventType eventType, const NotificationCallback < T, ContextDataType > & eventCallback) attaches an event of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const uint64_t notificationId =0U, const NotificationCallback < T, ContextDataType > & eventCallback ={}) attaches an event of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const NotificationCallback < T, ContextDataType > & eventCallback) attaches an event of a given class to the WaitSet . template <typename T ,typename StateType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value>> cxx::expected< WaitSetError > attachState (T & stateOrigin, const StateType stateType, const uint64_t id =0U, const NotificationCallback < T, ContextDataType > & stateCallback ={}) attaches a state of a given class to the WaitSet . template <typename T ,typename StateType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value, void>> cxx::expected< WaitSetError > attachState (T & stateOrigin, const StateType stateType, const NotificationCallback < T, ContextDataType > & stateCallback) attaches a state of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachState (T & stateOrigin, const uint64_t id =0U, const NotificationCallback < T, ContextDataType > & stateCallback ={}) attaches a state of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachState (T & stateOrigin, const NotificationCallback < T, ContextDataType > & stateCallback) attaches a state of a given class to the WaitSet . template <typename T ,typename... Targs> void detachEvent (T & eventOrigin, const Targs &... args) detaches an event from the WaitSet template <typename T ,typename... Targs> void detachState (T & stateOrigin, const Targs &... args) detaches a state based trigger from the WaitSet NotificationInfoVector timedWait (const units::Duration timeout) Blocking wait with time limit till one or more of the triggers are triggered. NotificationInfoVector wait () Blocking wait till one or more of the triggers are triggered. uint64_t size () const Returns the amount of stored Trigger inside of the WaitSet . constexpr uint64_t capacity () returns the maximum amount of triggers which can be acquired from a waitset Protected Functions \ud83d\udd17 Name WaitSet (ConditionVariableData & condVarData) Public Attributes \ud83d\udd17 Name constexpr uint64_t CAPACITY Detailed Description \ud83d\udd17 template < uint64_t Capacity = MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET > class iox :: popo :: WaitSet ; Logical disjunction of a certain number of Triggers. Parameters : Capacity the amount of events/states which can be attached to the waitset The WaitSet stores Triggers and allows the user to wait till one or more of those Triggers are triggered. It works over process borders. With the creation of a WaitSet it requests a condition variable from RouDi and destroys it with the destructor. Hence the lifetime of the condition variable is bound to the lifetime of the WaitSet . Public Types Documentation \ud83d\udd17 using TriggerArray \ud83d\udd17 using iox :: popo :: WaitSet < Capacity >:: TriggerArray = cxx :: optional < Trigger > [ Capacity ]; using NotificationInfoVector \ud83d\udd17 using iox :: popo :: WaitSet < Capacity >:: NotificationInfoVector = cxx :: vector < const NotificationInfo * , CAPACITY > ; Public Functions Documentation \ud83d\udd17 function WaitSet \ud83d\udd17 WaitSet () function ~WaitSet \ud83d\udd17 ~ WaitSet () function WaitSet \ud83d\udd17 WaitSet ( const WaitSet & rhs ) all the Trigger have a pointer pointing to this waitset for cleanup calls, therefore the WaitSet cannot be moved function WaitSet \ud83d\udd17 WaitSet ( WaitSet && rhs ) function operator= \ud83d\udd17 WaitSet & operator = ( const WaitSet & rhs ) function operator= \ud83d\udd17 WaitSet & operator = ( WaitSet && rhs ) function markForDestruction \ud83d\udd17 void markForDestruction () Non-reversible call. After this call wait() and timedWait() do not block any longer and never return triggered events/states. This method can be used to manually initialize destruction and to wakeup any thread which is waiting in wait() or timedWait() . function attachEvent \ud83d\udd17 template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType > & eventCallback = {} ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. eventType the event specified by the class notificationId an arbitrary user defined id for the event eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. function attachEvent \ud83d\udd17 template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value , void >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType > & eventCallback ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. eventType the event specified by the class eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. function attachEvent \ud83d\udd17 template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType > & eventCallback = {} ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. notificationId an arbitrary user defined id for the event eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. function attachEvent \ud83d\udd17 template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType > & eventCallback ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached. function attachState \ud83d\udd17 template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType > & stateCallback = {} ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. stateType the state specified by the class id an arbitrary user defined id for the state stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. function attachState \ud83d\udd17 template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value , void >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const NotificationCallback < T , ContextDataType > & stateCallback ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. stateType the state specified by the class stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. function attachState \ud83d\udd17 template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType > & stateCallback = {} ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. id an arbitrary user defined id for the state stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. function attachState \ud83d\udd17 template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const NotificationCallback < T , ContextDataType > & stateCallback ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached. function detachEvent \ud83d\udd17 template < typename T , typename ... Targs > void detachEvent ( T & eventOrigin , const Targs & ... args ) detaches an event from the WaitSet Parameters : eventOrigin the origin of the event that should be detached args... additional event identifying arguments function detachState \ud83d\udd17 template < typename T , typename ... Targs > void detachState ( T & stateOrigin , const Targs & ... args ) detaches a state based trigger from the WaitSet Parameters : stateOrigin the origin of the state that should be detached args... additional state identifying arguments function timedWait \ud83d\udd17 NotificationInfoVector timedWait ( const units :: Duration timeout ) Blocking wait with time limit till one or more of the triggers are triggered. Parameters : timeout How long shall we waite for a trigger Return : NotificationInfoVector of NotificationInfos that have been triggered function wait \ud83d\udd17 NotificationInfoVector wait () Blocking wait till one or more of the triggers are triggered. Return : NotificationInfoVector of NotificationInfos that have been triggered function size \ud83d\udd17 uint64_t size () const Returns the amount of stored Trigger inside of the WaitSet . function capacity \ud83d\udd17 static constexpr uint64_t capacity () returns the maximum amount of triggers which can be acquired from a waitset Protected Functions Documentation \ud83d\udd17 function WaitSet \ud83d\udd17 explicit WaitSet ( ConditionVariableData & condVarData ) Public Attributes Documentation \ud83d\udd17 variable CAPACITY \ud83d\udd17 static constexpr uint64_t CAPACITY = Capacity ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#ioxpopowaitset","text":"Logical disjunction of a certain number of Triggers. More... #include <iceoryx_posh/popo/wait_set.hpp>","title":"iox::popo::WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-types","text":"Name using cxx::optional< Trigger >[Capacity] TriggerArray using cxx::vector< const NotificationInfo *, CAPACITY > NotificationInfoVector","title":"Public Types"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-functions","text":"Name WaitSet () ~WaitSet () WaitSet (const WaitSet & rhs) all the Trigger have a pointer pointing to this waitset for cleanup calls, therefore the WaitSet cannot be moved WaitSet ( WaitSet && rhs) WaitSet & operator= (const WaitSet & rhs) WaitSet & operator= ( WaitSet && rhs) void markForDestruction () Non-reversible call. After this call wait() and timedWait() do not block any longer and never return triggered events/states. This method can be used to manually initialize destruction and to wakeup any thread which is waiting in wait() or timedWait() . template <typename T ,typename EventType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value>> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const EventType eventType, const uint64_t notificationId =0U, const NotificationCallback < T, ContextDataType > & eventCallback ={}) attaches an event of a given class to the WaitSet . template <typename T ,typename EventType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value, void>> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const EventType eventType, const NotificationCallback < T, ContextDataType > & eventCallback) attaches an event of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const uint64_t notificationId =0U, const NotificationCallback < T, ContextDataType > & eventCallback ={}) attaches an event of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachEvent (T & eventOrigin, const NotificationCallback < T, ContextDataType > & eventCallback) attaches an event of a given class to the WaitSet . template <typename T ,typename StateType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value>> cxx::expected< WaitSetError > attachState (T & stateOrigin, const StateType stateType, const uint64_t id =0U, const NotificationCallback < T, ContextDataType > & stateCallback ={}) attaches a state of a given class to the WaitSet . template <typename T ,typename StateType ,typename ContextDataType =internal::NoType_t,typename =std::enable_if_t ::value, void>> cxx::expected< WaitSetError > attachState (T & stateOrigin, const StateType stateType, const NotificationCallback < T, ContextDataType > & stateCallback) attaches a state of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachState (T & stateOrigin, const uint64_t id =0U, const NotificationCallback < T, ContextDataType > & stateCallback ={}) attaches a state of a given class to the WaitSet . template <typename T ,typename ContextDataType =internal::NoType_t> cxx::expected< WaitSetError > attachState (T & stateOrigin, const NotificationCallback < T, ContextDataType > & stateCallback) attaches a state of a given class to the WaitSet . template <typename T ,typename... Targs> void detachEvent (T & eventOrigin, const Targs &... args) detaches an event from the WaitSet template <typename T ,typename... Targs> void detachState (T & stateOrigin, const Targs &... args) detaches a state based trigger from the WaitSet NotificationInfoVector timedWait (const units::Duration timeout) Blocking wait with time limit till one or more of the triggers are triggered. NotificationInfoVector wait () Blocking wait till one or more of the triggers are triggered. uint64_t size () const Returns the amount of stored Trigger inside of the WaitSet . constexpr uint64_t capacity () returns the maximum amount of triggers which can be acquired from a waitset","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#protected-functions","text":"Name WaitSet (ConditionVariableData & condVarData)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-attributes","text":"Name constexpr uint64_t CAPACITY","title":"Public Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#detailed-description","text":"template < uint64_t Capacity = MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET > class iox :: popo :: WaitSet ; Logical disjunction of a certain number of Triggers. Parameters : Capacity the amount of events/states which can be attached to the waitset The WaitSet stores Triggers and allows the user to wait till one or more of those Triggers are triggered. It works over process borders. With the creation of a WaitSet it requests a condition variable from RouDi and destroys it with the destructor. Hence the lifetime of the condition variable is bound to the lifetime of the WaitSet .","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#using-triggerarray","text":"using iox :: popo :: WaitSet < Capacity >:: TriggerArray = cxx :: optional < Trigger > [ Capacity ];","title":"using TriggerArray"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#using-notificationinfovector","text":"using iox :: popo :: WaitSet < Capacity >:: NotificationInfoVector = cxx :: vector < const NotificationInfo * , CAPACITY > ;","title":"using NotificationInfoVector"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset","text":"WaitSet ()","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_1","text":"~ WaitSet ()","title":"function ~WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_2","text":"WaitSet ( const WaitSet & rhs ) all the Trigger have a pointer pointing to this waitset for cleanup calls, therefore the WaitSet cannot be moved","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_3","text":"WaitSet ( WaitSet && rhs )","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-operator","text":"WaitSet & operator = ( const WaitSet & rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-operator_1","text":"WaitSet & operator = ( WaitSet && rhs )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-markfordestruction","text":"void markForDestruction () Non-reversible call. After this call wait() and timedWait() do not block any longer and never return triggered events/states. This method can be used to manually initialize destruction and to wakeup any thread which is waiting in wait() or timedWait() .","title":"function markForDestruction"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent","text":"template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType > & eventCallback = {} ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. eventType the event specified by the class notificationId an arbitrary user defined id for the event eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached.","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent_1","text":"template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value , void >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType > & eventCallback ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. eventType the event specified by the class eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached.","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent_2","text":"template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType > & eventCallback = {} ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. notificationId an arbitrary user defined id for the event eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached.","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachevent_3","text":"template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType > & eventCallback ) attaches an event of a given class to the WaitSet . Parameters : eventOrigin the class from which the event originates. eventCallback a callback which should be assigned to the event Note : attachEvent does not take ownership of callback in the underlying eventCallback or the optional contextData. The user has to ensure that both will live as long as the event is attached.","title":"function attachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate","text":"template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType > & stateCallback = {} ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. stateType the state specified by the class id an arbitrary user defined id for the state stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached.","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate_1","text":"template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value , void >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const NotificationCallback < T , ContextDataType > & stateCallback ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. stateType the state specified by the class stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached.","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate_2","text":"template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType > & stateCallback = {} ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. id an arbitrary user defined id for the state stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached.","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-attachstate_3","text":"template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const NotificationCallback < T , ContextDataType > & stateCallback ) attaches a state of a given class to the WaitSet . Parameters : stateOrigin the class from which the state originates. stateCallback a callback which should be assigned to the state Note : attachState does not take ownership of callback in the underlying stateCallback or the optional contextData. The user has to ensure that both will live as long as the state is attached.","title":"function attachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-detachevent","text":"template < typename T , typename ... Targs > void detachEvent ( T & eventOrigin , const Targs & ... args ) detaches an event from the WaitSet Parameters : eventOrigin the origin of the event that should be detached args... additional event identifying arguments","title":"function detachEvent"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-detachstate","text":"template < typename T , typename ... Targs > void detachState ( T & stateOrigin , const Targs & ... args ) detaches a state based trigger from the WaitSet Parameters : stateOrigin the origin of the state that should be detached args... additional state identifying arguments","title":"function detachState"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-timedwait","text":"NotificationInfoVector timedWait ( const units :: Duration timeout ) Blocking wait with time limit till one or more of the triggers are triggered. Parameters : timeout How long shall we waite for a trigger Return : NotificationInfoVector of NotificationInfos that have been triggered","title":"function timedWait"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-wait","text":"NotificationInfoVector wait () Blocking wait till one or more of the triggers are triggered. Return : NotificationInfoVector of NotificationInfos that have been triggered","title":"function wait"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-size","text":"uint64_t size () const Returns the amount of stored Trigger inside of the WaitSet .","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-capacity","text":"static constexpr uint64_t capacity () returns the maximum amount of triggers which can be acquired from a waitset","title":"function capacity"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#function-waitset_4","text":"explicit WaitSet ( ConditionVariableData & condVarData )","title":"function WaitSet"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1popo_1_1WaitSet/#variable-capacity","text":"static constexpr uint64_t CAPACITY = Capacity ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable CAPACITY"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/","text":"iox::roudi::GenericMemoryBlock \ud83d\udd17 The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. More... #include <iceoryx_posh/roudi/memory/generic_memory_block.hpp> Inherits from iox::roudi::MemoryBlock Public Functions \ud83d\udd17 Name GenericMemoryBlock () =default ~GenericMemoryBlock () GenericMemoryBlock (const GenericMemoryBlock & ) GenericMemoryBlock ( GenericMemoryBlock && ) GenericMemoryBlock & operator= (const GenericMemoryBlock & ) GenericMemoryBlock & operator= ( GenericMemoryBlock && ) virtual uint64_t size () const override This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. virtual uint64_t alignment () const override This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . template <typename... Targs> cxx::optional< T * > emplace (Targs &&... args) A new element is constructed by forwarding the arguments to the constructor of T. If the MemoryBlock has a value then the destructor of T is called. cxx::optional< T * > value () const This function enables the access to the underlying type. Protected Functions \ud83d\udd17 Name virtual void destroy () override The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. Friends \ud83d\udd17 Name class MemoryProvider Additional inherited members \ud83d\udd17 Public Functions inherited from iox::roudi::MemoryBlock Name MemoryBlock () =default virtual ~MemoryBlock () =default MemoryBlock (const MemoryBlock & ) MemoryBlock ( MemoryBlock && ) cxx::optional< void * > memory () const This function provides the pointer to the requested memory. Protected Functions inherited from iox::roudi::MemoryBlock Name virtual void onMemoryAvailable (cxx::not_null< void * > memory) This function is called once the memory is available and is therefore the earliest possibility to use the memory. Detailed Description \ud83d\udd17 template < typename T > class iox :: roudi :: GenericMemoryBlock ; The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. Public Functions Documentation \ud83d\udd17 function GenericMemoryBlock \ud83d\udd17 GenericMemoryBlock () = default function ~GenericMemoryBlock \ud83d\udd17 ~ GenericMemoryBlock () function GenericMemoryBlock \ud83d\udd17 GenericMemoryBlock ( const GenericMemoryBlock & ) function GenericMemoryBlock \ud83d\udd17 GenericMemoryBlock ( GenericMemoryBlock && ) function operator= \ud83d\udd17 GenericMemoryBlock & operator = ( const GenericMemoryBlock & ) function operator= \ud83d\udd17 GenericMemoryBlock & operator = ( GenericMemoryBlock && ) function size \ud83d\udd17 virtual uint64_t size () const override This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. Return : the required memory as multiple of the alignment Note : The size of the underlying type T Reimplements : iox::roudi::MemoryBlock::size function alignment \ud83d\udd17 virtual uint64_t alignment () const override This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . Return : the alignment of the underlying data. Note : The alignment of the underlying type T Reimplements : iox::roudi::MemoryBlock::alignment function emplace \ud83d\udd17 template < typename ... Targs > cxx :: optional < T * > emplace ( Targs && ... args ) A new element is constructed by forwarding the arguments to the constructor of T. If the MemoryBlock has a value then the destructor of T is called. Parameters : args are perfectly forwarded to the constructor of T to perform a placement new Return : an optional pointer to the underlying type, cxx::nullopt_t if memory was not yet available function value \ud83d\udd17 cxx :: optional < T * > value () const This function enables the access to the underlying type. Return : an optional pointer to the underlying type, cxx::nullopt_t if value is not initialized Protected Functions Documentation \ud83d\udd17 function destroy \ud83d\udd17 virtual void destroy () override The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. Note : This function can be called multiple times. Make sure that the implementation can handle this. This will destroy the underlying type T Reimplements : iox::roudi::MemoryBlock::destroy Friends \ud83d\udd17 friend MemoryProvider \ud83d\udd17 friend class MemoryProvider ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#ioxroudigenericmemoryblock","text":"The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. More... #include <iceoryx_posh/roudi/memory/generic_memory_block.hpp> Inherits from iox::roudi::MemoryBlock","title":"iox::roudi::GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#public-functions","text":"Name GenericMemoryBlock () =default ~GenericMemoryBlock () GenericMemoryBlock (const GenericMemoryBlock & ) GenericMemoryBlock ( GenericMemoryBlock && ) GenericMemoryBlock & operator= (const GenericMemoryBlock & ) GenericMemoryBlock & operator= ( GenericMemoryBlock && ) virtual uint64_t size () const override This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. virtual uint64_t alignment () const override This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . template <typename... Targs> cxx::optional< T * > emplace (Targs &&... args) A new element is constructed by forwarding the arguments to the constructor of T. If the MemoryBlock has a value then the destructor of T is called. cxx::optional< T * > value () const This function enables the access to the underlying type.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#protected-functions","text":"Name virtual void destroy () override The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#friends","text":"Name class MemoryProvider","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#additional-inherited-members","text":"Public Functions inherited from iox::roudi::MemoryBlock Name MemoryBlock () =default virtual ~MemoryBlock () =default MemoryBlock (const MemoryBlock & ) MemoryBlock ( MemoryBlock && ) cxx::optional< void * > memory () const This function provides the pointer to the requested memory. Protected Functions inherited from iox::roudi::MemoryBlock Name virtual void onMemoryAvailable (cxx::not_null< void * > memory) This function is called once the memory is available and is therefore the earliest possibility to use the memory.","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#detailed-description","text":"template < typename T > class iox :: roudi :: GenericMemoryBlock ; The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case.","title":"Detailed Description"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock","text":"GenericMemoryBlock () = default","title":"function GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock_1","text":"~ GenericMemoryBlock ()","title":"function ~GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock_2","text":"GenericMemoryBlock ( const GenericMemoryBlock & )","title":"function GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-genericmemoryblock_3","text":"GenericMemoryBlock ( GenericMemoryBlock && )","title":"function GenericMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-operator","text":"GenericMemoryBlock & operator = ( const GenericMemoryBlock & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-operator_1","text":"GenericMemoryBlock & operator = ( GenericMemoryBlock && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-size","text":"virtual uint64_t size () const override This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. Return : the required memory as multiple of the alignment Note : The size of the underlying type T Reimplements : iox::roudi::MemoryBlock::size","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-alignment","text":"virtual uint64_t alignment () const override This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . Return : the alignment of the underlying data. Note : The alignment of the underlying type T Reimplements : iox::roudi::MemoryBlock::alignment","title":"function alignment"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-emplace","text":"template < typename ... Targs > cxx :: optional < T * > emplace ( Targs && ... args ) A new element is constructed by forwarding the arguments to the constructor of T. If the MemoryBlock has a value then the destructor of T is called. Parameters : args are perfectly forwarded to the constructor of T to perform a placement new Return : an optional pointer to the underlying type, cxx::nullopt_t if memory was not yet available","title":"function emplace"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-value","text":"cxx :: optional < T * > value () const This function enables the access to the underlying type. Return : an optional pointer to the underlying type, cxx::nullopt_t if value is not initialized","title":"function value"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#function-destroy","text":"virtual void destroy () override The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. Note : This function can be called multiple times. Make sure that the implementation can handle this. This will destroy the underlying type T Reimplements : iox::roudi::MemoryBlock::destroy","title":"function destroy"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1GenericMemoryBlock/#friend-memoryprovider","text":"friend class MemoryProvider ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/","text":"iox::roudi::IceOryxRouDiApp \ud83d\udd17 Inherits from iox::roudi::RouDiApp Public Functions \ud83d\udd17 Name IceOryxRouDiApp (const config::CmdLineArgs_t & cmdLineArgs, const RouDiConfig_t & roudiConfig) constructor to create the RouDi daemon with a given config virtual uint8_t run () override starts the execution of the RouDi daemon Additional inherited members \ud83d\udd17 Public Functions inherited from iox::roudi::RouDiApp Name void roudiSigHandler (int32_t signal) Method passed to the OS signal handler. RouDiApp (const config::CmdLineArgs_t & cmdLineArgs, const RouDiConfig_t & config) C'tor with command line parser, which has already parsed the command line parameters. virtual ~RouDiApp () Protected Functions inherited from iox::roudi::RouDiApp Name void registerSigHandler () Tells the OS which signals shall be hooked. bool waitForSignal () waits for the next signal to RouDi daemon Protected Attributes inherited from iox::roudi::RouDiApp Name iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode bool m_run RouDiConfig_t m_config posix::Semaphore m_semaphore version::CompatibilityCheckLevel m_compatibilityCheckLevel units::Duration m_processKillDelay Public Functions Documentation \ud83d\udd17 function IceOryxRouDiApp \ud83d\udd17 IceOryxRouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & roudiConfig ) constructor to create the RouDi daemon with a given config Parameters : Command liner parser object, that provides the settings RouDi config for mempool configuration function run \ud83d\udd17 virtual uint8_t run () override starts the execution of the RouDi daemon Return : Return code for programm execution Reimplements : iox::roudi::RouDiApp::run Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::IceOryxRouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#ioxroudiiceoryxroudiapp","text":"Inherits from iox::roudi::RouDiApp","title":"iox::roudi::IceOryxRouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#public-functions","text":"Name IceOryxRouDiApp (const config::CmdLineArgs_t & cmdLineArgs, const RouDiConfig_t & roudiConfig) constructor to create the RouDi daemon with a given config virtual uint8_t run () override starts the execution of the RouDi daemon","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#additional-inherited-members","text":"Public Functions inherited from iox::roudi::RouDiApp Name void roudiSigHandler (int32_t signal) Method passed to the OS signal handler. RouDiApp (const config::CmdLineArgs_t & cmdLineArgs, const RouDiConfig_t & config) C'tor with command line parser, which has already parsed the command line parameters. virtual ~RouDiApp () Protected Functions inherited from iox::roudi::RouDiApp Name void registerSigHandler () Tells the OS which signals shall be hooked. bool waitForSignal () waits for the next signal to RouDi daemon Protected Attributes inherited from iox::roudi::RouDiApp Name iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode bool m_run RouDiConfig_t m_config posix::Semaphore m_semaphore version::CompatibilityCheckLevel m_compatibilityCheckLevel units::Duration m_processKillDelay","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#function-iceoryxroudiapp","text":"IceOryxRouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & roudiConfig ) constructor to create the RouDi daemon with a given config Parameters : Command liner parser object, that provides the settings RouDi config for mempool configuration","title":"function IceOryxRouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiApp/#function-run","text":"virtual uint8_t run () override starts the execution of the RouDi daemon Return : Return code for programm execution Reimplements : iox::roudi::RouDiApp::run Updated on 18 December 2023 at 13:11:43 CET","title":"function run"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/","text":"iox::roudi::IceOryxRouDiMemoryManager \ud83d\udd17 Inherits from iox::roudi::RouDiMemoryInterface Public Functions \ud83d\udd17 Name IceOryxRouDiMemoryManager (const RouDiConfig_t & roudiConfig) virtual ~IceOryxRouDiMemoryManager () =default The Destructor of the IceOryxRouDiMemoryManager also calls destroy on the registered MemoryProvider . IceOryxRouDiMemoryManager ( IceOryxRouDiMemoryManager && ) IceOryxRouDiMemoryManager & operator= ( IceOryxRouDiMemoryManager && ) IceOryxRouDiMemoryManager (const IceOryxRouDiMemoryManager & ) IceOryxRouDiMemoryManager & operator= (const IceOryxRouDiMemoryManager & ) virtual cxx::expected< RouDiMemoryManagerError > createAndAnnounceMemory () override The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. virtual cxx::expected< RouDiMemoryManagerError > destroyMemory () override The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const override virtual cxx::optional< PortPool * > portPool () override virtual cxx::optional< mepoo::MemoryManager * > introspectionMemoryManager () const override virtual cxx::optional< mepoo::SegmentManager<> * > segmentManager () const override Additional inherited members \ud83d\udd17 Public Functions inherited from iox::roudi::RouDiMemoryInterface Name RouDiMemoryInterface () =default virtual ~RouDiMemoryInterface () =default The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider . RouDiMemoryInterface ( RouDiMemoryInterface && ) RouDiMemoryInterface (const RouDiMemoryInterface & ) Public Functions Documentation \ud83d\udd17 function IceOryxRouDiMemoryManager \ud83d\udd17 IceOryxRouDiMemoryManager ( const RouDiConfig_t & roudiConfig ) function ~IceOryxRouDiMemoryManager \ud83d\udd17 virtual ~ IceOryxRouDiMemoryManager () = default The Destructor of the IceOryxRouDiMemoryManager also calls destroy on the registered MemoryProvider . function IceOryxRouDiMemoryManager \ud83d\udd17 IceOryxRouDiMemoryManager ( IceOryxRouDiMemoryManager && ) function operator= \ud83d\udd17 IceOryxRouDiMemoryManager & operator = ( IceOryxRouDiMemoryManager && ) function IceOryxRouDiMemoryManager \ud83d\udd17 IceOryxRouDiMemoryManager ( const IceOryxRouDiMemoryManager & ) function operator= \ud83d\udd17 IceOryxRouDiMemoryManager & operator = ( const IceOryxRouDiMemoryManager & ) function createAndAnnounceMemory \ud83d\udd17 virtual cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () override The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. Return : an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success Reimplements : iox::roudi::RouDiMemoryInterface::createAndAnnounceMemory function destroyMemory \ud83d\udd17 virtual cxx :: expected < RouDiMemoryManagerError > destroyMemory () override The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Reimplements : iox::roudi::RouDiMemoryInterface::destroyMemory function mgmtMemoryProvider \ud83d\udd17 virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const override Reimplements : iox::roudi::RouDiMemoryInterface::mgmtMemoryProvider function portPool \ud83d\udd17 virtual cxx :: optional < PortPool * > portPool () override Reimplements : iox::roudi::RouDiMemoryInterface::portPool function introspectionMemoryManager \ud83d\udd17 virtual cxx :: optional < mepoo :: MemoryManager * > introspectionMemoryManager () const override Reimplements : iox::roudi::RouDiMemoryInterface::introspectionMemoryManager function segmentManager \ud83d\udd17 virtual cxx :: optional < mepoo :: SegmentManager <> * > segmentManager () const override Reimplements : iox::roudi::RouDiMemoryInterface::segmentManager Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#ioxroudiiceoryxroudimemorymanager","text":"Inherits from iox::roudi::RouDiMemoryInterface","title":"iox::roudi::IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#public-functions","text":"Name IceOryxRouDiMemoryManager (const RouDiConfig_t & roudiConfig) virtual ~IceOryxRouDiMemoryManager () =default The Destructor of the IceOryxRouDiMemoryManager also calls destroy on the registered MemoryProvider . IceOryxRouDiMemoryManager ( IceOryxRouDiMemoryManager && ) IceOryxRouDiMemoryManager & operator= ( IceOryxRouDiMemoryManager && ) IceOryxRouDiMemoryManager (const IceOryxRouDiMemoryManager & ) IceOryxRouDiMemoryManager & operator= (const IceOryxRouDiMemoryManager & ) virtual cxx::expected< RouDiMemoryManagerError > createAndAnnounceMemory () override The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. virtual cxx::expected< RouDiMemoryManagerError > destroyMemory () override The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const override virtual cxx::optional< PortPool * > portPool () override virtual cxx::optional< mepoo::MemoryManager * > introspectionMemoryManager () const override virtual cxx::optional< mepoo::SegmentManager<> * > segmentManager () const override","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#additional-inherited-members","text":"Public Functions inherited from iox::roudi::RouDiMemoryInterface Name RouDiMemoryInterface () =default virtual ~RouDiMemoryInterface () =default The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider . RouDiMemoryInterface ( RouDiMemoryInterface && ) RouDiMemoryInterface (const RouDiMemoryInterface & )","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager","text":"IceOryxRouDiMemoryManager ( const RouDiConfig_t & roudiConfig )","title":"function IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager_1","text":"virtual ~ IceOryxRouDiMemoryManager () = default The Destructor of the IceOryxRouDiMemoryManager also calls destroy on the registered MemoryProvider .","title":"function ~IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager_2","text":"IceOryxRouDiMemoryManager ( IceOryxRouDiMemoryManager && )","title":"function IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-operator","text":"IceOryxRouDiMemoryManager & operator = ( IceOryxRouDiMemoryManager && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-iceoryxroudimemorymanager_3","text":"IceOryxRouDiMemoryManager ( const IceOryxRouDiMemoryManager & )","title":"function IceOryxRouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-operator_1","text":"IceOryxRouDiMemoryManager & operator = ( const IceOryxRouDiMemoryManager & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-createandannouncememory","text":"virtual cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () override The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. Return : an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success Reimplements : iox::roudi::RouDiMemoryInterface::createAndAnnounceMemory","title":"function createAndAnnounceMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-destroymemory","text":"virtual cxx :: expected < RouDiMemoryManagerError > destroyMemory () override The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Reimplements : iox::roudi::RouDiMemoryInterface::destroyMemory","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-mgmtmemoryprovider","text":"virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const override Reimplements : iox::roudi::RouDiMemoryInterface::mgmtMemoryProvider","title":"function mgmtMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-portpool","text":"virtual cxx :: optional < PortPool * > portPool () override Reimplements : iox::roudi::RouDiMemoryInterface::portPool","title":"function portPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-introspectionmemorymanager","text":"virtual cxx :: optional < mepoo :: MemoryManager * > introspectionMemoryManager () const override Reimplements : iox::roudi::RouDiMemoryInterface::introspectionMemoryManager","title":"function introspectionMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1IceOryxRouDiMemoryManager/#function-segmentmanager","text":"virtual cxx :: optional < mepoo :: SegmentManager <> * > segmentManager () const override Reimplements : iox::roudi::RouDiMemoryInterface::segmentManager Updated on 18 December 2023 at 13:11:43 CET","title":"function segmentManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/","text":"iox::roudi::MemoryBlock \ud83d\udd17 The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider , which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case. #include <iceoryx_posh/roudi/memory/memory_block.hpp> Inherited by iox::roudi::GenericMemoryBlock< T > Public Functions \ud83d\udd17 Name MemoryBlock () =default virtual ~MemoryBlock () =default MemoryBlock (const MemoryBlock & ) MemoryBlock ( MemoryBlock && ) MemoryBlock & operator= (const MemoryBlock & ) MemoryBlock & operator= ( MemoryBlock && ) virtual uint64_t size () const =0 This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. virtual uint64_t alignment () const =0 This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . cxx::optional< void * > memory () const This function provides the pointer to the requested memory. Protected Functions \ud83d\udd17 Name virtual void destroy () =0 The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. virtual void onMemoryAvailable (cxx::not_null< void * > memory) This function is called once the memory is available and is therefore the earliest possibility to use the memory. Friends \ud83d\udd17 Name class MemoryProvider Public Functions Documentation \ud83d\udd17 function MemoryBlock \ud83d\udd17 MemoryBlock () = default function ~MemoryBlock \ud83d\udd17 virtual ~ MemoryBlock () = default function MemoryBlock \ud83d\udd17 MemoryBlock ( const MemoryBlock & ) Note : this is intentional not movable/copyable, since a pointer to the memory block is registered at a MemoryProvider and therefore an instance of a MemoryBlock must be pinned to memory function MemoryBlock \ud83d\udd17 MemoryBlock ( MemoryBlock && ) function operator= \ud83d\udd17 MemoryBlock & operator = ( const MemoryBlock & ) function operator= \ud83d\udd17 MemoryBlock & operator = ( MemoryBlock && ) function size \ud83d\udd17 virtual uint64_t size () const = 0 This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. Return : the required memory as multiple of the alignment Reimplemented by : iox::roudi::GenericMemoryBlock::size function alignment \ud83d\udd17 virtual uint64_t alignment () const = 0 This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . Return : the alignment of the underlying data. Reimplemented by : iox::roudi::GenericMemoryBlock::alignment function memory \ud83d\udd17 cxx :: optional < void * > memory () const This function provides the pointer to the requested memory. Return : an optional pointer to a memory block with the requested size and alignment if the memory is available, otherwise a cxx::nullopt_t Protected Functions Documentation \ud83d\udd17 function destroy \ud83d\udd17 virtual void destroy () = 0 The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. Note : This function can be called multiple times. Make sure that the implementation can handle this. Reimplemented by : iox::roudi::GenericMemoryBlock::destroy function onMemoryAvailable \ud83d\udd17 virtual void onMemoryAvailable ( cxx :: not_null < void * > memory ) This function is called once the memory is available and is therefore the earliest possibility to use the memory. Parameters : memory pointer to a valid memory block, the same one that the memory() member function would return Friends \ud83d\udd17 friend MemoryProvider \ud83d\udd17 friend class MemoryProvider ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#ioxroudimemoryblock","text":"The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider , which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case. #include <iceoryx_posh/roudi/memory/memory_block.hpp> Inherited by iox::roudi::GenericMemoryBlock< T >","title":"iox::roudi::MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#public-functions","text":"Name MemoryBlock () =default virtual ~MemoryBlock () =default MemoryBlock (const MemoryBlock & ) MemoryBlock ( MemoryBlock && ) MemoryBlock & operator= (const MemoryBlock & ) MemoryBlock & operator= ( MemoryBlock && ) virtual uint64_t size () const =0 This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. virtual uint64_t alignment () const =0 This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . cxx::optional< void * > memory () const This function provides the pointer to the requested memory.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#protected-functions","text":"Name virtual void destroy () =0 The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. virtual void onMemoryAvailable (cxx::not_null< void * > memory) This function is called once the memory is available and is therefore the earliest possibility to use the memory.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#friends","text":"Name class MemoryProvider","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock","text":"MemoryBlock () = default","title":"function MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock_1","text":"virtual ~ MemoryBlock () = default","title":"function ~MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock_2","text":"MemoryBlock ( const MemoryBlock & ) Note : this is intentional not movable/copyable, since a pointer to the memory block is registered at a MemoryProvider and therefore an instance of a MemoryBlock must be pinned to memory","title":"function MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memoryblock_3","text":"MemoryBlock ( MemoryBlock && )","title":"function MemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-operator","text":"MemoryBlock & operator = ( const MemoryBlock & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-operator_1","text":"MemoryBlock & operator = ( MemoryBlock && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-size","text":"virtual uint64_t size () const = 0 This function provides the size of the required memory for the underlying data. It is needed for the MemoryProvider to calculate the total size of memory. Return : the required memory as multiple of the alignment Reimplemented by : iox::roudi::GenericMemoryBlock::size","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-alignment","text":"virtual uint64_t alignment () const = 0 This function provides the alignment of the memory for the underlying data. This information is needed for the MemoryProvider . Return : the alignment of the underlying data. Reimplemented by : iox::roudi::GenericMemoryBlock::alignment","title":"function alignment"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-memory","text":"cxx :: optional < void * > memory () const This function provides the pointer to the requested memory. Return : an optional pointer to a memory block with the requested size and alignment if the memory is available, otherwise a cxx::nullopt_t","title":"function memory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-destroy","text":"virtual void destroy () = 0 The MemoryProvider calls this either when MemoryProvider::destroy is called or in its destructor. Note : This function can be called multiple times. Make sure that the implementation can handle this. Reimplemented by : iox::roudi::GenericMemoryBlock::destroy","title":"function destroy"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#function-onmemoryavailable","text":"virtual void onMemoryAvailable ( cxx :: not_null < void * > memory ) This function is called once the memory is available and is therefore the earliest possibility to use the memory. Parameters : memory pointer to a valid memory block, the same one that the memory() member function would return","title":"function onMemoryAvailable"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryBlock/#friend-memoryprovider","text":"friend class MemoryProvider ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/","text":"iox::roudi::MemoryProvider \ud83d\udd17 This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider . #include <iceoryx_posh/roudi/memory/memory_provider.hpp> Inherited by iox::roudi::PosixShmMemoryProvider Public Functions \ud83d\udd17 Name MemoryProvider () =default virtual ~MemoryProvider () MemoryProvider (const MemoryProvider & ) MemoryProvider ( MemoryProvider && ) MemoryProvider & operator= (const MemoryProvider & ) MemoryProvider & operator= ( MemoryProvider && ) cxx::expected< MemoryProviderError > addMemoryBlock (cxx::not_null< MemoryBlock * > memoryBlock) This function add a MemoryBlock to the list of memory requester. cxx::expected< MemoryProviderError > create () With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider . void announceMemoryAvailable () This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::expected< MemoryProviderError > destroy () This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::optional< void * > baseAddress () const This function provides the base address of the created memory. uint64_t size () const This function provides the size of the created memory. cxx::optional< uint64_t > segmentId () const This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider . bool isAvailable () const This function can be used to check if the requested memory is already available. bool isAvailableAnnounced () const This function can be used to check if the availability of the memory was announced to the MemoryBlocks. Protected Functions \ud83d\udd17 Name virtual cxx::expected< void *, MemoryProviderError > createMemory (const uint64_t size, const uint64_t alignment) =0 This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. virtual cxx::expected< MemoryProviderError > destroyMemory () =0 This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. const char * getErrorString (const MemoryProviderError error) Friends \ud83d\udd17 Name class RouDiMemoryManager Public Functions Documentation \ud83d\udd17 function MemoryProvider \ud83d\udd17 MemoryProvider () = default function ~MemoryProvider \ud83d\udd17 virtual ~ MemoryProvider () function MemoryProvider \ud83d\udd17 MemoryProvider ( const MemoryProvider & ) Note : this is intentional not movable/copyable, since a pointer to the memory provider is registered at the RouDiMemoryManager and therefore an instance of a MemoryProvider must be pinned to memory function MemoryProvider \ud83d\udd17 MemoryProvider ( MemoryProvider && ) function operator= \ud83d\udd17 MemoryProvider & operator = ( const MemoryProvider & ) function operator= \ud83d\udd17 MemoryProvider & operator = ( MemoryProvider && ) function addMemoryBlock \ud83d\udd17 cxx :: expected < MemoryProviderError > addMemoryBlock ( cxx :: not_null < MemoryBlock * > memoryBlock ) This function add a MemoryBlock to the list of memory requester. Parameters : memoryBlock is a pointer to a user defined MemoryBlock Return : an MemoryProviderError::MEMORY_BLOCKS_EXHAUSTED error if no further memory blocks can be added, otherwise success function create \ud83d\udd17 cxx :: expected < MemoryProviderError > create () With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider . Return : an MemoryProviderError if memory allocation was not successful, otherwise success function announceMemoryAvailable \ud83d\udd17 void announceMemoryAvailable () This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider . function destroy \ud83d\udd17 cxx :: expected < MemoryProviderError > destroy () This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider . Return : an error if memory destruction was not successful, otherwise success function baseAddress \ud83d\udd17 cxx :: optional < void * > baseAddress () const This function provides the base address of the created memory. Return : an optional pointer to the base address of the created memory if the memory is available, otherwise a cxx::nullopt_t function size \ud83d\udd17 uint64_t size () const This function provides the size of the created memory. Return : the size of the created memory function segmentId \ud83d\udd17 cxx :: optional < uint64_t > segmentId () const This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider . Return : an optional segment id for the created memory if the memory is available, otherwise cxx::nullopt_t function isAvailable \ud83d\udd17 bool isAvailable () const This function can be used to check if the requested memory is already available. Return : true if the requested memory is available, false otherwise function isAvailableAnnounced \ud83d\udd17 bool isAvailableAnnounced () const This function can be used to check if the availability of the memory was announced to the MemoryBlocks. Return : true if the availability of the memory was announced to the MemoryBlocks, false otherwise Protected Functions Documentation \ud83d\udd17 function createMemory \ud83d\udd17 virtual cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) = 0 This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. Parameters : size is the size in bytes for the requested memory, the size should already be calculated according to the alignment requirements alignment the required alignment for the memory Return : the pointer of the begin of the created memory or a MemoryProviderError if the memory could not be created Reimplemented by : iox::roudi::PosixShmMemoryProvider::createMemory function destroyMemory \ud83d\udd17 virtual cxx :: expected < MemoryProviderError > destroyMemory () = 0 This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. Return : a MemoryProviderError if the destruction failed, otherwise success Reimplemented by : iox::roudi::PosixShmMemoryProvider::destroyMemory function getErrorString \ud83d\udd17 static const char * getErrorString ( const MemoryProviderError error ) Friends \ud83d\udd17 friend RouDiMemoryManager \ud83d\udd17 friend class RouDiMemoryManager ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#ioxroudimemoryprovider","text":"This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider . #include <iceoryx_posh/roudi/memory/memory_provider.hpp> Inherited by iox::roudi::PosixShmMemoryProvider","title":"iox::roudi::MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#public-functions","text":"Name MemoryProvider () =default virtual ~MemoryProvider () MemoryProvider (const MemoryProvider & ) MemoryProvider ( MemoryProvider && ) MemoryProvider & operator= (const MemoryProvider & ) MemoryProvider & operator= ( MemoryProvider && ) cxx::expected< MemoryProviderError > addMemoryBlock (cxx::not_null< MemoryBlock * > memoryBlock) This function add a MemoryBlock to the list of memory requester. cxx::expected< MemoryProviderError > create () With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider . void announceMemoryAvailable () This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::expected< MemoryProviderError > destroy () This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::optional< void * > baseAddress () const This function provides the base address of the created memory. uint64_t size () const This function provides the size of the created memory. cxx::optional< uint64_t > segmentId () const This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider . bool isAvailable () const This function can be used to check if the requested memory is already available. bool isAvailableAnnounced () const This function can be used to check if the availability of the memory was announced to the MemoryBlocks.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#protected-functions","text":"Name virtual cxx::expected< void *, MemoryProviderError > createMemory (const uint64_t size, const uint64_t alignment) =0 This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. virtual cxx::expected< MemoryProviderError > destroyMemory () =0 This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. const char * getErrorString (const MemoryProviderError error)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#friends","text":"Name class RouDiMemoryManager","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider","text":"MemoryProvider () = default","title":"function MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider_1","text":"virtual ~ MemoryProvider ()","title":"function ~MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider_2","text":"MemoryProvider ( const MemoryProvider & ) Note : this is intentional not movable/copyable, since a pointer to the memory provider is registered at the RouDiMemoryManager and therefore an instance of a MemoryProvider must be pinned to memory","title":"function MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-memoryprovider_3","text":"MemoryProvider ( MemoryProvider && )","title":"function MemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-operator","text":"MemoryProvider & operator = ( const MemoryProvider & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-operator_1","text":"MemoryProvider & operator = ( MemoryProvider && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-addmemoryblock","text":"cxx :: expected < MemoryProviderError > addMemoryBlock ( cxx :: not_null < MemoryBlock * > memoryBlock ) This function add a MemoryBlock to the list of memory requester. Parameters : memoryBlock is a pointer to a user defined MemoryBlock Return : an MemoryProviderError::MEMORY_BLOCKS_EXHAUSTED error if no further memory blocks can be added, otherwise success","title":"function addMemoryBlock"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-create","text":"cxx :: expected < MemoryProviderError > create () With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider . Return : an MemoryProviderError if memory allocation was not successful, otherwise success","title":"function create"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-announcememoryavailable","text":"void announceMemoryAvailable () This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider .","title":"function announceMemoryAvailable"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-destroy","text":"cxx :: expected < MemoryProviderError > destroy () This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider . Return : an error if memory destruction was not successful, otherwise success","title":"function destroy"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-baseaddress","text":"cxx :: optional < void * > baseAddress () const This function provides the base address of the created memory. Return : an optional pointer to the base address of the created memory if the memory is available, otherwise a cxx::nullopt_t","title":"function baseAddress"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-size","text":"uint64_t size () const This function provides the size of the created memory. Return : the size of the created memory","title":"function size"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-segmentid","text":"cxx :: optional < uint64_t > segmentId () const This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider . Return : an optional segment id for the created memory if the memory is available, otherwise cxx::nullopt_t","title":"function segmentId"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-isavailable","text":"bool isAvailable () const This function can be used to check if the requested memory is already available. Return : true if the requested memory is available, false otherwise","title":"function isAvailable"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-isavailableannounced","text":"bool isAvailableAnnounced () const This function can be used to check if the availability of the memory was announced to the MemoryBlocks. Return : true if the availability of the memory was announced to the MemoryBlocks, false otherwise","title":"function isAvailableAnnounced"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-creatememory","text":"virtual cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) = 0 This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. Parameters : size is the size in bytes for the requested memory, the size should already be calculated according to the alignment requirements alignment the required alignment for the memory Return : the pointer of the begin of the created memory or a MemoryProviderError if the memory could not be created Reimplemented by : iox::roudi::PosixShmMemoryProvider::createMemory","title":"function createMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-destroymemory","text":"virtual cxx :: expected < MemoryProviderError > destroyMemory () = 0 This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. Return : a MemoryProviderError if the destruction failed, otherwise success Reimplemented by : iox::roudi::PosixShmMemoryProvider::destroyMemory","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#function-geterrorstring","text":"static const char * getErrorString ( const MemoryProviderError error )","title":"function getErrorString"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1MemoryProvider/#friend-roudimemorymanager","text":"friend class RouDiMemoryManager ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/","text":"iox::roudi::PortPool \ud83d\udd17 Public Functions \ud83d\udd17 Name PortPool (PortPoolData & portPoolData) virtual ~PortPool () =default cxx::vector< PublisherPortRouDiType::MemberType_t *, MAX_PUBLISHERS > getPublisherPortDataList () cxx::vector< SubscriberPortType::MemberType_t *, MAX_SUBSCRIBERS > getSubscriberPortDataList () cxx::vector< popo::ClientPortData *, MAX_CLIENTS > getClientPortDataList () cxx::vector< popo::ServerPortData *, MAX_SERVERS > getServerPortDataList () cxx::vector< popo::InterfacePortData *, MAX_INTERFACE_NUMBER > getInterfacePortDataList () cxx::vector< runtime::NodeData *, MAX_NODE_NUMBER > getNodeDataList () cxx::vector< popo::ConditionVariableData *, MAX_NUMBER_OF_CONDITION_VARIABLES > getConditionVariableDataList () cxx::expected< PublisherPortRouDiType::MemberType_t *, PortPoolError > addPublisherPort (const capro::ServiceDescription & serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t & runtimeName, const popo::PublisherOptions & publisherOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) cxx::expected< SubscriberPortType::MemberType_t *, PortPoolError > addSubscriberPort (const capro::ServiceDescription & serviceDescription, const RuntimeName_t & runtimeName, const popo::SubscriberOptions & subscriberOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) template <typename T ,std::enable_if_t< std::is_same< T, iox::build::ManyToManyPolicy >::value > * =nullptr> iox::popo::SubscriberPortData * constructSubscriber (const capro::ServiceDescription & serviceDescription, const RuntimeName_t & runtimeName, const popo::SubscriberOptions & subscriberOptions, const mepoo::MemoryInfo & memoryInfo) template <typename T ,std::enable_if_t< std::is_same< T, iox::build::OneToManyPolicy >::value > * =nullptr> iox::popo::SubscriberPortData * constructSubscriber (const capro::ServiceDescription & serviceDescription, const RuntimeName_t & runtimeName, const popo::SubscriberOptions & subscriberOptions, const mepoo::MemoryInfo & memoryInfo) cxx::expected< popo::ClientPortData *, PortPoolError > addClientPort (const capro::ServiceDescription & serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t & runtimeName, const popo::ClientOptions & clientOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) Adds a ClientPortData to the internal pool and returns a pointer for further usage. cxx::expected< popo::ServerPortData *, PortPoolError > addServerPort (const capro::ServiceDescription & serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t & runtimeName, const popo::ServerOptions & serverOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) Adds a ServerPortData to the internal pool and returns a pointer for further usage. cxx::expected< popo::InterfacePortData *, PortPoolError > addInterfacePort (const RuntimeName_t & runtimeName, const capro::Interfaces interface) cxx::expected< runtime::NodeData *, PortPoolError > addNodeData (const RuntimeName_t & runtimeName, const NodeName_t & nodeName, const uint64_t nodeDeviceIdentifier) cxx::expected< popo::ConditionVariableData *, PortPoolError > addConditionVariableData (const RuntimeName_t & runtimeName) void removePublisherPort (const PublisherPortRouDiType::MemberType_t *const portData) Removes a PublisherPortData from the internal pool. void removeSubscriberPort (const SubscriberPortType::MemberType_t *const portData) Removes a SubscriberPortData from the internal pool. void removeClientPort (const popo::ClientPortData *const portData) Removes a ClientPortData from the internal pool. void removeServerPort (const popo::ServerPortData *const portData) Removes a ServerPortData from the internal pool. void removeInterfacePort (const popo::InterfacePortData *const portData) Removes a InterfacePortData from the internal pool. void removeNodeData (const runtime::NodeData *const nodeData) Removes a NodeData from the internal pool. void removeConditionVariableData (const popo::ConditionVariableData *const conditionVariableData) Removes a ConditionVariableData from the internal pool. Public Functions Documentation \ud83d\udd17 function PortPool \ud83d\udd17 PortPool ( PortPoolData & portPoolData ) function ~PortPool \ud83d\udd17 virtual ~ PortPool () = default function getPublisherPortDataList \ud83d\udd17 cxx :: vector < PublisherPortRouDiType :: MemberType_t * , MAX_PUBLISHERS > getPublisherPortDataList () Todo : don't create the vector with each call but only when the data really change there could be a member \"cxx::vector<popo::PublisherPortData* m_publisherPorts;\" and publisherPorts() would just update this member if the publisher ports actually changed function getSubscriberPortDataList \ud83d\udd17 cxx :: vector < SubscriberPortType :: MemberType_t * , MAX_SUBSCRIBERS > getSubscriberPortDataList () function getClientPortDataList \ud83d\udd17 cxx :: vector < popo :: ClientPortData * , MAX_CLIENTS > getClientPortDataList () function getServerPortDataList \ud83d\udd17 cxx :: vector < popo :: ServerPortData * , MAX_SERVERS > getServerPortDataList () function getInterfacePortDataList \ud83d\udd17 cxx :: vector < popo :: InterfacePortData * , MAX_INTERFACE_NUMBER > getInterfacePortDataList () function getNodeDataList \ud83d\udd17 cxx :: vector < runtime :: NodeData * , MAX_NODE_NUMBER > getNodeDataList () function getConditionVariableDataList \ud83d\udd17 cxx :: vector < popo :: ConditionVariableData * , MAX_NUMBER_OF_CONDITION_VARIABLES > getConditionVariableDataList () function addPublisherPort \ud83d\udd17 cxx :: expected < PublisherPortRouDiType :: MemberType_t * , PortPoolError > addPublisherPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: PublisherOptions & publisherOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () ) function addSubscriberPort \ud83d\udd17 cxx :: expected < SubscriberPortType :: MemberType_t * , PortPoolError > addSubscriberPort ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () ) function constructSubscriber \ud83d\udd17 template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: ManyToManyPolicy >:: value > * = nullptr > inline iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) function constructSubscriber \ud83d\udd17 template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: OneToManyPolicy >:: value > * = nullptr > iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) function addClientPort \ud83d\udd17 cxx :: expected < popo :: ClientPortData * , PortPoolError > addClientPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ClientOptions & clientOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () ) Adds a ClientPortData to the internal pool and returns a pointer for further usage. Parameters : serviceDescription for the new client port memoryManager to acquire chunks for the requests runtimeName of the runtime the new client port belongs to clientOptions for the new client port memoryInfo for the new client port Return : on success a pointer to a ClientPortData; on error a PortPoolError function addServerPort \ud83d\udd17 cxx :: expected < popo :: ServerPortData * , PortPoolError > addServerPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ServerOptions & serverOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () ) Adds a ServerPortData to the internal pool and returns a pointer for further usage. Parameters : serviceDescription for the new server port memoryManager to acquire chunks for the responses runtimeName of the runtime the new server port belongs to serverOptions for the new server port memoryInfo for the new server port Return : on success a pointer to a ServerPortData; on error a PortPoolError function addInterfacePort \ud83d\udd17 cxx :: expected < popo :: InterfacePortData * , PortPoolError > addInterfacePort ( const RuntimeName_t & runtimeName , const capro :: Interfaces interface ) function addNodeData \ud83d\udd17 cxx :: expected < runtime :: NodeData * , PortPoolError > addNodeData ( const RuntimeName_t & runtimeName , const NodeName_t & nodeName , const uint64_t nodeDeviceIdentifier ) function addConditionVariableData \ud83d\udd17 cxx :: expected < popo :: ConditionVariableData * , PortPoolError > addConditionVariableData ( const RuntimeName_t & runtimeName ) function removePublisherPort \ud83d\udd17 void removePublisherPort ( const PublisherPortRouDiType :: MemberType_t * const portData ) Removes a PublisherPortData from the internal pool. Parameters : portData is a pointer to the PublisherPortData to be removed Note : after this call the provided PublisherPortData is no longer available for usage function removeSubscriberPort \ud83d\udd17 void removeSubscriberPort ( const SubscriberPortType :: MemberType_t * const portData ) Removes a SubscriberPortData from the internal pool. Parameters : portData is a pointer to the SubscriberPortData to be removed Note : after this call the provided SubscriberPortData is no longer available for usage function removeClientPort \ud83d\udd17 void removeClientPort ( const popo :: ClientPortData * const portData ) Removes a ClientPortData from the internal pool. Parameters : portData is a pointer to the ClientPortData to be removed Note : after this call the provided ClientPortData is no longer available for usage function removeServerPort \ud83d\udd17 void removeServerPort ( const popo :: ServerPortData * const portData ) Removes a ServerPortData from the internal pool. Parameters : portData is a pointer to the ServerPortData to be removed Note : after this call the provided ServerPortData is no longer available for usage function removeInterfacePort \ud83d\udd17 void removeInterfacePort ( const popo :: InterfacePortData * const portData ) Removes a InterfacePortData from the internal pool. Parameters : portData is a pointer to the InterfacePortData to be removed Note : after this call the provided InterfacePortData is no longer available for usage function removeNodeData \ud83d\udd17 void removeNodeData ( const runtime :: NodeData * const nodeData ) Removes a NodeData from the internal pool. Parameters : nodeData is a pointer to the NodeData to be removed Note : after this call the provided NodeData is no longer available for usage function removeConditionVariableData \ud83d\udd17 void removeConditionVariableData ( const popo :: ConditionVariableData * const conditionVariableData ) Removes a ConditionVariableData from the internal pool. Parameters : conditionVariableData is a pointer to the ConditionVariableData to be removed Note : after this call the provided ConditionVariableData is no longer available for usage Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#ioxroudiportpool","text":"","title":"iox::roudi::PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#public-functions","text":"Name PortPool (PortPoolData & portPoolData) virtual ~PortPool () =default cxx::vector< PublisherPortRouDiType::MemberType_t *, MAX_PUBLISHERS > getPublisherPortDataList () cxx::vector< SubscriberPortType::MemberType_t *, MAX_SUBSCRIBERS > getSubscriberPortDataList () cxx::vector< popo::ClientPortData *, MAX_CLIENTS > getClientPortDataList () cxx::vector< popo::ServerPortData *, MAX_SERVERS > getServerPortDataList () cxx::vector< popo::InterfacePortData *, MAX_INTERFACE_NUMBER > getInterfacePortDataList () cxx::vector< runtime::NodeData *, MAX_NODE_NUMBER > getNodeDataList () cxx::vector< popo::ConditionVariableData *, MAX_NUMBER_OF_CONDITION_VARIABLES > getConditionVariableDataList () cxx::expected< PublisherPortRouDiType::MemberType_t *, PortPoolError > addPublisherPort (const capro::ServiceDescription & serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t & runtimeName, const popo::PublisherOptions & publisherOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) cxx::expected< SubscriberPortType::MemberType_t *, PortPoolError > addSubscriberPort (const capro::ServiceDescription & serviceDescription, const RuntimeName_t & runtimeName, const popo::SubscriberOptions & subscriberOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) template <typename T ,std::enable_if_t< std::is_same< T, iox::build::ManyToManyPolicy >::value > * =nullptr> iox::popo::SubscriberPortData * constructSubscriber (const capro::ServiceDescription & serviceDescription, const RuntimeName_t & runtimeName, const popo::SubscriberOptions & subscriberOptions, const mepoo::MemoryInfo & memoryInfo) template <typename T ,std::enable_if_t< std::is_same< T, iox::build::OneToManyPolicy >::value > * =nullptr> iox::popo::SubscriberPortData * constructSubscriber (const capro::ServiceDescription & serviceDescription, const RuntimeName_t & runtimeName, const popo::SubscriberOptions & subscriberOptions, const mepoo::MemoryInfo & memoryInfo) cxx::expected< popo::ClientPortData *, PortPoolError > addClientPort (const capro::ServiceDescription & serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t & runtimeName, const popo::ClientOptions & clientOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) Adds a ClientPortData to the internal pool and returns a pointer for further usage. cxx::expected< popo::ServerPortData *, PortPoolError > addServerPort (const capro::ServiceDescription & serviceDescription, mepoo::MemoryManager *const memoryManager, const RuntimeName_t & runtimeName, const popo::ServerOptions & serverOptions, const mepoo::MemoryInfo & memoryInfo = mepoo::MemoryInfo ()) Adds a ServerPortData to the internal pool and returns a pointer for further usage. cxx::expected< popo::InterfacePortData *, PortPoolError > addInterfacePort (const RuntimeName_t & runtimeName, const capro::Interfaces interface) cxx::expected< runtime::NodeData *, PortPoolError > addNodeData (const RuntimeName_t & runtimeName, const NodeName_t & nodeName, const uint64_t nodeDeviceIdentifier) cxx::expected< popo::ConditionVariableData *, PortPoolError > addConditionVariableData (const RuntimeName_t & runtimeName) void removePublisherPort (const PublisherPortRouDiType::MemberType_t *const portData) Removes a PublisherPortData from the internal pool. void removeSubscriberPort (const SubscriberPortType::MemberType_t *const portData) Removes a SubscriberPortData from the internal pool. void removeClientPort (const popo::ClientPortData *const portData) Removes a ClientPortData from the internal pool. void removeServerPort (const popo::ServerPortData *const portData) Removes a ServerPortData from the internal pool. void removeInterfacePort (const popo::InterfacePortData *const portData) Removes a InterfacePortData from the internal pool. void removeNodeData (const runtime::NodeData *const nodeData) Removes a NodeData from the internal pool. void removeConditionVariableData (const popo::ConditionVariableData *const conditionVariableData) Removes a ConditionVariableData from the internal pool.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-portpool","text":"PortPool ( PortPoolData & portPoolData )","title":"function PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-portpool_1","text":"virtual ~ PortPool () = default","title":"function ~PortPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getpublisherportdatalist","text":"cxx :: vector < PublisherPortRouDiType :: MemberType_t * , MAX_PUBLISHERS > getPublisherPortDataList () Todo : don't create the vector with each call but only when the data really change there could be a member \"cxx::vector<popo::PublisherPortData* m_publisherPorts;\" and publisherPorts() would just update this member if the publisher ports actually changed","title":"function getPublisherPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getsubscriberportdatalist","text":"cxx :: vector < SubscriberPortType :: MemberType_t * , MAX_SUBSCRIBERS > getSubscriberPortDataList ()","title":"function getSubscriberPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getclientportdatalist","text":"cxx :: vector < popo :: ClientPortData * , MAX_CLIENTS > getClientPortDataList ()","title":"function getClientPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getserverportdatalist","text":"cxx :: vector < popo :: ServerPortData * , MAX_SERVERS > getServerPortDataList ()","title":"function getServerPortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getinterfaceportdatalist","text":"cxx :: vector < popo :: InterfacePortData * , MAX_INTERFACE_NUMBER > getInterfacePortDataList ()","title":"function getInterfacePortDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getnodedatalist","text":"cxx :: vector < runtime :: NodeData * , MAX_NODE_NUMBER > getNodeDataList ()","title":"function getNodeDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-getconditionvariabledatalist","text":"cxx :: vector < popo :: ConditionVariableData * , MAX_NUMBER_OF_CONDITION_VARIABLES > getConditionVariableDataList ()","title":"function getConditionVariableDataList"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addpublisherport","text":"cxx :: expected < PublisherPortRouDiType :: MemberType_t * , PortPoolError > addPublisherPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: PublisherOptions & publisherOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () )","title":"function addPublisherPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addsubscriberport","text":"cxx :: expected < SubscriberPortType :: MemberType_t * , PortPoolError > addSubscriberPort ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () )","title":"function addSubscriberPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-constructsubscriber","text":"template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: ManyToManyPolicy >:: value > * = nullptr > inline iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo )","title":"function constructSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-constructsubscriber_1","text":"template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: OneToManyPolicy >:: value > * = nullptr > iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo )","title":"function constructSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addclientport","text":"cxx :: expected < popo :: ClientPortData * , PortPoolError > addClientPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ClientOptions & clientOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () ) Adds a ClientPortData to the internal pool and returns a pointer for further usage. Parameters : serviceDescription for the new client port memoryManager to acquire chunks for the requests runtimeName of the runtime the new client port belongs to clientOptions for the new client port memoryInfo for the new client port Return : on success a pointer to a ClientPortData; on error a PortPoolError","title":"function addClientPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addserverport","text":"cxx :: expected < popo :: ServerPortData * , PortPoolError > addServerPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ServerOptions & serverOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo () ) Adds a ServerPortData to the internal pool and returns a pointer for further usage. Parameters : serviceDescription for the new server port memoryManager to acquire chunks for the responses runtimeName of the runtime the new server port belongs to serverOptions for the new server port memoryInfo for the new server port Return : on success a pointer to a ServerPortData; on error a PortPoolError","title":"function addServerPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addinterfaceport","text":"cxx :: expected < popo :: InterfacePortData * , PortPoolError > addInterfacePort ( const RuntimeName_t & runtimeName , const capro :: Interfaces interface )","title":"function addInterfacePort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addnodedata","text":"cxx :: expected < runtime :: NodeData * , PortPoolError > addNodeData ( const RuntimeName_t & runtimeName , const NodeName_t & nodeName , const uint64_t nodeDeviceIdentifier )","title":"function addNodeData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-addconditionvariabledata","text":"cxx :: expected < popo :: ConditionVariableData * , PortPoolError > addConditionVariableData ( const RuntimeName_t & runtimeName )","title":"function addConditionVariableData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removepublisherport","text":"void removePublisherPort ( const PublisherPortRouDiType :: MemberType_t * const portData ) Removes a PublisherPortData from the internal pool. Parameters : portData is a pointer to the PublisherPortData to be removed Note : after this call the provided PublisherPortData is no longer available for usage","title":"function removePublisherPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removesubscriberport","text":"void removeSubscriberPort ( const SubscriberPortType :: MemberType_t * const portData ) Removes a SubscriberPortData from the internal pool. Parameters : portData is a pointer to the SubscriberPortData to be removed Note : after this call the provided SubscriberPortData is no longer available for usage","title":"function removeSubscriberPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeclientport","text":"void removeClientPort ( const popo :: ClientPortData * const portData ) Removes a ClientPortData from the internal pool. Parameters : portData is a pointer to the ClientPortData to be removed Note : after this call the provided ClientPortData is no longer available for usage","title":"function removeClientPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeserverport","text":"void removeServerPort ( const popo :: ServerPortData * const portData ) Removes a ServerPortData from the internal pool. Parameters : portData is a pointer to the ServerPortData to be removed Note : after this call the provided ServerPortData is no longer available for usage","title":"function removeServerPort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeinterfaceport","text":"void removeInterfacePort ( const popo :: InterfacePortData * const portData ) Removes a InterfacePortData from the internal pool. Parameters : portData is a pointer to the InterfacePortData to be removed Note : after this call the provided InterfacePortData is no longer available for usage","title":"function removeInterfacePort"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removenodedata","text":"void removeNodeData ( const runtime :: NodeData * const nodeData ) Removes a NodeData from the internal pool. Parameters : nodeData is a pointer to the NodeData to be removed Note : after this call the provided NodeData is no longer available for usage","title":"function removeNodeData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PortPool/#function-removeconditionvariabledata","text":"void removeConditionVariableData ( const popo :: ConditionVariableData * const conditionVariableData ) Removes a ConditionVariableData from the internal pool. Parameters : conditionVariableData is a pointer to the ConditionVariableData to be removed Note : after this call the provided ConditionVariableData is no longer available for usage Updated on 18 December 2023 at 13:11:43 CET","title":"function removeConditionVariableData"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/","text":"iox::roudi::PosixShmMemoryProvider \ud83d\udd17 Creates the shared memory based on a provided configuration. #include <iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp> Inherits from iox::roudi::MemoryProvider Public Functions \ud83d\udd17 Name PosixShmMemoryProvider (const ShmName_t & shmName, const posix::AccessMode accessMode, const posix::OpenMode openMode) Constructs a PosixShmMemoryProvider which can be used to request memory via MemoryBlocks. ~PosixShmMemoryProvider () PosixShmMemoryProvider ( PosixShmMemoryProvider && ) PosixShmMemoryProvider & operator= ( PosixShmMemoryProvider && ) PosixShmMemoryProvider (const PosixShmMemoryProvider & ) PosixShmMemoryProvider & operator= (const PosixShmMemoryProvider & ) Protected Functions \ud83d\udd17 Name virtual cxx::expected< void *, MemoryProviderError > createMemory (const uint64_t size, const uint64_t alignment) This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. virtual cxx::expected< MemoryProviderError > destroyMemory () This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. Additional inherited members \ud83d\udd17 Public Functions inherited from iox::roudi::MemoryProvider Name MemoryProvider () =default virtual ~MemoryProvider () MemoryProvider (const MemoryProvider & ) MemoryProvider ( MemoryProvider && ) cxx::expected< MemoryProviderError > addMemoryBlock (cxx::not_null< MemoryBlock * > memoryBlock) This function add a MemoryBlock to the list of memory requester. cxx::expected< MemoryProviderError > create () With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider . void announceMemoryAvailable () This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::expected< MemoryProviderError > destroy () This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::optional< void * > baseAddress () const This function provides the base address of the created memory. uint64_t size () const This function provides the size of the created memory. cxx::optional< uint64_t > segmentId () const This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider . bool isAvailable () const This function can be used to check if the requested memory is already available. bool isAvailableAnnounced () const This function can be used to check if the availability of the memory was announced to the MemoryBlocks. Protected Functions inherited from iox::roudi::MemoryProvider Name const char * getErrorString (const MemoryProviderError error) Friends inherited from iox::roudi::MemoryProvider Name class RouDiMemoryManager Public Functions Documentation \ud83d\udd17 function PosixShmMemoryProvider \ud83d\udd17 PosixShmMemoryProvider ( const ShmName_t & shmName , const posix :: AccessMode accessMode , const posix :: OpenMode openMode ) Constructs a PosixShmMemoryProvider which can be used to request memory via MemoryBlocks. Parameters : shmName is the name of the posix share memory accessMode defines the read and write access to the memory openMode defines the creation/open mode of the shared memory. function ~PosixShmMemoryProvider \ud83d\udd17 ~ PosixShmMemoryProvider () function PosixShmMemoryProvider \ud83d\udd17 PosixShmMemoryProvider ( PosixShmMemoryProvider && ) function operator= \ud83d\udd17 PosixShmMemoryProvider & operator = ( PosixShmMemoryProvider && ) function PosixShmMemoryProvider \ud83d\udd17 PosixShmMemoryProvider ( const PosixShmMemoryProvider & ) function operator= \ud83d\udd17 PosixShmMemoryProvider & operator = ( const PosixShmMemoryProvider & ) Protected Functions Documentation \ud83d\udd17 function createMemory \ud83d\udd17 virtual cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. Parameters : size is the size in bytes for the requested memory, the size should already be calculated according to the alignment requirements alignment the required alignment for the memory Return : the pointer of the begin of the created memory or a MemoryProviderError if the memory could not be created Note : This creates and maps a POSIX shared memory to the address space of the application Reimplements : iox::roudi::MemoryProvider::createMemory function destroyMemory \ud83d\udd17 virtual cxx :: expected < MemoryProviderError > destroyMemory () This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. Return : a MemoryProviderError if the destruction failed, otherwise success Note : This closes and unmaps a POSIX shared memory Reimplements : iox::roudi::MemoryProvider::destroyMemory Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#ioxroudiposixshmmemoryprovider","text":"Creates the shared memory based on a provided configuration. #include <iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp> Inherits from iox::roudi::MemoryProvider","title":"iox::roudi::PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#public-functions","text":"Name PosixShmMemoryProvider (const ShmName_t & shmName, const posix::AccessMode accessMode, const posix::OpenMode openMode) Constructs a PosixShmMemoryProvider which can be used to request memory via MemoryBlocks. ~PosixShmMemoryProvider () PosixShmMemoryProvider ( PosixShmMemoryProvider && ) PosixShmMemoryProvider & operator= ( PosixShmMemoryProvider && ) PosixShmMemoryProvider (const PosixShmMemoryProvider & ) PosixShmMemoryProvider & operator= (const PosixShmMemoryProvider & )","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#protected-functions","text":"Name virtual cxx::expected< void *, MemoryProviderError > createMemory (const uint64_t size, const uint64_t alignment) This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. virtual cxx::expected< MemoryProviderError > destroyMemory () This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function.","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#additional-inherited-members","text":"Public Functions inherited from iox::roudi::MemoryProvider Name MemoryProvider () =default virtual ~MemoryProvider () MemoryProvider (const MemoryProvider & ) MemoryProvider ( MemoryProvider && ) cxx::expected< MemoryProviderError > addMemoryBlock (cxx::not_null< MemoryBlock * > memoryBlock) This function add a MemoryBlock to the list of memory requester. cxx::expected< MemoryProviderError > create () With this call the memory requested by the MemoryBlocks need to be created. The function should be called from a MemoryManager which handles one or more MemoryProvider . void announceMemoryAvailable () This function announces the availability of the memory to the MemoryBlocks. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::expected< MemoryProviderError > destroy () This function destroys the previously allocated memory. Before the destruction, all MemoryBlocks are requested to handle this appropriately, e.g. call the destructor of the underlying type. The function should be called from a MemoryManager which handles one or more MemoryProvider . cxx::optional< void * > baseAddress () const This function provides the base address of the created memory. uint64_t size () const This function provides the size of the created memory. cxx::optional< uint64_t > segmentId () const This function provides the segment id of the relocatable memory segment which is owned by the MemoryProvider . bool isAvailable () const This function can be used to check if the requested memory is already available. bool isAvailableAnnounced () const This function can be used to check if the availability of the memory was announced to the MemoryBlocks. Protected Functions inherited from iox::roudi::MemoryProvider Name const char * getErrorString (const MemoryProviderError error) Friends inherited from iox::roudi::MemoryProvider Name class RouDiMemoryManager","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider","text":"PosixShmMemoryProvider ( const ShmName_t & shmName , const posix :: AccessMode accessMode , const posix :: OpenMode openMode ) Constructs a PosixShmMemoryProvider which can be used to request memory via MemoryBlocks. Parameters : shmName is the name of the posix share memory accessMode defines the read and write access to the memory openMode defines the creation/open mode of the shared memory.","title":"function PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider_1","text":"~ PosixShmMemoryProvider ()","title":"function ~PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider_2","text":"PosixShmMemoryProvider ( PosixShmMemoryProvider && )","title":"function PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-operator","text":"PosixShmMemoryProvider & operator = ( PosixShmMemoryProvider && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-posixshmmemoryprovider_3","text":"PosixShmMemoryProvider ( const PosixShmMemoryProvider & )","title":"function PosixShmMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-operator_1","text":"PosixShmMemoryProvider & operator = ( const PosixShmMemoryProvider & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-creatememory","text":"virtual cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) This function needs to be implemented to provide the actual memory, e.g. in case of POSIX SHM, shm_open and mmap would need to be called in the implementation of this function. Parameters : size is the size in bytes for the requested memory, the size should already be calculated according to the alignment requirements alignment the required alignment for the memory Return : the pointer of the begin of the created memory or a MemoryProviderError if the memory could not be created Note : This creates and maps a POSIX shared memory to the address space of the application Reimplements : iox::roudi::MemoryProvider::createMemory","title":"function createMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1PosixShmMemoryProvider/#function-destroymemory","text":"virtual cxx :: expected < MemoryProviderError > destroyMemory () This function needs to be implemented to free the actual memory, e.g. in case of POSIX SHM, shm_unlink and munmap would need to be called in the implementation of this function. Return : a MemoryProviderError if the destruction failed, otherwise success Note : This closes and unmaps a POSIX shared memory Reimplements : iox::roudi::MemoryProvider::destroyMemory Updated on 18 December 2023 at 13:11:43 CET","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/","text":"iox::roudi::RouDiApp \ud83d\udd17 base class for RouDi daemons #include <iceoryx_posh/roudi/roudi_app.hpp> Inherited by iox::roudi::IceOryxRouDiApp Public Functions \ud83d\udd17 Name void roudiSigHandler (int32_t signal) Method passed to the OS signal handler. RouDiApp (const config::CmdLineArgs_t & cmdLineArgs, const RouDiConfig_t & config) C'tor with command line parser, which has already parsed the command line parameters. virtual ~RouDiApp () virtual uint8_t run () =0 interface to start the execution of the RouDi daemon Protected Functions \ud83d\udd17 Name void registerSigHandler () Tells the OS which signals shall be hooked. bool waitForSignal () waits for the next signal to RouDi daemon Protected Attributes \ud83d\udd17 Name iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode bool m_run RouDiConfig_t m_config posix::Semaphore m_semaphore version::CompatibilityCheckLevel m_compatibilityCheckLevel units::Duration m_processKillDelay Public Functions Documentation \ud83d\udd17 function roudiSigHandler \ud83d\udd17 static void roudiSigHandler ( int32_t signal ) Method passed to the OS signal handler. function RouDiApp \ud83d\udd17 RouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & config ) C'tor with command line parser, which has already parsed the command line parameters. Parameters : cmdLineParser reference to a command line parser object config the configuration to use function ~RouDiApp \ud83d\udd17 inline virtual ~ RouDiApp () function run \ud83d\udd17 virtual uint8_t run () = 0 interface to start the execution of the RouDi daemon Return : Return code for programm execution Reimplemented by : iox::roudi::IceOryxRouDiApp::run Protected Functions Documentation \ud83d\udd17 function registerSigHandler \ud83d\udd17 void registerSigHandler () Tells the OS which signals shall be hooked. function waitForSignal \ud83d\udd17 bool waitForSignal () waits for the next signal to RouDi daemon Protected Attributes Documentation \ud83d\udd17 variable m_logLevel \ud83d\udd17 iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn }; variable m_monitoringMode \ud83d\udd17 roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON }; variable m_run \ud83d\udd17 bool m_run { true }; variable m_config \ud83d\udd17 RouDiConfig_t m_config ; variable m_semaphore \ud83d\udd17 posix :: Semaphore m_semaphore = std :: move ( posix :: Semaphore :: create ( posix :: CreateUnnamedSingleProcessSemaphore , 0u ) . or_else ([]( posix :: SemaphoreError & ) { errorHandler ( Error :: kROUDI_APP__FAILED_TO_CREATE_SEMAPHORE , nullptr , ErrorLevel :: FATAL ); }) . value ()); variable m_compatibilityCheckLevel \ud83d\udd17 version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; variable m_processKillDelay \ud83d\udd17 units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#ioxroudiroudiapp","text":"base class for RouDi daemons #include <iceoryx_posh/roudi/roudi_app.hpp> Inherited by iox::roudi::IceOryxRouDiApp","title":"iox::roudi::RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#public-functions","text":"Name void roudiSigHandler (int32_t signal) Method passed to the OS signal handler. RouDiApp (const config::CmdLineArgs_t & cmdLineArgs, const RouDiConfig_t & config) C'tor with command line parser, which has already parsed the command line parameters. virtual ~RouDiApp () virtual uint8_t run () =0 interface to start the execution of the RouDi daemon","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-functions","text":"Name void registerSigHandler () Tells the OS which signals shall be hooked. bool waitForSignal () waits for the next signal to RouDi daemon","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-attributes","text":"Name iox::log::LogLevel m_logLevel roudi::MonitoringMode m_monitoringMode bool m_run RouDiConfig_t m_config posix::Semaphore m_semaphore version::CompatibilityCheckLevel m_compatibilityCheckLevel units::Duration m_processKillDelay","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-roudisighandler","text":"static void roudiSigHandler ( int32_t signal ) Method passed to the OS signal handler.","title":"function roudiSigHandler"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-roudiapp","text":"RouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & config ) C'tor with command line parser, which has already parsed the command line parameters. Parameters : cmdLineParser reference to a command line parser object config the configuration to use","title":"function RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-roudiapp_1","text":"inline virtual ~ RouDiApp ()","title":"function ~RouDiApp"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-run","text":"virtual uint8_t run () = 0 interface to start the execution of the RouDi daemon Return : Return code for programm execution Reimplemented by : iox::roudi::IceOryxRouDiApp::run","title":"function run"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-registersighandler","text":"void registerSigHandler () Tells the OS which signals shall be hooked.","title":"function registerSigHandler"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#function-waitforsignal","text":"bool waitForSignal () waits for the next signal to RouDi daemon","title":"function waitForSignal"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_loglevel","text":"iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn };","title":"variable m_logLevel"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_monitoringmode","text":"roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON };","title":"variable m_monitoringMode"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_run","text":"bool m_run { true };","title":"variable m_run"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_config","text":"RouDiConfig_t m_config ;","title":"variable m_config"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_semaphore","text":"posix :: Semaphore m_semaphore = std :: move ( posix :: Semaphore :: create ( posix :: CreateUnnamedSingleProcessSemaphore , 0u ) . or_else ([]( posix :: SemaphoreError & ) { errorHandler ( Error :: kROUDI_APP__FAILED_TO_CREATE_SEMAPHORE , nullptr , ErrorLevel :: FATAL ); }) . value ());","title":"variable m_semaphore"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_compatibilitychecklevel","text":"version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH };","title":"variable m_compatibilityCheckLevel"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiApp/#variable-m_processkilldelay","text":"units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_processKillDelay"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/","text":"iox::roudi::RouDiConfigFileProvider \ud83d\udd17 Base class for a config file provider. #include <iceoryx_posh/roudi/roudi_config_file_provider.hpp> Inherited by iox::config::TomlRouDiConfigFileProvider Public Functions \ud83d\udd17 Name virtual cxx::expected< RouDiConfig_t , RouDiConfigFileParseError > parse () =0 interface to parse a config file which needs to be implemented for a custom parser Protected Attributes \ud83d\udd17 Name ConfigFilePathString_t m_customConfigFilePath Public Functions Documentation \ud83d\udd17 function parse \ud83d\udd17 virtual cxx :: expected < RouDiConfig_t , RouDiConfigFileParseError > parse () = 0 interface to parse a config file which needs to be implemented for a custom parser Parameters : configFilePath to the custom RouDi config file Return : a cxx::expected with either the parsed RouDiConfig_t if the parsing was successful or a parsing error Reimplemented by : iox::config::TomlRouDiConfigFileProvider::parse Protected Attributes Documentation \ud83d\udd17 variable m_customConfigFilePath \ud83d\udd17 ConfigFilePathString_t m_customConfigFilePath ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::RouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#ioxroudiroudiconfigfileprovider","text":"Base class for a config file provider. #include <iceoryx_posh/roudi/roudi_config_file_provider.hpp> Inherited by iox::config::TomlRouDiConfigFileProvider","title":"iox::roudi::RouDiConfigFileProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#public-functions","text":"Name virtual cxx::expected< RouDiConfig_t , RouDiConfigFileParseError > parse () =0 interface to parse a config file which needs to be implemented for a custom parser","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#protected-attributes","text":"Name ConfigFilePathString_t m_customConfigFilePath","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#function-parse","text":"virtual cxx :: expected < RouDiConfig_t , RouDiConfigFileParseError > parse () = 0 interface to parse a config file which needs to be implemented for a custom parser Parameters : configFilePath to the custom RouDi config file Return : a cxx::expected with either the parsed RouDiConfig_t if the parsing was successful or a parsing error Reimplemented by : iox::config::TomlRouDiConfigFileProvider::parse","title":"function parse"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiConfigFileProvider/#variable-m_customconfigfilepath","text":"ConfigFilePathString_t m_customConfigFilePath ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_customConfigFilePath"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/","text":"iox::roudi::RouDiMemoryInterface \ud83d\udd17 Inherited by iox::roudi::IceOryxRouDiMemoryManager Public Functions \ud83d\udd17 Name RouDiMemoryInterface () =default virtual ~RouDiMemoryInterface () =default The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider . RouDiMemoryInterface ( RouDiMemoryInterface && ) RouDiMemoryInterface & operator= ( RouDiMemoryInterface && ) RouDiMemoryInterface (const RouDiMemoryInterface & ) RouDiMemoryInterface & operator= (const RouDiMemoryInterface & ) virtual cxx::expected< RouDiMemoryManagerError > createAndAnnounceMemory () =0 The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. virtual cxx::expected< RouDiMemoryManagerError > destroyMemory () =0 The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const =0 virtual cxx::optional< PortPool * > portPool () =0 virtual cxx::optional< mepoo::MemoryManager * > introspectionMemoryManager () const =0 virtual cxx::optional< mepoo::SegmentManager<> * > segmentManager () const =0 Public Functions Documentation \ud83d\udd17 function RouDiMemoryInterface \ud83d\udd17 RouDiMemoryInterface () = default function ~RouDiMemoryInterface \ud83d\udd17 virtual ~ RouDiMemoryInterface () = default The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider . function RouDiMemoryInterface \ud83d\udd17 RouDiMemoryInterface ( RouDiMemoryInterface && ) function operator= \ud83d\udd17 RouDiMemoryInterface & operator = ( RouDiMemoryInterface && ) function RouDiMemoryInterface \ud83d\udd17 RouDiMemoryInterface ( const RouDiMemoryInterface & ) function operator= \ud83d\udd17 RouDiMemoryInterface & operator = ( const RouDiMemoryInterface & ) function createAndAnnounceMemory \ud83d\udd17 virtual cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () = 0 The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. Return : an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::createAndAnnounceMemory function destroyMemory \ud83d\udd17 virtual cxx :: expected < RouDiMemoryManagerError > destroyMemory () = 0 The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::destroyMemory function mgmtMemoryProvider \ud83d\udd17 virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::mgmtMemoryProvider function portPool \ud83d\udd17 virtual cxx :: optional < PortPool * > portPool () = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::portPool function introspectionMemoryManager \ud83d\udd17 virtual cxx :: optional < mepoo :: MemoryManager * > introspectionMemoryManager () const = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::introspectionMemoryManager function segmentManager \ud83d\udd17 virtual cxx :: optional < mepoo :: SegmentManager <> * > segmentManager () const = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::segmentManager Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#ioxroudiroudimemoryinterface","text":"Inherited by iox::roudi::IceOryxRouDiMemoryManager","title":"iox::roudi::RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#public-functions","text":"Name RouDiMemoryInterface () =default virtual ~RouDiMemoryInterface () =default The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider . RouDiMemoryInterface ( RouDiMemoryInterface && ) RouDiMemoryInterface & operator= ( RouDiMemoryInterface && ) RouDiMemoryInterface (const RouDiMemoryInterface & ) RouDiMemoryInterface & operator= (const RouDiMemoryInterface & ) virtual cxx::expected< RouDiMemoryManagerError > createAndAnnounceMemory () =0 The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. virtual cxx::expected< RouDiMemoryManagerError > destroyMemory () =0 The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const =0 virtual cxx::optional< PortPool * > portPool () =0 virtual cxx::optional< mepoo::MemoryManager * > introspectionMemoryManager () const =0 virtual cxx::optional< mepoo::SegmentManager<> * > segmentManager () const =0","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface","text":"RouDiMemoryInterface () = default","title":"function RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface_1","text":"virtual ~ RouDiMemoryInterface () = default The Destructor of the RouDiMemoryInterface also calls destroy on the registered MemoryProvider .","title":"function ~RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface_2","text":"RouDiMemoryInterface ( RouDiMemoryInterface && )","title":"function RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-operator","text":"RouDiMemoryInterface & operator = ( RouDiMemoryInterface && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-roudimemoryinterface_3","text":"RouDiMemoryInterface ( const RouDiMemoryInterface & )","title":"function RouDiMemoryInterface"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-operator_1","text":"RouDiMemoryInterface & operator = ( const RouDiMemoryInterface & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-createandannouncememory","text":"virtual cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () = 0 The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. Return : an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::createAndAnnounceMemory","title":"function createAndAnnounceMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-destroymemory","text":"virtual cxx :: expected < RouDiMemoryManagerError > destroyMemory () = 0 The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::destroyMemory","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-mgmtmemoryprovider","text":"virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::mgmtMemoryProvider","title":"function mgmtMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-portpool","text":"virtual cxx :: optional < PortPool * > portPool () = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::portPool","title":"function portPool"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-introspectionmemorymanager","text":"virtual cxx :: optional < mepoo :: MemoryManager * > introspectionMemoryManager () const = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::introspectionMemoryManager","title":"function introspectionMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryInterface/#function-segmentmanager","text":"virtual cxx :: optional < mepoo :: SegmentManager <> * > segmentManager () const = 0 Reimplemented by : iox::roudi::IceOryxRouDiMemoryManager::segmentManager Updated on 18 December 2023 at 13:11:43 CET","title":"function segmentManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/","text":"iox::roudi::RouDiMemoryManager \ud83d\udd17 Public Functions \ud83d\udd17 Name RouDiMemoryManager () =default virtual ~RouDiMemoryManager () The Destructor of the RouDiMemoryManager also calls destroy on the registered MemoryProvider . RouDiMemoryManager ( RouDiMemoryManager && ) RouDiMemoryManager & operator= ( RouDiMemoryManager && ) RouDiMemoryManager (const RouDiMemoryManager & ) RouDiMemoryManager & operator= (const RouDiMemoryManager & ) cxx::expected< RouDiMemoryManagerError > addMemoryProvider ( MemoryProvider * memoryProvider) This function add a MemoryProvider to the memory manager. cxx::expected< RouDiMemoryManagerError > createAndAnnounceMemory () The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. cxx::expected< RouDiMemoryManagerError > destroyMemory () The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Public Functions Documentation \ud83d\udd17 function RouDiMemoryManager \ud83d\udd17 RouDiMemoryManager () = default function ~RouDiMemoryManager \ud83d\udd17 virtual ~ RouDiMemoryManager () The Destructor of the RouDiMemoryManager also calls destroy on the registered MemoryProvider . function RouDiMemoryManager \ud83d\udd17 RouDiMemoryManager ( RouDiMemoryManager && ) function operator= \ud83d\udd17 RouDiMemoryManager & operator = ( RouDiMemoryManager && ) function RouDiMemoryManager \ud83d\udd17 RouDiMemoryManager ( const RouDiMemoryManager & ) function operator= \ud83d\udd17 RouDiMemoryManager & operator = ( const RouDiMemoryManager & ) function addMemoryProvider \ud83d\udd17 cxx :: expected < RouDiMemoryManagerError > addMemoryProvider ( MemoryProvider * memoryProvider ) This function add a MemoryProvider to the memory manager. Parameters : memoryProvider is a pointer to a user defined MemoryProvider Return : an RouDiMemoryManagerError::MEMORY_PROVIDER_EXHAUSTED error if no further memory provider can be added, otherwise success function createAndAnnounceMemory \ud83d\udd17 cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. Return : an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success function destroyMemory \ud83d\udd17 cxx :: expected < RouDiMemoryManagerError > destroyMemory () The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#ioxroudiroudimemorymanager","text":"","title":"iox::roudi::RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#public-functions","text":"Name RouDiMemoryManager () =default virtual ~RouDiMemoryManager () The Destructor of the RouDiMemoryManager also calls destroy on the registered MemoryProvider . RouDiMemoryManager ( RouDiMemoryManager && ) RouDiMemoryManager & operator= ( RouDiMemoryManager && ) RouDiMemoryManager (const RouDiMemoryManager & ) RouDiMemoryManager & operator= (const RouDiMemoryManager & ) cxx::expected< RouDiMemoryManagerError > addMemoryProvider ( MemoryProvider * memoryProvider) This function add a MemoryProvider to the memory manager. cxx::expected< RouDiMemoryManagerError > createAndAnnounceMemory () The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. cxx::expected< RouDiMemoryManagerError > destroyMemory () The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager","text":"RouDiMemoryManager () = default","title":"function RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager_1","text":"virtual ~ RouDiMemoryManager () The Destructor of the RouDiMemoryManager also calls destroy on the registered MemoryProvider .","title":"function ~RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager_2","text":"RouDiMemoryManager ( RouDiMemoryManager && )","title":"function RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-operator","text":"RouDiMemoryManager & operator = ( RouDiMemoryManager && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-roudimemorymanager_3","text":"RouDiMemoryManager ( const RouDiMemoryManager & )","title":"function RouDiMemoryManager"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-operator_1","text":"RouDiMemoryManager & operator = ( const RouDiMemoryManager & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-addmemoryprovider","text":"cxx :: expected < RouDiMemoryManagerError > addMemoryProvider ( MemoryProvider * memoryProvider ) This function add a MemoryProvider to the memory manager. Parameters : memoryProvider is a pointer to a user defined MemoryProvider Return : an RouDiMemoryManagerError::MEMORY_PROVIDER_EXHAUSTED error if no further memory provider can be added, otherwise success","title":"function addMemoryProvider"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-createandannouncememory","text":"cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () The RouDiMemoryManager calls the the MemoryProvider to create the memory and announce the availability to its MemoryBlocks. Return : an RouDiMemoryManagerError if the MemoryProvider cannot create the memory, otherwise success","title":"function createAndAnnounceMemory"},{"location":"API-reference/posh/Classes/classiox_1_1roudi_1_1RouDiMemoryManager/#function-destroymemory","text":"cxx :: expected < RouDiMemoryManagerError > destroyMemory () The RouDiMemoryManager calls the the MemoryProvider to destroy the memory, which in turn prompts the MemoryBlocks to destroy their data. Updated on 18 December 2023 at 13:11:43 CET","title":"function destroyMemory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/","text":"iox::runtime::Node \ud83d\udd17 class which represents a node #include <iceoryx_posh/runtime/node.hpp> Public Functions \ud83d\udd17 Name Node (const NodeName_t & nodeName) constructor which requires the name of the node ~Node () destructor Node (const Node & ) Node & operator= (const Node & ) Node ( Node && rhs) move constructor Node & operator= ( Node && rhs) move assignment operator NodeName_t getNodeName () const returns the name of the node RuntimeName_t getRuntimeName () const returns the name of the application's runtime Protected Functions \ud83d\udd17 Name Node (NodeData *const data) Protected Attributes \ud83d\udd17 Name NodeData * m_data Public Functions Documentation \ud83d\udd17 function Node \ud83d\udd17 Node ( const NodeName_t & nodeName ) constructor which requires the name of the node Parameters : nodeName name of the node function ~Node \ud83d\udd17 ~ Node () destructor function Node \ud83d\udd17 Node ( const Node & ) function operator= \ud83d\udd17 Node & operator = ( const Node & ) function Node \ud83d\udd17 Node ( Node && rhs ) move constructor Parameters : rhs source object function operator= \ud83d\udd17 Node & operator = ( Node && rhs ) move assignment operator Parameters : rhs source object, where to move from function getNodeName \ud83d\udd17 NodeName_t getNodeName () const returns the name of the node Return : string which contains the node name function getRuntimeName \ud83d\udd17 RuntimeName_t getRuntimeName () const returns the name of the application's runtime Return : string which contains the runtime name Protected Functions Documentation \ud83d\udd17 function Node \ud83d\udd17 Node ( NodeData * const data ) Protected Attributes Documentation \ud83d\udd17 variable m_data \ud83d\udd17 NodeData * m_data = nullptr ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::runtime::Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#ioxruntimenode","text":"class which represents a node #include <iceoryx_posh/runtime/node.hpp>","title":"iox::runtime::Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#public-functions","text":"Name Node (const NodeName_t & nodeName) constructor which requires the name of the node ~Node () destructor Node (const Node & ) Node & operator= (const Node & ) Node ( Node && rhs) move constructor Node & operator= ( Node && rhs) move assignment operator NodeName_t getNodeName () const returns the name of the node RuntimeName_t getRuntimeName () const returns the name of the application's runtime","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-functions","text":"Name Node (NodeData *const data)","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-attributes","text":"Name NodeData * m_data","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node","text":"Node ( const NodeName_t & nodeName ) constructor which requires the name of the node Parameters : nodeName name of the node","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_1","text":"~ Node () destructor","title":"function ~Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_2","text":"Node ( const Node & )","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-operator","text":"Node & operator = ( const Node & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_3","text":"Node ( Node && rhs ) move constructor Parameters : rhs source object","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-operator_1","text":"Node & operator = ( Node && rhs ) move assignment operator Parameters : rhs source object, where to move from","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-getnodename","text":"NodeName_t getNodeName () const returns the name of the node Return : string which contains the node name","title":"function getNodeName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-getruntimename","text":"RuntimeName_t getRuntimeName () const returns the name of the application's runtime Return : string which contains the runtime name","title":"function getRuntimeName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#function-node_4","text":"Node ( NodeData * const data )","title":"function Node"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1Node/#variable-m_data","text":"NodeData * m_data = nullptr ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_data"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/","text":"iox::runtime::PoshRuntime \ud83d\udd17 The runtime that is needed for each application to communicate with the RouDi daemon. #include <iceoryx_posh/runtime/posh_runtime.hpp> Protected Types \ud83d\udd17 Name using PoshRuntime &(*)(cxx::optional< const RuntimeName_t * >) factory_t Public Functions \ud83d\udd17 Name PoshRuntime (const PoshRuntime & ) PoshRuntime & operator= (const PoshRuntime & ) PoshRuntime ( PoshRuntime && ) PoshRuntime & operator= ( PoshRuntime && ) virtual ~PoshRuntime () =default RuntimeName_t getInstanceName () const get the name that was used to register with RouDi void shutdown () initiates the shutdown of the runtime to unblock all potentially blocking publisher with the ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER option set virtual PublisherPortUserType::MemberType_t * getMiddlewarePublisher (const capro::ServiceDescription & service, const popo::PublisherOptions & publisherOptions ={}, const PortConfigInfo & portConfigInfo ={}) =0 request the RouDi daemon to create a publisher port virtual SubscriberPortUserType::MemberType_t * getMiddlewareSubscriber (const capro::ServiceDescription & service, const popo::SubscriberOptions & subscriberOptions ={}, const PortConfigInfo & portConfigInfo ={}) =0 request the RouDi daemon to create a subscriber port virtual popo::ClientPortData * getMiddlewareClient (const capro::ServiceDescription & service, const popo::ClientOptions & clientOptions ={}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) =0 request the RouDi daemon to create a client port virtual popo::ServerPortData * getMiddlewareServer (const capro::ServiceDescription & service, const popo::ServerOptions & serverOptions ={}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) =0 request the RouDi daemon to create a server port virtual popo::InterfacePortData * getMiddlewareInterface (const capro::Interfaces interface, const NodeName_t & nodeName ={}) =0 request the RouDi daemon to create an interface port virtual popo::ConditionVariableData * getMiddlewareConditionVariable () =0 request the RouDi daemon to create a condition variable virtual NodeData * createNode (const NodeProperty & nodeProperty) =0 request the RouDi daemon to create a node virtual bool sendRequestToRouDi (const IpcMessage & msg, IpcMessage & answer) =0 send a request to the RouDi daemon and get the response currently each request is followed by a response PoshRuntime & getInstance () returns active runtime PoshRuntime & initRuntime (const RuntimeName_t & name) creates the runtime with given name Protected Functions \ud83d\udd17 Name PoshRuntime (cxx::optional< const RuntimeName_t * > name) const RuntimeName_t & verifyInstanceName (cxx::optional< const RuntimeName_t * > name) checks the given application name for certain constraints like length or if is empty PoshRuntime & defaultRuntimeFactory (cxx::optional< const RuntimeName_t * > name) factory_t & getRuntimeFactory () gets current runtime factory. If the runtime factory is not yet initialized it is set to defaultRuntimeFactory. void setRuntimeFactory (const factory_t & factory) sets runtime factory, terminates if given factory is empty PoshRuntime & getInstance (cxx::optional< const RuntimeName_t * > name) creates the runtime or returns the already existing one -> Singleton Protected Attributes \ud83d\udd17 Name const RuntimeName_t m_appName std::atomic< bool > m_shutdownRequested Friends \ud83d\udd17 Name class roudi::RuntimeTestInterface Protected Types Documentation \ud83d\udd17 using factory_t \ud83d\udd17 using iox :: runtime :: PoshRuntime :: factory_t = PoshRuntime & ( * )( cxx :: optional < const RuntimeName_t *> ); Public Functions Documentation \ud83d\udd17 function PoshRuntime \ud83d\udd17 PoshRuntime ( const PoshRuntime & ) function operator= \ud83d\udd17 PoshRuntime & operator = ( const PoshRuntime & ) function PoshRuntime \ud83d\udd17 PoshRuntime ( PoshRuntime && ) function operator= \ud83d\udd17 PoshRuntime & operator = ( PoshRuntime && ) function ~PoshRuntime \ud83d\udd17 virtual ~ PoshRuntime () = default function getInstanceName \ud83d\udd17 RuntimeName_t getInstanceName () const get the name that was used to register with RouDi Return : name of the registered application function shutdown \ud83d\udd17 void shutdown () initiates the shutdown of the runtime to unblock all potentially blocking publisher with the ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER option set function getMiddlewarePublisher \ud83d\udd17 virtual PublisherPortUserType :: MemberType_t * getMiddlewarePublisher ( const capro :: ServiceDescription & service , const popo :: PublisherOptions & publisherOptions = {}, const PortConfigInfo & portConfigInfo = {} ) = 0 request the RouDi daemon to create a publisher port Parameters : serviceDescription service description for the new publisher port publisherOptions like the history capacity of a publisher portConfigInfo configuration information for the port (i.e. what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created publisher port user function getMiddlewareSubscriber \ud83d\udd17 virtual SubscriberPortUserType :: MemberType_t * getMiddlewareSubscriber ( const capro :: ServiceDescription & service , const popo :: SubscriberOptions & subscriberOptions = {}, const PortConfigInfo & portConfigInfo = {} ) = 0 request the RouDi daemon to create a subscriber port Parameters : serviceDescription service description for the new subscriber port subscriberOptions like the queue capacity and history requested by a subscriber portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created subscriber port data function getMiddlewareClient \ud83d\udd17 virtual popo :: ClientPortData * getMiddlewareClient ( const capro :: ServiceDescription & service , const popo :: ClientOptions & clientOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo () ) = 0 request the RouDi daemon to create a client port Parameters : serviceDescription service description for the new client port clientOptions like the queue capacity and queue full policy by a client portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created client port data function getMiddlewareServer \ud83d\udd17 virtual popo :: ServerPortData * getMiddlewareServer ( const capro :: ServiceDescription & service , const popo :: ServerOptions & serverOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo () ) = 0 request the RouDi daemon to create a server port Parameters : serviceDescription service description for the new server port serverOptions like the queue capacity and queue full policy by a server portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created server port data function getMiddlewareInterface \ud83d\udd17 virtual popo :: InterfacePortData * getMiddlewareInterface ( const capro :: Interfaces interface , const NodeName_t & nodeName = {} ) = 0 request the RouDi daemon to create an interface port Parameters : interface interface to create nodeName name of the node where the interface should belong to Return : pointer to a created interface port data function getMiddlewareConditionVariable \ud83d\udd17 virtual popo :: ConditionVariableData * getMiddlewareConditionVariable () = 0 request the RouDi daemon to create a condition variable Return : pointer to a created condition variable data function createNode \ud83d\udd17 virtual NodeData * createNode ( const NodeProperty & nodeProperty ) = 0 request the RouDi daemon to create a node Parameters : nodeProperty class which contains all properties which the node should have Return : pointer to the data of the node function sendRequestToRouDi \ud83d\udd17 virtual bool sendRequestToRouDi ( const IpcMessage & msg , IpcMessage & answer ) = 0 send a request to the RouDi daemon and get the response currently each request is followed by a response Parameters : msg request message to send response from the RouDi daemon Return : true if sucessful request/response, false on error function getInstance \ud83d\udd17 static PoshRuntime & getInstance () returns active runtime Return : active runtime function initRuntime \ud83d\udd17 static PoshRuntime & initRuntime ( const RuntimeName_t & name ) creates the runtime with given name Parameters : name used for registering the process with the RouDi daemon Return : active runtime Protected Functions Documentation \ud83d\udd17 function PoshRuntime \ud83d\udd17 PoshRuntime ( cxx :: optional < const RuntimeName_t * > name ) function verifyInstanceName \ud83d\udd17 const RuntimeName_t & verifyInstanceName ( cxx :: optional < const RuntimeName_t * > name ) checks the given application name for certain constraints like length or if is empty function defaultRuntimeFactory \ud83d\udd17 static PoshRuntime & defaultRuntimeFactory ( cxx :: optional < const RuntimeName_t * > name ) function getRuntimeFactory \ud83d\udd17 static factory_t & getRuntimeFactory () gets current runtime factory. If the runtime factory is not yet initialized it is set to defaultRuntimeFactory. Return : current runtime factory function setRuntimeFactory \ud83d\udd17 static void setRuntimeFactory ( const factory_t & factory ) sets runtime factory, terminates if given factory is empty Parameters : factory std::function to which the runtime factory should be set function getInstance \ud83d\udd17 static PoshRuntime & getInstance ( cxx :: optional < const RuntimeName_t * > name ) creates the runtime or returns the already existing one -> Singleton Parameters : name optional containing the name used for registering with the RouDi daemon Return : active runtime Protected Attributes Documentation \ud83d\udd17 variable m_appName \ud83d\udd17 const RuntimeName_t m_appName ; variable m_shutdownRequested \ud83d\udd17 std :: atomic < bool > m_shutdownRequested { false }; Friends \ud83d\udd17 friend roudi::RuntimeTestInterface \ud83d\udd17 friend class roudi :: RuntimeTestInterface ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::runtime::PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#ioxruntimeposhruntime","text":"The runtime that is needed for each application to communicate with the RouDi daemon. #include <iceoryx_posh/runtime/posh_runtime.hpp>","title":"iox::runtime::PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-types","text":"Name using PoshRuntime &(*)(cxx::optional< const RuntimeName_t * >) factory_t","title":"Protected Types"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#public-functions","text":"Name PoshRuntime (const PoshRuntime & ) PoshRuntime & operator= (const PoshRuntime & ) PoshRuntime ( PoshRuntime && ) PoshRuntime & operator= ( PoshRuntime && ) virtual ~PoshRuntime () =default RuntimeName_t getInstanceName () const get the name that was used to register with RouDi void shutdown () initiates the shutdown of the runtime to unblock all potentially blocking publisher with the ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER option set virtual PublisherPortUserType::MemberType_t * getMiddlewarePublisher (const capro::ServiceDescription & service, const popo::PublisherOptions & publisherOptions ={}, const PortConfigInfo & portConfigInfo ={}) =0 request the RouDi daemon to create a publisher port virtual SubscriberPortUserType::MemberType_t * getMiddlewareSubscriber (const capro::ServiceDescription & service, const popo::SubscriberOptions & subscriberOptions ={}, const PortConfigInfo & portConfigInfo ={}) =0 request the RouDi daemon to create a subscriber port virtual popo::ClientPortData * getMiddlewareClient (const capro::ServiceDescription & service, const popo::ClientOptions & clientOptions ={}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) =0 request the RouDi daemon to create a client port virtual popo::ServerPortData * getMiddlewareServer (const capro::ServiceDescription & service, const popo::ServerOptions & serverOptions ={}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) =0 request the RouDi daemon to create a server port virtual popo::InterfacePortData * getMiddlewareInterface (const capro::Interfaces interface, const NodeName_t & nodeName ={}) =0 request the RouDi daemon to create an interface port virtual popo::ConditionVariableData * getMiddlewareConditionVariable () =0 request the RouDi daemon to create a condition variable virtual NodeData * createNode (const NodeProperty & nodeProperty) =0 request the RouDi daemon to create a node virtual bool sendRequestToRouDi (const IpcMessage & msg, IpcMessage & answer) =0 send a request to the RouDi daemon and get the response currently each request is followed by a response PoshRuntime & getInstance () returns active runtime PoshRuntime & initRuntime (const RuntimeName_t & name) creates the runtime with given name","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-functions","text":"Name PoshRuntime (cxx::optional< const RuntimeName_t * > name) const RuntimeName_t & verifyInstanceName (cxx::optional< const RuntimeName_t * > name) checks the given application name for certain constraints like length or if is empty PoshRuntime & defaultRuntimeFactory (cxx::optional< const RuntimeName_t * > name) factory_t & getRuntimeFactory () gets current runtime factory. If the runtime factory is not yet initialized it is set to defaultRuntimeFactory. void setRuntimeFactory (const factory_t & factory) sets runtime factory, terminates if given factory is empty PoshRuntime & getInstance (cxx::optional< const RuntimeName_t * > name) creates the runtime or returns the already existing one -> Singleton","title":"Protected Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-attributes","text":"Name const RuntimeName_t m_appName std::atomic< bool > m_shutdownRequested","title":"Protected Attributes"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#friends","text":"Name class roudi::RuntimeTestInterface","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-types-documentation","text":"","title":"Protected Types Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#using-factory_t","text":"using iox :: runtime :: PoshRuntime :: factory_t = PoshRuntime & ( * )( cxx :: optional < const RuntimeName_t *> );","title":"using factory_t"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime","text":"PoshRuntime ( const PoshRuntime & )","title":"function PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-operator","text":"PoshRuntime & operator = ( const PoshRuntime & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime_1","text":"PoshRuntime ( PoshRuntime && )","title":"function PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-operator_1","text":"PoshRuntime & operator = ( PoshRuntime && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime_2","text":"virtual ~ PoshRuntime () = default","title":"function ~PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getinstancename","text":"RuntimeName_t getInstanceName () const get the name that was used to register with RouDi Return : name of the registered application","title":"function getInstanceName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-shutdown","text":"void shutdown () initiates the shutdown of the runtime to unblock all potentially blocking publisher with the ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER option set","title":"function shutdown"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewarepublisher","text":"virtual PublisherPortUserType :: MemberType_t * getMiddlewarePublisher ( const capro :: ServiceDescription & service , const popo :: PublisherOptions & publisherOptions = {}, const PortConfigInfo & portConfigInfo = {} ) = 0 request the RouDi daemon to create a publisher port Parameters : serviceDescription service description for the new publisher port publisherOptions like the history capacity of a publisher portConfigInfo configuration information for the port (i.e. what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created publisher port user","title":"function getMiddlewarePublisher"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewaresubscriber","text":"virtual SubscriberPortUserType :: MemberType_t * getMiddlewareSubscriber ( const capro :: ServiceDescription & service , const popo :: SubscriberOptions & subscriberOptions = {}, const PortConfigInfo & portConfigInfo = {} ) = 0 request the RouDi daemon to create a subscriber port Parameters : serviceDescription service description for the new subscriber port subscriberOptions like the queue capacity and history requested by a subscriber portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created subscriber port data","title":"function getMiddlewareSubscriber"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareclient","text":"virtual popo :: ClientPortData * getMiddlewareClient ( const capro :: ServiceDescription & service , const popo :: ClientOptions & clientOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo () ) = 0 request the RouDi daemon to create a client port Parameters : serviceDescription service description for the new client port clientOptions like the queue capacity and queue full policy by a client portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created client port data","title":"function getMiddlewareClient"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareserver","text":"virtual popo :: ServerPortData * getMiddlewareServer ( const capro :: ServiceDescription & service , const popo :: ServerOptions & serverOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo () ) = 0 request the RouDi daemon to create a server port Parameters : serviceDescription service description for the new server port serverOptions like the queue capacity and queue full policy by a server portConfigInfo configuration information for the port (what type of port is requested, device where its payload memory is located on etc.) Return : pointer to a created server port data","title":"function getMiddlewareServer"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareinterface","text":"virtual popo :: InterfacePortData * getMiddlewareInterface ( const capro :: Interfaces interface , const NodeName_t & nodeName = {} ) = 0 request the RouDi daemon to create an interface port Parameters : interface interface to create nodeName name of the node where the interface should belong to Return : pointer to a created interface port data","title":"function getMiddlewareInterface"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getmiddlewareconditionvariable","text":"virtual popo :: ConditionVariableData * getMiddlewareConditionVariable () = 0 request the RouDi daemon to create a condition variable Return : pointer to a created condition variable data","title":"function getMiddlewareConditionVariable"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-createnode","text":"virtual NodeData * createNode ( const NodeProperty & nodeProperty ) = 0 request the RouDi daemon to create a node Parameters : nodeProperty class which contains all properties which the node should have Return : pointer to the data of the node","title":"function createNode"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-sendrequesttoroudi","text":"virtual bool sendRequestToRouDi ( const IpcMessage & msg , IpcMessage & answer ) = 0 send a request to the RouDi daemon and get the response currently each request is followed by a response Parameters : msg request message to send response from the RouDi daemon Return : true if sucessful request/response, false on error","title":"function sendRequestToRouDi"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getinstance","text":"static PoshRuntime & getInstance () returns active runtime Return : active runtime","title":"function getInstance"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-initruntime","text":"static PoshRuntime & initRuntime ( const RuntimeName_t & name ) creates the runtime with given name Parameters : name used for registering the process with the RouDi daemon Return : active runtime","title":"function initRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-poshruntime_3","text":"PoshRuntime ( cxx :: optional < const RuntimeName_t * > name )","title":"function PoshRuntime"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-verifyinstancename","text":"const RuntimeName_t & verifyInstanceName ( cxx :: optional < const RuntimeName_t * > name ) checks the given application name for certain constraints like length or if is empty","title":"function verifyInstanceName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-defaultruntimefactory","text":"static PoshRuntime & defaultRuntimeFactory ( cxx :: optional < const RuntimeName_t * > name )","title":"function defaultRuntimeFactory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getruntimefactory","text":"static factory_t & getRuntimeFactory () gets current runtime factory. If the runtime factory is not yet initialized it is set to defaultRuntimeFactory. Return : current runtime factory","title":"function getRuntimeFactory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-setruntimefactory","text":"static void setRuntimeFactory ( const factory_t & factory ) sets runtime factory, terminates if given factory is empty Parameters : factory std::function to which the runtime factory should be set","title":"function setRuntimeFactory"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#function-getinstance_1","text":"static PoshRuntime & getInstance ( cxx :: optional < const RuntimeName_t * > name ) creates the runtime or returns the already existing one -> Singleton Parameters : name optional containing the name used for registering with the RouDi daemon Return : active runtime","title":"function getInstance"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#variable-m_appname","text":"const RuntimeName_t m_appName ;","title":"variable m_appName"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#variable-m_shutdownrequested","text":"std :: atomic < bool > m_shutdownRequested { false };","title":"variable m_shutdownRequested"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntime/#friend-roudiruntimetestinterface","text":"friend class roudi :: RuntimeTestInterface ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend roudi::RuntimeTestInterface"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/","text":"iox::runtime::PoshRuntimeSingleProcess \ud83d\udd17 Inherits from PoshRuntimeImpl Public Functions \ud83d\udd17 Name PoshRuntimeSingleProcess (const RuntimeName_t & name) ~PoshRuntimeSingleProcess () Public Functions Documentation \ud83d\udd17 function PoshRuntimeSingleProcess \ud83d\udd17 PoshRuntimeSingleProcess ( const RuntimeName_t & name ) function ~PoshRuntimeSingleProcess \ud83d\udd17 ~ PoshRuntimeSingleProcess () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::runtime::PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#ioxruntimeposhruntimesingleprocess","text":"Inherits from PoshRuntimeImpl","title":"iox::runtime::PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#public-functions","text":"Name PoshRuntimeSingleProcess (const RuntimeName_t & name) ~PoshRuntimeSingleProcess ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#function-poshruntimesingleprocess","text":"PoshRuntimeSingleProcess ( const RuntimeName_t & name )","title":"function PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1PoshRuntimeSingleProcess/#function-poshruntimesingleprocess_1","text":"~ PoshRuntimeSingleProcess () Updated on 18 December 2023 at 13:11:43 CET","title":"function ~PoshRuntimeSingleProcess"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/","text":"iox::runtime::ServiceDiscovery \ud83d\udd17 Public Functions \ud83d\udd17 Name ServiceDiscovery () ServiceDiscovery (const ServiceDiscovery & ) ServiceDiscovery & operator= (const ServiceDiscovery & ) ServiceDiscovery ( ServiceDiscovery && ) ServiceDiscovery & operator= ( ServiceDiscovery && ) ~ServiceDiscovery () =default void findService (const cxx::optional< capro::IdString_t > & service, const cxx::optional< capro::IdString_t > & instance, const cxx::optional< capro::IdString_t > & event, const cxx::function_ref< void(const capro::ServiceDescription &)> & callableForEach, const popo::MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. Public Functions Documentation \ud83d\udd17 function ServiceDiscovery \ud83d\udd17 ServiceDiscovery () function ServiceDiscovery \ud83d\udd17 ServiceDiscovery ( const ServiceDiscovery & ) function operator= \ud83d\udd17 ServiceDiscovery & operator = ( const ServiceDiscovery & ) function ServiceDiscovery \ud83d\udd17 ServiceDiscovery ( ServiceDiscovery && ) function operator= \ud83d\udd17 ServiceDiscovery & operator = ( ServiceDiscovery && ) function ~ServiceDiscovery \ud83d\udd17 ~ ServiceDiscovery () = default function findService \ud83d\udd17 void findService ( const cxx :: optional < capro :: IdString_t > & service , const cxx :: optional < capro :: IdString_t > & instance , const cxx :: optional < capro :: IdString_t > & event , const cxx :: function_ref < void ( const capro :: ServiceDescription & ) > & callableForEach , const popo :: MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. Parameters : service service string to search for, a nullopt corresponds to a wildcard instance instance string to search for, a nullopt corresponds to a wildcard event event string to search for, a nullopt corresponds to a wildcard callableForEach callable to apply to all matching services pattern messaging pattern of the service to search Updated on 18 December 2023 at 13:11:43 CET","title":"iox::runtime::ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#ioxruntimeservicediscovery","text":"","title":"iox::runtime::ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#public-functions","text":"Name ServiceDiscovery () ServiceDiscovery (const ServiceDiscovery & ) ServiceDiscovery & operator= (const ServiceDiscovery & ) ServiceDiscovery ( ServiceDiscovery && ) ServiceDiscovery & operator= ( ServiceDiscovery && ) ~ServiceDiscovery () =default void findService (const cxx::optional< capro::IdString_t > & service, const cxx::optional< capro::IdString_t > & instance, const cxx::optional< capro::IdString_t > & event, const cxx::function_ref< void(const capro::ServiceDescription &)> & callableForEach, const popo::MessagingPattern pattern) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them.","title":"Public Functions"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery","text":"ServiceDiscovery ()","title":"function ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery_1","text":"ServiceDiscovery ( const ServiceDiscovery & )","title":"function ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-operator","text":"ServiceDiscovery & operator = ( const ServiceDiscovery & )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery_2","text":"ServiceDiscovery ( ServiceDiscovery && )","title":"function ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-operator_1","text":"ServiceDiscovery & operator = ( ServiceDiscovery && )","title":"function operator="},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-servicediscovery_3","text":"~ ServiceDiscovery () = default","title":"function ~ServiceDiscovery"},{"location":"API-reference/posh/Classes/classiox_1_1runtime_1_1ServiceDiscovery/#function-findservice","text":"void findService ( const cxx :: optional < capro :: IdString_t > & service , const cxx :: optional < capro :: IdString_t > & instance , const cxx :: optional < capro :: IdString_t > & event , const cxx :: function_ref < void ( const capro :: ServiceDescription & ) > & callableForEach , const popo :: MessagingPattern pattern ) Searches all services with the given messaging pattern that match the provided service description and applies a function to each of them. Parameters : service service string to search for, a nullopt corresponds to a wildcard instance instance string to search for, a nullopt corresponds to a wildcard event event string to search for, a nullopt corresponds to a wildcard callableForEach callable to apply to all matching services pattern messaging pattern of the service to search Updated on 18 December 2023 at 13:11:43 CET","title":"function findService"},{"location":"API-reference/posh/Classes/structiox_1_1Config/","text":"iox::Config \ud83d\udd17 More... Inherits from ConfigParts Public Functions \ud83d\udd17 Name Config & setDefaults () template <typename T > Config & setModuleDefaults () Config & optimize () Detailed Description \ud83d\udd17 template < typename ... ConfigParts > struct iox :: Config ; Public Functions Documentation \ud83d\udd17 function setDefaults \ud83d\udd17 inline Config & setDefaults () function setModuleDefaults \ud83d\udd17 template < typename T > inline Config & setModuleDefaults () function optimize \ud83d\udd17 inline Config & optimize () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::Config"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#ioxconfig","text":"More... Inherits from ConfigParts","title":"iox::Config"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#public-functions","text":"Name Config & setDefaults () template <typename T > Config & setModuleDefaults () Config & optimize ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#detailed-description","text":"template < typename ... ConfigParts > struct iox :: Config ;","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#function-setdefaults","text":"inline Config & setDefaults ()","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#function-setmoduledefaults","text":"template < typename T > inline Config & setModuleDefaults ()","title":"function setModuleDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1Config/#function-optimize","text":"inline Config & optimize () Updated on 18 December 2023 at 13:11:43 CET","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/","text":"iox::DefaultChunkDistributorConfig \ud83d\udd17 Public Attributes \ud83d\udd17 Name constexpr uint32_t MAX_QUEUES constexpr uint64_t MAX_HISTORY_CAPACITY Public Attributes Documentation \ud83d\udd17 variable MAX_QUEUES \ud83d\udd17 static constexpr uint32_t MAX_QUEUES = MAX_SUBSCRIBERS_PER_PUBLISHER ; variable MAX_HISTORY_CAPACITY \ud83d\udd17 static constexpr uint64_t MAX_HISTORY_CAPACITY = MAX_PUBLISHER_HISTORY ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::DefaultChunkDistributorConfig"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#ioxdefaultchunkdistributorconfig","text":"","title":"iox::DefaultChunkDistributorConfig"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#public-attributes","text":"Name constexpr uint32_t MAX_QUEUES constexpr uint64_t MAX_HISTORY_CAPACITY","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#variable-max_queues","text":"static constexpr uint32_t MAX_QUEUES = MAX_SUBSCRIBERS_PER_PUBLISHER ;","title":"variable MAX_QUEUES"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkDistributorConfig/#variable-max_history_capacity","text":"static constexpr uint64_t MAX_HISTORY_CAPACITY = MAX_PUBLISHER_HISTORY ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable MAX_HISTORY_CAPACITY"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/","text":"iox::DefaultChunkQueueConfig \ud83d\udd17 Public Attributes \ud83d\udd17 Name constexpr uint64_t MAX_QUEUE_CAPACITY Public Attributes Documentation \ud83d\udd17 variable MAX_QUEUE_CAPACITY \ud83d\udd17 static constexpr uint64_t MAX_QUEUE_CAPACITY = MAX_SUBSCRIBER_QUEUE_CAPACITY ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::DefaultChunkQueueConfig"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#ioxdefaultchunkqueueconfig","text":"","title":"iox::DefaultChunkQueueConfig"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#public-attributes","text":"Name constexpr uint64_t MAX_QUEUE_CAPACITY","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1DefaultChunkQueueConfig/#variable-max_queue_capacity","text":"static constexpr uint64_t MAX_QUEUE_CAPACITY = MAX_SUBSCRIBER_QUEUE_CAPACITY ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable MAX_QUEUE_CAPACITY"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/","text":"iox::capro::ServiceDescription::ClassHash \ud83d\udd17 Public Functions \ud83d\udd17 Name ClassHash () ClassHash (const std::initializer_list< uint32_t > & values) uint32_t & operator[] (iox::cxx::range< uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 > index) const uint32_t & operator[] (iox::cxx::range< uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 > index) const bool operator== (const ClassHash & rhs) const bool operator!= (const ClassHash & rhs) const Public Functions Documentation \ud83d\udd17 function ClassHash \ud83d\udd17 ClassHash () function ClassHash \ud83d\udd17 ClassHash ( const std :: initializer_list < uint32_t > & values ) function operator[] \ud83d\udd17 uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) function operator[] \ud83d\udd17 const uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) const function operator== \ud83d\udd17 bool operator == ( const ClassHash & rhs ) const function operator!= \ud83d\udd17 bool operator != ( const ClassHash & rhs ) const Updated on 18 December 2023 at 13:11:43 CET","title":"iox::capro::ServiceDescription::ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#ioxcaproservicedescriptionclasshash","text":"","title":"iox::capro::ServiceDescription::ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#public-functions","text":"Name ClassHash () ClassHash (const std::initializer_list< uint32_t > & values) uint32_t & operator[] (iox::cxx::range< uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 > index) const uint32_t & operator[] (iox::cxx::range< uint64_t, 0, CLASS_HASH_ELEMENT_COUNT - 1 > index) const bool operator== (const ClassHash & rhs) const bool operator!= (const ClassHash & rhs) const","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-classhash","text":"ClassHash ()","title":"function ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-classhash_1","text":"ClassHash ( const std :: initializer_list < uint32_t > & values )","title":"function ClassHash"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator","text":"uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index )","title":"function operator[]"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator_1","text":"const uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) const","title":"function operator[]"},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator_2","text":"bool operator == ( const ClassHash & rhs ) const","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1capro_1_1ServiceDescription_1_1ClassHash/#function-operator_3","text":"bool operator != ( const ClassHash & rhs ) const Updated on 18 December 2023 at 13:11:43 CET","title":"function operator!="},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/","text":"iox::config::CmdLineArgs_t \ud83d\udd17 Public Attributes \ud83d\udd17 Name roudi::MonitoringMode monitoringMode iox::log::LogLevel logLevel version::CompatibilityCheckLevel compatibilityCheckLevel units::Duration processKillDelay cxx::optional< uint16_t > uniqueRouDiId bool run roudi::ConfigFilePathString_t configFilePath Public Attributes Documentation \ud83d\udd17 variable monitoringMode \ud83d\udd17 roudi :: MonitoringMode monitoringMode { roudi :: MonitoringMode :: ON }; variable logLevel \ud83d\udd17 iox :: log :: LogLevel logLevel { iox :: log :: LogLevel :: kWarn }; variable compatibilityCheckLevel \ud83d\udd17 version :: CompatibilityCheckLevel compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; variable processKillDelay \ud83d\udd17 units :: Duration processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; variable uniqueRouDiId \ud83d\udd17 cxx :: optional < uint16_t > uniqueRouDiId { cxx :: nullopt }; variable run \ud83d\udd17 bool run { true }; variable configFilePath \ud83d\udd17 roudi :: ConfigFilePathString_t configFilePath ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::CmdLineArgs_t"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#ioxconfigcmdlineargs_t","text":"","title":"iox::config::CmdLineArgs_t"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#public-attributes","text":"Name roudi::MonitoringMode monitoringMode iox::log::LogLevel logLevel version::CompatibilityCheckLevel compatibilityCheckLevel units::Duration processKillDelay cxx::optional< uint16_t > uniqueRouDiId bool run roudi::ConfigFilePathString_t configFilePath","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-monitoringmode","text":"roudi :: MonitoringMode monitoringMode { roudi :: MonitoringMode :: ON };","title":"variable monitoringMode"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-loglevel","text":"iox :: log :: LogLevel logLevel { iox :: log :: LogLevel :: kWarn };","title":"variable logLevel"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-compatibilitychecklevel","text":"version :: CompatibilityCheckLevel compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH };","title":"variable compatibilityCheckLevel"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-processkilldelay","text":"units :: Duration processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY };","title":"variable processKillDelay"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-uniqueroudiid","text":"cxx :: optional < uint16_t > uniqueRouDiId { cxx :: nullopt };","title":"variable uniqueRouDiId"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-run","text":"bool run { true };","title":"variable run"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1CmdLineArgs__t/#variable-configfilepath","text":"roudi :: ConfigFilePathString_t configFilePath ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable configFilePath"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/","text":"iox::config::GatewayConfig \ud83d\udd17 Generic configuration for gateways. #include <iceoryx_posh/gateway/gateway_config.hpp> Public Classes \ud83d\udd17 Name struct ServiceEntry Public Functions \ud83d\udd17 Name void setDefaults () Public Attributes \ud83d\udd17 Name iox::cxx::vector< ServiceEntry , MAX_GATEWAY_SERVICES > m_configuredServices Public Functions Documentation \ud83d\udd17 function setDefaults \ud83d\udd17 void setDefaults () Public Attributes Documentation \ud83d\udd17 variable m_configuredServices \ud83d\udd17 iox :: cxx :: vector < ServiceEntry , MAX_GATEWAY_SERVICES > m_configuredServices ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::GatewayConfig"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#ioxconfiggatewayconfig","text":"Generic configuration for gateways. #include <iceoryx_posh/gateway/gateway_config.hpp>","title":"iox::config::GatewayConfig"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-classes","text":"Name struct ServiceEntry","title":"Public Classes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-functions","text":"Name void setDefaults ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-attributes","text":"Name iox::cxx::vector< ServiceEntry , MAX_GATEWAY_SERVICES > m_configuredServices","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#function-setdefaults","text":"void setDefaults ()","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig/#variable-m_configuredservices","text":"iox :: cxx :: vector < ServiceEntry , MAX_GATEWAY_SERVICES > m_configuredServices ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_configuredServices"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/","text":"iox::config::GatewayConfig::ServiceEntry \ud83d\udd17 Public Attributes \ud83d\udd17 Name capro::ServiceDescription m_serviceDescription Public Attributes Documentation \ud83d\udd17 variable m_serviceDescription \ud83d\udd17 capro :: ServiceDescription m_serviceDescription ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::GatewayConfig::ServiceEntry"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#ioxconfiggatewayconfigserviceentry","text":"","title":"iox::config::GatewayConfig::ServiceEntry"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#public-attributes","text":"Name capro::ServiceDescription m_serviceDescription","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1GatewayConfig_1_1ServiceEntry/#variable-m_servicedescription","text":"capro :: ServiceDescription m_serviceDescription ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_serviceDescription"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/","text":"iox::config::RouDiConfig \ud83d\udd17 Public Functions \ud83d\udd17 Name RouDiConfig & setDefaults () RouDiConfig & optimize () Public Functions Documentation \ud83d\udd17 function setDefaults \ud83d\udd17 RouDiConfig & setDefaults () function optimize \ud83d\udd17 RouDiConfig & optimize () Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config::RouDiConfig"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#ioxconfigroudiconfig","text":"","title":"iox::config::RouDiConfig"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#public-functions","text":"Name RouDiConfig & setDefaults () RouDiConfig & optimize ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#function-setdefaults","text":"RouDiConfig & setDefaults ()","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1config_1_1RouDiConfig/#function-optimize","text":"RouDiConfig & optimize () Updated on 18 December 2023 at 13:11:43 CET","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize/","text":"iox::helper::Optimize \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename ... ConfigParts > struct iox :: helper :: Optimize ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper::Optimize"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize/#ioxhelperoptimize","text":"More...","title":"iox::helper::Optimize"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize/#detailed-description","text":"template < typename ... ConfigParts > struct iox :: helper :: Optimize ; Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/","text":"iox::helper::Optimize< FinalArg > \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename BaseType > void apply (BaseType * me) Detailed Description \ud83d\udd17 template < typename FinalArg > struct iox :: helper :: Optimize < FinalArg > ; Public Functions Documentation \ud83d\udd17 function apply \ud83d\udd17 template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper::Optimize< FinalArg >"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#ioxhelperoptimize-finalarg","text":"More...","title":"iox::helper::Optimize&lt; FinalArg &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#public-functions","text":"Name template <typename BaseType > void apply (BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#detailed-description","text":"template < typename FinalArg > struct iox :: helper :: Optimize < FinalArg > ;","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FinalArg_01_4/#function-apply","text":"template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/","text":"iox::helper::Optimize< FirstArg, RemainderArgs... > \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename BaseType > void apply (BaseType * me) Detailed Description \ud83d\udd17 template < typename FirstArg , typename ... RemainderArgs > struct iox :: helper :: Optimize < FirstArg , RemainderArgs ... > ; Public Functions Documentation \ud83d\udd17 function apply \ud83d\udd17 template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper::Optimize< FirstArg, RemainderArgs... >"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#ioxhelperoptimize-firstarg-remainderargs","text":"More...","title":"iox::helper::Optimize&lt; FirstArg, RemainderArgs... &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions","text":"Name template <typename BaseType > void apply (BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#detailed-description","text":"template < typename FirstArg , typename ... RemainderArgs > struct iox :: helper :: Optimize < FirstArg , RemainderArgs ... > ;","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1Optimize_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#function-apply","text":"template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults/","text":"iox::helper::SetDefaults \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename ... ConfigParts > struct iox :: helper :: SetDefaults ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper::SetDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults/#ioxhelpersetdefaults","text":"More...","title":"iox::helper::SetDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults/#detailed-description","text":"template < typename ... ConfigParts > struct iox :: helper :: SetDefaults ; Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/","text":"iox::helper::SetDefaults< FinalArg > \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename BaseType > void apply (BaseType * me) Detailed Description \ud83d\udd17 template < typename FinalArg > struct iox :: helper :: SetDefaults < FinalArg > ; Public Functions Documentation \ud83d\udd17 function apply \ud83d\udd17 template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper::SetDefaults< FinalArg >"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#ioxhelpersetdefaults-finalarg","text":"More...","title":"iox::helper::SetDefaults&lt; FinalArg &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#public-functions","text":"Name template <typename BaseType > void apply (BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#detailed-description","text":"template < typename FinalArg > struct iox :: helper :: SetDefaults < FinalArg > ;","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FinalArg_01_4/#function-apply","text":"template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/","text":"iox::helper::SetDefaults< FirstArg, RemainderArgs... > \ud83d\udd17 More... Public Functions \ud83d\udd17 Name template <typename BaseType > void apply (BaseType * me) Detailed Description \ud83d\udd17 template < typename FirstArg , typename ... RemainderArgs > struct iox :: helper :: SetDefaults < FirstArg , RemainderArgs ... > ; Public Functions Documentation \ud83d\udd17 function apply \ud83d\udd17 template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper::SetDefaults< FirstArg, RemainderArgs... >"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#ioxhelpersetdefaults-firstarg-remainderargs","text":"More...","title":"iox::helper::SetDefaults&lt; FirstArg, RemainderArgs... &gt;"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions","text":"Name template <typename BaseType > void apply (BaseType * me)","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#detailed-description","text":"template < typename FirstArg , typename ... RemainderArgs > struct iox :: helper :: SetDefaults < FirstArg , RemainderArgs ... > ;","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1helper_1_1SetDefaults_3_01FirstArg_00_01RemainderArgs_8_8_8_01_4/#function-apply","text":"template < typename BaseType > static inline void apply ( BaseType * me ) Updated on 18 December 2023 at 13:11:43 CET","title":"function apply"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/","text":"iox::mepoo::ChunkHeader \ud83d\udd17 Public Types \ud83d\udd17 Name using uint32_t UserPayloadOffset_t Public Functions \ud83d\udd17 Name ChunkHeader (const uint32_t chunkSize, const ChunkSettings & chunkSettings) constructs and initializes a ChunkHeader ChunkHeader (const ChunkHeader & ) ChunkHeader ( ChunkHeader && ) ChunkHeader & operator= (const ChunkHeader & ) ChunkHeader & operator= ( ChunkHeader && ) uint8_t chunkHeaderVersion () const The ChunkHeader version is used to detect incompatibilities for record&replay functionality. uint16_t userHeaderId () const The id of the user-header used by the chunk; if no user-header is used, this is set to NO_USER_HEADER. void * userHeader () Get the pointer to the user-header. const void * userHeader () const Get the const pointer to the user-header. void * userPayload () Get a pointer to the user-payload carried by the chunk. const void * userPayload () const Get a const pointer to the user-payload carried by the chunk. uint32_t usedSizeOfChunk () const Calculates the used size of the chunk with the ChunkHeader , user-heander and user-payload. uint32_t chunkSize () const The size of the whole chunk, including the header. uint32_t userHeaderSize () const The size of the chunk occupied by the user-header. uint32_t userPayloadSize () const The size of the chunk occupied by the user-payload. uint32_t userPayloadAlignment () const The alignment of the chunk occupied by the user-payload. popo::UniquePortId originId () const The unique identifier of the publisher the chunk was sent from. uint64_t sequenceNumber () const A serial number for the sent chunks. ChunkHeader * fromUserPayload (void *const userPayload) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. const ChunkHeader * fromUserPayload (const void *const userPayload) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. ChunkHeader * fromUserHeader (void *const userHeader) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. const ChunkHeader * fromUserHeader (const void *const userHeader) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. Public Attributes \ud83d\udd17 Name constexpr uint8_t CHUNK_HEADER_VERSION From the 1.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint16_t NO_USER_HEADER User-Header id for no user-header. constexpr uint16_t UNKNOWN_USER_HEADER User-Header id for an unknown user-header. Friends \ud83d\udd17 Name class popo::ChunkSender Public Types Documentation \ud83d\udd17 using UserPayloadOffset_t \ud83d\udd17 using iox :: mepoo :: ChunkHeader :: UserPayloadOffset_t = uint32_t ; Public Functions Documentation \ud83d\udd17 function ChunkHeader \ud83d\udd17 ChunkHeader ( const uint32_t chunkSize , const ChunkSettings & chunkSettings ) constructs and initializes a ChunkHeader Parameters : chunkSize is the size of the chunk the ChunkHeader is constructed chunkSettings are the settings like user-payload size and user-header alignment function ChunkHeader \ud83d\udd17 ChunkHeader ( const ChunkHeader & ) function ChunkHeader \ud83d\udd17 ChunkHeader ( ChunkHeader && ) function operator= \ud83d\udd17 ChunkHeader & operator = ( const ChunkHeader & ) function operator= \ud83d\udd17 ChunkHeader & operator = ( ChunkHeader && ) function chunkHeaderVersion \ud83d\udd17 uint8_t chunkHeaderVersion () const The ChunkHeader version is used to detect incompatibilities for record&replay functionality. Return : the ChunkHeader version function userHeaderId \ud83d\udd17 uint16_t userHeaderId () const The id of the user-header used by the chunk; if no user-header is used, this is set to NO_USER_HEADER. Return : the user-header id of the chunk function userHeader \ud83d\udd17 void * userHeader () Get the pointer to the user-header. Return : the pointer to the user-header function userHeader \ud83d\udd17 const void * userHeader () const Get the const pointer to the user-header. Return : the const pointer to the user-header function userPayload \ud83d\udd17 void * userPayload () Get a pointer to the user-payload carried by the chunk. Return : the pointer to the user-payload function userPayload \ud83d\udd17 const void * userPayload () const Get a const pointer to the user-payload carried by the chunk. Return : the const pointer to the user-payload function usedSizeOfChunk \ud83d\udd17 uint32_t usedSizeOfChunk () const Calculates the used size of the chunk with the ChunkHeader , user-heander and user-payload. Return : the used size of the chunk function chunkSize \ud83d\udd17 uint32_t chunkSize () const The size of the whole chunk, including the header. Return : the chunk size function userHeaderSize \ud83d\udd17 uint32_t userHeaderSize () const The size of the chunk occupied by the user-header. Return : the user-header size function userPayloadSize \ud83d\udd17 uint32_t userPayloadSize () const The size of the chunk occupied by the user-payload. Return : the user-payload size function userPayloadAlignment \ud83d\udd17 uint32_t userPayloadAlignment () const The alignment of the chunk occupied by the user-payload. Return : the user-payload alignment function originId \ud83d\udd17 popo :: UniquePortId originId () const The unique identifier of the publisher the chunk was sent from. Return : the id of the publisher the chunk was sent from function sequenceNumber \ud83d\udd17 uint64_t sequenceNumber () const A serial number for the sent chunks. the serquence number of the chunk function fromUserPayload \ud83d\udd17 static ChunkHeader * fromUserPayload ( void * const userPayload ) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. Parameters : userPayload is the pointer to the user-payload of the chunk Return : the pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userPayload is a nullptr function fromUserPayload \ud83d\udd17 static const ChunkHeader * fromUserPayload ( const void * const userPayload ) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. Parameters : userPayload is the const pointer to the user-payload of the chunk Return : the const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userPayload is a nullptr function fromUserHeader \ud83d\udd17 static ChunkHeader * fromUserHeader ( void * const userHeader ) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. Parameters : userHeader is the pointer to the user-header of the chunk Return : the pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userHeader is a nullptr function fromUserHeader \ud83d\udd17 static const ChunkHeader * fromUserHeader ( const void * const userHeader ) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. Parameters : userHeader is the const pointer to the user-header of the chunk Return : the const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userPayload is a nullptr Public Attributes Documentation \ud83d\udd17 variable CHUNK_HEADER_VERSION \ud83d\udd17 static constexpr uint8_t CHUNK_HEADER_VERSION { 1U }; From the 1.0 release onward, this must be incremented for each incompatible change, e.g. data width of members changes members are rearranged semantic meaning of a member changes variable NO_USER_HEADER \ud83d\udd17 static constexpr uint16_t NO_USER_HEADER { 0x0000 }; User-Header id for no user-header. variable UNKNOWN_USER_HEADER \ud83d\udd17 static constexpr uint16_t UNKNOWN_USER_HEADER { 0xFFFF }; User-Header id for an unknown user-header. Friends \ud83d\udd17 friend popo::ChunkSender \ud83d\udd17 friend class popo :: ChunkSender ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#ioxmepoochunkheader","text":"","title":"iox::mepoo::ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-types","text":"Name using uint32_t UserPayloadOffset_t","title":"Public Types"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-functions","text":"Name ChunkHeader (const uint32_t chunkSize, const ChunkSettings & chunkSettings) constructs and initializes a ChunkHeader ChunkHeader (const ChunkHeader & ) ChunkHeader ( ChunkHeader && ) ChunkHeader & operator= (const ChunkHeader & ) ChunkHeader & operator= ( ChunkHeader && ) uint8_t chunkHeaderVersion () const The ChunkHeader version is used to detect incompatibilities for record&replay functionality. uint16_t userHeaderId () const The id of the user-header used by the chunk; if no user-header is used, this is set to NO_USER_HEADER. void * userHeader () Get the pointer to the user-header. const void * userHeader () const Get the const pointer to the user-header. void * userPayload () Get a pointer to the user-payload carried by the chunk. const void * userPayload () const Get a const pointer to the user-payload carried by the chunk. uint32_t usedSizeOfChunk () const Calculates the used size of the chunk with the ChunkHeader , user-heander and user-payload. uint32_t chunkSize () const The size of the whole chunk, including the header. uint32_t userHeaderSize () const The size of the chunk occupied by the user-header. uint32_t userPayloadSize () const The size of the chunk occupied by the user-payload. uint32_t userPayloadAlignment () const The alignment of the chunk occupied by the user-payload. popo::UniquePortId originId () const The unique identifier of the publisher the chunk was sent from. uint64_t sequenceNumber () const A serial number for the sent chunks. ChunkHeader * fromUserPayload (void *const userPayload) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. const ChunkHeader * fromUserPayload (const void *const userPayload) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. ChunkHeader * fromUserHeader (void *const userHeader) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. const ChunkHeader * fromUserHeader (const void *const userHeader) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk.","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-attributes","text":"Name constexpr uint8_t CHUNK_HEADER_VERSION From the 1.0 release onward, this must be incremented for each incompatible change, e.g. constexpr uint16_t NO_USER_HEADER User-Header id for no user-header. constexpr uint16_t UNKNOWN_USER_HEADER User-Header id for an unknown user-header.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#friends","text":"Name class popo::ChunkSender","title":"Friends"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#using-userpayloadoffset_t","text":"using iox :: mepoo :: ChunkHeader :: UserPayloadOffset_t = uint32_t ;","title":"using UserPayloadOffset_t"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheader","text":"ChunkHeader ( const uint32_t chunkSize , const ChunkSettings & chunkSettings ) constructs and initializes a ChunkHeader Parameters : chunkSize is the size of the chunk the ChunkHeader is constructed chunkSettings are the settings like user-payload size and user-header alignment","title":"function ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheader_1","text":"ChunkHeader ( const ChunkHeader & )","title":"function ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheader_2","text":"ChunkHeader ( ChunkHeader && )","title":"function ChunkHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-operator","text":"ChunkHeader & operator = ( const ChunkHeader & )","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-operator_1","text":"ChunkHeader & operator = ( ChunkHeader && )","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunkheaderversion","text":"uint8_t chunkHeaderVersion () const The ChunkHeader version is used to detect incompatibilities for record&replay functionality. Return : the ChunkHeader version","title":"function chunkHeaderVersion"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheaderid","text":"uint16_t userHeaderId () const The id of the user-header used by the chunk; if no user-header is used, this is set to NO_USER_HEADER. Return : the user-header id of the chunk","title":"function userHeaderId"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheader","text":"void * userHeader () Get the pointer to the user-header. Return : the pointer to the user-header","title":"function userHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheader_1","text":"const void * userHeader () const Get the const pointer to the user-header. Return : the const pointer to the user-header","title":"function userHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayload","text":"void * userPayload () Get a pointer to the user-payload carried by the chunk. Return : the pointer to the user-payload","title":"function userPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayload_1","text":"const void * userPayload () const Get a const pointer to the user-payload carried by the chunk. Return : the const pointer to the user-payload","title":"function userPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-usedsizeofchunk","text":"uint32_t usedSizeOfChunk () const Calculates the used size of the chunk with the ChunkHeader , user-heander and user-payload. Return : the used size of the chunk","title":"function usedSizeOfChunk"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-chunksize","text":"uint32_t chunkSize () const The size of the whole chunk, including the header. Return : the chunk size","title":"function chunkSize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userheadersize","text":"uint32_t userHeaderSize () const The size of the chunk occupied by the user-header. Return : the user-header size","title":"function userHeaderSize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayloadsize","text":"uint32_t userPayloadSize () const The size of the chunk occupied by the user-payload. Return : the user-payload size","title":"function userPayloadSize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-userpayloadalignment","text":"uint32_t userPayloadAlignment () const The alignment of the chunk occupied by the user-payload. Return : the user-payload alignment","title":"function userPayloadAlignment"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-originid","text":"popo :: UniquePortId originId () const The unique identifier of the publisher the chunk was sent from. Return : the id of the publisher the chunk was sent from","title":"function originId"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-sequencenumber","text":"uint64_t sequenceNumber () const A serial number for the sent chunks. the serquence number of the chunk","title":"function sequenceNumber"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserpayload","text":"static ChunkHeader * fromUserPayload ( void * const userPayload ) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. Parameters : userPayload is the pointer to the user-payload of the chunk Return : the pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userPayload is a nullptr","title":"function fromUserPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserpayload_1","text":"static const ChunkHeader * fromUserPayload ( const void * const userPayload ) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-payload of the chunk. Parameters : userPayload is the const pointer to the user-payload of the chunk Return : the const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userPayload is a nullptr","title":"function fromUserPayload"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserheader","text":"static ChunkHeader * fromUserHeader ( void * const userHeader ) Get a pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. Parameters : userHeader is the pointer to the user-header of the chunk Return : the pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userHeader is a nullptr","title":"function fromUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#function-fromuserheader_1","text":"static const ChunkHeader * fromUserHeader ( const void * const userHeader ) Get a const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) associated to the user-header of the chunk. Parameters : userHeader is the const pointer to the user-header of the chunk Return : the const pointer to the [ChunkHeader](/v2.0.5/API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/) or a nullptr if userPayload is a nullptr","title":"function fromUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#variable-chunk_header_version","text":"static constexpr uint8_t CHUNK_HEADER_VERSION { 1U }; From the 1.0 release onward, this must be incremented for each incompatible change, e.g. data width of members changes members are rearranged semantic meaning of a member changes","title":"variable CHUNK_HEADER_VERSION"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#variable-no_user_header","text":"static constexpr uint16_t NO_USER_HEADER { 0x0000 }; User-Header id for no user-header.","title":"variable NO_USER_HEADER"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#variable-unknown_user_header","text":"static constexpr uint16_t UNKNOWN_USER_HEADER { 0xFFFF }; User-Header id for an unknown user-header.","title":"variable UNKNOWN_USER_HEADER"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#friends_1","text":"","title":"Friends"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1ChunkHeader/#friend-popochunksender","text":"friend class popo :: ChunkSender ; Updated on 18 December 2023 at 13:11:43 CET","title":"friend popo::ChunkSender"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/","text":"iox::mepoo::MePooConfig \ud83d\udd17 Public Classes \ud83d\udd17 Name struct Entry Public Types \ud83d\udd17 Name using cxx::vector< Entry , MAX_NUMBER_OF_MEMPOOLS > MePooConfigContainerType Public Functions \ud83d\udd17 Name MePooConfig () =default Default constructor to set the configuration for memory pools. const MePooConfigContainerType * getMemPoolConfig () const Get function for receiving memory pool configuration. void addMemPool ( Entry f_entry) Function for adding new entry. MePooConfig & setDefaults () Function for creating default memory pools. MePooConfig & optimize () Function for optimizing the size of memory pool according to new entry. Public Attributes \ud83d\udd17 Name MePooConfigContainerType m_mempoolConfig Public Types Documentation \ud83d\udd17 using MePooConfigContainerType \ud83d\udd17 using iox :: mepoo :: MePooConfig :: MePooConfigContainerType = cxx :: vector < Entry , MAX_NUMBER_OF_MEMPOOLS > ; Public Functions Documentation \ud83d\udd17 function MePooConfig \ud83d\udd17 MePooConfig () = default Default constructor to set the configuration for memory pools. function getMemPoolConfig \ud83d\udd17 const MePooConfigContainerType * getMemPoolConfig () const Get function for receiving memory pool configuration. Return : cxx::vector of config information size and count of chunks function addMemPool \ud83d\udd17 void addMemPool ( Entry f_entry ) Function for adding new entry. Parameters : Entry structure of mempool configuration function setDefaults \ud83d\udd17 MePooConfig & setDefaults () Function for creating default memory pools. function optimize \ud83d\udd17 MePooConfig & optimize () Function for optimizing the size of memory pool according to new entry. Public Attributes Documentation \ud83d\udd17 variable m_mempoolConfig \ud83d\udd17 MePooConfigContainerType m_mempoolConfig ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::MePooConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#ioxmepoomepooconfig","text":"","title":"iox::mepoo::MePooConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-classes","text":"Name struct Entry","title":"Public Classes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-types","text":"Name using cxx::vector< Entry , MAX_NUMBER_OF_MEMPOOLS > MePooConfigContainerType","title":"Public Types"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-functions","text":"Name MePooConfig () =default Default constructor to set the configuration for memory pools. const MePooConfigContainerType * getMemPoolConfig () const Get function for receiving memory pool configuration. void addMemPool ( Entry f_entry) Function for adding new entry. MePooConfig & setDefaults () Function for creating default memory pools. MePooConfig & optimize () Function for optimizing the size of memory pool according to new entry.","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-attributes","text":"Name MePooConfigContainerType m_mempoolConfig","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#using-mepooconfigcontainertype","text":"using iox :: mepoo :: MePooConfig :: MePooConfigContainerType = cxx :: vector < Entry , MAX_NUMBER_OF_MEMPOOLS > ;","title":"using MePooConfigContainerType"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-mepooconfig","text":"MePooConfig () = default Default constructor to set the configuration for memory pools.","title":"function MePooConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-getmempoolconfig","text":"const MePooConfigContainerType * getMemPoolConfig () const Get function for receiving memory pool configuration. Return : cxx::vector of config information size and count of chunks","title":"function getMemPoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-addmempool","text":"void addMemPool ( Entry f_entry ) Function for adding new entry. Parameters : Entry structure of mempool configuration","title":"function addMemPool"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-setdefaults","text":"MePooConfig & setDefaults () Function for creating default memory pools.","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#function-optimize","text":"MePooConfig & optimize () Function for optimizing the size of memory pool according to new entry.","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig/#variable-m_mempoolconfig","text":"MePooConfigContainerType m_mempoolConfig ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_mempoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/","text":"iox::mepoo::MePooConfig::Entry \ud83d\udd17 Public Functions \ud83d\udd17 Name Entry (uint32_t f_size, uint32_t f_chunkCount) set the size and count of memory chunks Public Attributes \ud83d\udd17 Name uint32_t m_size uint32_t m_chunkCount Public Functions Documentation \ud83d\udd17 function Entry \ud83d\udd17 inline Entry ( uint32_t f_size , uint32_t f_chunkCount ) set the size and count of memory chunks Public Attributes Documentation \ud83d\udd17 variable m_size \ud83d\udd17 uint32_t m_size { 0 }; variable m_chunkCount \ud83d\udd17 uint32_t m_chunkCount { 0 }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::MePooConfig::Entry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#ioxmepoomepooconfigentry","text":"","title":"iox::mepoo::MePooConfig::Entry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-functions","text":"Name Entry (uint32_t f_size, uint32_t f_chunkCount) set the size and count of memory chunks","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-attributes","text":"Name uint32_t m_size uint32_t m_chunkCount","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#function-entry","text":"inline Entry ( uint32_t f_size , uint32_t f_chunkCount ) set the size and count of memory chunks","title":"function Entry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#variable-m_size","text":"uint32_t m_size { 0 };","title":"variable m_size"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MePooConfig_1_1Entry/#variable-m_chunkcount","text":"uint32_t m_chunkCount { 0 }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_chunkCount"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/","text":"iox::mepoo::MemoryInfo \ud83d\udd17 Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics. #include <iceoryx_posh/mepoo/memory_info.hpp> Public Functions \ud83d\udd17 Name MemoryInfo (const MemoryInfo & ) =default MemoryInfo ( MemoryInfo && ) =default MemoryInfo & operator= (const MemoryInfo & ) =default MemoryInfo & operator= ( MemoryInfo && ) =default MemoryInfo (uint32_t deviceId =DEFAULT_DEVICE_ID, uint32_t memoryType =DEFAULT_MEMORY_TYPE) creates a MemoryInfo object bool operator== (const MemoryInfo & rhs) const comparison operator Public Attributes \ud83d\udd17 Name constexpr uint32_t DEFAULT_DEVICE_ID constexpr uint32_t DEFAULT_MEMORY_TYPE uint32_t deviceId uint32_t memoryType Public Functions Documentation \ud83d\udd17 function MemoryInfo \ud83d\udd17 MemoryInfo ( const MemoryInfo & ) = default function MemoryInfo \ud83d\udd17 MemoryInfo ( MemoryInfo && ) = default function operator= \ud83d\udd17 MemoryInfo & operator = ( const MemoryInfo & ) = default function operator= \ud83d\udd17 MemoryInfo & operator = ( MemoryInfo && ) = default function MemoryInfo \ud83d\udd17 explicit MemoryInfo ( uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) creates a MemoryInfo object Parameters : deviceId specifies the device where the memory is located memoryType encodes additional information about the memory function operator== \ud83d\udd17 bool operator == ( const MemoryInfo & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison Public Attributes Documentation \ud83d\udd17 variable DEFAULT_DEVICE_ID \ud83d\udd17 static constexpr uint32_t DEFAULT_DEVICE_ID { 0U }; variable DEFAULT_MEMORY_TYPE \ud83d\udd17 static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U }; variable deviceId \ud83d\udd17 uint32_t deviceId { DEFAULT_DEVICE_ID }; variable memoryType \ud83d\udd17 uint32_t memoryType { DEFAULT_MEMORY_TYPE }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#ioxmepoomemoryinfo","text":"Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics. #include <iceoryx_posh/mepoo/memory_info.hpp>","title":"iox::mepoo::MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-functions","text":"Name MemoryInfo (const MemoryInfo & ) =default MemoryInfo ( MemoryInfo && ) =default MemoryInfo & operator= (const MemoryInfo & ) =default MemoryInfo & operator= ( MemoryInfo && ) =default MemoryInfo (uint32_t deviceId =DEFAULT_DEVICE_ID, uint32_t memoryType =DEFAULT_MEMORY_TYPE) creates a MemoryInfo object bool operator== (const MemoryInfo & rhs) const comparison operator","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-attributes","text":"Name constexpr uint32_t DEFAULT_DEVICE_ID constexpr uint32_t DEFAULT_MEMORY_TYPE uint32_t deviceId uint32_t memoryType","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-memoryinfo","text":"MemoryInfo ( const MemoryInfo & ) = default","title":"function MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-memoryinfo_1","text":"MemoryInfo ( MemoryInfo && ) = default","title":"function MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-operator","text":"MemoryInfo & operator = ( const MemoryInfo & ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-operator_1","text":"MemoryInfo & operator = ( MemoryInfo && ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-memoryinfo_2","text":"explicit MemoryInfo ( uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) creates a MemoryInfo object Parameters : deviceId specifies the device where the memory is located memoryType encodes additional information about the memory","title":"function MemoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#function-operator_2","text":"bool operator == ( const MemoryInfo & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-default_device_id","text":"static constexpr uint32_t DEFAULT_DEVICE_ID { 0U };","title":"variable DEFAULT_DEVICE_ID"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-default_memory_type","text":"static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U };","title":"variable DEFAULT_MEMORY_TYPE"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-deviceid","text":"uint32_t deviceId { DEFAULT_DEVICE_ID };","title":"variable deviceId"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1MemoryInfo/#variable-memorytype","text":"uint32_t memoryType { DEFAULT_MEMORY_TYPE }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable memoryType"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1NoUserHeader/","text":"iox::mepoo::NoUserHeader \ud83d\udd17 Helper struct to use as default template parameter when no user-header is used. #include <iceoryx_posh/mepoo/chunk_header.hpp> Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::NoUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1NoUserHeader/#ioxmepoonouserheader","text":"Helper struct to use as default template parameter when no user-header is used. #include <iceoryx_posh/mepoo/chunk_header.hpp> Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::NoUserHeader"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/","text":"iox::mepoo::SegmentConfig \ud83d\udd17 Public Classes \ud83d\udd17 Name struct SegmentEntry Public Functions \ud83d\udd17 Name SegmentConfig & setDefaults () Set Function for default values to be added in SegmentConfig . SegmentConfig & optimize () Public Attributes \ud83d\udd17 Name cxx::vector< SegmentEntry , MAX_SHM_SEGMENTS > m_sharedMemorySegments Public Functions Documentation \ud83d\udd17 function setDefaults \ud83d\udd17 SegmentConfig & setDefaults () Set Function for default values to be added in SegmentConfig . function optimize \ud83d\udd17 SegmentConfig & optimize () Public Attributes Documentation \ud83d\udd17 variable m_sharedMemorySegments \ud83d\udd17 cxx :: vector < SegmentEntry , MAX_SHM_SEGMENTS > m_sharedMemorySegments ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::SegmentConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#ioxmepoosegmentconfig","text":"","title":"iox::mepoo::SegmentConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-classes","text":"Name struct SegmentEntry","title":"Public Classes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-functions","text":"Name SegmentConfig & setDefaults () Set Function for default values to be added in SegmentConfig . SegmentConfig & optimize ()","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-attributes","text":"Name cxx::vector< SegmentEntry , MAX_SHM_SEGMENTS > m_sharedMemorySegments","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#function-setdefaults","text":"SegmentConfig & setDefaults () Set Function for default values to be added in SegmentConfig .","title":"function setDefaults"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#function-optimize","text":"SegmentConfig & optimize ()","title":"function optimize"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig/#variable-m_sharedmemorysegments","text":"cxx :: vector < SegmentEntry , MAX_SHM_SEGMENTS > m_sharedMemorySegments ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_sharedMemorySegments"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/","text":"iox::mepoo::SegmentConfig::SegmentEntry \ud83d\udd17 Public Functions \ud83d\udd17 Name SegmentEntry (const posix::PosixGroup::string_t & readerGroup, const posix::PosixGroup::string_t & writerGroup, const MePooConfig & memPoolConfig, iox::mepoo::MemoryInfo memoryInfo = iox::mepoo::MemoryInfo ()) Public Attributes \ud83d\udd17 Name posix::PosixGroup::string_t m_readerGroup posix::PosixGroup::string_t m_writerGroup MePooConfig m_mempoolConfig iox::mepoo::MemoryInfo m_memoryInfo Public Functions Documentation \ud83d\udd17 function SegmentEntry \ud83d\udd17 inline SegmentEntry ( const posix :: PosixGroup :: string_t & readerGroup , const posix :: PosixGroup :: string_t & writerGroup , const MePooConfig & memPoolConfig , iox :: mepoo :: MemoryInfo memoryInfo = iox :: mepoo :: MemoryInfo () ) Public Attributes Documentation \ud83d\udd17 variable m_readerGroup \ud83d\udd17 posix :: PosixGroup :: string_t m_readerGroup ; variable m_writerGroup \ud83d\udd17 posix :: PosixGroup :: string_t m_writerGroup ; variable m_mempoolConfig \ud83d\udd17 MePooConfig m_mempoolConfig ; variable m_memoryInfo \ud83d\udd17 iox :: mepoo :: MemoryInfo m_memoryInfo ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo::SegmentConfig::SegmentEntry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#ioxmepoosegmentconfigsegmententry","text":"","title":"iox::mepoo::SegmentConfig::SegmentEntry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-functions","text":"Name SegmentEntry (const posix::PosixGroup::string_t & readerGroup, const posix::PosixGroup::string_t & writerGroup, const MePooConfig & memPoolConfig, iox::mepoo::MemoryInfo memoryInfo = iox::mepoo::MemoryInfo ())","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-attributes","text":"Name posix::PosixGroup::string_t m_readerGroup posix::PosixGroup::string_t m_writerGroup MePooConfig m_mempoolConfig iox::mepoo::MemoryInfo m_memoryInfo","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#function-segmententry","text":"inline SegmentEntry ( const posix :: PosixGroup :: string_t & readerGroup , const posix :: PosixGroup :: string_t & writerGroup , const MePooConfig & memPoolConfig , iox :: mepoo :: MemoryInfo memoryInfo = iox :: mepoo :: MemoryInfo () )","title":"function SegmentEntry"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_readergroup","text":"posix :: PosixGroup :: string_t m_readerGroup ;","title":"variable m_readerGroup"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_writergroup","text":"posix :: PosixGroup :: string_t m_writerGroup ;","title":"variable m_writerGroup"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_mempoolconfig","text":"MePooConfig m_mempoolConfig ;","title":"variable m_mempoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1mepoo_1_1SegmentConfig_1_1SegmentEntry/#variable-m_memoryinfo","text":"iox :: mepoo :: MemoryInfo m_memoryInfo ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_memoryInfo"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/","text":"iox::popo::ClientOptions \ud83d\udd17 This struct is used to configure the client. #include <iceoryx_posh/popo/client_options.hpp> Public Functions \ud83d\udd17 Name cxx::Serialization serialize () const serialization of the ClientOptions bool operator== (const ClientOptions & rhs) const comparison operator cxx::expected< ClientOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the ClientOptions Public Attributes \ud83d\udd17 Name uint64_t responseQueueCapacity The size of the response queue where chunks are stored before they are passed to the user. iox::NodeName_t nodeName The name of the node where the client should belong to. bool connectOnCreate The option whether the client shall try to connect when creating it. QueueFullPolicy responseQueueFullPolicy The option whether the server should block when the response queue is full. ConsumerTooSlowPolicy serverTooSlowPolicy The option whether the client should block when the request queue is full. Public Functions Documentation \ud83d\udd17 function serialize \ud83d\udd17 cxx :: Serialization serialize () const serialization of the ClientOptions function operator== \ud83d\udd17 bool operator == ( const ClientOptions & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison function deserialize \ud83d\udd17 static cxx :: expected < ClientOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the ClientOptions Public Attributes Documentation \ud83d\udd17 variable responseQueueCapacity \ud83d\udd17 uint64_t responseQueueCapacity { ClientChunkQueueData_t :: MAX_CAPACITY }; The size of the response queue where chunks are stored before they are passed to the user. Attention : Depending on the underlying queue there can be a different overflow behavior variable nodeName \ud83d\udd17 iox :: NodeName_t nodeName { \"\" }; The name of the node where the client should belong to. variable connectOnCreate \ud83d\udd17 bool connectOnCreate { true }; The option whether the client shall try to connect when creating it. variable responseQueueFullPolicy \ud83d\udd17 QueueFullPolicy responseQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; The option whether the server should block when the response queue is full. Note : Corresponds with ServerOptions::clientTooSlowPolicy variable serverTooSlowPolicy \ud83d\udd17 ConsumerTooSlowPolicy serverTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; The option whether the client should block when the request queue is full. Note : Corresponds with ServerOptions::requestQueueFullPolicy Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ClientOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#ioxpopoclientoptions","text":"This struct is used to configure the client. #include <iceoryx_posh/popo/client_options.hpp>","title":"iox::popo::ClientOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-functions","text":"Name cxx::Serialization serialize () const serialization of the ClientOptions bool operator== (const ClientOptions & rhs) const comparison operator cxx::expected< ClientOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the ClientOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-attributes","text":"Name uint64_t responseQueueCapacity The size of the response queue where chunks are stored before they are passed to the user. iox::NodeName_t nodeName The name of the node where the client should belong to. bool connectOnCreate The option whether the client shall try to connect when creating it. QueueFullPolicy responseQueueFullPolicy The option whether the server should block when the response queue is full. ConsumerTooSlowPolicy serverTooSlowPolicy The option whether the client should block when the request queue is full.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#function-serialize","text":"cxx :: Serialization serialize () const serialization of the ClientOptions","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#function-operator","text":"bool operator == ( const ClientOptions & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#function-deserialize","text":"static cxx :: expected < ClientOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the ClientOptions","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-responsequeuecapacity","text":"uint64_t responseQueueCapacity { ClientChunkQueueData_t :: MAX_CAPACITY }; The size of the response queue where chunks are stored before they are passed to the user. Attention : Depending on the underlying queue there can be a different overflow behavior","title":"variable responseQueueCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-nodename","text":"iox :: NodeName_t nodeName { \"\" }; The name of the node where the client should belong to.","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-connectoncreate","text":"bool connectOnCreate { true }; The option whether the client shall try to connect when creating it.","title":"variable connectOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-responsequeuefullpolicy","text":"QueueFullPolicy responseQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; The option whether the server should block when the response queue is full. Note : Corresponds with ServerOptions::clientTooSlowPolicy","title":"variable responseQueueFullPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ClientOptions/#variable-servertooslowpolicy","text":"ConsumerTooSlowPolicy serverTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; The option whether the client should block when the request queue is full. Note : Corresponds with ServerOptions::requestQueueFullPolicy Updated on 18 December 2023 at 13:11:43 CET","title":"variable serverTooSlowPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventBasedTrigger__t/","text":"iox::popo::EventBasedTrigger_t \ud83d\udd17 Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::EventBasedTrigger_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventBasedTrigger__t/#ioxpopoeventbasedtrigger_t","text":"Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::EventBasedTrigger_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventCallback/","text":"iox::popo::EventCallback \ud83d\udd17 More... Detailed Description \ud83d\udd17 template < typename OriginType , typename ContextDataType > struct iox :: popo :: EventCallback ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::EventCallback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventCallback/#ioxpopoeventcallback","text":"More...","title":"iox::popo::EventCallback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1EventCallback/#detailed-description","text":"template < typename OriginType , typename ContextDataType > struct iox :: popo :: EventCallback ; Updated on 18 December 2023 at 13:11:43 CET","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/","text":"iox::popo::NotificationCallback \ud83d\udd17 the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener More... #include <iceoryx_posh/popo/notification_callback.hpp> Public Types \ud83d\udd17 Name using void(&)(OriginType const, ContextDataType const) Ref_t using void( )(OriginType const, ContextDataType *const) Ptr_t Public Attributes \ud83d\udd17 Name Ptr_t m_callback ContextDataType * m_contextData Detailed Description \ud83d\udd17 template < typename OriginType , typename ContextDataType > struct iox :: popo :: NotificationCallback ; the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener Public Types Documentation \ud83d\udd17 using Ref_t \ud83d\udd17 using iox :: popo :: NotificationCallback < OriginType , ContextDataType >:: Ref_t = void ( & )( OriginType * const , ContextDataType * const ); using Ptr_t \ud83d\udd17 using iox :: popo :: NotificationCallback < OriginType , ContextDataType >:: Ptr_t = void ( * )( OriginType * const , ContextDataType * const ); Public Attributes Documentation \ud83d\udd17 variable m_callback \ud83d\udd17 Ptr_t m_callback = nullptr ; variable m_contextData \ud83d\udd17 ContextDataType * m_contextData = nullptr ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::NotificationCallback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#ioxpoponotificationcallback","text":"the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener More... #include <iceoryx_posh/popo/notification_callback.hpp>","title":"iox::popo::NotificationCallback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-types","text":"Name using void(&)(OriginType const, ContextDataType const) Ref_t using void( )(OriginType const, ContextDataType *const) Ptr_t","title":"Public Types"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-attributes","text":"Name Ptr_t m_callback ContextDataType * m_contextData","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#detailed-description","text":"template < typename OriginType , typename ContextDataType > struct iox :: popo :: NotificationCallback ; the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener","title":"Detailed Description"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#using-ref_t","text":"using iox :: popo :: NotificationCallback < OriginType , ContextDataType >:: Ref_t = void ( & )( OriginType * const , ContextDataType * const );","title":"using Ref_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#using-ptr_t","text":"using iox :: popo :: NotificationCallback < OriginType , ContextDataType >:: Ptr_t = void ( * )( OriginType * const , ContextDataType * const );","title":"using Ptr_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#variable-m_callback","text":"Ptr_t m_callback = nullptr ;","title":"variable m_callback"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1NotificationCallback/#variable-m_contextdata","text":"ContextDataType * m_contextData = nullptr ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_contextData"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/","text":"iox::popo::PublisherOptions \ud83d\udd17 This struct is used to configure the publisher. #include <iceoryx_posh/popo/publisher_options.hpp> Public Functions \ud83d\udd17 Name cxx::Serialization serialize () const serialization of the PublisherOptions cxx::expected< PublisherOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the PublisherOptions Public Attributes \ud83d\udd17 Name uint64_t historyCapacity The size of the history chunk queue. iox::NodeName_t nodeName The name of the node where the publisher should belong to. bool offerOnCreate The option whether the publisher should already be offered when creating it. ConsumerTooSlowPolicy subscriberTooSlowPolicy The option whether the publisher should block when the subscriber queue is full. Public Functions Documentation \ud83d\udd17 function serialize \ud83d\udd17 cxx :: Serialization serialize () const serialization of the PublisherOptions function deserialize \ud83d\udd17 static cxx :: expected < PublisherOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the PublisherOptions Public Attributes Documentation \ud83d\udd17 variable historyCapacity \ud83d\udd17 uint64_t historyCapacity { 0U }; The size of the history chunk queue. variable nodeName \ud83d\udd17 iox :: NodeName_t nodeName { \"\" }; The name of the node where the publisher should belong to. variable offerOnCreate \ud83d\udd17 bool offerOnCreate { true }; The option whether the publisher should already be offered when creating it. variable subscriberTooSlowPolicy \ud83d\udd17 ConsumerTooSlowPolicy subscriberTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; The option whether the publisher should block when the subscriber queue is full. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::PublisherOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#ioxpopopublisheroptions","text":"This struct is used to configure the publisher. #include <iceoryx_posh/popo/publisher_options.hpp>","title":"iox::popo::PublisherOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-functions","text":"Name cxx::Serialization serialize () const serialization of the PublisherOptions cxx::expected< PublisherOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the PublisherOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-attributes","text":"Name uint64_t historyCapacity The size of the history chunk queue. iox::NodeName_t nodeName The name of the node where the publisher should belong to. bool offerOnCreate The option whether the publisher should already be offered when creating it. ConsumerTooSlowPolicy subscriberTooSlowPolicy The option whether the publisher should block when the subscriber queue is full.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#function-serialize","text":"cxx :: Serialization serialize () const serialization of the PublisherOptions","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#function-deserialize","text":"static cxx :: expected < PublisherOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the PublisherOptions","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-historycapacity","text":"uint64_t historyCapacity { 0U }; The size of the history chunk queue.","title":"variable historyCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-nodename","text":"iox :: NodeName_t nodeName { \"\" }; The name of the node where the publisher should belong to.","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-offeroncreate","text":"bool offerOnCreate { true }; The option whether the publisher should already be offered when creating it.","title":"variable offerOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1PublisherOptions/#variable-subscribertooslowpolicy","text":"ConsumerTooSlowPolicy subscriberTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; The option whether the publisher should block when the subscriber queue is full. Updated on 18 December 2023 at 13:11:43 CET","title":"variable subscriberTooSlowPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/","text":"iox::popo::ServerOptions \ud83d\udd17 This struct is used to configure the server. #include <iceoryx_posh/popo/server_options.hpp> Public Functions \ud83d\udd17 Name cxx::Serialization serialize () const serialization of the ServerOptions bool operator== (const ServerOptions & rhs) const comparison operator cxx::expected< ServerOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the ServerOptions Public Attributes \ud83d\udd17 Name uint64_t requestQueueCapacity The size of the request queue where chunks are stored before they are passed to the user. iox::NodeName_t nodeName The name of the node where the server should belong to. bool offerOnCreate The option whether the server should already be offered when creating it. QueueFullPolicy requestQueueFullPolicy The option whether the client should block when the request queue is full. ConsumerTooSlowPolicy clientTooSlowPolicy The option whether the server should block when the response queue is full. Public Functions Documentation \ud83d\udd17 function serialize \ud83d\udd17 cxx :: Serialization serialize () const serialization of the ServerOptions function operator== \ud83d\udd17 bool operator == ( const ServerOptions & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison function deserialize \ud83d\udd17 static cxx :: expected < ServerOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the ServerOptions Public Attributes Documentation \ud83d\udd17 variable requestQueueCapacity \ud83d\udd17 uint64_t requestQueueCapacity { ServerChunkQueueData_t :: MAX_CAPACITY }; The size of the request queue where chunks are stored before they are passed to the user. Attention : Depending on the underlying queue there can be a different overflow behavior variable nodeName \ud83d\udd17 iox :: NodeName_t nodeName { \"\" }; The name of the node where the server should belong to. variable offerOnCreate \ud83d\udd17 bool offerOnCreate { true }; The option whether the server should already be offered when creating it. variable requestQueueFullPolicy \ud83d\udd17 QueueFullPolicy requestQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; The option whether the client should block when the request queue is full. Note : Corresponds with ClientOptions::serverTooSlowPolicy variable clientTooSlowPolicy \ud83d\udd17 ConsumerTooSlowPolicy clientTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; The option whether the server should block when the response queue is full. Note : Corresponds with ClientOptions::responseQueueFullPolicy Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::ServerOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#ioxpoposerveroptions","text":"This struct is used to configure the server. #include <iceoryx_posh/popo/server_options.hpp>","title":"iox::popo::ServerOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-functions","text":"Name cxx::Serialization serialize () const serialization of the ServerOptions bool operator== (const ServerOptions & rhs) const comparison operator cxx::expected< ServerOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the ServerOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-attributes","text":"Name uint64_t requestQueueCapacity The size of the request queue where chunks are stored before they are passed to the user. iox::NodeName_t nodeName The name of the node where the server should belong to. bool offerOnCreate The option whether the server should already be offered when creating it. QueueFullPolicy requestQueueFullPolicy The option whether the client should block when the request queue is full. ConsumerTooSlowPolicy clientTooSlowPolicy The option whether the server should block when the response queue is full.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#function-serialize","text":"cxx :: Serialization serialize () const serialization of the ServerOptions","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#function-operator","text":"bool operator == ( const ServerOptions & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#function-deserialize","text":"static cxx :: expected < ServerOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the ServerOptions","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-requestqueuecapacity","text":"uint64_t requestQueueCapacity { ServerChunkQueueData_t :: MAX_CAPACITY }; The size of the request queue where chunks are stored before they are passed to the user. Attention : Depending on the underlying queue there can be a different overflow behavior","title":"variable requestQueueCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-nodename","text":"iox :: NodeName_t nodeName { \"\" }; The name of the node where the server should belong to.","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-offeroncreate","text":"bool offerOnCreate { true }; The option whether the server should already be offered when creating it.","title":"variable offerOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-requestqueuefullpolicy","text":"QueueFullPolicy requestQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; The option whether the client should block when the request queue is full. Note : Corresponds with ClientOptions::serverTooSlowPolicy","title":"variable requestQueueFullPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1ServerOptions/#variable-clienttooslowpolicy","text":"ConsumerTooSlowPolicy clientTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; The option whether the server should block when the response queue is full. Note : Corresponds with ClientOptions::responseQueueFullPolicy Updated on 18 December 2023 at 13:11:43 CET","title":"variable clientTooSlowPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1StateBasedTrigger__t/","text":"iox::popo::StateBasedTrigger_t \ud83d\udd17 Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::StateBasedTrigger_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1StateBasedTrigger__t/#ioxpopostatebasedtrigger_t","text":"Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::StateBasedTrigger_t"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/","text":"iox::popo::SubscriberOptions \ud83d\udd17 This struct is used to configure the subscriber. #include <iceoryx_posh/popo/subscriber_options.hpp> Public Functions \ud83d\udd17 Name cxx::Serialization serialize () const serialization of the SubscriberOptions cxx::expected< SubscriberOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the SubscriberOptions Public Attributes \ud83d\udd17 Name uint64_t queueCapacity The size of the receiver queue where chunks are stored before they are passed to the user. uint64_t historyRequest The max number of chunks received after subscription if chunks are available. iox::NodeName_t nodeName The name of the node where the subscriber should belong to. bool subscribeOnCreate The option whether the subscriber shall try to subscribe when creating it. QueueFullPolicy queueFullPolicy The option whether the publisher should block when the subscriber queue is full. bool requiresPublisherHistorySupport Indicates whether to enforce history support of the publisher, i.e. require historyCapacity > 0 to be eligible to be connected. Public Functions Documentation \ud83d\udd17 function serialize \ud83d\udd17 cxx :: Serialization serialize () const serialization of the SubscriberOptions function deserialize \ud83d\udd17 static cxx :: expected < SubscriberOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the SubscriberOptions Public Attributes Documentation \ud83d\udd17 variable queueCapacity \ud83d\udd17 uint64_t queueCapacity { SubscriberChunkQueueData_t :: MAX_CAPACITY }; The size of the receiver queue where chunks are stored before they are passed to the user. Attention : Depending on the underlying queue there can be a different overflow behavior variable historyRequest \ud83d\udd17 uint64_t historyRequest { 0U }; The max number of chunks received after subscription if chunks are available. variable nodeName \ud83d\udd17 iox :: NodeName_t nodeName { \"\" }; The name of the node where the subscriber should belong to. variable subscribeOnCreate \ud83d\udd17 bool subscribeOnCreate { true }; The option whether the subscriber shall try to subscribe when creating it. variable queueFullPolicy \ud83d\udd17 QueueFullPolicy queueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; The option whether the publisher should block when the subscriber queue is full. variable requiresPublisherHistorySupport \ud83d\udd17 bool requiresPublisherHistorySupport { false }; Indicates whether to enforce history support of the publisher, i.e. require historyCapacity > 0 to be eligible to be connected. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::SubscriberOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#ioxpoposubscriberoptions","text":"This struct is used to configure the subscriber. #include <iceoryx_posh/popo/subscriber_options.hpp>","title":"iox::popo::SubscriberOptions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-functions","text":"Name cxx::Serialization serialize () const serialization of the SubscriberOptions cxx::expected< SubscriberOptions , cxx::Serialization::Error > deserialize (const cxx::Serialization & serialized) deserialization of the SubscriberOptions","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-attributes","text":"Name uint64_t queueCapacity The size of the receiver queue where chunks are stored before they are passed to the user. uint64_t historyRequest The max number of chunks received after subscription if chunks are available. iox::NodeName_t nodeName The name of the node where the subscriber should belong to. bool subscribeOnCreate The option whether the subscriber shall try to subscribe when creating it. QueueFullPolicy queueFullPolicy The option whether the publisher should block when the subscriber queue is full. bool requiresPublisherHistorySupport Indicates whether to enforce history support of the publisher, i.e. require historyCapacity > 0 to be eligible to be connected.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#function-serialize","text":"cxx :: Serialization serialize () const serialization of the SubscriberOptions","title":"function serialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#function-deserialize","text":"static cxx :: expected < SubscriberOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) deserialization of the SubscriberOptions","title":"function deserialize"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-queuecapacity","text":"uint64_t queueCapacity { SubscriberChunkQueueData_t :: MAX_CAPACITY }; The size of the receiver queue where chunks are stored before they are passed to the user. Attention : Depending on the underlying queue there can be a different overflow behavior","title":"variable queueCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-historyrequest","text":"uint64_t historyRequest { 0U }; The max number of chunks received after subscription if chunks are available.","title":"variable historyRequest"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-nodename","text":"iox :: NodeName_t nodeName { \"\" }; The name of the node where the subscriber should belong to.","title":"variable nodeName"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-subscribeoncreate","text":"bool subscribeOnCreate { true }; The option whether the subscriber shall try to subscribe when creating it.","title":"variable subscribeOnCreate"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-queuefullpolicy","text":"QueueFullPolicy queueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; The option whether the publisher should block when the subscriber queue is full.","title":"variable queueFullPolicy"},{"location":"API-reference/posh/Classes/structiox_1_1popo_1_1SubscriberOptions/#variable-requirespublisherhistorysupport","text":"bool requiresPublisherHistorySupport { false }; Indicates whether to enforce history support of the publisher, i.e. require historyCapacity > 0 to be eligible to be connected. Updated on 18 December 2023 at 13:11:43 CET","title":"variable requiresPublisherHistorySupport"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/","text":"iox::roudi::DefaultRouDiMemory \ud83d\udd17 Public Functions \ud83d\udd17 Name DefaultRouDiMemory (const RouDiConfig_t & roudiConfig) virtual ~DefaultRouDiMemory () =default DefaultRouDiMemory ( DefaultRouDiMemory && ) DefaultRouDiMemory & operator= ( DefaultRouDiMemory && ) DefaultRouDiMemory (const DefaultRouDiMemory & ) DefaultRouDiMemory & operator= (const DefaultRouDiMemory & ) mepoo::MePooConfig introspectionMemPoolConfig () const Public Attributes \ud83d\udd17 Name MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock PosixShmMemoryProvider m_managementShm Public Functions Documentation \ud83d\udd17 function DefaultRouDiMemory \ud83d\udd17 DefaultRouDiMemory ( const RouDiConfig_t & roudiConfig ) function ~DefaultRouDiMemory \ud83d\udd17 virtual ~ DefaultRouDiMemory () = default function DefaultRouDiMemory \ud83d\udd17 DefaultRouDiMemory ( DefaultRouDiMemory && ) function operator= \ud83d\udd17 DefaultRouDiMemory & operator = ( DefaultRouDiMemory && ) function DefaultRouDiMemory \ud83d\udd17 DefaultRouDiMemory ( const DefaultRouDiMemory & ) function operator= \ud83d\udd17 DefaultRouDiMemory & operator = ( const DefaultRouDiMemory & ) function introspectionMemPoolConfig \ud83d\udd17 mepoo :: MePooConfig introspectionMemPoolConfig () const Public Attributes Documentation \ud83d\udd17 variable m_introspectionMemPoolBlock \ud83d\udd17 MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock ; variable m_segmentManagerBlock \ud83d\udd17 MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock ; variable m_managementShm \ud83d\udd17 PosixShmMemoryProvider m_managementShm ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#ioxroudidefaultroudimemory","text":"","title":"iox::roudi::DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-functions","text":"Name DefaultRouDiMemory (const RouDiConfig_t & roudiConfig) virtual ~DefaultRouDiMemory () =default DefaultRouDiMemory ( DefaultRouDiMemory && ) DefaultRouDiMemory & operator= ( DefaultRouDiMemory && ) DefaultRouDiMemory (const DefaultRouDiMemory & ) DefaultRouDiMemory & operator= (const DefaultRouDiMemory & ) mepoo::MePooConfig introspectionMemPoolConfig () const","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-attributes","text":"Name MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock PosixShmMemoryProvider m_managementShm","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory","text":"DefaultRouDiMemory ( const RouDiConfig_t & roudiConfig )","title":"function DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory_1","text":"virtual ~ DefaultRouDiMemory () = default","title":"function ~DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory_2","text":"DefaultRouDiMemory ( DefaultRouDiMemory && )","title":"function DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-operator","text":"DefaultRouDiMemory & operator = ( DefaultRouDiMemory && )","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-defaultroudimemory_3","text":"DefaultRouDiMemory ( const DefaultRouDiMemory & )","title":"function DefaultRouDiMemory"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-operator_1","text":"DefaultRouDiMemory & operator = ( const DefaultRouDiMemory & )","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#function-introspectionmempoolconfig","text":"mepoo :: MePooConfig introspectionMemPoolConfig () const","title":"function introspectionMemPoolConfig"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#variable-m_introspectionmempoolblock","text":"MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock ;","title":"variable m_introspectionMemPoolBlock"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#variable-m_segmentmanagerblock","text":"MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock ;","title":"variable m_segmentManagerBlock"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1DefaultRouDiMemory/#variable-m_managementshm","text":"PosixShmMemoryProvider m_managementShm ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_managementShm"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/","text":"iox::roudi::IceOryxRouDiComponents \ud83d\udd17 Public Functions \ud83d\udd17 Name IceOryxRouDiComponents (const RouDiConfig_t & roudiConfig) virtual ~IceOryxRouDiComponents () =default Public Attributes \ud83d\udd17 Name IceOryxRouDiMemoryManager rouDiMemoryManager Handles MemoryProvider and MemoryBlocks. PortManager portManager Handles the ports in shared memory. Public Functions Documentation \ud83d\udd17 function IceOryxRouDiComponents \ud83d\udd17 IceOryxRouDiComponents ( const RouDiConfig_t & roudiConfig ) function ~IceOryxRouDiComponents \ud83d\udd17 virtual ~ IceOryxRouDiComponents () = default Public Attributes Documentation \ud83d\udd17 variable rouDiMemoryManager \ud83d\udd17 IceOryxRouDiMemoryManager rouDiMemoryManager ; Handles MemoryProvider and MemoryBlocks. variable portManager \ud83d\udd17 PortManager portManager ; Handles the ports in shared memory. Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#ioxroudiiceoryxroudicomponents","text":"","title":"iox::roudi::IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-functions","text":"Name IceOryxRouDiComponents (const RouDiConfig_t & roudiConfig) virtual ~IceOryxRouDiComponents () =default","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-attributes","text":"Name IceOryxRouDiMemoryManager rouDiMemoryManager Handles MemoryProvider and MemoryBlocks. PortManager portManager Handles the ports in shared memory.","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#function-iceoryxroudicomponents","text":"IceOryxRouDiComponents ( const RouDiConfig_t & roudiConfig )","title":"function IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#function-iceoryxroudicomponents_1","text":"virtual ~ IceOryxRouDiComponents () = default","title":"function ~IceOryxRouDiComponents"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#variable-roudimemorymanager","text":"IceOryxRouDiMemoryManager rouDiMemoryManager ; Handles MemoryProvider and MemoryBlocks.","title":"variable rouDiMemoryManager"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1IceOryxRouDiComponents/#variable-portmanager","text":"PortManager portManager ; Handles the ports in shared memory. Updated on 18 December 2023 at 13:11:43 CET","title":"variable portManager"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/","text":"iox::roudi::MemPoolInfo \ud83d\udd17 struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools. #include <iceoryx_posh/roudi/introspection_types.hpp> Public Attributes \ud83d\udd17 Name uint32_t m_usedChunks uint32_t m_minFreeChunks uint32_t m_numChunks uint32_t m_chunkSize uint32_t m_chunkPayloadSize Public Attributes Documentation \ud83d\udd17 variable m_usedChunks \ud83d\udd17 uint32_t m_usedChunks { 0 }; variable m_minFreeChunks \ud83d\udd17 uint32_t m_minFreeChunks { 0 }; variable m_numChunks \ud83d\udd17 uint32_t m_numChunks { 0 }; variable m_chunkSize \ud83d\udd17 uint32_t m_chunkSize { 0 }; variable m_chunkPayloadSize \ud83d\udd17 uint32_t m_chunkPayloadSize { 0 }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::MemPoolInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#ioxroudimempoolinfo","text":"struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools. #include <iceoryx_posh/roudi/introspection_types.hpp>","title":"iox::roudi::MemPoolInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#public-attributes","text":"Name uint32_t m_usedChunks uint32_t m_minFreeChunks uint32_t m_numChunks uint32_t m_chunkSize uint32_t m_chunkPayloadSize","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_usedchunks","text":"uint32_t m_usedChunks { 0 };","title":"variable m_usedChunks"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_minfreechunks","text":"uint32_t m_minFreeChunks { 0 };","title":"variable m_minFreeChunks"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_numchunks","text":"uint32_t m_numChunks { 0 };","title":"variable m_numChunks"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_chunksize","text":"uint32_t m_chunkSize { 0 };","title":"variable m_chunkSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolInfo/#variable-m_chunkpayloadsize","text":"uint32_t m_chunkPayloadSize { 0 }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_chunkPayloadSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/","text":"iox::roudi::MemPoolIntrospectionInfo \ud83d\udd17 the topic for the mempool introspection that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp> Public Attributes \ud83d\udd17 Name uint32_t m_id cxx::string< MAX_GROUP_NAME_LENGTH > m_writerGroupName cxx::string< MAX_GROUP_NAME_LENGTH > m_readerGroupName MemPoolInfoContainer m_mempoolInfo Public Attributes Documentation \ud83d\udd17 variable m_id \ud83d\udd17 uint32_t m_id ; variable m_writerGroupName \ud83d\udd17 cxx :: string < MAX_GROUP_NAME_LENGTH > m_writerGroupName ; variable m_readerGroupName \ud83d\udd17 cxx :: string < MAX_GROUP_NAME_LENGTH > m_readerGroupName ; variable m_mempoolInfo \ud83d\udd17 MemPoolInfoContainer m_mempoolInfo ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::MemPoolIntrospectionInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#ioxroudimempoolintrospectioninfo","text":"the topic for the mempool introspection that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp>","title":"iox::roudi::MemPoolIntrospectionInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#public-attributes","text":"Name uint32_t m_id cxx::string< MAX_GROUP_NAME_LENGTH > m_writerGroupName cxx::string< MAX_GROUP_NAME_LENGTH > m_readerGroupName MemPoolInfoContainer m_mempoolInfo","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_id","text":"uint32_t m_id ;","title":"variable m_id"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_writergroupname","text":"cxx :: string < MAX_GROUP_NAME_LENGTH > m_writerGroupName ;","title":"variable m_writerGroupName"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_readergroupname","text":"cxx :: string < MAX_GROUP_NAME_LENGTH > m_readerGroupName ;","title":"variable m_readerGroupName"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1MemPoolIntrospectionInfo/#variable-m_mempoolinfo","text":"MemPoolInfoContainer m_mempoolInfo ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_mempoolInfo"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/","text":"iox::roudi::PortData \ud83d\udd17 container for common port data which is related to the subscriber port as well as the publisher port #include <iceoryx_posh/roudi/introspection_types.hpp> Inherited by iox::roudi::PublisherPortData Public Attributes \ud83d\udd17 Name RuntimeName_t m_name capro::IdString_t m_caproInstanceID capro::IdString_t m_caproServiceID capro::IdString_t m_caproEventMethodID NodeName_t m_node Public Attributes Documentation \ud83d\udd17 variable m_name \ud83d\udd17 RuntimeName_t m_name ; variable m_caproInstanceID \ud83d\udd17 capro :: IdString_t m_caproInstanceID ; variable m_caproServiceID \ud83d\udd17 capro :: IdString_t m_caproServiceID ; variable m_caproEventMethodID \ud83d\udd17 capro :: IdString_t m_caproEventMethodID ; variable m_node \ud83d\udd17 NodeName_t m_node ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PortData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#ioxroudiportdata","text":"container for common port data which is related to the subscriber port as well as the publisher port #include <iceoryx_posh/roudi/introspection_types.hpp> Inherited by iox::roudi::PublisherPortData","title":"iox::roudi::PortData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#public-attributes","text":"Name RuntimeName_t m_name capro::IdString_t m_caproInstanceID capro::IdString_t m_caproServiceID capro::IdString_t m_caproEventMethodID NodeName_t m_node","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_name","text":"RuntimeName_t m_name ;","title":"variable m_name"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_caproinstanceid","text":"capro :: IdString_t m_caproInstanceID ;","title":"variable m_caproInstanceID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_caproserviceid","text":"capro :: IdString_t m_caproServiceID ;","title":"variable m_caproServiceID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_caproeventmethodid","text":"capro :: IdString_t m_caproEventMethodID ;","title":"variable m_caproEventMethodID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortData/#variable-m_node","text":"NodeName_t m_node ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_node"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/","text":"iox::roudi::PortIntrospectionFieldTopic \ud83d\udd17 the topic for the port introspection that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp> Public Attributes \ud83d\udd17 Name cxx::vector< SubscriberPortData , MAX_SUBSCRIBERS > m_subscriberList cxx::vector< PublisherPortData , MAX_PUBLISHERS > m_publisherList Public Attributes Documentation \ud83d\udd17 variable m_subscriberList \ud83d\udd17 cxx :: vector < SubscriberPortData , MAX_SUBSCRIBERS > m_subscriberList ; variable m_publisherList \ud83d\udd17 cxx :: vector < PublisherPortData , MAX_PUBLISHERS > m_publisherList ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PortIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#ioxroudiportintrospectionfieldtopic","text":"the topic for the port introspection that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp>","title":"iox::roudi::PortIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#public-attributes","text":"Name cxx::vector< SubscriberPortData , MAX_SUBSCRIBERS > m_subscriberList cxx::vector< PublisherPortData , MAX_PUBLISHERS > m_publisherList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#variable-m_subscriberlist","text":"cxx :: vector < SubscriberPortData , MAX_SUBSCRIBERS > m_subscriberList ;","title":"variable m_subscriberList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortIntrospectionFieldTopic/#variable-m_publisherlist","text":"cxx :: vector < PublisherPortData , MAX_PUBLISHERS > m_publisherList ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_publisherList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/","text":"iox::roudi::PortThroughputData \ud83d\udd17 Public Attributes \ud83d\udd17 Name uint64_t m_publisherPortID uint32_t m_sampleSize uint32_t m_chunkSize double m_chunksPerMinute uint64_t m_lastSendIntervalInNanoseconds bool m_isField Public Attributes Documentation \ud83d\udd17 variable m_publisherPortID \ud83d\udd17 uint64_t m_publisherPortID { 0 }; variable m_sampleSize \ud83d\udd17 uint32_t m_sampleSize { 0 }; variable m_chunkSize \ud83d\udd17 uint32_t m_chunkSize { 0 }; variable m_chunksPerMinute \ud83d\udd17 double m_chunksPerMinute { 0 }; variable m_lastSendIntervalInNanoseconds \ud83d\udd17 uint64_t m_lastSendIntervalInNanoseconds { 0 }; variable m_isField \ud83d\udd17 bool m_isField { false }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PortThroughputData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#ioxroudiportthroughputdata","text":"","title":"iox::roudi::PortThroughputData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#public-attributes","text":"Name uint64_t m_publisherPortID uint32_t m_sampleSize uint32_t m_chunkSize double m_chunksPerMinute uint64_t m_lastSendIntervalInNanoseconds bool m_isField","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_publisherportid","text":"uint64_t m_publisherPortID { 0 };","title":"variable m_publisherPortID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_samplesize","text":"uint32_t m_sampleSize { 0 };","title":"variable m_sampleSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_chunksize","text":"uint32_t m_chunkSize { 0 };","title":"variable m_chunkSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_chunksperminute","text":"double m_chunksPerMinute { 0 };","title":"variable m_chunksPerMinute"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_lastsendintervalinnanoseconds","text":"uint64_t m_lastSendIntervalInNanoseconds { 0 };","title":"variable m_lastSendIntervalInNanoseconds"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputData/#variable-m_isfield","text":"bool m_isField { false }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_isField"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/","text":"iox::roudi::PortThroughputIntrospectionFieldTopic \ud83d\udd17 the topic for the port throughput that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp> Public Attributes \ud83d\udd17 Name cxx::vector< PortThroughputData , MAX_PUBLISHERS > m_throughputList Public Attributes Documentation \ud83d\udd17 variable m_throughputList \ud83d\udd17 cxx :: vector < PortThroughputData , MAX_PUBLISHERS > m_throughputList ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PortThroughputIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#ioxroudiportthroughputintrospectionfieldtopic","text":"the topic for the port throughput that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp>","title":"iox::roudi::PortThroughputIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#public-attributes","text":"Name cxx::vector< PortThroughputData , MAX_PUBLISHERS > m_throughputList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PortThroughputIntrospectionFieldTopic/#variable-m_throughputlist","text":"cxx :: vector < PortThroughputData , MAX_PUBLISHERS > m_throughputList ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_throughputList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/","text":"iox::roudi::ProcessIntrospectionData \ud83d\udd17 Public Attributes \ud83d\udd17 Name int m_pid RuntimeName_t m_name cxx::vector< NodeName_t, MAX_NODE_PER_PROCESS > m_nodes Public Attributes Documentation \ud83d\udd17 variable m_pid \ud83d\udd17 int m_pid { 0 }; variable m_name \ud83d\udd17 RuntimeName_t m_name ; variable m_nodes \ud83d\udd17 cxx :: vector < NodeName_t , MAX_NODE_PER_PROCESS > m_nodes ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::ProcessIntrospectionData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#ioxroudiprocessintrospectiondata","text":"","title":"iox::roudi::ProcessIntrospectionData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#public-attributes","text":"Name int m_pid RuntimeName_t m_name cxx::vector< NodeName_t, MAX_NODE_PER_PROCESS > m_nodes","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#variable-m_pid","text":"int m_pid { 0 };","title":"variable m_pid"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#variable-m_name","text":"RuntimeName_t m_name ;","title":"variable m_name"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionData/#variable-m_nodes","text":"cxx :: vector < NodeName_t , MAX_NODE_PER_PROCESS > m_nodes ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_nodes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/","text":"iox::roudi::ProcessIntrospectionFieldTopic \ud83d\udd17 the topic for the process introspection that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp> Public Attributes \ud83d\udd17 Name cxx::vector< ProcessIntrospectionData , MAX_PROCESS_NUMBER > m_processList Public Attributes Documentation \ud83d\udd17 variable m_processList \ud83d\udd17 cxx :: vector < ProcessIntrospectionData , MAX_PROCESS_NUMBER > m_processList ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::ProcessIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#ioxroudiprocessintrospectionfieldtopic","text":"the topic for the process introspection that a user can subscribe to #include <iceoryx_posh/roudi/introspection_types.hpp>","title":"iox::roudi::ProcessIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#public-attributes","text":"Name cxx::vector< ProcessIntrospectionData , MAX_PROCESS_NUMBER > m_processList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1ProcessIntrospectionFieldTopic/#variable-m_processlist","text":"cxx :: vector < ProcessIntrospectionData , MAX_PROCESS_NUMBER > m_processList ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_processList"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/","text":"iox::roudi::PublisherPortData \ud83d\udd17 container for publisher port introspection data. #include <iceoryx_posh/roudi/introspection_types.hpp> Inherits from iox::roudi::PortData Public Attributes \ud83d\udd17 Name uint64_t m_publisherPortID iox::capro::Interfaces m_sourceInterface Additional inherited members \ud83d\udd17 Public Attributes inherited from iox::roudi::PortData Name RuntimeName_t m_name capro::IdString_t m_caproInstanceID capro::IdString_t m_caproServiceID capro::IdString_t m_caproEventMethodID NodeName_t m_node Public Attributes Documentation \ud83d\udd17 variable m_publisherPortID \ud83d\udd17 uint64_t m_publisherPortID { 0 }; variable m_sourceInterface \ud83d\udd17 iox :: capro :: Interfaces m_sourceInterface { iox :: capro :: Interfaces :: INTERFACE_END }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::PublisherPortData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#ioxroudipublisherportdata","text":"container for publisher port introspection data. #include <iceoryx_posh/roudi/introspection_types.hpp> Inherits from iox::roudi::PortData","title":"iox::roudi::PublisherPortData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#public-attributes","text":"Name uint64_t m_publisherPortID iox::capro::Interfaces m_sourceInterface","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#additional-inherited-members","text":"Public Attributes inherited from iox::roudi::PortData Name RuntimeName_t m_name capro::IdString_t m_caproInstanceID capro::IdString_t m_caproServiceID capro::IdString_t m_caproEventMethodID NodeName_t m_node","title":"Additional inherited members"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#variable-m_publisherportid","text":"uint64_t m_publisherPortID { 0 };","title":"variable m_publisherPortID"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1PublisherPortData/#variable-m_sourceinterface","text":"iox :: capro :: Interfaces m_sourceInterface { iox :: capro :: Interfaces :: INTERFACE_END }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable m_sourceInterface"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/","text":"iox::roudi::SubscriberPortChangingData \ud83d\udd17 Public Attributes \ud83d\udd17 Name uint64_t fifoSize uint64_t fifoCapacity iox::SubscribeState subscriptionState capro::Scope propagationScope Public Attributes Documentation \ud83d\udd17 variable fifoSize \ud83d\udd17 uint64_t fifoSize { 0 }; variable fifoCapacity \ud83d\udd17 uint64_t fifoCapacity { 0 }; variable subscriptionState \ud83d\udd17 iox :: SubscribeState subscriptionState { iox :: SubscribeState :: NOT_SUBSCRIBED }; variable propagationScope \ud83d\udd17 capro :: Scope propagationScope { capro :: Scope :: INVALID }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::SubscriberPortChangingData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#ioxroudisubscriberportchangingdata","text":"","title":"iox::roudi::SubscriberPortChangingData"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#public-attributes","text":"Name uint64_t fifoSize uint64_t fifoCapacity iox::SubscribeState subscriptionState capro::Scope propagationScope","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-fifosize","text":"uint64_t fifoSize { 0 };","title":"variable fifoSize"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-fifocapacity","text":"uint64_t fifoCapacity { 0 };","title":"variable fifoCapacity"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-subscriptionstate","text":"iox :: SubscribeState subscriptionState { iox :: SubscribeState :: NOT_SUBSCRIBED };","title":"variable subscriptionState"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingData/#variable-propagationscope","text":"capro :: Scope propagationScope { capro :: Scope :: INVALID }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable propagationScope"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/","text":"iox::roudi::SubscriberPortChangingIntrospectionFieldTopic \ud83d\udd17 Public Attributes \ud83d\udd17 Name cxx::vector< SubscriberPortChangingData , MAX_SUBSCRIBERS > subscriberPortChangingDataList Public Attributes Documentation \ud83d\udd17 variable subscriberPortChangingDataList \ud83d\udd17 cxx :: vector < SubscriberPortChangingData , MAX_SUBSCRIBERS > subscriberPortChangingDataList ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi::SubscriberPortChangingIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#ioxroudisubscriberportchangingintrospectionfieldtopic","text":"","title":"iox::roudi::SubscriberPortChangingIntrospectionFieldTopic"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#public-attributes","text":"Name cxx::vector< SubscriberPortChangingData , MAX_SUBSCRIBERS > subscriberPortChangingDataList","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1roudi_1_1SubscriberPortChangingIntrospectionFieldTopic/#variable-subscriberportchangingdatalist","text":"cxx :: vector < SubscriberPortChangingData , MAX_SUBSCRIBERS > subscriberPortChangingDataList ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable subscriberPortChangingDataList"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/","text":"iox::runtime::PortConfigInfo \ud83d\udd17 Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU). #include <iceoryx_posh/runtime/port_config_info.hpp> Public Functions \ud83d\udd17 Name PortConfigInfo (const PortConfigInfo & ) =default PortConfigInfo ( PortConfigInfo && ) =default PortConfigInfo & operator= (const PortConfigInfo & ) =default PortConfigInfo & operator= ( PortConfigInfo && ) =default PortConfigInfo (uint32_t portType =DEFAULT_PORT_TYPE, uint32_t deviceId =DEFAULT_DEVICE_ID, uint32_t memoryType =DEFAULT_MEMORY_TYPE) creates a PortConfigInfo object PortConfigInfo (const cxx::Serialization & serialization) creates a PortConfigInfo object from its serialization operator cxx::Serialization () const creates a serilaization of the PortConfigInfo bool operator== (const PortConfigInfo & rhs) const comparison operator Public Attributes \ud83d\udd17 Name constexpr uint32_t DEFAULT_PORT_TYPE constexpr uint32_t DEFAULT_DEVICE_ID constexpr uint32_t DEFAULT_MEMORY_TYPE uint32_t portType iox::mepoo::MemoryInfo memoryInfo Public Functions Documentation \ud83d\udd17 function PortConfigInfo \ud83d\udd17 PortConfigInfo ( const PortConfigInfo & ) = default function PortConfigInfo \ud83d\udd17 PortConfigInfo ( PortConfigInfo && ) = default function operator= \ud83d\udd17 PortConfigInfo & operator = ( const PortConfigInfo & ) = default function operator= \ud83d\udd17 PortConfigInfo & operator = ( PortConfigInfo && ) = default function PortConfigInfo \ud83d\udd17 PortConfigInfo ( uint32_t portType = DEFAULT_PORT_TYPE , uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) creates a PortConfigInfo object Parameters : portType specifies the type of port to be created deviceId specifies the device the port operates on (CPU, GPUx etc.) memoryType encodes additional information about the memory used by the port function PortConfigInfo \ud83d\udd17 PortConfigInfo ( const cxx :: Serialization & serialization ) creates a PortConfigInfo object from its serialization Parameters : serialization specifies the serialization from which the port is created function operator cxx::Serialization \ud83d\udd17 operator cxx :: Serialization () const creates a serilaization of the PortConfigInfo function operator== \ud83d\udd17 bool operator == ( const PortConfigInfo & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison Public Attributes Documentation \ud83d\udd17 variable DEFAULT_PORT_TYPE \ud83d\udd17 static constexpr uint32_t DEFAULT_PORT_TYPE { 0U }; variable DEFAULT_DEVICE_ID \ud83d\udd17 static constexpr uint32_t DEFAULT_DEVICE_ID { 0U }; variable DEFAULT_MEMORY_TYPE \ud83d\udd17 static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U }; variable portType \ud83d\udd17 uint32_t portType { DEFAULT_PORT_TYPE }; variable memoryInfo \ud83d\udd17 iox :: mepoo :: MemoryInfo memoryInfo ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::runtime::PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#ioxruntimeportconfiginfo","text":"Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU). #include <iceoryx_posh/runtime/port_config_info.hpp>","title":"iox::runtime::PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-functions","text":"Name PortConfigInfo (const PortConfigInfo & ) =default PortConfigInfo ( PortConfigInfo && ) =default PortConfigInfo & operator= (const PortConfigInfo & ) =default PortConfigInfo & operator= ( PortConfigInfo && ) =default PortConfigInfo (uint32_t portType =DEFAULT_PORT_TYPE, uint32_t deviceId =DEFAULT_DEVICE_ID, uint32_t memoryType =DEFAULT_MEMORY_TYPE) creates a PortConfigInfo object PortConfigInfo (const cxx::Serialization & serialization) creates a PortConfigInfo object from its serialization operator cxx::Serialization () const creates a serilaization of the PortConfigInfo bool operator== (const PortConfigInfo & rhs) const comparison operator","title":"Public Functions"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-attributes","text":"Name constexpr uint32_t DEFAULT_PORT_TYPE constexpr uint32_t DEFAULT_DEVICE_ID constexpr uint32_t DEFAULT_MEMORY_TYPE uint32_t portType iox::mepoo::MemoryInfo memoryInfo","title":"Public Attributes"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo","text":"PortConfigInfo ( const PortConfigInfo & ) = default","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo_1","text":"PortConfigInfo ( PortConfigInfo && ) = default","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator","text":"PortConfigInfo & operator = ( const PortConfigInfo & ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator_1","text":"PortConfigInfo & operator = ( PortConfigInfo && ) = default","title":"function operator="},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo_2","text":"PortConfigInfo ( uint32_t portType = DEFAULT_PORT_TYPE , uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) creates a PortConfigInfo object Parameters : portType specifies the type of port to be created deviceId specifies the device the port operates on (CPU, GPUx etc.) memoryType encodes additional information about the memory used by the port","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-portconfiginfo_3","text":"PortConfigInfo ( const cxx :: Serialization & serialization ) creates a PortConfigInfo object from its serialization Parameters : serialization specifies the serialization from which the port is created","title":"function PortConfigInfo"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator-cxxserialization","text":"operator cxx :: Serialization () const creates a serilaization of the PortConfigInfo","title":"function operator cxx::Serialization"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#function-operator_2","text":"bool operator == ( const PortConfigInfo & rhs ) const comparison operator Parameters : rhs the right hand side of the comparison","title":"function operator=="},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-default_port_type","text":"static constexpr uint32_t DEFAULT_PORT_TYPE { 0U };","title":"variable DEFAULT_PORT_TYPE"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-default_device_id","text":"static constexpr uint32_t DEFAULT_DEVICE_ID { 0U };","title":"variable DEFAULT_DEVICE_ID"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-default_memory_type","text":"static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U };","title":"variable DEFAULT_MEMORY_TYPE"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-porttype","text":"uint32_t portType { DEFAULT_PORT_TYPE };","title":"variable portType"},{"location":"API-reference/posh/Classes/structiox_1_1runtime_1_1PortConfigInfo/#variable-memoryinfo","text":"iox :: mepoo :: MemoryInfo memoryInfo ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable memoryInfo"},{"location":"API-reference/posh/Files/base__client_8hpp/","text":"iceoryx_posh/internal/popo/base_client.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::BaseClient The BaseClient class contains the common implementation for the different clients. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_CLIENT_HPP #define IOX_POSH_POPO_BASE_CLIENT_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { using uid_t = UniquePortId ; template < typename PortT = ClientPortUser , typename TriggerHandleT = TriggerHandle > class BaseClient { public : virtual ~ BaseClient () noexcept ; BaseClient ( const BaseClient & other ) = delete ; BaseClient & operator = ( const BaseClient & ) = delete ; BaseClient ( BaseClient && rhs ) = delete ; BaseClient & operator = ( BaseClient && rhs ) = delete ; uid_t getUid () const noexcept ; const capro :: ServiceDescription & getServiceDescription () const noexcept ; void connect () noexcept ; ConnectionState getConnectionState () const noexcept ; void disconnect () noexcept ; bool hasResponses () const noexcept ; bool hasMissedResponses () noexcept ; void releaseQueuedResponses () noexcept ; friend class NotificationAttorney ; protected : using SelfType = BaseClient < PortT , TriggerHandleT > ; using PortType = PortT ; BaseClient ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions ) noexcept ; void invalidateTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void enableState ( TriggerHandleT && triggerHandle , const ClientState clientState ) noexcept ; WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ClientState clientState ) const noexcept ; void disableState ( const ClientState clientState ) noexcept ; void enableEvent ( TriggerHandleT && triggerHandle , const ClientEvent clientEvent ) noexcept ; void disableEvent ( const ClientEvent clientEvent ) noexcept ; const PortT & port () const noexcept ; PortT & port () noexcept ; protected : PortT m_port ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) TriggerHandleT m_trigger ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_client.inl\" #endif // IOX_POSH_POPO_BASE_CLIENT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/base_client.hpp"},{"location":"API-reference/posh/Files/base__client_8hpp/#iceoryx_poshinternalpopobase_clienthpp","text":"","title":"iceoryx_posh/internal/popo/base_client.hpp"},{"location":"API-reference/posh/Files/base__client_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/base__client_8hpp/#classes","text":"Name class iox::popo::BaseClient The BaseClient class contains the common implementation for the different clients.","title":"Classes"},{"location":"API-reference/posh/Files/base__client_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_CLIENT_HPP #define IOX_POSH_POPO_BASE_CLIENT_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { using uid_t = UniquePortId ; template < typename PortT = ClientPortUser , typename TriggerHandleT = TriggerHandle > class BaseClient { public : virtual ~ BaseClient () noexcept ; BaseClient ( const BaseClient & other ) = delete ; BaseClient & operator = ( const BaseClient & ) = delete ; BaseClient ( BaseClient && rhs ) = delete ; BaseClient & operator = ( BaseClient && rhs ) = delete ; uid_t getUid () const noexcept ; const capro :: ServiceDescription & getServiceDescription () const noexcept ; void connect () noexcept ; ConnectionState getConnectionState () const noexcept ; void disconnect () noexcept ; bool hasResponses () const noexcept ; bool hasMissedResponses () noexcept ; void releaseQueuedResponses () noexcept ; friend class NotificationAttorney ; protected : using SelfType = BaseClient < PortT , TriggerHandleT > ; using PortType = PortT ; BaseClient ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions ) noexcept ; void invalidateTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void enableState ( TriggerHandleT && triggerHandle , const ClientState clientState ) noexcept ; WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ClientState clientState ) const noexcept ; void disableState ( const ClientState clientState ) noexcept ; void enableEvent ( TriggerHandleT && triggerHandle , const ClientEvent clientEvent ) noexcept ; void disableEvent ( const ClientEvent clientEvent ) noexcept ; const PortT & port () const noexcept ; PortT & port () noexcept ; protected : PortT m_port ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) TriggerHandleT m_trigger ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_client.inl\" #endif // IOX_POSH_POPO_BASE_CLIENT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/base__publisher_8hpp/","text":"iceoryx_posh/internal/popo/base_publisher.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::BasePublisher The BasePublisher class contains the common implementation for the different publisher specializations. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_PUBLISHER_HPP #define IOX_POSH_POPO_BASE_PUBLISHER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_user.hpp\" #include \"iceoryx_posh/internal/popo/sample_deleter.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" namespace iox { namespace popo { using uid_t = UniquePortId ; template < typename port_t = iox :: PublisherPortUserType > class BasePublisher { public : using PortType = port_t ; BasePublisher ( const BasePublisher & other ) = delete ; BasePublisher & operator = ( const BasePublisher & ) = delete ; BasePublisher ( BasePublisher && rhs ) = delete ; BasePublisher & operator = ( BasePublisher && rhs ) = delete ; virtual ~ BasePublisher () noexcept ; uid_t getUid () const noexcept ; capro :: ServiceDescription getServiceDescription () const noexcept ; void offer () noexcept ; void stopOffer () noexcept ; bool isOffered () const noexcept ; bool hasSubscribers () const noexcept ; protected : BasePublisher () = default ; // Required for testing. BasePublisher ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions ); const port_t & port () const noexcept ; port_t & port () noexcept ; port_t m_port { nullptr }; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_publisher.inl\" #endif // IOX_POSH_POPO_BASE_PUBLISHER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/base_publisher.hpp"},{"location":"API-reference/posh/Files/base__publisher_8hpp/#iceoryx_poshinternalpopobase_publisherhpp","text":"","title":"iceoryx_posh/internal/popo/base_publisher.hpp"},{"location":"API-reference/posh/Files/base__publisher_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/base__publisher_8hpp/#classes","text":"Name class iox::popo::BasePublisher The BasePublisher class contains the common implementation for the different publisher specializations.","title":"Classes"},{"location":"API-reference/posh/Files/base__publisher_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_PUBLISHER_HPP #define IOX_POSH_POPO_BASE_PUBLISHER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_user.hpp\" #include \"iceoryx_posh/internal/popo/sample_deleter.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" namespace iox { namespace popo { using uid_t = UniquePortId ; template < typename port_t = iox :: PublisherPortUserType > class BasePublisher { public : using PortType = port_t ; BasePublisher ( const BasePublisher & other ) = delete ; BasePublisher & operator = ( const BasePublisher & ) = delete ; BasePublisher ( BasePublisher && rhs ) = delete ; BasePublisher & operator = ( BasePublisher && rhs ) = delete ; virtual ~ BasePublisher () noexcept ; uid_t getUid () const noexcept ; capro :: ServiceDescription getServiceDescription () const noexcept ; void offer () noexcept ; void stopOffer () noexcept ; bool isOffered () const noexcept ; bool hasSubscribers () const noexcept ; protected : BasePublisher () = default ; // Required for testing. BasePublisher ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions ); const port_t & port () const noexcept ; port_t & port () noexcept ; port_t m_port { nullptr }; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_publisher.inl\" #endif // IOX_POSH_POPO_BASE_PUBLISHER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/base__server_8hpp/","text":"iceoryx_posh/internal/popo/base_server.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::BaseServer The BaseServer class contains the common implementation for the different server. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_SERVER_HPP #define IOX_POSH_POPO_BASE_SERVER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { using uid_t = UniquePortId ; template < typename PortT = ServerPortUser , typename TriggerHandleT = TriggerHandle > class BaseServer { public : virtual ~ BaseServer () noexcept ; BaseServer ( const BaseServer & other ) = delete ; BaseServer & operator = ( const BaseServer & ) = delete ; BaseServer ( BaseServer && rhs ) = delete ; BaseServer & operator = ( BaseServer && rhs ) = delete ; uid_t getUid () const noexcept ; const capro :: ServiceDescription & getServiceDescription () const noexcept ; void offer () noexcept ; void stopOffer () noexcept ; bool isOffered () const noexcept ; bool hasClients () const noexcept ; bool hasRequests () const noexcept ; bool hasMissedRequests () noexcept ; void releaseQueuedRequests () noexcept ; friend class NotificationAttorney ; protected : using SelfType = BaseServer < PortT , TriggerHandleT > ; using PortType = PortT ; BaseServer ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions ) noexcept ; void invalidateTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void enableState ( TriggerHandleT && triggerHandle , const ServerState serverState ) noexcept ; WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ServerState serverState ) const noexcept ; void disableState ( const ServerState serverState ) noexcept ; void enableEvent ( TriggerHandleT && triggerHandle , const ServerEvent serverEvent ) noexcept ; void disableEvent ( const ServerEvent serverEvent ) noexcept ; const PortT & port () const noexcept ; PortT & port () noexcept ; PortT m_port ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) TriggerHandleT m_trigger ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_server.inl\" #endif // IOX_POSH_POPO_BASE_SERVER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/base_server.hpp"},{"location":"API-reference/posh/Files/base__server_8hpp/#iceoryx_poshinternalpopobase_serverhpp","text":"","title":"iceoryx_posh/internal/popo/base_server.hpp"},{"location":"API-reference/posh/Files/base__server_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/base__server_8hpp/#classes","text":"Name class iox::popo::BaseServer The BaseServer class contains the common implementation for the different server.","title":"Classes"},{"location":"API-reference/posh/Files/base__server_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_SERVER_HPP #define IOX_POSH_POPO_BASE_SERVER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { using uid_t = UniquePortId ; template < typename PortT = ServerPortUser , typename TriggerHandleT = TriggerHandle > class BaseServer { public : virtual ~ BaseServer () noexcept ; BaseServer ( const BaseServer & other ) = delete ; BaseServer & operator = ( const BaseServer & ) = delete ; BaseServer ( BaseServer && rhs ) = delete ; BaseServer & operator = ( BaseServer && rhs ) = delete ; uid_t getUid () const noexcept ; const capro :: ServiceDescription & getServiceDescription () const noexcept ; void offer () noexcept ; void stopOffer () noexcept ; bool isOffered () const noexcept ; bool hasClients () const noexcept ; bool hasRequests () const noexcept ; bool hasMissedRequests () noexcept ; void releaseQueuedRequests () noexcept ; friend class NotificationAttorney ; protected : using SelfType = BaseServer < PortT , TriggerHandleT > ; using PortType = PortT ; BaseServer ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions ) noexcept ; void invalidateTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void enableState ( TriggerHandleT && triggerHandle , const ServerState serverState ) noexcept ; WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const ServerState serverState ) const noexcept ; void disableState ( const ServerState serverState ) noexcept ; void enableEvent ( TriggerHandleT && triggerHandle , const ServerEvent serverEvent ) noexcept ; void disableEvent ( const ServerEvent serverEvent ) noexcept ; const PortT & port () const noexcept ; PortT & port () noexcept ; PortT m_port ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) TriggerHandleT m_trigger ; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes) }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_server.inl\" #endif // IOX_POSH_POPO_BASE_SERVER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/base__subscriber_8hpp/","text":"iceoryx_posh/internal/popo/base_subscriber.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::runtime iox::popo Classes \ud83d\udd17 Name class iox::popo::BaseSubscriber base class for all types of subscriber Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_SUBSCRIBER_HPP #define IOX_POSH_POPO_BASE_SUBSCRIBER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_user.hpp\" #include \"iceoryx_posh/popo/enum_trigger_type.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" #include \"iceoryx_posh/popo/subscriber_options.hpp\" #include \"iceoryx_posh/popo/wait_set.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace runtime { class ServiceDiscovery ; } namespace popo { using uid_t = UniquePortId ; enum class SubscriberEvent : EventEnumIdentifier { DATA_RECEIVED }; enum class SubscriberState : StateEnumIdentifier { HAS_DATA }; template < typename port_t = iox :: SubscriberPortUserType > class BaseSubscriber { public : virtual ~ BaseSubscriber () noexcept ; uid_t getUid () const noexcept ; capro :: ServiceDescription getServiceDescription () const noexcept ; void subscribe () noexcept ; SubscribeState getSubscriptionState () const noexcept ; void unsubscribe () noexcept ; bool hasData () const noexcept ; bool hasMissedData () noexcept ; void releaseQueuedData () noexcept ; friend class NotificationAttorney ; friend class iox :: runtime :: ServiceDiscovery ; protected : using SelfType = BaseSubscriber < port_t > ; using PortType = port_t ; BaseSubscriber () noexcept ; // Required for testing. BaseSubscriber ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions ) noexcept ; BaseSubscriber ( const BaseSubscriber & other ) = delete ; BaseSubscriber & operator = ( const BaseSubscriber & ) = delete ; BaseSubscriber ( BaseSubscriber && rhs ) = delete ; BaseSubscriber & operator = ( BaseSubscriber && rhs ) = delete ; cxx :: expected < const mepoo :: ChunkHeader * , ChunkReceiveResult > takeChunk () noexcept ; void invalidateTrigger ( const uint64_t trigger ) noexcept ; void enableState ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberState subscriberState ) noexcept ; WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const SubscriberState subscriberState ) const noexcept ; void disableState ( const SubscriberState subscriberState ) noexcept ; void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberEvent subscriberState ) noexcept ; void disableEvent ( const SubscriberEvent subscriberEvent ) noexcept ; const port_t & port () const noexcept ; port_t & port () noexcept ; protected : port_t m_port { nullptr }; TriggerHandle m_trigger ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_subscriber.inl\" #endif // IOX_POSH_POPO_BASE_SUBSCRIBER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/base_subscriber.hpp"},{"location":"API-reference/posh/Files/base__subscriber_8hpp/#iceoryx_poshinternalpopobase_subscriberhpp","text":"","title":"iceoryx_posh/internal/popo/base_subscriber.hpp"},{"location":"API-reference/posh/Files/base__subscriber_8hpp/#namespaces","text":"Name iox iox::runtime iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/base__subscriber_8hpp/#classes","text":"Name class iox::popo::BaseSubscriber base class for all types of subscriber","title":"Classes"},{"location":"API-reference/posh/Files/base__subscriber_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_BASE_SUBSCRIBER_HPP #define IOX_POSH_POPO_BASE_SUBSCRIBER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_user.hpp\" #include \"iceoryx_posh/popo/enum_trigger_type.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" #include \"iceoryx_posh/popo/subscriber_options.hpp\" #include \"iceoryx_posh/popo/wait_set.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace runtime { class ServiceDiscovery ; } namespace popo { using uid_t = UniquePortId ; enum class SubscriberEvent : EventEnumIdentifier { DATA_RECEIVED }; enum class SubscriberState : StateEnumIdentifier { HAS_DATA }; template < typename port_t = iox :: SubscriberPortUserType > class BaseSubscriber { public : virtual ~ BaseSubscriber () noexcept ; uid_t getUid () const noexcept ; capro :: ServiceDescription getServiceDescription () const noexcept ; void subscribe () noexcept ; SubscribeState getSubscriptionState () const noexcept ; void unsubscribe () noexcept ; bool hasData () const noexcept ; bool hasMissedData () noexcept ; void releaseQueuedData () noexcept ; friend class NotificationAttorney ; friend class iox :: runtime :: ServiceDiscovery ; protected : using SelfType = BaseSubscriber < port_t > ; using PortType = port_t ; BaseSubscriber () noexcept ; // Required for testing. BaseSubscriber ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions ) noexcept ; BaseSubscriber ( const BaseSubscriber & other ) = delete ; BaseSubscriber & operator = ( const BaseSubscriber & ) = delete ; BaseSubscriber ( BaseSubscriber && rhs ) = delete ; BaseSubscriber & operator = ( BaseSubscriber && rhs ) = delete ; cxx :: expected < const mepoo :: ChunkHeader * , ChunkReceiveResult > takeChunk () noexcept ; void invalidateTrigger ( const uint64_t trigger ) noexcept ; void enableState ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberState subscriberState ) noexcept ; WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const SubscriberState subscriberState ) const noexcept ; void disableState ( const SubscriberState subscriberState ) noexcept ; void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle , const SubscriberEvent subscriberState ) noexcept ; void disableEvent ( const SubscriberEvent subscriberEvent ) noexcept ; const port_t & port () const noexcept ; port_t & port () noexcept ; protected : port_t m_port { nullptr }; TriggerHandle m_trigger ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/base_subscriber.inl\" #endif // IOX_POSH_POPO_BASE_SUBSCRIBER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/channel_8hpp/","text":"iceoryx_posh/gateway/channel.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::gw Classes \ud83d\udd17 Name class iox: :Channel A data structure representing a channel between Iceoryx and an external system. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_CHANNEL_HPP #define IOX_POSH_GW_CHANNEL_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/internal/objectpool/objectpool.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <memory> namespace iox { namespace gw { enum class ChannelError : uint8_t { OBJECT_POOL_FULL }; template < typename IceoryxTerminal , typename ExternalTerminal > class Channel { using IceoryxTerminalPtr = std :: shared_ptr < IceoryxTerminal > ; using IceoryxTerminalPool = cxx :: ObjectPool < IceoryxTerminal , MAX_CHANNEL_NUMBER > ; using ExternalTerminalPtr = std :: shared_ptr < ExternalTerminal > ; using ExternalTerminalPool = cxx :: ObjectPool < ExternalTerminal , MAX_CHANNEL_NUMBER > ; public : constexpr Channel ( const capro :: ServiceDescription & service , const IceoryxTerminalPtr iceoryxTerminal , const ExternalTerminalPtr externalTerminal ) noexcept ; constexpr bool operator == ( const Channel < IceoryxTerminal , ExternalTerminal >& rhs ) const noexcept ; template < typename IceoryxPubSubOptions > static cxx :: expected < Channel , ChannelError > create ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) noexcept ; capro :: ServiceDescription getServiceDescription () const noexcept ; IceoryxTerminalPtr getIceoryxTerminal () const noexcept ; ExternalTerminalPtr getExternalTerminal () const noexcept ; private : static IceoryxTerminalPool s_iceoryxTerminals ; static ExternalTerminalPool s_externalTerminals ; capro :: ServiceDescription m_service ; IceoryxTerminalPtr m_iceoryxTerminal ; ExternalTerminalPtr m_externalTerminal ; }; } // namespace gw } // namespace iox #include \"iceoryx_posh/internal/gateway/channel.inl\" #endif // IOX_POSH_GW_CHANNEL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway/channel.hpp"},{"location":"API-reference/posh/Files/channel_8hpp/#iceoryx_poshgatewaychannelhpp","text":"","title":"iceoryx_posh/gateway/channel.hpp"},{"location":"API-reference/posh/Files/channel_8hpp/#namespaces","text":"Name iox iox::gw","title":"Namespaces"},{"location":"API-reference/posh/Files/channel_8hpp/#classes","text":"Name class iox: :Channel A data structure representing a channel between Iceoryx and an external system.","title":"Classes"},{"location":"API-reference/posh/Files/channel_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_CHANNEL_HPP #define IOX_POSH_GW_CHANNEL_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/internal/objectpool/objectpool.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <memory> namespace iox { namespace gw { enum class ChannelError : uint8_t { OBJECT_POOL_FULL }; template < typename IceoryxTerminal , typename ExternalTerminal > class Channel { using IceoryxTerminalPtr = std :: shared_ptr < IceoryxTerminal > ; using IceoryxTerminalPool = cxx :: ObjectPool < IceoryxTerminal , MAX_CHANNEL_NUMBER > ; using ExternalTerminalPtr = std :: shared_ptr < ExternalTerminal > ; using ExternalTerminalPool = cxx :: ObjectPool < ExternalTerminal , MAX_CHANNEL_NUMBER > ; public : constexpr Channel ( const capro :: ServiceDescription & service , const IceoryxTerminalPtr iceoryxTerminal , const ExternalTerminalPtr externalTerminal ) noexcept ; constexpr bool operator == ( const Channel < IceoryxTerminal , ExternalTerminal >& rhs ) const noexcept ; template < typename IceoryxPubSubOptions > static cxx :: expected < Channel , ChannelError > create ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) noexcept ; capro :: ServiceDescription getServiceDescription () const noexcept ; IceoryxTerminalPtr getIceoryxTerminal () const noexcept ; ExternalTerminalPtr getExternalTerminal () const noexcept ; private : static IceoryxTerminalPool s_iceoryxTerminals ; static ExternalTerminalPool s_externalTerminals ; capro :: ServiceDescription m_service ; IceoryxTerminalPtr m_iceoryxTerminal ; ExternalTerminalPtr m_externalTerminal ; }; } // namespace gw } // namespace iox #include \"iceoryx_posh/internal/gateway/channel.inl\" #endif // IOX_POSH_GW_CHANNEL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/chunk__header_8hpp/","text":"iceoryx_posh/mepoo/chunk_header.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo iox::mepoo Classes \ud83d\udd17 Name class iox::popo::ChunkSender struct iox::mepoo::NoUserHeader Helper struct to use as default template parameter when no user-header is used. struct iox::mepoo::ChunkHeader Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_CHUNK_HEADER_HPP #define IOX_POSH_MEPOO_CHUNK_HEADER_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/unique_port_id.hpp\" #include \"iceoryx_posh/mepoo/chunk_settings.hpp\" #include <cstdint> namespace iox { namespace popo { template < typename T > class ChunkSender ; } namespace mepoo { struct NoUserHeader { }; struct ChunkHeader { using UserPayloadOffset_t = uint32_t ; ChunkHeader ( const uint32_t chunkSize , const ChunkSettings & chunkSettings ) noexcept ; // copy/move ctors/assignment operators are deleted since the calculations for the user-header and user-payload // alignment are dependent on the address of the this pointer ChunkHeader ( const ChunkHeader & ) = delete ; ChunkHeader ( ChunkHeader && ) = delete ; ChunkHeader & operator = ( const ChunkHeader & ) = delete ; ChunkHeader & operator = ( ChunkHeader && ) = delete ; static constexpr uint8_t CHUNK_HEADER_VERSION { 1U }; static constexpr uint16_t NO_USER_HEADER { 0x0000 }; static constexpr uint16_t UNKNOWN_USER_HEADER { 0xFFFF }; uint8_t chunkHeaderVersion () const noexcept ; uint16_t userHeaderId () const noexcept ; void * userHeader () noexcept ; const void * userHeader () const noexcept ; void * userPayload () noexcept ; const void * userPayload () const noexcept ; static ChunkHeader * fromUserPayload ( void * const userPayload ) noexcept ; static const ChunkHeader * fromUserPayload ( const void * const userPayload ) noexcept ; static ChunkHeader * fromUserHeader ( void * const userHeader ) noexcept ; static const ChunkHeader * fromUserHeader ( const void * const userHeader ) noexcept ; uint32_t usedSizeOfChunk () const noexcept ; uint32_t chunkSize () const noexcept ; uint32_t userHeaderSize () const noexcept ; uint32_t userPayloadSize () const noexcept ; uint32_t userPayloadAlignment () const noexcept ; popo :: UniquePortId originId () const noexcept ; uint64_t sequenceNumber () const noexcept ; private : template < typename T > friend class popo :: ChunkSender ; void setOriginId ( const popo :: UniquePortId originId ) noexcept ; void setSequenceNumber ( const uint64_t sequenceNumber ) noexcept ; uint64_t overflowSafeUsedSizeOfChunk () const noexcept ; private : // the order of these members must be changed carefully and if this happens, the m_chunkHeaderVersion // needs to be adapted in order to be able to detect incompatibilities between publisher/subscriber // or record&replay, m_chunkSize and m_chunkHeaderVersion should therefore neither changed the type, // nor the position // size of the whole chunk, including the header uint32_t m_chunkSize { 0U }; uint8_t m_chunkHeaderVersion { CHUNK_HEADER_VERSION }; // reserved for future functionality and used to indicate the padding bytes; currently not used and set to `0` uint8_t m_reserved { 0 }; // currently just a placeholder uint16_t m_userHeaderId { NO_USER_HEADER }; popo :: UniquePortId m_originId { popo :: InvalidPortId }; uint64_t m_sequenceNumber { 0U }; uint32_t m_userHeaderSize { 0U }; uint32_t m_userPayloadSize { 0U }; uint32_t m_userPayloadAlignment { 1U }; UserPayloadOffset_t m_userPayloadOffset { sizeof ( ChunkHeader )}; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_CHUNK_HEADER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/mepoo/chunk_header.hpp"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#iceoryx_poshmepoochunk_headerhpp","text":"","title":"iceoryx_posh/mepoo/chunk_header.hpp"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#namespaces","text":"Name iox iox::popo iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#classes","text":"Name class iox::popo::ChunkSender struct iox::mepoo::NoUserHeader Helper struct to use as default template parameter when no user-header is used. struct iox::mepoo::ChunkHeader","title":"Classes"},{"location":"API-reference/posh/Files/chunk__header_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_CHUNK_HEADER_HPP #define IOX_POSH_MEPOO_CHUNK_HEADER_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/unique_port_id.hpp\" #include \"iceoryx_posh/mepoo/chunk_settings.hpp\" #include <cstdint> namespace iox { namespace popo { template < typename T > class ChunkSender ; } namespace mepoo { struct NoUserHeader { }; struct ChunkHeader { using UserPayloadOffset_t = uint32_t ; ChunkHeader ( const uint32_t chunkSize , const ChunkSettings & chunkSettings ) noexcept ; // copy/move ctors/assignment operators are deleted since the calculations for the user-header and user-payload // alignment are dependent on the address of the this pointer ChunkHeader ( const ChunkHeader & ) = delete ; ChunkHeader ( ChunkHeader && ) = delete ; ChunkHeader & operator = ( const ChunkHeader & ) = delete ; ChunkHeader & operator = ( ChunkHeader && ) = delete ; static constexpr uint8_t CHUNK_HEADER_VERSION { 1U }; static constexpr uint16_t NO_USER_HEADER { 0x0000 }; static constexpr uint16_t UNKNOWN_USER_HEADER { 0xFFFF }; uint8_t chunkHeaderVersion () const noexcept ; uint16_t userHeaderId () const noexcept ; void * userHeader () noexcept ; const void * userHeader () const noexcept ; void * userPayload () noexcept ; const void * userPayload () const noexcept ; static ChunkHeader * fromUserPayload ( void * const userPayload ) noexcept ; static const ChunkHeader * fromUserPayload ( const void * const userPayload ) noexcept ; static ChunkHeader * fromUserHeader ( void * const userHeader ) noexcept ; static const ChunkHeader * fromUserHeader ( const void * const userHeader ) noexcept ; uint32_t usedSizeOfChunk () const noexcept ; uint32_t chunkSize () const noexcept ; uint32_t userHeaderSize () const noexcept ; uint32_t userPayloadSize () const noexcept ; uint32_t userPayloadAlignment () const noexcept ; popo :: UniquePortId originId () const noexcept ; uint64_t sequenceNumber () const noexcept ; private : template < typename T > friend class popo :: ChunkSender ; void setOriginId ( const popo :: UniquePortId originId ) noexcept ; void setSequenceNumber ( const uint64_t sequenceNumber ) noexcept ; uint64_t overflowSafeUsedSizeOfChunk () const noexcept ; private : // the order of these members must be changed carefully and if this happens, the m_chunkHeaderVersion // needs to be adapted in order to be able to detect incompatibilities between publisher/subscriber // or record&replay, m_chunkSize and m_chunkHeaderVersion should therefore neither changed the type, // nor the position // size of the whole chunk, including the header uint32_t m_chunkSize { 0U }; uint8_t m_chunkHeaderVersion { CHUNK_HEADER_VERSION }; // reserved for future functionality and used to indicate the padding bytes; currently not used and set to `0` uint8_t m_reserved { 0 }; // currently just a placeholder uint16_t m_userHeaderId { NO_USER_HEADER }; popo :: UniquePortId m_originId { popo :: InvalidPortId }; uint64_t m_sequenceNumber { 0U }; uint32_t m_userHeaderSize { 0U }; uint32_t m_userPayloadSize { 0U }; uint32_t m_userPayloadAlignment { 1U }; UserPayloadOffset_t m_userPayloadOffset { sizeof ( ChunkHeader )}; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_CHUNK_HEADER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/","text":"iceoryx_posh/mepoo/chunk_settings.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::mepoo Classes \ud83d\udd17 Name class iox::mepoo::ChunkSettings Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP #define IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace mepoo { class ChunkSettings { public : enum class Error { ALIGNMENT_NOT_POWER_OF_TWO , USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT , USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT , REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE , }; static cxx :: expected < ChunkSettings , ChunkSettings :: Error > create ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) noexcept ; uint32_t requiredChunkSize () const noexcept ; uint32_t userPayloadSize () const noexcept ; uint32_t userPayloadAlignment () const noexcept ; uint32_t userHeaderSize () const noexcept ; uint32_t userHeaderAlignment () const noexcept ; private : ChunkSettings ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize , const uint32_t userHeaderAlignment , const uint32_t requiredChunkSize ) noexcept ; static uint64_t calculateRequiredChunkSize ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize ) noexcept ; private : uint32_t m_userPayloadSize { 0U }; uint32_t m_userPayloadAlignment { 0U }; uint32_t m_userHeaderSize { 0U }; uint32_t m_userHeaderAlignment { 0U }; uint32_t m_requiredChunkSize { 0U }; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/mepoo/chunk_settings.hpp"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#iceoryx_poshmepoochunk_settingshpp","text":"","title":"iceoryx_posh/mepoo/chunk_settings.hpp"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#namespaces","text":"Name iox iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#classes","text":"Name class iox::mepoo::ChunkSettings","title":"Classes"},{"location":"API-reference/posh/Files/chunk__settings_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP #define IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace mepoo { class ChunkSettings { public : enum class Error { ALIGNMENT_NOT_POWER_OF_TWO , USER_HEADER_ALIGNMENT_EXCEEDS_CHUNK_HEADER_ALIGNMENT , USER_HEADER_SIZE_NOT_MULTIPLE_OF_ITS_ALIGNMENT , REQUIRED_CHUNK_SIZE_EXCEEDS_MAX_CHUNK_SIZE , }; static cxx :: expected < ChunkSettings , ChunkSettings :: Error > create ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) noexcept ; uint32_t requiredChunkSize () const noexcept ; uint32_t userPayloadSize () const noexcept ; uint32_t userPayloadAlignment () const noexcept ; uint32_t userHeaderSize () const noexcept ; uint32_t userHeaderAlignment () const noexcept ; private : ChunkSettings ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize , const uint32_t userHeaderAlignment , const uint32_t requiredChunkSize ) noexcept ; static uint64_t calculateRequiredChunkSize ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment , const uint32_t userHeaderSize ) noexcept ; private : uint32_t m_userPayloadSize { 0U }; uint32_t m_userPayloadAlignment { 0U }; uint32_t m_userHeaderSize { 0U }; uint32_t m_userHeaderAlignment { 0U }; uint32_t m_requiredChunkSize { 0U }; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_CHUNK_SETTINGS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/client_8hpp/","text":"iceoryx_posh/popo/client.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::Client The Client class for the request-response messaging pattern in iceoryx. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_CLIENT_HPP #define IOX_POSH_POPO_CLIENT_HPP #include \"iceoryx_posh/internal/popo/client_impl.hpp\" namespace iox { namespace popo { template < typename Req , typename Res > class Client : public ClientImpl < Req , Res > { using Impl = ClientImpl < Req , Res > ; public : using ClientImpl < Req , Res >:: ClientImpl ; virtual ~ Client () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_CLIENT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/client.hpp"},{"location":"API-reference/posh/Files/client_8hpp/#iceoryx_poshpopoclienthpp","text":"","title":"iceoryx_posh/popo/client.hpp"},{"location":"API-reference/posh/Files/client_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/client_8hpp/#classes","text":"Name class iox::popo::Client The Client class for the request-response messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/client_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_CLIENT_HPP #define IOX_POSH_POPO_CLIENT_HPP #include \"iceoryx_posh/internal/popo/client_impl.hpp\" namespace iox { namespace popo { template < typename Req , typename Res > class Client : public ClientImpl < Req , Res > { using Impl = ClientImpl < Req , Res > ; public : using ClientImpl < Req , Res >:: ClientImpl ; virtual ~ Client () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_CLIENT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/client__impl_8hpp/","text":"iceoryx_posh/internal/popo/client_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::ClientImpl The ClientImpl class implements the typed client API. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_CLIENT_IMPL_HPP #define IOX_POSH_POPO_CLIENT_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_client.hpp\" #include \"iceoryx_posh/internal/popo/request_deleter.hpp\" #include \"iceoryx_posh/internal/popo/response_deleter.hpp\" #include \"iceoryx_posh/internal/popo/rpc_interface.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/request.hpp\" #include \"iceoryx_posh/popo/response.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { template < typename Req , typename Res , typename BaseClientT = BaseClient <>> class ClientImpl : public BaseClientT , private RpcInterface < Request < Req > , ClientSendError > { using RequestTypeAssert = typename TypedPortApiTrait < Req >:: Assert ; using ResponseTypeAssert = typename TypedPortApiTrait < Res >:: Assert ; public : explicit ClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {}) noexcept ; virtual ~ ClientImpl () noexcept ; ClientImpl ( const ClientImpl & ) = delete ; ClientImpl ( ClientImpl && ) = delete ; ClientImpl & operator = ( const ClientImpl & ) = delete ; ClientImpl & operator = ( ClientImpl && ) = delete ; template < typename ... Args > cxx :: expected < Request < Req > , AllocationError > loan ( Args && ... args ) noexcept ; cxx :: expected < ClientSendError > send ( Request < Req >&& request ) noexcept override ; cxx :: expected < Response < const Res > , ChunkReceiveResult > take () noexcept ; protected : using BaseClientT :: port ; private : cxx :: expected < Request < Req > , AllocationError > loanUninitialized () noexcept ; using RequestSampleDeleter = RequestDeleter < typename BaseClientT :: PortType > ; RequestSampleDeleter m_requestDeleter { port ()}; using ResponseSampleDeleter = ResponseDeleter < typename BaseClientT :: PortType > ; ResponseSampleDeleter m_responseDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/client_impl.inl\" #endif // IOX_POSH_POPO_CLIENT_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/client_impl.hpp"},{"location":"API-reference/posh/Files/client__impl_8hpp/#iceoryx_poshinternalpopoclient_implhpp","text":"","title":"iceoryx_posh/internal/popo/client_impl.hpp"},{"location":"API-reference/posh/Files/client__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/client__impl_8hpp/#classes","text":"Name class iox::popo::ClientImpl The ClientImpl class implements the typed client API.","title":"Classes"},{"location":"API-reference/posh/Files/client__impl_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_CLIENT_IMPL_HPP #define IOX_POSH_POPO_CLIENT_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_client.hpp\" #include \"iceoryx_posh/internal/popo/request_deleter.hpp\" #include \"iceoryx_posh/internal/popo/response_deleter.hpp\" #include \"iceoryx_posh/internal/popo/rpc_interface.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/request.hpp\" #include \"iceoryx_posh/popo/response.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { template < typename Req , typename Res , typename BaseClientT = BaseClient <>> class ClientImpl : public BaseClientT , private RpcInterface < Request < Req > , ClientSendError > { using RequestTypeAssert = typename TypedPortApiTrait < Req >:: Assert ; using ResponseTypeAssert = typename TypedPortApiTrait < Res >:: Assert ; public : explicit ClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {}) noexcept ; virtual ~ ClientImpl () noexcept ; ClientImpl ( const ClientImpl & ) = delete ; ClientImpl ( ClientImpl && ) = delete ; ClientImpl & operator = ( const ClientImpl & ) = delete ; ClientImpl & operator = ( ClientImpl && ) = delete ; template < typename ... Args > cxx :: expected < Request < Req > , AllocationError > loan ( Args && ... args ) noexcept ; cxx :: expected < ClientSendError > send ( Request < Req >&& request ) noexcept override ; cxx :: expected < Response < const Res > , ChunkReceiveResult > take () noexcept ; protected : using BaseClientT :: port ; private : cxx :: expected < Request < Req > , AllocationError > loanUninitialized () noexcept ; using RequestSampleDeleter = RequestDeleter < typename BaseClientT :: PortType > ; RequestSampleDeleter m_requestDeleter { port ()}; using ResponseSampleDeleter = ResponseDeleter < typename BaseClientT :: PortType > ; ResponseSampleDeleter m_responseDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/client_impl.inl\" #endif // IOX_POSH_POPO_CLIENT_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/client__options_8hpp/","text":"iceoryx_posh/popo/client_options.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name struct iox::popo::ClientOptions This struct is used to configure the client. Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_CLIENT_OPTIONS_HPP #define IOX_POSH_POPO_CLIENT_OPTIONS_HPP #include \"iceoryx_posh/internal/popo/ports/client_server_port_types.hpp\" #include \"iceoryx_posh/popo/port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct ClientOptions { uint64_t responseQueueCapacity { ClientChunkQueueData_t :: MAX_CAPACITY }; iox :: NodeName_t nodeName { \"\" }; bool connectOnCreate { true }; QueueFullPolicy responseQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; ConsumerTooSlowPolicy serverTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < ClientOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; bool operator == ( const ClientOptions & rhs ) const noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_CLIENT_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/client_options.hpp"},{"location":"API-reference/posh/Files/client__options_8hpp/#iceoryx_poshpopoclient_optionshpp","text":"","title":"iceoryx_posh/popo/client_options.hpp"},{"location":"API-reference/posh/Files/client__options_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/client__options_8hpp/#classes","text":"Name struct iox::popo::ClientOptions This struct is used to configure the client.","title":"Classes"},{"location":"API-reference/posh/Files/client__options_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_CLIENT_OPTIONS_HPP #define IOX_POSH_POPO_CLIENT_OPTIONS_HPP #include \"iceoryx_posh/internal/popo/ports/client_server_port_types.hpp\" #include \"iceoryx_posh/popo/port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct ClientOptions { uint64_t responseQueueCapacity { ClientChunkQueueData_t :: MAX_CAPACITY }; iox :: NodeName_t nodeName { \"\" }; bool connectOnCreate { true }; QueueFullPolicy responseQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; ConsumerTooSlowPolicy serverTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < ClientOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; bool operator == ( const ClientOptions & rhs ) const noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_CLIENT_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/","text":"iceoryx_posh/roudi/cmd_line_args.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name struct iox::config::CmdLineArgs_t Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP #define IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP #include \"iceoryx_hoofs/log/logstream.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/version/compatibility_check_level.hpp\" #include <cstdint> namespace iox { namespace config { struct CmdLineArgs_t { roudi :: MonitoringMode monitoringMode { roudi :: MonitoringMode :: ON }; iox :: log :: LogLevel logLevel { iox :: log :: LogLevel :: kWarn }; version :: CompatibilityCheckLevel compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; units :: Duration processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; cxx :: optional < uint16_t > uniqueRouDiId { cxx :: nullopt }; bool run { true }; roudi :: ConfigFilePathString_t configFilePath ; }; inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const CmdLineArgs_t & cmdLineArgs ) noexcept { logstream << \"Log level: \" << cmdLineArgs . logLevel << \" \\n \" ; logstream << \"Monitoring mode: \" << cmdLineArgs . monitoringMode << \" \\n \" ; logstream << \"Compatibility check level: \" << cmdLineArgs . compatibilityCheckLevel << \" \\n \" ; cmdLineArgs . uniqueRouDiId . and_then ([ & logstream ]( auto & id ) { logstream << \"Unique RouDi ID: \" << id << \" \\n \" ; }) . or_else ([ & logstream ] { logstream << \"Unique RouDi ID: < unset > \\n \" ; }); logstream << \"Process kill delay: \" << cmdLineArgs . processKillDelay . toSeconds () << \" s \\n \" ; if ( ! cmdLineArgs . configFilePath . empty ()) { logstream << \"Config file used is: \" << cmdLineArgs . configFilePath ; } else { logstream << \"Config file used is: < none >\" ; } return logstream ; } } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/cmd_line_args.hpp"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#iceoryx_poshroudicmd_line_argshpp","text":"","title":"iceoryx_posh/roudi/cmd_line_args.hpp"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#classes","text":"Name struct iox::config::CmdLineArgs_t","title":"Classes"},{"location":"API-reference/posh/Files/cmd__line__args_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP #define IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP #include \"iceoryx_hoofs/log/logstream.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/version/compatibility_check_level.hpp\" #include <cstdint> namespace iox { namespace config { struct CmdLineArgs_t { roudi :: MonitoringMode monitoringMode { roudi :: MonitoringMode :: ON }; iox :: log :: LogLevel logLevel { iox :: log :: LogLevel :: kWarn }; version :: CompatibilityCheckLevel compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; units :: Duration processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; cxx :: optional < uint16_t > uniqueRouDiId { cxx :: nullopt }; bool run { true }; roudi :: ConfigFilePathString_t configFilePath ; }; inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const CmdLineArgs_t & cmdLineArgs ) noexcept { logstream << \"Log level: \" << cmdLineArgs . logLevel << \" \\n \" ; logstream << \"Monitoring mode: \" << cmdLineArgs . monitoringMode << \" \\n \" ; logstream << \"Compatibility check level: \" << cmdLineArgs . compatibilityCheckLevel << \" \\n \" ; cmdLineArgs . uniqueRouDiId . and_then ([ & logstream ]( auto & id ) { logstream << \"Unique RouDi ID: \" << id << \" \\n \" ; }) . or_else ([ & logstream ] { logstream << \"Unique RouDi ID: < unset > \\n \" ; }); logstream << \"Process kill delay: \" << cmdLineArgs . processKillDelay . toSeconds () << \" s \\n \" ; if ( ! cmdLineArgs . configFilePath . empty ()) { logstream << \"Config file used is: \" << cmdLineArgs . configFilePath ; } else { logstream << \"Config file used is: < none >\" ; } return logstream ; } } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_CMD_LINE_ARGS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/","text":"iceoryx_posh/version/compatibility_check_level.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::version Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP #define IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP #include \"iceoryx_hoofs/log/logstream.hpp\" namespace iox { namespace version { enum class CompatibilityCheckLevel { OFF , MAJOR , MINOR , PATCH , COMMIT_ID , BUILD_DATE }; inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const version :: CompatibilityCheckLevel & level ) noexcept { switch ( level ) { case CompatibilityCheckLevel :: OFF : logstream << \"CompatibilityCheckLevel::OFF\" ; break ; case CompatibilityCheckLevel :: MAJOR : logstream << \"CompatibilityCheckLevel::MAJOR\" ; break ; case CompatibilityCheckLevel :: MINOR : logstream << \"CompatibilityCheckLevel::MINOR\" ; break ; case CompatibilityCheckLevel :: PATCH : logstream << \"CompatibilityCheckLevel::PATCH\" ; break ; case CompatibilityCheckLevel :: COMMIT_ID : logstream << \"CompatibilityCheckLevel::COMMIT_ID\" ; break ; case CompatibilityCheckLevel :: BUILD_DATE : logstream << \"CompatibilityCheckLevel::BUILD_DATE\" ; break ; default : logstream << \"CompatibilityCheckLevel::UNDEFINED\" ; break ; } return logstream ; } } // namespace version } // namespace iox #endif // IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/version/compatibility_check_level.hpp"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/#iceoryx_poshversioncompatibility_check_levelhpp","text":"","title":"iceoryx_posh/version/compatibility_check_level.hpp"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/#namespaces","text":"Name iox iox::version","title":"Namespaces"},{"location":"API-reference/posh/Files/compatibility__check__level_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP #define IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP #include \"iceoryx_hoofs/log/logstream.hpp\" namespace iox { namespace version { enum class CompatibilityCheckLevel { OFF , MAJOR , MINOR , PATCH , COMMIT_ID , BUILD_DATE }; inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const version :: CompatibilityCheckLevel & level ) noexcept { switch ( level ) { case CompatibilityCheckLevel :: OFF : logstream << \"CompatibilityCheckLevel::OFF\" ; break ; case CompatibilityCheckLevel :: MAJOR : logstream << \"CompatibilityCheckLevel::MAJOR\" ; break ; case CompatibilityCheckLevel :: MINOR : logstream << \"CompatibilityCheckLevel::MINOR\" ; break ; case CompatibilityCheckLevel :: PATCH : logstream << \"CompatibilityCheckLevel::PATCH\" ; break ; case CompatibilityCheckLevel :: COMMIT_ID : logstream << \"CompatibilityCheckLevel::COMMIT_ID\" ; break ; case CompatibilityCheckLevel :: BUILD_DATE : logstream << \"CompatibilityCheckLevel::BUILD_DATE\" ; break ; default : logstream << \"CompatibilityCheckLevel::UNDEFINED\" ; break ; } return logstream ; } } // namespace version } // namespace iox #endif // IOX_POSH_VERSION_COMPATIBILITY_CHECK_LEVEL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/","text":"iceoryx_posh/roudi/memory/default_roudi_memory.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name struct iox::roudi::DefaultRouDiMemory Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP #define IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP #include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\" #include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\" namespace iox { namespace roudi { struct DefaultRouDiMemory { public : DefaultRouDiMemory ( const RouDiConfig_t & roudiConfig ) noexcept ; virtual ~ DefaultRouDiMemory () noexcept = default ; DefaultRouDiMemory ( DefaultRouDiMemory && ) = delete ; DefaultRouDiMemory & operator = ( DefaultRouDiMemory && ) = delete ; DefaultRouDiMemory ( const DefaultRouDiMemory & ) = delete ; DefaultRouDiMemory & operator = ( const DefaultRouDiMemory & ) = delete ; mepoo :: MePooConfig introspectionMemPoolConfig () const noexcept ; MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock ; MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock ; PosixShmMemoryProvider m_managementShm ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/default_roudi_memory.hpp"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#iceoryx_poshroudimemorydefault_roudi_memoryhpp","text":"","title":"iceoryx_posh/roudi/memory/default_roudi_memory.hpp"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#classes","text":"Name struct iox::roudi::DefaultRouDiMemory","title":"Classes"},{"location":"API-reference/posh/Files/default__roudi__memory_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP #define IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP #include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\" #include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\" namespace iox { namespace roudi { struct DefaultRouDiMemory { public : DefaultRouDiMemory ( const RouDiConfig_t & roudiConfig ) noexcept ; virtual ~ DefaultRouDiMemory () noexcept = default ; DefaultRouDiMemory ( DefaultRouDiMemory && ) = delete ; DefaultRouDiMemory & operator = ( DefaultRouDiMemory && ) = delete ; DefaultRouDiMemory ( const DefaultRouDiMemory & ) = delete ; DefaultRouDiMemory & operator = ( const DefaultRouDiMemory & ) = delete ; mepoo :: MePooConfig introspectionMemPoolConfig () const noexcept ; MemPoolCollectionMemoryBlock m_introspectionMemPoolBlock ; MemPoolSegmentManagerMemoryBlock m_segmentManagerBlock ; PosixShmMemoryProvider m_managementShm ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_DEFAULT_ROUDI_MEMORY_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/dir_1151a212187b560a7f722eb27ccfc7c0/","text":"iceoryx_posh/runtime \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/runtime/node.hpp iceoryx_posh/runtime/port_config_info.hpp iceoryx_posh/runtime/posh_runtime.hpp iceoryx_posh/runtime/posh_runtime_single_process.hpp iceoryx_posh/runtime/service_discovery.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/runtime"},{"location":"API-reference/posh/Files/dir_1151a212187b560a7f722eb27ccfc7c0/#iceoryx_poshruntime","text":"","title":"iceoryx_posh/runtime"},{"location":"API-reference/posh/Files/dir_1151a212187b560a7f722eb27ccfc7c0/#files","text":"Name iceoryx_posh/runtime/node.hpp iceoryx_posh/runtime/port_config_info.hpp iceoryx_posh/runtime/posh_runtime.hpp iceoryx_posh/runtime/posh_runtime_single_process.hpp iceoryx_posh/runtime/service_discovery.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_1b67add0cf43a7d102340612f5a4e07f/","text":"iceoryx_posh/mepoo \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/mepoo/chunk_header.hpp iceoryx_posh/mepoo/chunk_settings.hpp iceoryx_posh/mepoo/memory_info.hpp iceoryx_posh/mepoo/mepoo_config.hpp iceoryx_posh/mepoo/segment_config.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/mepoo"},{"location":"API-reference/posh/Files/dir_1b67add0cf43a7d102340612f5a4e07f/#iceoryx_poshmepoo","text":"","title":"iceoryx_posh/mepoo"},{"location":"API-reference/posh/Files/dir_1b67add0cf43a7d102340612f5a4e07f/#files","text":"Name iceoryx_posh/mepoo/chunk_header.hpp iceoryx_posh/mepoo/chunk_settings.hpp iceoryx_posh/mepoo/memory_info.hpp iceoryx_posh/mepoo/mepoo_config.hpp iceoryx_posh/mepoo/segment_config.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/","text":"iceoryx_posh/roudi \ud83d\udd17 Directories \ud83d\udd17 Name iceoryx_posh/roudi/memory Files \ud83d\udd17 Name iceoryx_posh/roudi/cmd_line_args.hpp iceoryx_posh/roudi/iceoryx_roudi_app.hpp iceoryx_posh/roudi/iceoryx_roudi_components.hpp iceoryx_posh/roudi/introspection_types.hpp iceoryx_posh/roudi/port_pool.hpp iceoryx_posh/roudi/port_pool.inl iceoryx_posh/roudi/roudi_app.hpp iceoryx_posh/roudi/roudi_cmd_line_parser.hpp iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp iceoryx_posh/roudi/roudi_config.hpp iceoryx_posh/roudi/roudi_config_file_provider.hpp iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/#iceoryx_poshroudi","text":"","title":"iceoryx_posh/roudi"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/#directories","text":"Name iceoryx_posh/roudi/memory","title":"Directories"},{"location":"API-reference/posh/Files/dir_3ca70bb3ac23c90924f17c59db4a0f53/#files","text":"Name iceoryx_posh/roudi/cmd_line_args.hpp iceoryx_posh/roudi/iceoryx_roudi_app.hpp iceoryx_posh/roudi/iceoryx_roudi_components.hpp iceoryx_posh/roudi/introspection_types.hpp iceoryx_posh/roudi/port_pool.hpp iceoryx_posh/roudi/port_pool.inl iceoryx_posh/roudi/roudi_app.hpp iceoryx_posh/roudi/roudi_cmd_line_parser.hpp iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp iceoryx_posh/roudi/roudi_config.hpp iceoryx_posh/roudi/roudi_config_file_provider.hpp iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_419dceea7b650cada8c28739688bd20d/","text":"iceoryx_posh/popo \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/popo/client.hpp iceoryx_posh/popo/client_options.hpp iceoryx_posh/popo/enum_trigger_type.hpp iceoryx_posh/popo/listener.hpp iceoryx_posh/popo/notification_attorney.hpp iceoryx_posh/popo/notification_callback.hpp iceoryx_posh/popo/notification_info.hpp iceoryx_posh/popo/port_queue_policies.hpp iceoryx_posh/popo/publisher.hpp iceoryx_posh/popo/publisher_options.hpp iceoryx_posh/popo/request.hpp iceoryx_posh/popo/response.hpp iceoryx_posh/popo/rpc_header.hpp iceoryx_posh/popo/sample.hpp iceoryx_posh/popo/server.hpp iceoryx_posh/popo/server_options.hpp iceoryx_posh/popo/subscriber.hpp iceoryx_posh/popo/subscriber_options.hpp iceoryx_posh/popo/trigger.hpp iceoryx_posh/popo/trigger_handle.hpp iceoryx_posh/popo/untyped_client.hpp iceoryx_posh/popo/untyped_publisher.hpp iceoryx_posh/popo/untyped_server.hpp iceoryx_posh/popo/untyped_subscriber.hpp iceoryx_posh/popo/user_trigger.hpp iceoryx_posh/popo/wait_set.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo"},{"location":"API-reference/posh/Files/dir_419dceea7b650cada8c28739688bd20d/#iceoryx_poshpopo","text":"","title":"iceoryx_posh/popo"},{"location":"API-reference/posh/Files/dir_419dceea7b650cada8c28739688bd20d/#files","text":"Name iceoryx_posh/popo/client.hpp iceoryx_posh/popo/client_options.hpp iceoryx_posh/popo/enum_trigger_type.hpp iceoryx_posh/popo/listener.hpp iceoryx_posh/popo/notification_attorney.hpp iceoryx_posh/popo/notification_callback.hpp iceoryx_posh/popo/notification_info.hpp iceoryx_posh/popo/port_queue_policies.hpp iceoryx_posh/popo/publisher.hpp iceoryx_posh/popo/publisher_options.hpp iceoryx_posh/popo/request.hpp iceoryx_posh/popo/response.hpp iceoryx_posh/popo/rpc_header.hpp iceoryx_posh/popo/sample.hpp iceoryx_posh/popo/server.hpp iceoryx_posh/popo/server_options.hpp iceoryx_posh/popo/subscriber.hpp iceoryx_posh/popo/subscriber_options.hpp iceoryx_posh/popo/trigger.hpp iceoryx_posh/popo/trigger_handle.hpp iceoryx_posh/popo/untyped_client.hpp iceoryx_posh/popo/untyped_publisher.hpp iceoryx_posh/popo/untyped_server.hpp iceoryx_posh/popo/untyped_subscriber.hpp iceoryx_posh/popo/user_trigger.hpp iceoryx_posh/popo/wait_set.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/","text":"iceoryx_posh \ud83d\udd17 Directories \ud83d\udd17 Name iceoryx_posh/capro iceoryx_posh/gateway iceoryx_posh/internal iceoryx_posh/mepoo iceoryx_posh/popo iceoryx_posh/roudi iceoryx_posh/runtime iceoryx_posh/version Files \ud83d\udd17 Name iceoryx_posh/iceoryx_posh_config.hpp iceoryx_posh/iceoryx_posh_types.hpp iceoryx_posh/iceoryx_posh_types.inl Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/#iceoryx_posh","text":"","title":"iceoryx_posh"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/#directories","text":"Name iceoryx_posh/capro iceoryx_posh/gateway iceoryx_posh/internal iceoryx_posh/mepoo iceoryx_posh/popo iceoryx_posh/roudi iceoryx_posh/runtime iceoryx_posh/version","title":"Directories"},{"location":"API-reference/posh/Files/dir_4e3859a7879e1bd577e0dd52dd260e2c/#files","text":"Name iceoryx_posh/iceoryx_posh_config.hpp iceoryx_posh/iceoryx_posh_types.hpp iceoryx_posh/iceoryx_posh_types.inl Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_84fa8189f26ca4adb173569b8d483802/","text":"iceoryx_posh/gateway \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/gateway/channel.hpp iceoryx_posh/gateway/gateway_base.hpp iceoryx_posh/gateway/gateway_config.hpp iceoryx_posh/gateway/gateway_discovery.hpp iceoryx_posh/gateway/gateway_generic.hpp iceoryx_posh/gateway/toml_gateway_config_parser.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway"},{"location":"API-reference/posh/Files/dir_84fa8189f26ca4adb173569b8d483802/#iceoryx_poshgateway","text":"","title":"iceoryx_posh/gateway"},{"location":"API-reference/posh/Files/dir_84fa8189f26ca4adb173569b8d483802/#files","text":"Name iceoryx_posh/gateway/channel.hpp iceoryx_posh/gateway/gateway_base.hpp iceoryx_posh/gateway/gateway_config.hpp iceoryx_posh/gateway/gateway_discovery.hpp iceoryx_posh/gateway/gateway_generic.hpp iceoryx_posh/gateway/toml_gateway_config_parser.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_af77be8c49ebdd8490577ab90b78e8e9/","text":"iceoryx_posh/internal/popo \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/internal/popo/base_client.hpp iceoryx_posh/internal/popo/base_publisher.hpp iceoryx_posh/internal/popo/base_server.hpp iceoryx_posh/internal/popo/base_subscriber.hpp iceoryx_posh/internal/popo/client_impl.hpp iceoryx_posh/internal/popo/publisher_impl.hpp iceoryx_posh/internal/popo/server_impl.hpp iceoryx_posh/internal/popo/subscriber_impl.hpp iceoryx_posh/internal/popo/untyped_client_impl.hpp iceoryx_posh/internal/popo/untyped_publisher_impl.hpp iceoryx_posh/internal/popo/untyped_server_impl.hpp iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo"},{"location":"API-reference/posh/Files/dir_af77be8c49ebdd8490577ab90b78e8e9/#iceoryx_poshinternalpopo","text":"","title":"iceoryx_posh/internal/popo"},{"location":"API-reference/posh/Files/dir_af77be8c49ebdd8490577ab90b78e8e9/#files","text":"Name iceoryx_posh/internal/popo/base_client.hpp iceoryx_posh/internal/popo/base_publisher.hpp iceoryx_posh/internal/popo/base_server.hpp iceoryx_posh/internal/popo/base_subscriber.hpp iceoryx_posh/internal/popo/client_impl.hpp iceoryx_posh/internal/popo/publisher_impl.hpp iceoryx_posh/internal/popo/server_impl.hpp iceoryx_posh/internal/popo/subscriber_impl.hpp iceoryx_posh/internal/popo/untyped_client_impl.hpp iceoryx_posh/internal/popo/untyped_publisher_impl.hpp iceoryx_posh/internal/popo/untyped_server_impl.hpp iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_b79ea52762aefbdfcef432ced10e3c8e/","text":"iceoryx_posh/roudi/memory \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/roudi/memory/default_roudi_memory.hpp iceoryx_posh/roudi/memory/generic_memory_block.hpp iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp iceoryx_posh/roudi/memory/memory_block.hpp iceoryx_posh/roudi/memory/memory_provider.hpp iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp iceoryx_posh/roudi/memory/roudi_memory_interface.hpp iceoryx_posh/roudi/memory/roudi_memory_manager.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory"},{"location":"API-reference/posh/Files/dir_b79ea52762aefbdfcef432ced10e3c8e/#iceoryx_poshroudimemory","text":"","title":"iceoryx_posh/roudi/memory"},{"location":"API-reference/posh/Files/dir_b79ea52762aefbdfcef432ced10e3c8e/#files","text":"Name iceoryx_posh/roudi/memory/default_roudi_memory.hpp iceoryx_posh/roudi/memory/generic_memory_block.hpp iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp iceoryx_posh/roudi/memory/memory_block.hpp iceoryx_posh/roudi/memory/memory_provider.hpp iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp iceoryx_posh/roudi/memory/roudi_memory_interface.hpp iceoryx_posh/roudi/memory/roudi_memory_manager.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_d0fffd83abc47c1fbeae6c4f48164f96/","text":"iceoryx_posh/version \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/version/compatibility_check_level.hpp iceoryx_posh/version/version_info.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/version"},{"location":"API-reference/posh/Files/dir_d0fffd83abc47c1fbeae6c4f48164f96/#iceoryx_poshversion","text":"","title":"iceoryx_posh/version"},{"location":"API-reference/posh/Files/dir_d0fffd83abc47c1fbeae6c4f48164f96/#files","text":"Name iceoryx_posh/version/compatibility_check_level.hpp iceoryx_posh/version/version_info.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/dir_eef72c1d9a51b854a3de007d251e338b/","text":"iceoryx_posh/internal \ud83d\udd17 Directories \ud83d\udd17 Name iceoryx_posh/internal/popo Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal"},{"location":"API-reference/posh/Files/dir_eef72c1d9a51b854a3de007d251e338b/#iceoryx_poshinternal","text":"","title":"iceoryx_posh/internal"},{"location":"API-reference/posh/Files/dir_eef72c1d9a51b854a3de007d251e338b/#directories","text":"Name iceoryx_posh/internal/popo Updated on 18 December 2023 at 13:11:43 CET","title":"Directories"},{"location":"API-reference/posh/Files/dir_fa868a754275b86affbf0a162bbaf072/","text":"iceoryx_posh/capro \ud83d\udd17 Files \ud83d\udd17 Name iceoryx_posh/capro/service_description.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/capro"},{"location":"API-reference/posh/Files/dir_fa868a754275b86affbf0a162bbaf072/#iceoryx_poshcapro","text":"","title":"iceoryx_posh/capro"},{"location":"API-reference/posh/Files/dir_fa868a754275b86affbf0a162bbaf072/#files","text":"Name iceoryx_posh/capro/service_description.hpp Updated on 18 December 2023 at 13:11:43 CET","title":"Files"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/","text":"iceoryx_posh/popo/enum_trigger_type.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_ENUM_TRIGGER_TYPE_HPP #define IOX_POSH_POPO_ENUM_TRIGGER_TYPE_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include <cstdint> namespace iox { namespace popo { using StateEnumIdentifier = uint64_t ; using EventEnumIdentifier = int64_t ; template < typename T > constexpr bool IS_EVENT_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , EventEnumIdentifier >:: value ; template < typename T > constexpr bool IS_STATE_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , StateEnumIdentifier >:: value ; } // namespace popo } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/enum_trigger_type.hpp"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/#iceoryx_poshpopoenum_trigger_typehpp","text":"","title":"iceoryx_posh/popo/enum_trigger_type.hpp"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/enum__trigger__type_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_ENUM_TRIGGER_TYPE_HPP #define IOX_POSH_POPO_ENUM_TRIGGER_TYPE_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include <cstdint> namespace iox { namespace popo { using StateEnumIdentifier = uint64_t ; using EventEnumIdentifier = int64_t ; template < typename T > constexpr bool IS_EVENT_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , EventEnumIdentifier >:: value ; template < typename T > constexpr bool IS_STATE_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , StateEnumIdentifier >:: value ; } // namespace popo } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/gateway__base_8hpp/","text":"iceoryx_posh/gateway/gateway_base.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::capro iox::popo iox::gw Classes \ud83d\udd17 Name class iox: :GatewayBase Generic gateway for communication events. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_BASE_HPP #define IOX_POSH_GW_GATEWAY_BASE_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\" #include <memory> namespace iox { namespace capro { class CaproMessage ; } namespace popo { class InterfacePort ; } namespace gw { class GatewayBase { public : using CaproMessage = capro :: CaproMessage ; GatewayBase ( const capro :: Interfaces f_interface ) noexcept ; GatewayBase & operator = ( const GatewayBase & other ) = delete ; GatewayBase ( const GatewayBase & other ) = delete ; GatewayBase ( GatewayBase && other ) noexcept = default ; GatewayBase & operator = ( GatewayBase && ) noexcept = default ; virtual ~ GatewayBase () noexcept ; bool getCaProMessage ( CaproMessage & msg ) noexcept ; protected : // Needed for unit testing GatewayBase () noexcept = default ; capro :: Interfaces getInterface () const noexcept ; protected : popo :: InterfacePort m_interfaceImpl { nullptr }; }; } // namespace gw } // namespace iox #endif // IOX_POSH_GW_GATEWAY_BASE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway/gateway_base.hpp"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#iceoryx_poshgatewaygateway_basehpp","text":"","title":"iceoryx_posh/gateway/gateway_base.hpp"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#namespaces","text":"Name iox iox::capro iox::popo iox::gw","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#classes","text":"Name class iox: :GatewayBase Generic gateway for communication events.","title":"Classes"},{"location":"API-reference/posh/Files/gateway__base_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_BASE_HPP #define IOX_POSH_GW_GATEWAY_BASE_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\" #include <memory> namespace iox { namespace capro { class CaproMessage ; } namespace popo { class InterfacePort ; } namespace gw { class GatewayBase { public : using CaproMessage = capro :: CaproMessage ; GatewayBase ( const capro :: Interfaces f_interface ) noexcept ; GatewayBase & operator = ( const GatewayBase & other ) = delete ; GatewayBase ( const GatewayBase & other ) = delete ; GatewayBase ( GatewayBase && other ) noexcept = default ; GatewayBase & operator = ( GatewayBase && ) noexcept = default ; virtual ~ GatewayBase () noexcept ; bool getCaProMessage ( CaproMessage & msg ) noexcept ; protected : // Needed for unit testing GatewayBase () noexcept = default ; capro :: Interfaces getInterface () const noexcept ; protected : popo :: InterfacePort m_interfaceImpl { nullptr }; }; } // namespace gw } // namespace iox #endif // IOX_POSH_GW_GATEWAY_BASE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/gateway__config_8hpp/","text":"iceoryx_posh/gateway/gateway_config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name struct iox::config::GatewayConfig Generic configuration for gateways. struct iox::config::GatewayConfig::ServiceEntry Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_CONFIG_HPP #define IOX_POSH_GW_GATEWAY_CONFIG_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace config { struct GatewayConfig { struct ServiceEntry { capro :: ServiceDescription m_serviceDescription ; }; iox :: cxx :: vector < ServiceEntry , MAX_GATEWAY_SERVICES > m_configuredServices ; void setDefaults () noexcept ; }; } // namespace config } // namespace iox #endif // IOX_POSH_GW_GATEWAY_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway/gateway_config.hpp"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#iceoryx_poshgatewaygateway_confighpp","text":"","title":"iceoryx_posh/gateway/gateway_config.hpp"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#classes","text":"Name struct iox::config::GatewayConfig Generic configuration for gateways. struct iox::config::GatewayConfig::ServiceEntry","title":"Classes"},{"location":"API-reference/posh/Files/gateway__config_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_CONFIG_HPP #define IOX_POSH_GW_GATEWAY_CONFIG_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace config { struct GatewayConfig { struct ServiceEntry { capro :: ServiceDescription m_serviceDescription ; }; iox :: cxx :: vector < ServiceEntry , MAX_GATEWAY_SERVICES > m_configuredServices ; void setDefaults () noexcept ; }; } // namespace config } // namespace iox #endif // IOX_POSH_GW_GATEWAY_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/","text":"iceoryx_posh/gateway/gateway_discovery.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::capro iox::gw Classes \ud83d\udd17 Name class iox: :GatewayDiscovery Discover the gateway. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_DISCOVERY_HPP #define IOX_POSH_GW_GATEWAY_DISCOVERY_HPP #include \"iceoryx_posh/gateway/gateway_base.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace capro { class CaproMessage ; } namespace gw { class InterfacePort ; template < typename Impl_T = GatewayBase > class GatewayDiscovery { public : using CaproMessage = capro :: CaproMessage ; explicit GatewayDiscovery ( const capro :: Interfaces f_interface ) noexcept : m_impl ( f_interface ) { } bool getCaproMessage ( CaproMessage & msg ) noexcept { return m_impl . getCaProMessage ( msg ); } protected : // needed for unit testing explicit GatewayDiscovery ( Impl_T interfacePortImpl ) noexcept : m_impl ( interfacePortImpl ) { } private : Impl_T m_impl ; }; } // namespace gw } // namespace iox #endif // IOX_POSH_GW_GATEWAY_DISCOVERY_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway/gateway_discovery.hpp"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#iceoryx_poshgatewaygateway_discoveryhpp","text":"","title":"iceoryx_posh/gateway/gateway_discovery.hpp"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#namespaces","text":"Name iox iox::capro iox::gw","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#classes","text":"Name class iox: :GatewayDiscovery Discover the gateway.","title":"Classes"},{"location":"API-reference/posh/Files/gateway__discovery_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_DISCOVERY_HPP #define IOX_POSH_GW_GATEWAY_DISCOVERY_HPP #include \"iceoryx_posh/gateway/gateway_base.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace capro { class CaproMessage ; } namespace gw { class InterfacePort ; template < typename Impl_T = GatewayBase > class GatewayDiscovery { public : using CaproMessage = capro :: CaproMessage ; explicit GatewayDiscovery ( const capro :: Interfaces f_interface ) noexcept : m_impl ( f_interface ) { } bool getCaproMessage ( CaproMessage & msg ) noexcept { return m_impl . getCaProMessage ( msg ); } protected : // needed for unit testing explicit GatewayDiscovery ( Impl_T interfacePortImpl ) noexcept : m_impl ( interfacePortImpl ) { } private : Impl_T m_impl ; }; } // namespace gw } // namespace iox #endif // IOX_POSH_GW_GATEWAY_DISCOVERY_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/","text":"iceoryx_posh/gateway/gateway_generic.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::gw iox::units::duration_literals Classes \ud83d\udd17 Name class iox: :GatewayGeneric A reference generic gateway implementation. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_GENERIC_HPP #define IOX_POSH_GW_GATEWAY_GENERIC_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/internal/concurrent/smart_lock.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/gateway/gateway_base.hpp\" #include \"iceoryx_posh/gateway/gateway_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <atomic> #include <thread> namespace iox { namespace gw { using namespace iox :: units :: duration_literals ; enum class GatewayError : uint8_t { UNSUPPORTED_SERVICE_TYPE , UNSUCCESSFUL_CHANNEL_CREATION , NONEXISTANT_CHANNEL }; template < typename channel_t , typename gateway_t = GatewayBase > class GatewayGeneric : public gateway_t { using ChannelVector = cxx :: vector < channel_t , MAX_CHANNEL_NUMBER > ; using ConcurrentChannelVector = concurrent :: smart_lock < ChannelVector > ; public : virtual ~ GatewayGeneric () noexcept ; GatewayGeneric ( const GatewayGeneric & ) = delete ; GatewayGeneric & operator = ( const GatewayGeneric & ) = delete ; GatewayGeneric ( GatewayGeneric && ) = delete ; GatewayGeneric & operator = ( GatewayGeneric && ) = delete ; void runMultithreaded () noexcept ; void shutdown () noexcept ; virtual void loadConfiguration ( const config :: GatewayConfig & config ) noexcept = 0 ; virtual void discover ( const capro :: CaproMessage & msg ) noexcept = 0 ; virtual void forward ( const channel_t & channel ) noexcept = 0 ; uint64_t getNumberOfChannels () const noexcept ; protected : GatewayGeneric ( capro :: Interfaces interface , units :: Duration discoveryPeriod = 1000 _ms , units :: Duration forwardingPeriod = 50 _ms ) noexcept ; template < typename IceoryxPubSubOptions > cxx :: expected < channel_t , GatewayError > addChannel ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) noexcept ; cxx :: optional < channel_t > findChannel ( const capro :: ServiceDescription & service ) const noexcept ; void forEachChannel ( const cxx :: function_ref < void ( channel_t & ) > f ) const noexcept ; cxx :: expected < GatewayError > discardChannel ( const capro :: ServiceDescription & service ) noexcept ; private : ConcurrentChannelVector m_channels ; std :: atomic_bool m_isRunning { false }; units :: Duration m_discoveryPeriod ; units :: Duration m_forwardingPeriod ; std :: thread m_discoveryThread ; std :: thread m_forwardingThread ; void forwardingLoop () noexcept ; void discoveryLoop () noexcept ; }; } // namespace gw } // namespace iox #include \"iceoryx_posh/internal/gateway/gateway_generic.inl\" #endif // IOX_POSH_GW_GATEWAY_GENERIC_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway/gateway_generic.hpp"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#iceoryx_poshgatewaygateway_generichpp","text":"","title":"iceoryx_posh/gateway/gateway_generic.hpp"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#namespaces","text":"Name iox iox::gw iox::units::duration_literals","title":"Namespaces"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#classes","text":"Name class iox: :GatewayGeneric A reference generic gateway implementation.","title":"Classes"},{"location":"API-reference/posh/Files/gateway__generic_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_GATEWAY_GENERIC_HPP #define IOX_POSH_GW_GATEWAY_GENERIC_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/internal/concurrent/smart_lock.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/gateway/gateway_base.hpp\" #include \"iceoryx_posh/gateway/gateway_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <atomic> #include <thread> namespace iox { namespace gw { using namespace iox :: units :: duration_literals ; enum class GatewayError : uint8_t { UNSUPPORTED_SERVICE_TYPE , UNSUCCESSFUL_CHANNEL_CREATION , NONEXISTANT_CHANNEL }; template < typename channel_t , typename gateway_t = GatewayBase > class GatewayGeneric : public gateway_t { using ChannelVector = cxx :: vector < channel_t , MAX_CHANNEL_NUMBER > ; using ConcurrentChannelVector = concurrent :: smart_lock < ChannelVector > ; public : virtual ~ GatewayGeneric () noexcept ; GatewayGeneric ( const GatewayGeneric & ) = delete ; GatewayGeneric & operator = ( const GatewayGeneric & ) = delete ; GatewayGeneric ( GatewayGeneric && ) = delete ; GatewayGeneric & operator = ( GatewayGeneric && ) = delete ; void runMultithreaded () noexcept ; void shutdown () noexcept ; virtual void loadConfiguration ( const config :: GatewayConfig & config ) noexcept = 0 ; virtual void discover ( const capro :: CaproMessage & msg ) noexcept = 0 ; virtual void forward ( const channel_t & channel ) noexcept = 0 ; uint64_t getNumberOfChannels () const noexcept ; protected : GatewayGeneric ( capro :: Interfaces interface , units :: Duration discoveryPeriod = 1000 _ms , units :: Duration forwardingPeriod = 50 _ms ) noexcept ; template < typename IceoryxPubSubOptions > cxx :: expected < channel_t , GatewayError > addChannel ( const capro :: ServiceDescription & service , const IceoryxPubSubOptions & options ) noexcept ; cxx :: optional < channel_t > findChannel ( const capro :: ServiceDescription & service ) const noexcept ; void forEachChannel ( const cxx :: function_ref < void ( channel_t & ) > f ) const noexcept ; cxx :: expected < GatewayError > discardChannel ( const capro :: ServiceDescription & service ) noexcept ; private : ConcurrentChannelVector m_channels ; std :: atomic_bool m_isRunning { false }; units :: Duration m_discoveryPeriod ; units :: Duration m_forwardingPeriod ; std :: thread m_discoveryThread ; std :: thread m_forwardingThread ; void forwardingLoop () noexcept ; void discoveryLoop () noexcept ; }; } // namespace gw } // namespace iox #include \"iceoryx_posh/internal/gateway/gateway_generic.inl\" #endif // IOX_POSH_GW_GATEWAY_GENERIC_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/","text":"iceoryx_posh/roudi/memory/generic_memory_block.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::GenericMemoryBlock The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP #define IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP #include \"iceoryx_posh/roudi/memory/memory_block.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include <cstdint> namespace iox { namespace roudi { template < typename T > class GenericMemoryBlock final : public MemoryBlock { friend class MemoryProvider ; public : GenericMemoryBlock () noexcept = default ; ~ GenericMemoryBlock () noexcept ; GenericMemoryBlock ( const GenericMemoryBlock & ) = delete ; GenericMemoryBlock ( GenericMemoryBlock && ) = delete ; GenericMemoryBlock & operator = ( const GenericMemoryBlock & ) = delete ; GenericMemoryBlock & operator = ( GenericMemoryBlock && ) = delete ; uint64_t size () const noexcept override ; uint64_t alignment () const noexcept override ; template < typename ... Targs > cxx :: optional < T *> emplace ( Targs && ... args ) noexcept ; cxx :: optional < T *> value () const noexcept ; protected : void destroy () noexcept override ; private : T * m_value { nullptr }; }; } // namespace roudi } // namespace iox #include \"iceoryx_posh/internal/roudi/memory/generic_memory_block.inl\" #endif // IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/generic_memory_block.hpp"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#iceoryx_poshroudimemorygeneric_memory_blockhpp","text":"","title":"iceoryx_posh/roudi/memory/generic_memory_block.hpp"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#classes","text":"Name class iox::roudi::GenericMemoryBlock The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case.","title":"Classes"},{"location":"API-reference/posh/Files/generic__memory__block_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP #define IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP #include \"iceoryx_posh/roudi/memory/memory_block.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include <cstdint> namespace iox { namespace roudi { template < typename T > class GenericMemoryBlock final : public MemoryBlock { friend class MemoryProvider ; public : GenericMemoryBlock () noexcept = default ; ~ GenericMemoryBlock () noexcept ; GenericMemoryBlock ( const GenericMemoryBlock & ) = delete ; GenericMemoryBlock ( GenericMemoryBlock && ) = delete ; GenericMemoryBlock & operator = ( const GenericMemoryBlock & ) = delete ; GenericMemoryBlock & operator = ( GenericMemoryBlock && ) = delete ; uint64_t size () const noexcept override ; uint64_t alignment () const noexcept override ; template < typename ... Targs > cxx :: optional < T *> emplace ( Targs && ... args ) noexcept ; cxx :: optional < T *> value () const noexcept ; protected : void destroy () noexcept override ; private : T * m_value { nullptr }; }; } // namespace roudi } // namespace iox #include \"iceoryx_posh/internal/roudi/memory/generic_memory_block.inl\" #endif // IOX_POSH_ROUDI_MEMORY_GENERIC_MEMORY_BLOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/","text":"iceoryx_posh/iceoryx_posh_config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::helper Classes \ud83d\udd17 Name struct iox::helper::SetDefaults struct iox::helper::SetDefaults< FirstArg, RemainderArgs... > struct iox::helper::SetDefaults< FinalArg > struct iox::helper::Optimize struct iox::helper::Optimize< FirstArg, RemainderArgs... > struct iox::helper::Optimize< FinalArg > struct iox::Config Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ICEORYX_POSH_CONFIG_HPP #define IOX_POSH_ICEORYX_POSH_CONFIG_HPP #include \"iceoryx_posh/mepoo/segment_config.hpp\" #include \"roudi/roudi_config.hpp\" namespace iox { namespace helper { template < typename ... ConfigParts > struct SetDefaults ; template < typename FirstArg , typename ... RemainderArgs > struct SetDefaults < FirstArg , RemainderArgs ... > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { SetDefaults < FirstArg >:: apply ( me ); SetDefaults < RemainderArgs ... >:: apply ( me ); } }; template < typename FinalArg > struct SetDefaults < FinalArg > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { static_cast < FinalArg *> ( me ) -> setDefaults (); } }; template < typename ... ConfigParts > struct Optimize ; template < typename FirstArg , typename ... RemainderArgs > struct Optimize < FirstArg , RemainderArgs ... > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { Optimize < FirstArg >:: apply ( me ); Optimize < RemainderArgs ... >:: apply ( me ); } }; template < typename FinalArg > struct Optimize < FinalArg > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { static_cast < FinalArg *> ( me ) -> optimize (); } }; } // namespace helper template < typename ... ConfigParts > struct Config : public ConfigParts ... { Config & setDefaults () noexcept { helper :: SetDefaults < ConfigParts ... >:: apply ( this ); return * this ; } template < typename T > Config & setModuleDefaults () noexcept { T :: setDefaults (); return * this ; } Config & optimize () noexcept { helper :: Optimize < ConfigParts ... >:: apply ( this ); return * this ; } }; using RouDiConfig_t = Config < mepoo :: SegmentConfig , config :: RouDiConfig > ; } // namespace iox #endif // IOX_POSH_ICEORYX_POSH_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/iceoryx_posh_config.hpp"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#iceoryx_poshiceoryx_posh_confighpp","text":"","title":"iceoryx_posh/iceoryx_posh_config.hpp"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#namespaces","text":"Name iox iox::helper","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#classes","text":"Name struct iox::helper::SetDefaults struct iox::helper::SetDefaults< FirstArg, RemainderArgs... > struct iox::helper::SetDefaults< FinalArg > struct iox::helper::Optimize struct iox::helper::Optimize< FirstArg, RemainderArgs... > struct iox::helper::Optimize< FinalArg > struct iox::Config","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__posh__config_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ICEORYX_POSH_CONFIG_HPP #define IOX_POSH_ICEORYX_POSH_CONFIG_HPP #include \"iceoryx_posh/mepoo/segment_config.hpp\" #include \"roudi/roudi_config.hpp\" namespace iox { namespace helper { template < typename ... ConfigParts > struct SetDefaults ; template < typename FirstArg , typename ... RemainderArgs > struct SetDefaults < FirstArg , RemainderArgs ... > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { SetDefaults < FirstArg >:: apply ( me ); SetDefaults < RemainderArgs ... >:: apply ( me ); } }; template < typename FinalArg > struct SetDefaults < FinalArg > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { static_cast < FinalArg *> ( me ) -> setDefaults (); } }; template < typename ... ConfigParts > struct Optimize ; template < typename FirstArg , typename ... RemainderArgs > struct Optimize < FirstArg , RemainderArgs ... > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { Optimize < FirstArg >:: apply ( me ); Optimize < RemainderArgs ... >:: apply ( me ); } }; template < typename FinalArg > struct Optimize < FinalArg > { template < typename BaseType > static void apply ( BaseType * me ) noexcept { static_cast < FinalArg *> ( me ) -> optimize (); } }; } // namespace helper template < typename ... ConfigParts > struct Config : public ConfigParts ... { Config & setDefaults () noexcept { helper :: SetDefaults < ConfigParts ... >:: apply ( this ); return * this ; } template < typename T > Config & setModuleDefaults () noexcept { T :: setDefaults (); return * this ; } Config & optimize () noexcept { helper :: Optimize < ConfigParts ... >:: apply ( this ); return * this ; } }; using RouDiConfig_t = Config < mepoo :: SegmentConfig , config :: RouDiConfig > ; } // namespace iox #endif // IOX_POSH_ICEORYX_POSH_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/","text":"iceoryx_posh/iceoryx_posh_types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo iox::capro iox::runtime iox::roudi iox::mepoo iox::version Classes \ud83d\udd17 Name struct iox::DefaultChunkDistributorConfig struct iox::DefaultChunkQueueConfig Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ICEORYX_POSH_TYPES_HPP #define IOX_POSH_ICEORYX_POSH_TYPES_HPP #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/variant_queue.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/ipc_channel.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include \"iceoryx_hoofs/platform/platform_settings.hpp\" #include \"iceoryx_posh/iceoryx_posh_deployment.hpp\" #include <cstdint> namespace iox { namespace popo { class UniquePortId ; struct BasePortData ; class PublisherPortRouDi ; class PublisherPortUser ; class SubscriberPortRouDi ; class SubscriberPortUser ; } // namespace popo namespace capro { class ServiceDescription ; } using PublisherPortRouDiType = iox :: popo :: PublisherPortRouDi ; using PublisherPortUserType = iox :: popo :: PublisherPortUser ; using SubscriberPortRouDiType = iox :: popo :: SubscriberPortRouDi ; using SubscriberPortUserType = iox :: popo :: SubscriberPortUser ; using SubscriberPortType = iox :: build :: CommunicationPolicy ; //--------- Communication Resources Start--------------------- // Publisher constexpr uint32_t MAX_PUBLISHERS = build :: IOX_MAX_PUBLISHERS ; constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER = build :: IOX_MAX_SUBSCRIBERS_PER_PUBLISHER ; constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY ; constexpr uint64_t MAX_PUBLISHER_HISTORY = build :: IOX_MAX_PUBLISHER_HISTORY ; // Subscriber constexpr uint32_t MAX_SUBSCRIBERS = build :: IOX_MAX_SUBSCRIBERS ; constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ; constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ; // Introspection is using the following publisherPorts, which reduced the number of ports available for the user // 1x publisherPort mempool introspection // 1x publisherPort process introspection // 3x publisherPort port introspection constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION = 5 ; constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY = 1 ; constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS = PUBLISHERS_RESERVED_FOR_INTROSPECTION + PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY ; // Gateway constexpr uint32_t MAX_INTERFACE_NUMBER = build :: IOX_MAX_INTERFACE_NUMBER ; constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE = MAX_PUBLISHERS ; constexpr uint32_t MAX_CHANNEL_NUMBER = MAX_PUBLISHERS + MAX_SUBSCRIBERS ; constexpr uint32_t MAX_GATEWAY_SERVICES = 2 * MAX_CHANNEL_NUMBER ; // Client constexpr uint32_t MAX_CLIENTS = build :: IOX_MAX_SUBSCRIBERS ; constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY = 4U ; constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY = 16U ; constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY = 16U ; // Server constexpr uint32_t MAX_SERVERS = build :: IOX_MAX_PUBLISHERS ; constexpr uint32_t MAX_CLIENTS_PER_SERVER = 256U ; constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY = 4U ; constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY = MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY ; constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY = 1024 ; // Waitset namespace popo { using WaitSetIsConditionSatisfiedCallback = cxx :: ConstMethodCallback < bool > ; } constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES = 1024U ; constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS = build :: IOX_MAX_NUMBER_OF_NOTIFIERS ; constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET = MAX_NUMBER_OF_NOTIFIERS ; constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER = MAX_NUMBER_OF_NOTIFIERS ; //--------- Communication Resources End--------------------- // Memory constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS = 32U ; constexpr uint32_t MAX_SHM_SEGMENTS = 100U ; constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER = 8U ; constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER = 64U ; constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT { 8U }; constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE { 0U }; constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT { 1U }; // Message Queue constexpr uint32_t ROUDI_MAX_MESSAGES = 5U ; constexpr uint32_t ROUDI_MESSAGE_SIZE = 512U ; constexpr uint32_t APP_MAX_MESSAGES = 5U ; constexpr uint32_t APP_MESSAGE_SIZE = 512U ; // Processes constexpr uint32_t MAX_PROCESS_NUMBER = 300U ; // Service Discovery constexpr uint32_t SERVICE_REGISTRY_CAPACITY = MAX_PUBLISHERS + MAX_SERVERS ; constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE = SERVICE_REGISTRY_CAPACITY ; constexpr const char SERVICE_DISCOVERY_SERVICE_NAME [] = \"ServiceDiscovery\" ; constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME [] = \"RouDi_ID\" ; constexpr const char SERVICE_DISCOVERY_EVENT_NAME [] = \"ServiceRegistry\" ; namespace runtime { using ServiceContainer = iox :: cxx :: vector < capro :: ServiceDescription , MAX_FINDSERVICE_RESULT_SIZE > ; } // Nodes constexpr uint32_t MAX_NODE_NUMBER = 1000U ; constexpr uint32_t MAX_NODE_PER_PROCESS = 50U ; constexpr uint32_t MAX_RUNTIME_NAME_LENGTH = MAX_IPC_CHANNEL_NAME_LENGTH ; static_assert ( MAX_PROCESS_NUMBER * MAX_NODE_PER_PROCESS > MAX_NODE_NUMBER , \"Invalid configuration for nodes\" ); enum class SubscribeState : uint32_t { NOT_SUBSCRIBED = 0 , SUBSCRIBE_REQUESTED , SUBSCRIBED , UNSUBSCRIBE_REQUESTED , WAIT_FOR_OFFER }; enum class ConnectionState : uint32_t { NOT_CONNECTED = 0 , CONNECT_REQUESTED , CONNECTED , DISCONNECT_REQUESTED , WAIT_FOR_OFFER }; inline constexpr const char * asStringLiteral ( ConnectionState value ) noexcept ; inline std :: ostream & operator << ( std :: ostream & stream , ConnectionState value ) noexcept ; inline log :: LogStream & operator << ( log :: LogStream & stream , ConnectionState value ) noexcept ; // Default properties of ChunkDistributorData struct DefaultChunkDistributorConfig { static constexpr uint32_t MAX_QUEUES = MAX_SUBSCRIBERS_PER_PUBLISHER ; static constexpr uint64_t MAX_HISTORY_CAPACITY = MAX_PUBLISHER_HISTORY ; }; // Default properties of ChunkQueueData struct DefaultChunkQueueConfig { static constexpr uint64_t MAX_QUEUE_CAPACITY = MAX_SUBSCRIBER_QUEUE_CAPACITY ; }; // alias for cxx::string using RuntimeName_t = cxx :: string < MAX_RUNTIME_NAME_LENGTH > ; // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using NodeName_t = cxx :: string < 100 > ; // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using ShmName_t = cxx :: string < 128 > ; namespace capro { // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using IdString_t = cxx :: string < 100 > ; } // namespace capro namespace roudi { // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using ConfigFilePathString_t = cxx :: string < 1024 > ; constexpr const char ROUDI_LOCK_NAME [] = \"iox-unique-roudi\" ; constexpr const char IPC_CHANNEL_ROUDI_NAME [] = \"roudi\" ; constexpr const char SHM_NAME [] = \"iceoryx_mgmt\" ; // this is used by the UniquePortId constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID { 0U }; // Timeout using namespace units :: duration_literals ; constexpr units :: Duration PROCESS_DEFAULT_KILL_DELAY = 45 _s ; constexpr units :: Duration PROCESS_TERMINATED_CHECK_INTERVAL = 250 _ms ; constexpr units :: Duration DISCOVERY_INTERVAL = 100 _ms ; enum class MonitoringMode { ON , OFF }; iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const MonitoringMode & mode ) noexcept ; } // namespace roudi namespace mepoo { using SequenceNumber_t = std :: uint64_t ; using BaseClock_t = std :: chrono :: steady_clock ; // use signed integer for duration; // there is a bug in gcc 4.8 which leads to a wrong calculated time // when sleep_until() is used with a timepoint in the past using DurationNs_t = std :: chrono :: duration < std :: int64_t , std :: nano > ; using TimePointNs_t = std :: chrono :: time_point < BaseClock_t , DurationNs_t > ; } // namespace mepoo namespace runtime { using namespace units :: duration_literals ; constexpr units :: Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT = 60 _s ; constexpr units :: Duration PROCESS_KEEP_ALIVE_INTERVAL = 3 * roudi :: DISCOVERY_INTERVAL ; // > DISCOVERY_INTERVAL constexpr units :: Duration PROCESS_KEEP_ALIVE_TIMEOUT = 5 * PROCESS_KEEP_ALIVE_INTERVAL ; // > PROCESS_KEEP_ALIVE_INTERVAL } // namespace runtime namespace version { static const uint64_t COMMIT_ID_STRING_SIZE = 12U ; using CommitIdString_t = cxx :: string < COMMIT_ID_STRING_SIZE > ; static const uint64_t BUILD_DATE_STRING_SIZE = 36U ; using BuildDateString_t = cxx :: string < BUILD_DATE_STRING_SIZE > ; } // namespace version } // namespace iox #include \"iceoryx_posh/iceoryx_posh_types.inl\" #endif // IOX_POSH_ICEORYX_POSH_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/iceoryx_posh_types.hpp"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#iceoryx_poshiceoryx_posh_typeshpp","text":"","title":"iceoryx_posh/iceoryx_posh_types.hpp"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#namespaces","text":"Name iox iox::popo iox::capro iox::runtime iox::roudi iox::mepoo iox::version","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#classes","text":"Name struct iox::DefaultChunkDistributorConfig struct iox::DefaultChunkQueueConfig","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ICEORYX_POSH_TYPES_HPP #define IOX_POSH_ICEORYX_POSH_TYPES_HPP #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/variant_queue.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/ipc_channel.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include \"iceoryx_hoofs/platform/platform_settings.hpp\" #include \"iceoryx_posh/iceoryx_posh_deployment.hpp\" #include <cstdint> namespace iox { namespace popo { class UniquePortId ; struct BasePortData ; class PublisherPortRouDi ; class PublisherPortUser ; class SubscriberPortRouDi ; class SubscriberPortUser ; } // namespace popo namespace capro { class ServiceDescription ; } using PublisherPortRouDiType = iox :: popo :: PublisherPortRouDi ; using PublisherPortUserType = iox :: popo :: PublisherPortUser ; using SubscriberPortRouDiType = iox :: popo :: SubscriberPortRouDi ; using SubscriberPortUserType = iox :: popo :: SubscriberPortUser ; using SubscriberPortType = iox :: build :: CommunicationPolicy ; //--------- Communication Resources Start--------------------- // Publisher constexpr uint32_t MAX_PUBLISHERS = build :: IOX_MAX_PUBLISHERS ; constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER = build :: IOX_MAX_SUBSCRIBERS_PER_PUBLISHER ; constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY ; constexpr uint64_t MAX_PUBLISHER_HISTORY = build :: IOX_MAX_PUBLISHER_HISTORY ; // Subscriber constexpr uint32_t MAX_SUBSCRIBERS = build :: IOX_MAX_SUBSCRIBERS ; constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ; constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ; // Introspection is using the following publisherPorts, which reduced the number of ports available for the user // 1x publisherPort mempool introspection // 1x publisherPort process introspection // 3x publisherPort port introspection constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION = 5 ; constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY = 1 ; constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS = PUBLISHERS_RESERVED_FOR_INTROSPECTION + PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY ; // Gateway constexpr uint32_t MAX_INTERFACE_NUMBER = build :: IOX_MAX_INTERFACE_NUMBER ; constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE = MAX_PUBLISHERS ; constexpr uint32_t MAX_CHANNEL_NUMBER = MAX_PUBLISHERS + MAX_SUBSCRIBERS ; constexpr uint32_t MAX_GATEWAY_SERVICES = 2 * MAX_CHANNEL_NUMBER ; // Client constexpr uint32_t MAX_CLIENTS = build :: IOX_MAX_SUBSCRIBERS ; constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY = 4U ; constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY = 16U ; constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY = 16U ; // Server constexpr uint32_t MAX_SERVERS = build :: IOX_MAX_PUBLISHERS ; constexpr uint32_t MAX_CLIENTS_PER_SERVER = 256U ; constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY = 4U ; constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY = MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY ; constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY = 1024 ; // Waitset namespace popo { using WaitSetIsConditionSatisfiedCallback = cxx :: ConstMethodCallback < bool > ; } constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES = 1024U ; constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS = build :: IOX_MAX_NUMBER_OF_NOTIFIERS ; constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET = MAX_NUMBER_OF_NOTIFIERS ; constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER = MAX_NUMBER_OF_NOTIFIERS ; //--------- Communication Resources End--------------------- // Memory constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS = 32U ; constexpr uint32_t MAX_SHM_SEGMENTS = 100U ; constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER = 8U ; constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER = 64U ; constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT { 8U }; constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE { 0U }; constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT { 1U }; // Message Queue constexpr uint32_t ROUDI_MAX_MESSAGES = 5U ; constexpr uint32_t ROUDI_MESSAGE_SIZE = 512U ; constexpr uint32_t APP_MAX_MESSAGES = 5U ; constexpr uint32_t APP_MESSAGE_SIZE = 512U ; // Processes constexpr uint32_t MAX_PROCESS_NUMBER = 300U ; // Service Discovery constexpr uint32_t SERVICE_REGISTRY_CAPACITY = MAX_PUBLISHERS + MAX_SERVERS ; constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE = SERVICE_REGISTRY_CAPACITY ; constexpr const char SERVICE_DISCOVERY_SERVICE_NAME [] = \"ServiceDiscovery\" ; constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME [] = \"RouDi_ID\" ; constexpr const char SERVICE_DISCOVERY_EVENT_NAME [] = \"ServiceRegistry\" ; namespace runtime { using ServiceContainer = iox :: cxx :: vector < capro :: ServiceDescription , MAX_FINDSERVICE_RESULT_SIZE > ; } // Nodes constexpr uint32_t MAX_NODE_NUMBER = 1000U ; constexpr uint32_t MAX_NODE_PER_PROCESS = 50U ; constexpr uint32_t MAX_RUNTIME_NAME_LENGTH = MAX_IPC_CHANNEL_NAME_LENGTH ; static_assert ( MAX_PROCESS_NUMBER * MAX_NODE_PER_PROCESS > MAX_NODE_NUMBER , \"Invalid configuration for nodes\" ); enum class SubscribeState : uint32_t { NOT_SUBSCRIBED = 0 , SUBSCRIBE_REQUESTED , SUBSCRIBED , UNSUBSCRIBE_REQUESTED , WAIT_FOR_OFFER }; enum class ConnectionState : uint32_t { NOT_CONNECTED = 0 , CONNECT_REQUESTED , CONNECTED , DISCONNECT_REQUESTED , WAIT_FOR_OFFER }; inline constexpr const char * asStringLiteral ( ConnectionState value ) noexcept ; inline std :: ostream & operator << ( std :: ostream & stream , ConnectionState value ) noexcept ; inline log :: LogStream & operator << ( log :: LogStream & stream , ConnectionState value ) noexcept ; // Default properties of ChunkDistributorData struct DefaultChunkDistributorConfig { static constexpr uint32_t MAX_QUEUES = MAX_SUBSCRIBERS_PER_PUBLISHER ; static constexpr uint64_t MAX_HISTORY_CAPACITY = MAX_PUBLISHER_HISTORY ; }; // Default properties of ChunkQueueData struct DefaultChunkQueueConfig { static constexpr uint64_t MAX_QUEUE_CAPACITY = MAX_SUBSCRIBER_QUEUE_CAPACITY ; }; // alias for cxx::string using RuntimeName_t = cxx :: string < MAX_RUNTIME_NAME_LENGTH > ; // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using NodeName_t = cxx :: string < 100 > ; // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using ShmName_t = cxx :: string < 128 > ; namespace capro { // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using IdString_t = cxx :: string < 100 > ; } // namespace capro namespace roudi { // NOLINTNEXTLINE(cppcoreguidelines-avoid-magic-numbers) using ConfigFilePathString_t = cxx :: string < 1024 > ; constexpr const char ROUDI_LOCK_NAME [] = \"iox-unique-roudi\" ; constexpr const char IPC_CHANNEL_ROUDI_NAME [] = \"roudi\" ; constexpr const char SHM_NAME [] = \"iceoryx_mgmt\" ; // this is used by the UniquePortId constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID { 0U }; // Timeout using namespace units :: duration_literals ; constexpr units :: Duration PROCESS_DEFAULT_KILL_DELAY = 45 _s ; constexpr units :: Duration PROCESS_TERMINATED_CHECK_INTERVAL = 250 _ms ; constexpr units :: Duration DISCOVERY_INTERVAL = 100 _ms ; enum class MonitoringMode { ON , OFF }; iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const MonitoringMode & mode ) noexcept ; } // namespace roudi namespace mepoo { using SequenceNumber_t = std :: uint64_t ; using BaseClock_t = std :: chrono :: steady_clock ; // use signed integer for duration; // there is a bug in gcc 4.8 which leads to a wrong calculated time // when sleep_until() is used with a timepoint in the past using DurationNs_t = std :: chrono :: duration < std :: int64_t , std :: nano > ; using TimePointNs_t = std :: chrono :: time_point < BaseClock_t , DurationNs_t > ; } // namespace mepoo namespace runtime { using namespace units :: duration_literals ; constexpr units :: Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT = 60 _s ; constexpr units :: Duration PROCESS_KEEP_ALIVE_INTERVAL = 3 * roudi :: DISCOVERY_INTERVAL ; // > DISCOVERY_INTERVAL constexpr units :: Duration PROCESS_KEEP_ALIVE_TIMEOUT = 5 * PROCESS_KEEP_ALIVE_INTERVAL ; // > PROCESS_KEEP_ALIVE_INTERVAL } // namespace runtime namespace version { static const uint64_t COMMIT_ID_STRING_SIZE = 12U ; using CommitIdString_t = cxx :: string < COMMIT_ID_STRING_SIZE > ; static const uint64_t BUILD_DATE_STRING_SIZE = 36U ; using BuildDateString_t = cxx :: string < BUILD_DATE_STRING_SIZE > ; } // namespace version } // namespace iox #include \"iceoryx_posh/iceoryx_posh_types.inl\" #endif // IOX_POSH_ICEORYX_POSH_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/","text":"iceoryx_posh/iceoryx_posh_types.inl \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Defines \ud83d\udd17 Name IOX_POSH_ICEORYX_POSH_TYPES_INL Macro Documentation \ud83d\udd17 define IOX_POSH_ICEORYX_POSH_TYPES_INL \ud83d\udd17 #define IOX_POSH_ICEORYX_POSH_TYPES_INL Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ICEORYX_POSH_TYPES_INL #define IOX_POSH_ICEORYX_POSH_TYPES_INL namespace iox { inline constexpr const char * asStringLiteral ( ConnectionState value ) noexcept { switch ( value ) { case ConnectionState :: NOT_CONNECTED : return \"ConnectionState::NOT_CONNECTED\" ; case ConnectionState :: CONNECT_REQUESTED : return \"ConnectionState::CONNECT_REQUESTED\" ; case ConnectionState :: WAIT_FOR_OFFER : return \"ConnectionState::WAIT_FOR_OFFER\" ; case ConnectionState :: CONNECTED : return \"ConnectionState::CONNECTED\" ; case ConnectionState :: DISCONNECT_REQUESTED : return \"ConnectionState::DISCONNECT_REQUESTED\" ; } return \"[Undefined ConnectionState]\" ; } std :: ostream & operator << ( std :: ostream & stream , ConnectionState value ) noexcept { stream << asStringLiteral ( value ); return stream ; } log :: LogStream & operator << ( log :: LogStream & stream , ConnectionState value ) noexcept { stream << asStringLiteral ( value ); return stream ; } namespace roudi { inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const MonitoringMode & mode ) noexcept { switch ( mode ) { case MonitoringMode :: OFF : logstream << \"MonitoringMode::OFF\" ; break ; case MonitoringMode :: ON : logstream << \"MonitoringMode::ON\" ; break ; default : logstream << \"MonitoringMode::UNDEFINED\" ; break ; } return logstream ; } } // namespace roudi } // namespace iox #endif // IOX_POSH_ICEORYX_POSH_TYPES_INL Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/iceoryx_posh_types.inl"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#iceoryx_poshiceoryx_posh_typesinl","text":"","title":"iceoryx_posh/iceoryx_posh_types.inl"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#defines","text":"Name IOX_POSH_ICEORYX_POSH_TYPES_INL","title":"Defines"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#define-iox_posh_iceoryx_posh_types_inl","text":"#define IOX_POSH_ICEORYX_POSH_TYPES_INL","title":"define IOX_POSH_ICEORYX_POSH_TYPES_INL"},{"location":"API-reference/posh/Files/iceoryx__posh__types_8inl/#source-code","text":"// Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ICEORYX_POSH_TYPES_INL #define IOX_POSH_ICEORYX_POSH_TYPES_INL namespace iox { inline constexpr const char * asStringLiteral ( ConnectionState value ) noexcept { switch ( value ) { case ConnectionState :: NOT_CONNECTED : return \"ConnectionState::NOT_CONNECTED\" ; case ConnectionState :: CONNECT_REQUESTED : return \"ConnectionState::CONNECT_REQUESTED\" ; case ConnectionState :: WAIT_FOR_OFFER : return \"ConnectionState::WAIT_FOR_OFFER\" ; case ConnectionState :: CONNECTED : return \"ConnectionState::CONNECTED\" ; case ConnectionState :: DISCONNECT_REQUESTED : return \"ConnectionState::DISCONNECT_REQUESTED\" ; } return \"[Undefined ConnectionState]\" ; } std :: ostream & operator << ( std :: ostream & stream , ConnectionState value ) noexcept { stream << asStringLiteral ( value ); return stream ; } log :: LogStream & operator << ( log :: LogStream & stream , ConnectionState value ) noexcept { stream << asStringLiteral ( value ); return stream ; } namespace roudi { inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const MonitoringMode & mode ) noexcept { switch ( mode ) { case MonitoringMode :: OFF : logstream << \"MonitoringMode::OFF\" ; break ; case MonitoringMode :: ON : logstream << \"MonitoringMode::ON\" ; break ; default : logstream << \"MonitoringMode::UNDEFINED\" ; break ; } return logstream ; } } // namespace roudi } // namespace iox #endif // IOX_POSH_ICEORYX_POSH_TYPES_INL Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/","text":"iceoryx_posh/roudi/iceoryx_roudi_app.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::IceOryxRouDiApp Source code \ud83d\udd17 // Copyright (c) 2019, 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP #define IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP #include \"iceoryx_posh/roudi/roudi_app.hpp\" namespace iox { namespace roudi { class IceOryxRouDiApp : public RouDiApp { public : IceOryxRouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & roudiConfig ) noexcept ; uint8_t run () noexcept override ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/iceoryx_roudi_app.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#iceoryx_poshroudiiceoryx_roudi_apphpp","text":"","title":"iceoryx_posh/roudi/iceoryx_roudi_app.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#classes","text":"Name class iox::roudi::IceOryxRouDiApp","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__roudi__app_8hpp/#source-code","text":"// Copyright (c) 2019, 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP #define IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP #include \"iceoryx_posh/roudi/roudi_app.hpp\" namespace iox { namespace roudi { class IceOryxRouDiApp : public RouDiApp { public : IceOryxRouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & roudiConfig ) noexcept ; uint8_t run () noexcept override ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ICEORYX_ROUDI_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/","text":"iceoryx_posh/roudi/iceoryx_roudi_components.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name struct iox::roudi::IceOryxRouDiComponents Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP #define IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" #include \"iceoryx_posh/internal/roudi/port_manager.hpp\" #include \"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp\" namespace iox { namespace roudi { struct IceOryxRouDiComponents { public : IceOryxRouDiComponents ( const RouDiConfig_t & roudiConfig ) noexcept ; virtual ~ IceOryxRouDiComponents () = default ; IceOryxRouDiMemoryManager rouDiMemoryManager ; PortManager portManager ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/iceoryx_roudi_components.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#iceoryx_poshroudiiceoryx_roudi_componentshpp","text":"","title":"iceoryx_posh/roudi/iceoryx_roudi_components.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#classes","text":"Name struct iox::roudi::IceOryxRouDiComponents","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__roudi__components_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP #define IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/generic_raii.hpp\" #include \"iceoryx_posh/internal/roudi/port_manager.hpp\" #include \"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp\" namespace iox { namespace roudi { struct IceOryxRouDiComponents { public : IceOryxRouDiComponents ( const RouDiConfig_t & roudiConfig ) noexcept ; virtual ~ IceOryxRouDiComponents () = default ; IceOryxRouDiMemoryManager rouDiMemoryManager ; PortManager portManager ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ICEORYX_ROUDI_COMPONENTS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/","text":"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::IceOryxRouDiMemoryManager Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP #define IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP #include \"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp\" #include \"iceoryx_hoofs/posix_wrapper/file_lock.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/roudi/memory/default_roudi_memory.hpp\" #include \"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp\" #include \"iceoryx_posh/roudi/port_pool.hpp\" namespace iox { namespace roudi { class IceOryxRouDiMemoryManager : public RouDiMemoryInterface { public : IceOryxRouDiMemoryManager ( const RouDiConfig_t & roudiConfig ) noexcept ; virtual ~ IceOryxRouDiMemoryManager () noexcept = default ; IceOryxRouDiMemoryManager ( IceOryxRouDiMemoryManager && ) = delete ; IceOryxRouDiMemoryManager & operator = ( IceOryxRouDiMemoryManager && ) = delete ; IceOryxRouDiMemoryManager ( const IceOryxRouDiMemoryManager & ) = delete ; IceOryxRouDiMemoryManager & operator = ( const IceOryxRouDiMemoryManager & ) = delete ; cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () noexcept override ; cxx :: expected < RouDiMemoryManagerError > destroyMemory () noexcept override ; const PosixShmMemoryProvider * mgmtMemoryProvider () const noexcept override ; cxx :: optional < PortPool *> portPool () noexcept override ; cxx :: optional < mepoo :: MemoryManager *> introspectionMemoryManager () const noexcept override ; cxx :: optional < mepoo :: SegmentManager <>*> segmentManager () const noexcept override ; private : // in order to prevent a second RouDi to cleanup the memory resources of a running RouDi, this resources are // protected by a file lock posix :: FileLock fileLock = std :: move ( posix :: FileLock :: create ( ROUDI_LOCK_NAME ) . or_else ([]( auto & error ) { if ( error == posix :: FileLockError :: LOCKED_BY_OTHER_PROCESS ) { LogFatal () << \"Could not acquire lock, is RouDi still running?\" ; errorHandler ( Error :: kICEORYX_ROUDI_MEMORY_MANAGER__ROUDI_STILL_RUNNING , nullptr , iox :: ErrorLevel :: FATAL ); } else { LogFatal () << \"Error occurred while acquiring file lock named \" << ROUDI_LOCK_NAME ; errorHandler ( Error :: kICEORYX_ROUDI_MEMORY_MANAGER__COULD_NOT_ACQUIRE_FILE_LOCK , nullptr , iox :: ErrorLevel :: FATAL ); } }) . value ()); PortPoolMemoryBlock m_portPoolBlock ; cxx :: optional < PortPool > m_portPool ; DefaultRouDiMemory m_defaultMemory ; RouDiMemoryManager m_memoryManager ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#iceoryx_poshroudimemoryiceoryx_roudi_memory_managerhpp","text":"","title":"iceoryx_posh/roudi/memory/iceoryx_roudi_memory_manager.hpp"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#classes","text":"Name class iox::roudi::IceOryxRouDiMemoryManager","title":"Classes"},{"location":"API-reference/posh/Files/iceoryx__roudi__memory__manager_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP #define IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP #include \"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp\" #include \"iceoryx_hoofs/posix_wrapper/file_lock.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/roudi/memory/default_roudi_memory.hpp\" #include \"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp\" #include \"iceoryx_posh/roudi/port_pool.hpp\" namespace iox { namespace roudi { class IceOryxRouDiMemoryManager : public RouDiMemoryInterface { public : IceOryxRouDiMemoryManager ( const RouDiConfig_t & roudiConfig ) noexcept ; virtual ~ IceOryxRouDiMemoryManager () noexcept = default ; IceOryxRouDiMemoryManager ( IceOryxRouDiMemoryManager && ) = delete ; IceOryxRouDiMemoryManager & operator = ( IceOryxRouDiMemoryManager && ) = delete ; IceOryxRouDiMemoryManager ( const IceOryxRouDiMemoryManager & ) = delete ; IceOryxRouDiMemoryManager & operator = ( const IceOryxRouDiMemoryManager & ) = delete ; cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () noexcept override ; cxx :: expected < RouDiMemoryManagerError > destroyMemory () noexcept override ; const PosixShmMemoryProvider * mgmtMemoryProvider () const noexcept override ; cxx :: optional < PortPool *> portPool () noexcept override ; cxx :: optional < mepoo :: MemoryManager *> introspectionMemoryManager () const noexcept override ; cxx :: optional < mepoo :: SegmentManager <>*> segmentManager () const noexcept override ; private : // in order to prevent a second RouDi to cleanup the memory resources of a running RouDi, this resources are // protected by a file lock posix :: FileLock fileLock = std :: move ( posix :: FileLock :: create ( ROUDI_LOCK_NAME ) . or_else ([]( auto & error ) { if ( error == posix :: FileLockError :: LOCKED_BY_OTHER_PROCESS ) { LogFatal () << \"Could not acquire lock, is RouDi still running?\" ; errorHandler ( Error :: kICEORYX_ROUDI_MEMORY_MANAGER__ROUDI_STILL_RUNNING , nullptr , iox :: ErrorLevel :: FATAL ); } else { LogFatal () << \"Error occurred while acquiring file lock named \" << ROUDI_LOCK_NAME ; errorHandler ( Error :: kICEORYX_ROUDI_MEMORY_MANAGER__COULD_NOT_ACQUIRE_FILE_LOCK , nullptr , iox :: ErrorLevel :: FATAL ); } }) . value ()); PortPoolMemoryBlock m_portPoolBlock ; cxx :: optional < PortPool > m_portPool ; DefaultRouDiMemory m_defaultMemory ; RouDiMemoryManager m_memoryManager ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_ICEORYX_ROUDI_MEMORY_MANAGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/introspection__types_8hpp/","text":"iceoryx_posh/roudi/introspection_types.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name struct iox::roudi::MemPoolInfo struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools. struct iox::roudi::MemPoolIntrospectionInfo the topic for the mempool introspection that a user can subscribe to struct iox::roudi::PortData container for common port data which is related to the subscriber port as well as the publisher port struct iox::roudi::PublisherPortData container for publisher port introspection data. struct iox::roudi::PortIntrospectionFieldTopic the topic for the port introspection that a user can subscribe to struct iox::roudi::PortThroughputData struct iox::roudi::PortThroughputIntrospectionFieldTopic the topic for the port throughput that a user can subscribe to struct iox::roudi::SubscriberPortChangingData struct iox::roudi::SubscriberPortChangingIntrospectionFieldTopic struct iox::roudi::ProcessIntrospectionData struct iox::roudi::ProcessIntrospectionFieldTopic the topic for the process introspection that a user can subscribe to Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP #define IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/mepoo/mepoo_config.hpp\" namespace iox { namespace roudi { constexpr const char INTROSPECTION_SERVICE_ID [] = \"Introspection\" ; constexpr const char INTROSPECTION_APP_NAME [] = \"introspection\" ; constexpr const char INTROSPECTION_NODE_NAME [] = \"introspection\" ; const capro :: ServiceDescription IntrospectionMempoolService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"MemPool\" ); constexpr int MAX_GROUP_NAME_LENGTH = 32 ; struct MemPoolInfo { uint32_t m_usedChunks { 0 }; uint32_t m_minFreeChunks { 0 }; uint32_t m_numChunks { 0 }; uint32_t m_chunkSize { 0 }; uint32_t m_chunkPayloadSize { 0 }; }; using MemPoolInfoContainer = cxx :: vector < MemPoolInfo , MAX_NUMBER_OF_MEMPOOLS > ; struct MemPoolIntrospectionInfo { uint32_t m_id ; cxx :: string < MAX_GROUP_NAME_LENGTH > m_writerGroupName ; cxx :: string < MAX_GROUP_NAME_LENGTH > m_readerGroupName ; MemPoolInfoContainer m_mempoolInfo ; }; using MemPoolIntrospectionInfoContainer = cxx :: vector < MemPoolIntrospectionInfo , MAX_SHM_SEGMENTS + 1 > ; const capro :: ServiceDescription IntrospectionPortService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"Port\" ); struct PortData { RuntimeName_t m_name ; capro :: IdString_t m_caproInstanceID ; capro :: IdString_t m_caproServiceID ; capro :: IdString_t m_caproEventMethodID ; NodeName_t m_node ; }; using SubscriberPortData = PortData ; struct PublisherPortData : public PortData { uint64_t m_publisherPortID { 0 }; iox :: capro :: Interfaces m_sourceInterface { iox :: capro :: Interfaces :: INTERFACE_END }; }; struct PortIntrospectionFieldTopic { cxx :: vector < SubscriberPortData , MAX_SUBSCRIBERS > m_subscriberList ; cxx :: vector < PublisherPortData , MAX_PUBLISHERS > m_publisherList ; }; const capro :: ServiceDescription IntrospectionPortThroughputService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"PortThroughput\" ); struct PortThroughputData { uint64_t m_publisherPortID { 0 }; uint32_t m_sampleSize { 0 }; uint32_t m_chunkSize { 0 }; double m_chunksPerMinute { 0 }; uint64_t m_lastSendIntervalInNanoseconds { 0 }; bool m_isField { false }; }; struct PortThroughputIntrospectionFieldTopic { cxx :: vector < PortThroughputData , MAX_PUBLISHERS > m_throughputList ; }; const capro :: ServiceDescription IntrospectionSubscriberPortChangingDataService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"SubscriberPortsData\" ); struct SubscriberPortChangingData { // index used to identify subscriber is same as in PortIntrospectionFieldTopic->subscriberList uint64_t fifoSize { 0 }; uint64_t fifoCapacity { 0 }; iox :: SubscribeState subscriptionState { iox :: SubscribeState :: NOT_SUBSCRIBED }; capro :: Scope propagationScope { capro :: Scope :: INVALID }; }; struct SubscriberPortChangingIntrospectionFieldTopic { cxx :: vector < SubscriberPortChangingData , MAX_SUBSCRIBERS > subscriberPortChangingDataList ; }; const capro :: ServiceDescription IntrospectionProcessService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"Process\" ); struct ProcessIntrospectionData { int m_pid { 0 }; RuntimeName_t m_name ; cxx :: vector < NodeName_t , MAX_NODE_PER_PROCESS > m_nodes ; }; struct ProcessIntrospectionFieldTopic { cxx :: vector < ProcessIntrospectionData , MAX_PROCESS_NUMBER > m_processList ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/introspection_types.hpp"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#iceoryx_poshroudiintrospection_typeshpp","text":"","title":"iceoryx_posh/roudi/introspection_types.hpp"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#classes","text":"Name struct iox::roudi::MemPoolInfo struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools. struct iox::roudi::MemPoolIntrospectionInfo the topic for the mempool introspection that a user can subscribe to struct iox::roudi::PortData container for common port data which is related to the subscriber port as well as the publisher port struct iox::roudi::PublisherPortData container for publisher port introspection data. struct iox::roudi::PortIntrospectionFieldTopic the topic for the port introspection that a user can subscribe to struct iox::roudi::PortThroughputData struct iox::roudi::PortThroughputIntrospectionFieldTopic the topic for the port throughput that a user can subscribe to struct iox::roudi::SubscriberPortChangingData struct iox::roudi::SubscriberPortChangingIntrospectionFieldTopic struct iox::roudi::ProcessIntrospectionData struct iox::roudi::ProcessIntrospectionFieldTopic the topic for the process introspection that a user can subscribe to","title":"Classes"},{"location":"API-reference/posh/Files/introspection__types_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP #define IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/mepoo/mepoo_config.hpp\" namespace iox { namespace roudi { constexpr const char INTROSPECTION_SERVICE_ID [] = \"Introspection\" ; constexpr const char INTROSPECTION_APP_NAME [] = \"introspection\" ; constexpr const char INTROSPECTION_NODE_NAME [] = \"introspection\" ; const capro :: ServiceDescription IntrospectionMempoolService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"MemPool\" ); constexpr int MAX_GROUP_NAME_LENGTH = 32 ; struct MemPoolInfo { uint32_t m_usedChunks { 0 }; uint32_t m_minFreeChunks { 0 }; uint32_t m_numChunks { 0 }; uint32_t m_chunkSize { 0 }; uint32_t m_chunkPayloadSize { 0 }; }; using MemPoolInfoContainer = cxx :: vector < MemPoolInfo , MAX_NUMBER_OF_MEMPOOLS > ; struct MemPoolIntrospectionInfo { uint32_t m_id ; cxx :: string < MAX_GROUP_NAME_LENGTH > m_writerGroupName ; cxx :: string < MAX_GROUP_NAME_LENGTH > m_readerGroupName ; MemPoolInfoContainer m_mempoolInfo ; }; using MemPoolIntrospectionInfoContainer = cxx :: vector < MemPoolIntrospectionInfo , MAX_SHM_SEGMENTS + 1 > ; const capro :: ServiceDescription IntrospectionPortService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"Port\" ); struct PortData { RuntimeName_t m_name ; capro :: IdString_t m_caproInstanceID ; capro :: IdString_t m_caproServiceID ; capro :: IdString_t m_caproEventMethodID ; NodeName_t m_node ; }; using SubscriberPortData = PortData ; struct PublisherPortData : public PortData { uint64_t m_publisherPortID { 0 }; iox :: capro :: Interfaces m_sourceInterface { iox :: capro :: Interfaces :: INTERFACE_END }; }; struct PortIntrospectionFieldTopic { cxx :: vector < SubscriberPortData , MAX_SUBSCRIBERS > m_subscriberList ; cxx :: vector < PublisherPortData , MAX_PUBLISHERS > m_publisherList ; }; const capro :: ServiceDescription IntrospectionPortThroughputService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"PortThroughput\" ); struct PortThroughputData { uint64_t m_publisherPortID { 0 }; uint32_t m_sampleSize { 0 }; uint32_t m_chunkSize { 0 }; double m_chunksPerMinute { 0 }; uint64_t m_lastSendIntervalInNanoseconds { 0 }; bool m_isField { false }; }; struct PortThroughputIntrospectionFieldTopic { cxx :: vector < PortThroughputData , MAX_PUBLISHERS > m_throughputList ; }; const capro :: ServiceDescription IntrospectionSubscriberPortChangingDataService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"SubscriberPortsData\" ); struct SubscriberPortChangingData { // index used to identify subscriber is same as in PortIntrospectionFieldTopic->subscriberList uint64_t fifoSize { 0 }; uint64_t fifoCapacity { 0 }; iox :: SubscribeState subscriptionState { iox :: SubscribeState :: NOT_SUBSCRIBED }; capro :: Scope propagationScope { capro :: Scope :: INVALID }; }; struct SubscriberPortChangingIntrospectionFieldTopic { cxx :: vector < SubscriberPortChangingData , MAX_SUBSCRIBERS > subscriberPortChangingDataList ; }; const capro :: ServiceDescription IntrospectionProcessService ( INTROSPECTION_SERVICE_ID , \"RouDi_ID\" , \"Process\" ); struct ProcessIntrospectionData { int m_pid { 0 }; RuntimeName_t m_name ; cxx :: vector < NodeName_t , MAX_NODE_PER_PROCESS > m_nodes ; }; struct ProcessIntrospectionFieldTopic { cxx :: vector < ProcessIntrospectionData , MAX_PROCESS_NUMBER > m_processList ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_INTROSPECTION_TYPES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/listener_8hpp/","text":"iceoryx_posh/popo/listener.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo iox::popo::internal Classes \ud83d\udd17 Name class iox::popo::ListenerImpl The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. class iox::popo::Listener Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_LISTENER_HPP #define IOX_POSH_POPO_LISTENER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/internal/concurrent/loffli.hpp\" #include \"iceoryx_hoofs/internal/concurrent/smart_lock.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_listener.hpp\" #include \"iceoryx_posh/popo/enum_trigger_type.hpp\" #include \"iceoryx_posh/popo/notification_attorney.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" #include <thread> namespace iox { namespace popo { namespace internal { class Event_t { public : ~ Event_t () noexcept ; bool isEqualTo ( const void * const origin , const uint64_t eventType , const uint64_t eventTypeHash ) const noexcept ; bool reset () noexcept ; bool init ( const uint64_t eventId , void * const origin , void * const userType , const uint64_t eventType , const uint64_t eventTypeHash , internal :: GenericCallbackRef_t callback , internal :: TranslationCallbackRef_t translationCallback , const cxx :: MethodCallback < void , uint64_t > invalidationCallback ) noexcept ; void executeCallback () noexcept ; bool isInitialized () const noexcept ; private : static constexpr uint64_t INVALID_ID = std :: numeric_limits < uint64_t >:: max (); void * m_origin = nullptr ; uint64_t m_eventType = INVALID_ID ; uint64_t m_eventTypeHash = INVALID_ID ; internal :: GenericCallbackPtr_t m_callback = nullptr ; internal :: TranslationCallbackPtr_t m_translationCallback = nullptr ; void * m_userType = nullptr ; uint64_t m_eventId = INVALID_ID ; cxx :: MethodCallback < void , uint64_t > m_invalidationCallback ; }; } // namespace internal enum class ListenerError { LISTENER_FULL , EVENT_ALREADY_ATTACHED , EMPTY_EVENT_CALLBACK , EMPTY_INVALIDATION_CALLBACK }; template < uint64_t Capacity > class ListenerImpl { public : ListenerImpl () noexcept ; ListenerImpl ( const ListenerImpl & ) = delete ; ListenerImpl ( ListenerImpl && ) = delete ; ~ ListenerImpl () noexcept ; ListenerImpl & operator = ( const ListenerImpl & ) = delete ; ListenerImpl & operator = ( ListenerImpl && ) = delete ; template < typename T , typename EventType , typename ContextDataType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename ContextDataType > cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename EventType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> void detachEvent ( T & eventOrigin , const EventType eventType ) noexcept ; template < typename T > void detachEvent ( T & eventOrigin ) noexcept ; static constexpr uint64_t capacity () noexcept ; uint64_t size () const noexcept ; protected : ListenerImpl ( ConditionVariableData & conditionVariableData ) noexcept ; private : class Event_t ; void threadLoop () noexcept ; cxx :: expected < uint32_t , ListenerError > addEvent ( void * const origin , void * const userType , const uint64_t eventType , const uint64_t eventTypeHash , internal :: GenericCallbackRef_t callback , internal :: TranslationCallbackRef_t translationCallback , const cxx :: MethodCallback < void , uint64_t > invalidationCallback ) noexcept ; void removeTrigger ( const uint64_t index ) noexcept ; private : enum class NoEnumUsed : EventEnumIdentifier { PLACEHOLDER = 0 }; class IndexManager_t { public : IndexManager_t () noexcept ; bool pop ( uint32_t & index ) noexcept ; void push ( const uint32_t index ) noexcept ; uint64_t indicesInUse () const noexcept ; using LoFFLi = concurrent :: LoFFLi ; LoFFLi :: Index_t m_loffliStorage [ LoFFLi :: requiredIndexMemorySize ( Capacity ) / sizeof ( uint32_t )]; LoFFLi m_loffli ; std :: atomic < uint64_t > m_indicesInUse { 0U }; } m_indexManager ; std :: thread m_thread ; concurrent :: smart_lock < internal :: Event_t , std :: recursive_mutex > m_events [ Capacity ]; std :: mutex m_addEventMutex ; std :: atomic_bool m_wasDtorCalled { false }; ConditionVariableData * m_conditionVariableData = nullptr ; ConditionListener m_conditionListener ; }; class Listener : public ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > { public : using Parent = ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > ; Listener () noexcept ; protected : Listener ( ConditionVariableData & conditionVariableData ) noexcept ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/listener.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/listener.hpp"},{"location":"API-reference/posh/Files/listener_8hpp/#iceoryx_poshpopolistenerhpp","text":"","title":"iceoryx_posh/popo/listener.hpp"},{"location":"API-reference/posh/Files/listener_8hpp/#namespaces","text":"Name iox iox::popo iox::popo::internal","title":"Namespaces"},{"location":"API-reference/posh/Files/listener_8hpp/#classes","text":"Name class iox::popo::ListenerImpl The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. class iox::popo::Listener","title":"Classes"},{"location":"API-reference/posh/Files/listener_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_LISTENER_HPP #define IOX_POSH_POPO_LISTENER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/internal/concurrent/loffli.hpp\" #include \"iceoryx_hoofs/internal/concurrent/smart_lock.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_listener.hpp\" #include \"iceoryx_posh/popo/enum_trigger_type.hpp\" #include \"iceoryx_posh/popo/notification_attorney.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" #include <thread> namespace iox { namespace popo { namespace internal { class Event_t { public : ~ Event_t () noexcept ; bool isEqualTo ( const void * const origin , const uint64_t eventType , const uint64_t eventTypeHash ) const noexcept ; bool reset () noexcept ; bool init ( const uint64_t eventId , void * const origin , void * const userType , const uint64_t eventType , const uint64_t eventTypeHash , internal :: GenericCallbackRef_t callback , internal :: TranslationCallbackRef_t translationCallback , const cxx :: MethodCallback < void , uint64_t > invalidationCallback ) noexcept ; void executeCallback () noexcept ; bool isInitialized () const noexcept ; private : static constexpr uint64_t INVALID_ID = std :: numeric_limits < uint64_t >:: max (); void * m_origin = nullptr ; uint64_t m_eventType = INVALID_ID ; uint64_t m_eventTypeHash = INVALID_ID ; internal :: GenericCallbackPtr_t m_callback = nullptr ; internal :: TranslationCallbackPtr_t m_translationCallback = nullptr ; void * m_userType = nullptr ; uint64_t m_eventId = INVALID_ID ; cxx :: MethodCallback < void , uint64_t > m_invalidationCallback ; }; } // namespace internal enum class ListenerError { LISTENER_FULL , EVENT_ALREADY_ATTACHED , EMPTY_EVENT_CALLBACK , EMPTY_INVALIDATION_CALLBACK }; template < uint64_t Capacity > class ListenerImpl { public : ListenerImpl () noexcept ; ListenerImpl ( const ListenerImpl & ) = delete ; ListenerImpl ( ListenerImpl && ) = delete ; ~ ListenerImpl () noexcept ; ListenerImpl & operator = ( const ListenerImpl & ) = delete ; ListenerImpl & operator = ( ListenerImpl && ) = delete ; template < typename T , typename EventType , typename ContextDataType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename ContextDataType > cxx :: expected < ListenerError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename EventType , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> void detachEvent ( T & eventOrigin , const EventType eventType ) noexcept ; template < typename T > void detachEvent ( T & eventOrigin ) noexcept ; static constexpr uint64_t capacity () noexcept ; uint64_t size () const noexcept ; protected : ListenerImpl ( ConditionVariableData & conditionVariableData ) noexcept ; private : class Event_t ; void threadLoop () noexcept ; cxx :: expected < uint32_t , ListenerError > addEvent ( void * const origin , void * const userType , const uint64_t eventType , const uint64_t eventTypeHash , internal :: GenericCallbackRef_t callback , internal :: TranslationCallbackRef_t translationCallback , const cxx :: MethodCallback < void , uint64_t > invalidationCallback ) noexcept ; void removeTrigger ( const uint64_t index ) noexcept ; private : enum class NoEnumUsed : EventEnumIdentifier { PLACEHOLDER = 0 }; class IndexManager_t { public : IndexManager_t () noexcept ; bool pop ( uint32_t & index ) noexcept ; void push ( const uint32_t index ) noexcept ; uint64_t indicesInUse () const noexcept ; using LoFFLi = concurrent :: LoFFLi ; LoFFLi :: Index_t m_loffliStorage [ LoFFLi :: requiredIndexMemorySize ( Capacity ) / sizeof ( uint32_t )]; LoFFLi m_loffli ; std :: atomic < uint64_t > m_indicesInUse { 0U }; } m_indexManager ; std :: thread m_thread ; concurrent :: smart_lock < internal :: Event_t , std :: recursive_mutex > m_events [ Capacity ]; std :: mutex m_addEventMutex ; std :: atomic_bool m_wasDtorCalled { false }; ConditionVariableData * m_conditionVariableData = nullptr ; ConditionListener m_conditionListener ; }; class Listener : public ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > { public : using Parent = ListenerImpl < MAX_NUMBER_OF_EVENTS_PER_LISTENER > ; Listener () noexcept ; protected : Listener ( ConditionVariableData & conditionVariableData ) noexcept ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/listener.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/memory__block_8hpp/","text":"iceoryx_posh/roudi/memory/memory_block.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::MemoryBlock The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider , which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP #define IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryBlock { friend class MemoryProvider ; public : MemoryBlock () noexcept = default ; virtual ~ MemoryBlock () noexcept = default ; MemoryBlock ( const MemoryBlock & ) = delete ; MemoryBlock ( MemoryBlock && ) = delete ; MemoryBlock & operator = ( const MemoryBlock & ) = delete ; MemoryBlock & operator = ( MemoryBlock && ) = delete ; virtual uint64_t size () const noexcept = 0 ; virtual uint64_t alignment () const noexcept = 0 ; cxx :: optional < void *> memory () const noexcept ; protected : virtual void destroy () noexcept = 0 ; virtual void onMemoryAvailable ( cxx :: not_null < void *> memory ) noexcept ; private : void * m_memory { nullptr }; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/memory_block.hpp"},{"location":"API-reference/posh/Files/memory__block_8hpp/#iceoryx_poshroudimemorymemory_blockhpp","text":"","title":"iceoryx_posh/roudi/memory/memory_block.hpp"},{"location":"API-reference/posh/Files/memory__block_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/memory__block_8hpp/#classes","text":"Name class iox::roudi::MemoryBlock The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider , which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case.","title":"Classes"},{"location":"API-reference/posh/Files/memory__block_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP #define IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryBlock { friend class MemoryProvider ; public : MemoryBlock () noexcept = default ; virtual ~ MemoryBlock () noexcept = default ; MemoryBlock ( const MemoryBlock & ) = delete ; MemoryBlock ( MemoryBlock && ) = delete ; MemoryBlock & operator = ( const MemoryBlock & ) = delete ; MemoryBlock & operator = ( MemoryBlock && ) = delete ; virtual uint64_t size () const noexcept = 0 ; virtual uint64_t alignment () const noexcept = 0 ; cxx :: optional < void *> memory () const noexcept ; protected : virtual void destroy () noexcept = 0 ; virtual void onMemoryAvailable ( cxx :: not_null < void *> memory ) noexcept ; private : void * m_memory { nullptr }; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_MEMORY_BLOCK_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/memory__info_8hpp/","text":"iceoryx_posh/mepoo/memory_info.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::mepoo Classes \ud83d\udd17 Name struct iox::mepoo::MemoryInfo Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_MEMORY_INFO_HPP #define IOX_POSH_MEPOO_MEMORY_INFO_HPP #include <cstdint> namespace iox { namespace mepoo { struct MemoryInfo { static constexpr uint32_t DEFAULT_DEVICE_ID { 0U }; static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U }; // These are intentionally not defined as enum classes for flexibility and extendibility. // Currently only the defaults are used. // This will change when we support different devices (CPU, GPUs, ...) // and other properties that influence how memory is accessed. uint32_t deviceId { DEFAULT_DEVICE_ID }; uint32_t memoryType { DEFAULT_MEMORY_TYPE }; MemoryInfo ( const MemoryInfo & ) noexcept = default ; MemoryInfo ( MemoryInfo && ) noexcept = default ; MemoryInfo & operator = ( const MemoryInfo & ) noexcept = default ; MemoryInfo & operator = ( MemoryInfo && ) noexcept = default ; explicit MemoryInfo ( uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) noexcept ; bool operator == ( const MemoryInfo & rhs ) const noexcept ; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_MEMORY_INFO_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/mepoo/memory_info.hpp"},{"location":"API-reference/posh/Files/memory__info_8hpp/#iceoryx_poshmepoomemory_infohpp","text":"","title":"iceoryx_posh/mepoo/memory_info.hpp"},{"location":"API-reference/posh/Files/memory__info_8hpp/#namespaces","text":"Name iox iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/memory__info_8hpp/#classes","text":"Name struct iox::mepoo::MemoryInfo Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics.","title":"Classes"},{"location":"API-reference/posh/Files/memory__info_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_MEMORY_INFO_HPP #define IOX_POSH_MEPOO_MEMORY_INFO_HPP #include <cstdint> namespace iox { namespace mepoo { struct MemoryInfo { static constexpr uint32_t DEFAULT_DEVICE_ID { 0U }; static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U }; // These are intentionally not defined as enum classes for flexibility and extendibility. // Currently only the defaults are used. // This will change when we support different devices (CPU, GPUs, ...) // and other properties that influence how memory is accessed. uint32_t deviceId { DEFAULT_DEVICE_ID }; uint32_t memoryType { DEFAULT_MEMORY_TYPE }; MemoryInfo ( const MemoryInfo & ) noexcept = default ; MemoryInfo ( MemoryInfo && ) noexcept = default ; MemoryInfo & operator = ( const MemoryInfo & ) noexcept = default ; MemoryInfo & operator = ( MemoryInfo && ) noexcept = default ; explicit MemoryInfo ( uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) noexcept ; bool operator == ( const MemoryInfo & rhs ) const noexcept ; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_MEMORY_INFO_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/memory__provider_8hpp/","text":"iceoryx_posh/roudi/memory/memory_provider.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::MemoryProvider This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider . Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP #define IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryBlock ; enum class MemoryProviderError { MEMORY_BLOCKS_EXHAUSTED , NO_MEMORY_BLOCKS_PRESENT , MEMORY_ALREADY_CREATED , MEMORY_CREATION_FAILED , MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE , MEMORY_ALLOCATION_FAILED , MEMORY_MAPPING_FAILED , MEMORY_NOT_AVAILABLE , MEMORY_DESTRUCTION_FAILED , MEMORY_DEALLOCATION_FAILED , MEMORY_UNMAPPING_FAILED , SIGACTION_CALL_FAILED , }; class MemoryProvider { friend class RouDiMemoryManager ; public : MemoryProvider () noexcept = default ; virtual ~ MemoryProvider () noexcept ; MemoryProvider ( const MemoryProvider & ) = delete ; MemoryProvider ( MemoryProvider && ) = delete ; MemoryProvider & operator = ( const MemoryProvider & ) = delete ; MemoryProvider & operator = ( MemoryProvider && ) = delete ; cxx :: expected < MemoryProviderError > addMemoryBlock ( cxx :: not_null < MemoryBlock *> memoryBlock ) noexcept ; cxx :: expected < MemoryProviderError > create () noexcept ; void announceMemoryAvailable () noexcept ; cxx :: expected < MemoryProviderError > destroy () noexcept ; cxx :: optional < void *> baseAddress () const noexcept ; uint64_t size () const noexcept ; cxx :: optional < uint64_t > segmentId () const noexcept ; bool isAvailable () const noexcept ; bool isAvailableAnnounced () const noexcept ; protected : virtual cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) noexcept = 0 ; virtual cxx :: expected < MemoryProviderError > destroyMemory () noexcept = 0 ; static const char * getErrorString ( const MemoryProviderError error ) noexcept ; private : void * m_memory { nullptr }; uint64_t m_size { 0 }; uint64_t m_segmentId { 0 }; bool m_memoryAvailableAnnounced { false }; cxx :: vector < MemoryBlock * , MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER > m_memoryBlocks ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/memory_provider.hpp"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#iceoryx_poshroudimemorymemory_providerhpp","text":"","title":"iceoryx_posh/roudi/memory/memory_provider.hpp"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#classes","text":"Name class iox::roudi::MemoryProvider This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider .","title":"Classes"},{"location":"API-reference/posh/Files/memory__provider_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP #define IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryBlock ; enum class MemoryProviderError { MEMORY_BLOCKS_EXHAUSTED , NO_MEMORY_BLOCKS_PRESENT , MEMORY_ALREADY_CREATED , MEMORY_CREATION_FAILED , MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE , MEMORY_ALLOCATION_FAILED , MEMORY_MAPPING_FAILED , MEMORY_NOT_AVAILABLE , MEMORY_DESTRUCTION_FAILED , MEMORY_DEALLOCATION_FAILED , MEMORY_UNMAPPING_FAILED , SIGACTION_CALL_FAILED , }; class MemoryProvider { friend class RouDiMemoryManager ; public : MemoryProvider () noexcept = default ; virtual ~ MemoryProvider () noexcept ; MemoryProvider ( const MemoryProvider & ) = delete ; MemoryProvider ( MemoryProvider && ) = delete ; MemoryProvider & operator = ( const MemoryProvider & ) = delete ; MemoryProvider & operator = ( MemoryProvider && ) = delete ; cxx :: expected < MemoryProviderError > addMemoryBlock ( cxx :: not_null < MemoryBlock *> memoryBlock ) noexcept ; cxx :: expected < MemoryProviderError > create () noexcept ; void announceMemoryAvailable () noexcept ; cxx :: expected < MemoryProviderError > destroy () noexcept ; cxx :: optional < void *> baseAddress () const noexcept ; uint64_t size () const noexcept ; cxx :: optional < uint64_t > segmentId () const noexcept ; bool isAvailable () const noexcept ; bool isAvailableAnnounced () const noexcept ; protected : virtual cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) noexcept = 0 ; virtual cxx :: expected < MemoryProviderError > destroyMemory () noexcept = 0 ; static const char * getErrorString ( const MemoryProviderError error ) noexcept ; private : void * m_memory { nullptr }; uint64_t m_size { 0 }; uint64_t m_segmentId { 0 }; bool m_memoryAvailableAnnounced { false }; cxx :: vector < MemoryBlock * , MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER > m_memoryBlocks ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_MEMORY_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/","text":"iceoryx_posh/mepoo/mepoo_config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi iox::mepoo Classes \ud83d\udd17 Name struct iox::mepoo::MePooConfig struct iox::mepoo::MePooConfig::Entry Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_MEPOO_CONFIG_HPP #define IOX_POSH_MEPOO_MEPOO_CONFIG_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace roudi { class PortManager ; } namespace mepoo { struct MePooConfig { public : struct Entry { Entry ( uint32_t f_size , uint32_t f_chunkCount ) noexcept : m_size ( f_size ) , m_chunkCount ( f_chunkCount ) { } uint32_t m_size { 0 }; uint32_t m_chunkCount { 0 }; }; using MePooConfigContainerType = cxx :: vector < Entry , MAX_NUMBER_OF_MEMPOOLS > ; MePooConfigContainerType m_mempoolConfig ; MePooConfig () noexcept = default ; const MePooConfigContainerType * getMemPoolConfig () const noexcept ; void addMemPool ( Entry f_entry ) noexcept ; MePooConfig & setDefaults () noexcept ; MePooConfig & optimize () noexcept ; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_MEPOO_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/mepoo/mepoo_config.hpp"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#iceoryx_poshmepoomepoo_confighpp","text":"","title":"iceoryx_posh/mepoo/mepoo_config.hpp"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#namespaces","text":"Name iox iox::roudi iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#classes","text":"Name struct iox::mepoo::MePooConfig struct iox::mepoo::MePooConfig::Entry","title":"Classes"},{"location":"API-reference/posh/Files/mepoo__config_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_MEPOO_CONFIG_HPP #define IOX_POSH_MEPOO_MEPOO_CONFIG_HPP #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace roudi { class PortManager ; } namespace mepoo { struct MePooConfig { public : struct Entry { Entry ( uint32_t f_size , uint32_t f_chunkCount ) noexcept : m_size ( f_size ) , m_chunkCount ( f_chunkCount ) { } uint32_t m_size { 0 }; uint32_t m_chunkCount { 0 }; }; using MePooConfigContainerType = cxx :: vector < Entry , MAX_NUMBER_OF_MEMPOOLS > ; MePooConfigContainerType m_mempoolConfig ; MePooConfig () noexcept = default ; const MePooConfigContainerType * getMemPoolConfig () const noexcept ; void addMemPool ( Entry f_entry ) noexcept ; MePooConfig & setDefaults () noexcept ; MePooConfig & optimize () noexcept ; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_MEPOO_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/node_8hpp/","text":"iceoryx_posh/runtime/node.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::runtime Classes \ud83d\udd17 Name class iox::runtime::Node class which represents a node Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_NODE_HPP #define IOX_POSH_RUNTIME_NODE_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace runtime { class NodeData ; class Node { public : Node ( const NodeName_t & nodeName ) noexcept ; ~ Node () noexcept ; Node ( const Node & ) = delete ; Node & operator = ( const Node & ) = delete ; Node ( Node && rhs ) noexcept ; Node & operator = ( Node && rhs ) noexcept ; NodeName_t getNodeName () const noexcept ; RuntimeName_t getRuntimeName () const noexcept ; protected : Node ( NodeData * const data ) noexcept ; NodeData * m_data = nullptr ; }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_NODE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/runtime/node.hpp"},{"location":"API-reference/posh/Files/node_8hpp/#iceoryx_poshruntimenodehpp","text":"","title":"iceoryx_posh/runtime/node.hpp"},{"location":"API-reference/posh/Files/node_8hpp/#namespaces","text":"Name iox iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/node_8hpp/#classes","text":"Name class iox::runtime::Node class which represents a node","title":"Classes"},{"location":"API-reference/posh/Files/node_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_NODE_HPP #define IOX_POSH_RUNTIME_NODE_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace runtime { class NodeData ; class Node { public : Node ( const NodeName_t & nodeName ) noexcept ; ~ Node () noexcept ; Node ( const Node & ) = delete ; Node & operator = ( const Node & ) = delete ; Node ( Node && rhs ) noexcept ; Node & operator = ( Node && rhs ) noexcept ; NodeName_t getNodeName () const noexcept ; RuntimeName_t getRuntimeName () const noexcept ; protected : Node ( NodeData * const data ) noexcept ; NodeData * m_data = nullptr ; }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_NODE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/","text":"iceoryx_posh/popo/notification_attorney.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::NotificationAttorney Class which allows accessing private methods to friends of NotificationAttorney . Used for example by the WaitSet . Implements the Client-Attorney Pattern. Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_NOTIFICATION_ATTORNEY_HPP #define IOX_POSH_POPO_NOTIFICATION_ATTORNEY_HPP #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace popo { class NotificationAttorney { template < uint64_t > friend class WaitSet ; template < uint64_t > friend class ListenerImpl ; private : template < typename T , typename ... Targs > static void enableEvent ( T & eventOrigin , Targs && ... args ) noexcept ; template < typename T , typename ... Targs > static void disableEvent ( T & eventOrigin , Targs && ... args ) noexcept ; template < typename T , typename ... Targs > static void enableState ( T & stateOrigin , Targs && ... args ) noexcept ; template < typename T , typename ... Targs > static void disableState ( T & stateOrigin , Targs && ... args ) noexcept ; template < typename T > static cxx :: MethodCallback < void , uint64_t > getInvalidateTriggerMethod ( T & eventOrigin ) noexcept ; template < typename T , typename ... Targs > static WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( T & eventOrigin , Targs && ... args ) noexcept ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/notification_attorney.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/notification_attorney.hpp"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#iceoryx_poshpoponotification_attorneyhpp","text":"","title":"iceoryx_posh/popo/notification_attorney.hpp"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#classes","text":"Name class iox::popo::NotificationAttorney Class which allows accessing private methods to friends of NotificationAttorney . Used for example by the WaitSet . Implements the Client-Attorney Pattern.","title":"Classes"},{"location":"API-reference/posh/Files/notification__attorney_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_NOTIFICATION_ATTORNEY_HPP #define IOX_POSH_POPO_NOTIFICATION_ATTORNEY_HPP #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace popo { class NotificationAttorney { template < uint64_t > friend class WaitSet ; template < uint64_t > friend class ListenerImpl ; private : template < typename T , typename ... Targs > static void enableEvent ( T & eventOrigin , Targs && ... args ) noexcept ; template < typename T , typename ... Targs > static void disableEvent ( T & eventOrigin , Targs && ... args ) noexcept ; template < typename T , typename ... Targs > static void enableState ( T & stateOrigin , Targs && ... args ) noexcept ; template < typename T , typename ... Targs > static void disableState ( T & stateOrigin , Targs && ... args ) noexcept ; template < typename T > static cxx :: MethodCallback < void , uint64_t > getInvalidateTriggerMethod ( T & eventOrigin ) noexcept ; template < typename T , typename ... Targs > static WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( T & eventOrigin , Targs && ... args ) noexcept ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/notification_attorney.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/notification__callback_8hpp/","text":"iceoryx_posh/popo/notification_callback.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo iox::popo::internal Classes \ud83d\udd17 Name struct iox::popo::EventCallback struct iox::popo::NotificationCallback the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_EVENT_CALLBACK_HPP #define IOX_POSH_POPO_EVENT_CALLBACK_HPP #include \"iceoryx_hoofs/cxx/attributes.hpp\" namespace iox { namespace popo { template < typename OriginType , typename ContextDataType > struct EventCallback ; namespace internal { struct NoType_t { }; using GenericCallbackPtr_t = void ( * )(); using GenericCallbackRef_t = void ( & )(); using TranslationCallbackRef_t = void ( & )( void * const , void * const , GenericCallbackPtr_t const ); using TranslationCallbackPtr_t = void ( * )( void * const , void * const , GenericCallbackPtr_t const ); template < typename T , typename ContextDataType > struct TranslateAndCallTypelessCallback { static void call ( void * const origin , void * const userType , GenericCallbackPtr_t underlyingCallback ) noexcept ; }; template < typename T > struct TranslateAndCallTypelessCallback < T , NoType_t > { static void call ( void * const origin , void * const userType , GenericCallbackPtr_t underlyingCallback ) noexcept ; }; } // namespace internal template < typename OriginType , typename ContextDataType > struct NotificationCallback { using Ref_t = void ( & )( OriginType * const , ContextDataType * const ); using Ptr_t = void ( * )( OriginType * const , ContextDataType * const ); Ptr_t m_callback = nullptr ; ContextDataType * m_contextData = nullptr ; }; template < typename OriginType > struct NotificationCallback < OriginType , internal :: NoType_t > { using Ref_t = void ( & )( OriginType * const ); using Ptr_t = void ( * )( OriginType * const ); Ptr_t m_callback = nullptr ; internal :: NoType_t * m_contextData = nullptr ; }; template < typename OriginType , typename ContextDataType = internal :: NoType_t > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & callback )( OriginType * const )) noexcept ; template < typename OriginType , typename ContextDataType > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & callback )( OriginType * const , ContextDataType * const ), ContextDataType & userValue ) noexcept ; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/notification_callback.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/notification_callback.hpp"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#iceoryx_poshpoponotification_callbackhpp","text":"","title":"iceoryx_posh/popo/notification_callback.hpp"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#namespaces","text":"Name iox iox::popo iox::popo::internal","title":"Namespaces"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#classes","text":"Name struct iox::popo::EventCallback struct iox::popo::NotificationCallback the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener","title":"Classes"},{"location":"API-reference/posh/Files/notification__callback_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_EVENT_CALLBACK_HPP #define IOX_POSH_POPO_EVENT_CALLBACK_HPP #include \"iceoryx_hoofs/cxx/attributes.hpp\" namespace iox { namespace popo { template < typename OriginType , typename ContextDataType > struct EventCallback ; namespace internal { struct NoType_t { }; using GenericCallbackPtr_t = void ( * )(); using GenericCallbackRef_t = void ( & )(); using TranslationCallbackRef_t = void ( & )( void * const , void * const , GenericCallbackPtr_t const ); using TranslationCallbackPtr_t = void ( * )( void * const , void * const , GenericCallbackPtr_t const ); template < typename T , typename ContextDataType > struct TranslateAndCallTypelessCallback { static void call ( void * const origin , void * const userType , GenericCallbackPtr_t underlyingCallback ) noexcept ; }; template < typename T > struct TranslateAndCallTypelessCallback < T , NoType_t > { static void call ( void * const origin , void * const userType , GenericCallbackPtr_t underlyingCallback ) noexcept ; }; } // namespace internal template < typename OriginType , typename ContextDataType > struct NotificationCallback { using Ref_t = void ( & )( OriginType * const , ContextDataType * const ); using Ptr_t = void ( * )( OriginType * const , ContextDataType * const ); Ptr_t m_callback = nullptr ; ContextDataType * m_contextData = nullptr ; }; template < typename OriginType > struct NotificationCallback < OriginType , internal :: NoType_t > { using Ref_t = void ( & )( OriginType * const ); using Ptr_t = void ( * )( OriginType * const ); Ptr_t m_callback = nullptr ; internal :: NoType_t * m_contextData = nullptr ; }; template < typename OriginType , typename ContextDataType = internal :: NoType_t > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & callback )( OriginType * const )) noexcept ; template < typename OriginType , typename ContextDataType > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & callback )( OriginType * const , ContextDataType * const ), ContextDataType & userValue ) noexcept ; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/notification_callback.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/notification__info_8hpp/","text":"iceoryx_posh/popo/notification_info.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::NotificationInfo NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback. Source code \ud83d\udd17 // Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_NOTIFICATION_INFO_HPP #define IOX_POSH_POPO_NOTIFICATION_INFO_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/error_handling/error_handling.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include <cstdint> #include <limits> namespace iox { namespace popo { class NotificationInfo { public : static constexpr uint64_t INVALID_ID = std :: numeric_limits < uint64_t >:: max (); NotificationInfo () noexcept = default ; virtual ~ NotificationInfo () noexcept = default ; template < typename T , typename ContextDataType > NotificationInfo ( T * const notificationOrigin , const uint64_t notificationId , const NotificationCallback < T , ContextDataType >& callback ) noexcept ; uint64_t getNotificationId () const noexcept ; template < typename T > bool doesOriginateFrom ( T * const notificationOrigin ) const noexcept ; template < typename T > T * getOrigin () const noexcept ; bool operator ()() const noexcept ; friend class Trigger ; protected : void * m_notificationOrigin = nullptr ; void * m_userValue = nullptr ; uint64_t m_notificationOriginTypeHash = 0U ; uint64_t m_notificationId = INVALID_ID ; internal :: GenericCallbackPtr_t m_callbackPtr = nullptr ; internal :: TranslationCallbackPtr_t m_callback = nullptr ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/notification_info.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/notification_info.hpp"},{"location":"API-reference/posh/Files/notification__info_8hpp/#iceoryx_poshpoponotification_infohpp","text":"","title":"iceoryx_posh/popo/notification_info.hpp"},{"location":"API-reference/posh/Files/notification__info_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/notification__info_8hpp/#classes","text":"Name class iox::popo::NotificationInfo NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback.","title":"Classes"},{"location":"API-reference/posh/Files/notification__info_8hpp/#source-code","text":"// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_NOTIFICATION_INFO_HPP #define IOX_POSH_POPO_NOTIFICATION_INFO_HPP #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/error_handling/error_handling.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include <cstdint> #include <limits> namespace iox { namespace popo { class NotificationInfo { public : static constexpr uint64_t INVALID_ID = std :: numeric_limits < uint64_t >:: max (); NotificationInfo () noexcept = default ; virtual ~ NotificationInfo () noexcept = default ; template < typename T , typename ContextDataType > NotificationInfo ( T * const notificationOrigin , const uint64_t notificationId , const NotificationCallback < T , ContextDataType >& callback ) noexcept ; uint64_t getNotificationId () const noexcept ; template < typename T > bool doesOriginateFrom ( T * const notificationOrigin ) const noexcept ; template < typename T > T * getOrigin () const noexcept ; bool operator ()() const noexcept ; friend class Trigger ; protected : void * m_notificationOrigin = nullptr ; void * m_userValue = nullptr ; uint64_t m_notificationOriginTypeHash = 0U ; uint64_t m_notificationId = INVALID_ID ; internal :: GenericCallbackPtr_t m_callbackPtr = nullptr ; internal :: TranslationCallbackPtr_t m_callback = nullptr ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/notification_info.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/port__config__info_8hpp/","text":"iceoryx_posh/runtime/port_config_info.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::runtime Classes \ud83d\udd17 Name struct iox::runtime::PortConfigInfo Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU). Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP #define IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include \"iceoryx_posh/mepoo/memory_info.hpp\" #include <cstdint> namespace iox { namespace runtime { struct PortConfigInfo { static constexpr uint32_t DEFAULT_PORT_TYPE { 0U }; static constexpr uint32_t DEFAULT_DEVICE_ID { 0U }; static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U }; // these are intentionally not defined as enum classes for flexibility and extendibility // with specific user defined codes used by custom ports // values will be resolved at lower level, (i.e. in the port creation factory) uint32_t portType { DEFAULT_PORT_TYPE }; iox :: mepoo :: MemoryInfo memoryInfo ; PortConfigInfo ( const PortConfigInfo & ) noexcept = default ; PortConfigInfo ( PortConfigInfo && ) noexcept = default ; PortConfigInfo & operator = ( const PortConfigInfo & ) noexcept = default ; PortConfigInfo & operator = ( PortConfigInfo && ) noexcept = default ; PortConfigInfo ( uint32_t portType = DEFAULT_PORT_TYPE , uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) noexcept ; PortConfigInfo ( const cxx :: Serialization & serialization ) noexcept ; operator cxx :: Serialization () const noexcept ; bool operator == ( const PortConfigInfo & rhs ) const noexcept ; }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/runtime/port_config_info.hpp"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#iceoryx_poshruntimeport_config_infohpp","text":"","title":"iceoryx_posh/runtime/port_config_info.hpp"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#namespaces","text":"Name iox iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#classes","text":"Name struct iox::runtime::PortConfigInfo Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU).","title":"Classes"},{"location":"API-reference/posh/Files/port__config__info_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP #define IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include \"iceoryx_posh/mepoo/memory_info.hpp\" #include <cstdint> namespace iox { namespace runtime { struct PortConfigInfo { static constexpr uint32_t DEFAULT_PORT_TYPE { 0U }; static constexpr uint32_t DEFAULT_DEVICE_ID { 0U }; static constexpr uint32_t DEFAULT_MEMORY_TYPE { 0U }; // these are intentionally not defined as enum classes for flexibility and extendibility // with specific user defined codes used by custom ports // values will be resolved at lower level, (i.e. in the port creation factory) uint32_t portType { DEFAULT_PORT_TYPE }; iox :: mepoo :: MemoryInfo memoryInfo ; PortConfigInfo ( const PortConfigInfo & ) noexcept = default ; PortConfigInfo ( PortConfigInfo && ) noexcept = default ; PortConfigInfo & operator = ( const PortConfigInfo & ) noexcept = default ; PortConfigInfo & operator = ( PortConfigInfo && ) noexcept = default ; PortConfigInfo ( uint32_t portType = DEFAULT_PORT_TYPE , uint32_t deviceId = DEFAULT_DEVICE_ID , uint32_t memoryType = DEFAULT_MEMORY_TYPE ) noexcept ; PortConfigInfo ( const cxx :: Serialization & serialization ) noexcept ; operator cxx :: Serialization () const noexcept ; bool operator == ( const PortConfigInfo & rhs ) const noexcept ; }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_PORT_CONFIG_INFO_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/port__pool_8hpp/","text":"iceoryx_posh/roudi/port_pool.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::PortPool Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_PORT_POOL_HPP #define IOX_POSH_ROUDI_PORT_POOL_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_roudi.hpp\" #include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_roudi.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_roudi.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_multi_producer.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_single_producer.hpp\" #include \"iceoryx_posh/internal/roudi/port_pool_data.hpp\" #include \"iceoryx_posh/internal/runtime/node_data.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/publisher_options.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/subscriber_options.hpp\" namespace iox { namespace roudi { struct PortPoolDataBase ; enum class PortPoolError : uint8_t { UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS , INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN , PUBLISHER_PORT_LIST_FULL , SUBSCRIBER_PORT_LIST_FULL , INTERFACE_PORT_LIST_FULL , CLIENT_PORT_LIST_FULL , UNIQUE_SERVER_PORT_ALREADY_EXISTS , SERVER_PORT_LIST_FULL , NODE_DATA_LIST_FULL , CONDITION_VARIABLE_LIST_FULL , EVENT_VARIABLE_LIST_FULL , }; class PortPool { public : PortPool ( PortPoolData & portPoolData ) noexcept ; virtual ~ PortPool () noexcept = default ; cxx :: vector < PublisherPortRouDiType :: MemberType_t * , MAX_PUBLISHERS > getPublisherPortDataList () noexcept ; cxx :: vector < SubscriberPortType :: MemberType_t * , MAX_SUBSCRIBERS > getSubscriberPortDataList () noexcept ; cxx :: vector < popo :: ClientPortData * , MAX_CLIENTS > getClientPortDataList () noexcept ; cxx :: vector < popo :: ServerPortData * , MAX_SERVERS > getServerPortDataList () noexcept ; cxx :: vector < popo :: InterfacePortData * , MAX_INTERFACE_NUMBER > getInterfacePortDataList () noexcept ; cxx :: vector < runtime :: NodeData * , MAX_NODE_NUMBER > getNodeDataList () noexcept ; cxx :: vector < popo :: ConditionVariableData * , MAX_NUMBER_OF_CONDITION_VARIABLES > getConditionVariableDataList () noexcept ; cxx :: expected < PublisherPortRouDiType :: MemberType_t * , PortPoolError > addPublisherPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: PublisherOptions & publisherOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; cxx :: expected < SubscriberPortType :: MemberType_t * , PortPoolError > addSubscriberPort ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: ManyToManyPolicy >:: value >* = nullptr > iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept ; template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: OneToManyPolicy >:: value >* = nullptr > iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept ; cxx :: expected < popo :: ClientPortData * , PortPoolError > addClientPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ClientOptions & clientOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; cxx :: expected < popo :: ServerPortData * , PortPoolError > addServerPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ServerOptions & serverOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; cxx :: expected < popo :: InterfacePortData * , PortPoolError > addInterfacePort ( const RuntimeName_t & runtimeName , const capro :: Interfaces interface ) noexcept ; cxx :: expected < runtime :: NodeData * , PortPoolError > addNodeData ( const RuntimeName_t & runtimeName , const NodeName_t & nodeName , const uint64_t nodeDeviceIdentifier ) noexcept ; cxx :: expected < popo :: ConditionVariableData * , PortPoolError > addConditionVariableData ( const RuntimeName_t & runtimeName ) noexcept ; void removePublisherPort ( const PublisherPortRouDiType :: MemberType_t * const portData ) noexcept ; void removeSubscriberPort ( const SubscriberPortType :: MemberType_t * const portData ) noexcept ; void removeClientPort ( const popo :: ClientPortData * const portData ) noexcept ; void removeServerPort ( const popo :: ServerPortData * const portData ) noexcept ; void removeInterfacePort ( const popo :: InterfacePortData * const portData ) noexcept ; void removeNodeData ( const runtime :: NodeData * const nodeData ) noexcept ; void removeConditionVariableData ( const popo :: ConditionVariableData * const conditionVariableData ) noexcept ; private : PortPoolData * m_portPoolData ; }; } // namespace roudi } // namespace iox #include \"iceoryx_posh/roudi/port_pool.inl\" #endif // IOX_POSH_ROUDI_PORT_POOL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/port_pool.hpp"},{"location":"API-reference/posh/Files/port__pool_8hpp/#iceoryx_poshroudiport_poolhpp","text":"","title":"iceoryx_posh/roudi/port_pool.hpp"},{"location":"API-reference/posh/Files/port__pool_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/port__pool_8hpp/#classes","text":"Name class iox::roudi::PortPool","title":"Classes"},{"location":"API-reference/posh/Files/port__pool_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_PORT_POOL_HPP #define IOX_POSH_ROUDI_PORT_POOL_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_roudi.hpp\" #include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_roudi.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_roudi.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_multi_producer.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_single_producer.hpp\" #include \"iceoryx_posh/internal/roudi/port_pool_data.hpp\" #include \"iceoryx_posh/internal/runtime/node_data.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/publisher_options.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/subscriber_options.hpp\" namespace iox { namespace roudi { struct PortPoolDataBase ; enum class PortPoolError : uint8_t { UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS , INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN , PUBLISHER_PORT_LIST_FULL , SUBSCRIBER_PORT_LIST_FULL , INTERFACE_PORT_LIST_FULL , CLIENT_PORT_LIST_FULL , UNIQUE_SERVER_PORT_ALREADY_EXISTS , SERVER_PORT_LIST_FULL , NODE_DATA_LIST_FULL , CONDITION_VARIABLE_LIST_FULL , EVENT_VARIABLE_LIST_FULL , }; class PortPool { public : PortPool ( PortPoolData & portPoolData ) noexcept ; virtual ~ PortPool () noexcept = default ; cxx :: vector < PublisherPortRouDiType :: MemberType_t * , MAX_PUBLISHERS > getPublisherPortDataList () noexcept ; cxx :: vector < SubscriberPortType :: MemberType_t * , MAX_SUBSCRIBERS > getSubscriberPortDataList () noexcept ; cxx :: vector < popo :: ClientPortData * , MAX_CLIENTS > getClientPortDataList () noexcept ; cxx :: vector < popo :: ServerPortData * , MAX_SERVERS > getServerPortDataList () noexcept ; cxx :: vector < popo :: InterfacePortData * , MAX_INTERFACE_NUMBER > getInterfacePortDataList () noexcept ; cxx :: vector < runtime :: NodeData * , MAX_NODE_NUMBER > getNodeDataList () noexcept ; cxx :: vector < popo :: ConditionVariableData * , MAX_NUMBER_OF_CONDITION_VARIABLES > getConditionVariableDataList () noexcept ; cxx :: expected < PublisherPortRouDiType :: MemberType_t * , PortPoolError > addPublisherPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: PublisherOptions & publisherOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; cxx :: expected < SubscriberPortType :: MemberType_t * , PortPoolError > addSubscriberPort ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: ManyToManyPolicy >:: value >* = nullptr > iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept ; template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: OneToManyPolicy >:: value >* = nullptr > iox :: popo :: SubscriberPortData * constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept ; cxx :: expected < popo :: ClientPortData * , PortPoolError > addClientPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ClientOptions & clientOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; cxx :: expected < popo :: ServerPortData * , PortPoolError > addServerPort ( const capro :: ServiceDescription & serviceDescription , mepoo :: MemoryManager * const memoryManager , const RuntimeName_t & runtimeName , const popo :: ServerOptions & serverOptions , const mepoo :: MemoryInfo & memoryInfo = mepoo :: MemoryInfo ()) noexcept ; cxx :: expected < popo :: InterfacePortData * , PortPoolError > addInterfacePort ( const RuntimeName_t & runtimeName , const capro :: Interfaces interface ) noexcept ; cxx :: expected < runtime :: NodeData * , PortPoolError > addNodeData ( const RuntimeName_t & runtimeName , const NodeName_t & nodeName , const uint64_t nodeDeviceIdentifier ) noexcept ; cxx :: expected < popo :: ConditionVariableData * , PortPoolError > addConditionVariableData ( const RuntimeName_t & runtimeName ) noexcept ; void removePublisherPort ( const PublisherPortRouDiType :: MemberType_t * const portData ) noexcept ; void removeSubscriberPort ( const SubscriberPortType :: MemberType_t * const portData ) noexcept ; void removeClientPort ( const popo :: ClientPortData * const portData ) noexcept ; void removeServerPort ( const popo :: ServerPortData * const portData ) noexcept ; void removeInterfacePort ( const popo :: InterfacePortData * const portData ) noexcept ; void removeNodeData ( const runtime :: NodeData * const nodeData ) noexcept ; void removeConditionVariableData ( const popo :: ConditionVariableData * const conditionVariableData ) noexcept ; private : PortPoolData * m_portPoolData ; }; } // namespace roudi } // namespace iox #include \"iceoryx_posh/roudi/port_pool.inl\" #endif // IOX_POSH_ROUDI_PORT_POOL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/port__pool_8inl/","text":"iceoryx_posh/roudi/port_pool.inl \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Defines \ud83d\udd17 Name IOX_POSH_ROUDI_PORT_POOL_INL Macro Documentation \ud83d\udd17 define IOX_POSH_ROUDI_PORT_POOL_INL \ud83d\udd17 #define IOX_POSH_ROUDI_PORT_POOL_INL Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_PORT_POOL_INL #define IOX_POSH_ROUDI_PORT_POOL_INL namespace iox { namespace roudi { template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: ManyToManyPolicy >:: value >*> inline iox :: popo :: SubscriberPortData * PortPool :: constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept { return m_portPoolData -> m_subscriberPortMembers . insert ( serviceDescription , runtimeName , ( subscriberOptions . queueFullPolicy == popo :: QueueFullPolicy :: DISCARD_OLDEST_DATA ) ? cxx :: VariantQueueTypes :: SoFi_MultiProducerSingleConsumer : cxx :: VariantQueueTypes :: FiFo_MultiProducerSingleConsumer , subscriberOptions , memoryInfo ); } template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: OneToManyPolicy >:: value >*> inline iox :: popo :: SubscriberPortData * PortPool :: constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept { return m_portPoolData -> m_subscriberPortMembers . insert ( serviceDescription , runtimeName , ( subscriberOptions . queueFullPolicy == popo :: QueueFullPolicy :: DISCARD_OLDEST_DATA ) ? cxx :: VariantQueueTypes :: SoFi_SingleProducerSingleConsumer : cxx :: VariantQueueTypes :: FiFo_SingleProducerSingleConsumer , subscriberOptions , memoryInfo ); } } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_PORT_POOL_INL Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/port_pool.inl"},{"location":"API-reference/posh/Files/port__pool_8inl/#iceoryx_poshroudiport_poolinl","text":"","title":"iceoryx_posh/roudi/port_pool.inl"},{"location":"API-reference/posh/Files/port__pool_8inl/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/port__pool_8inl/#defines","text":"Name IOX_POSH_ROUDI_PORT_POOL_INL","title":"Defines"},{"location":"API-reference/posh/Files/port__pool_8inl/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"API-reference/posh/Files/port__pool_8inl/#define-iox_posh_roudi_port_pool_inl","text":"#define IOX_POSH_ROUDI_PORT_POOL_INL","title":"define IOX_POSH_ROUDI_PORT_POOL_INL"},{"location":"API-reference/posh/Files/port__pool_8inl/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_PORT_POOL_INL #define IOX_POSH_ROUDI_PORT_POOL_INL namespace iox { namespace roudi { template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: ManyToManyPolicy >:: value >*> inline iox :: popo :: SubscriberPortData * PortPool :: constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept { return m_portPoolData -> m_subscriberPortMembers . insert ( serviceDescription , runtimeName , ( subscriberOptions . queueFullPolicy == popo :: QueueFullPolicy :: DISCARD_OLDEST_DATA ) ? cxx :: VariantQueueTypes :: SoFi_MultiProducerSingleConsumer : cxx :: VariantQueueTypes :: FiFo_MultiProducerSingleConsumer , subscriberOptions , memoryInfo ); } template < typename T , std :: enable_if_t < std :: is_same < T , iox :: build :: OneToManyPolicy >:: value >*> inline iox :: popo :: SubscriberPortData * PortPool :: constructSubscriber ( const capro :: ServiceDescription & serviceDescription , const RuntimeName_t & runtimeName , const popo :: SubscriberOptions & subscriberOptions , const mepoo :: MemoryInfo & memoryInfo ) noexcept { return m_portPoolData -> m_subscriberPortMembers . insert ( serviceDescription , runtimeName , ( subscriberOptions . queueFullPolicy == popo :: QueueFullPolicy :: DISCARD_OLDEST_DATA ) ? cxx :: VariantQueueTypes :: SoFi_SingleProducerSingleConsumer : cxx :: VariantQueueTypes :: FiFo_SingleProducerSingleConsumer , subscriberOptions , memoryInfo ); } } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_PORT_POOL_INL Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/","text":"iceoryx_posh/popo/port_queue_policies.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Source code \ud83d\udd17 // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP #define IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP #include <cstdint> namespace iox { namespace popo { enum class ConsumerTooSlowPolicy : uint8_t { WAIT_FOR_CONSUMER , DISCARD_OLDEST_DATA }; enum class QueueFullPolicy : uint8_t { BLOCK_PRODUCER , DISCARD_OLDEST_DATA }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/port_queue_policies.hpp"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/#iceoryx_poshpopoport_queue_policieshpp","text":"","title":"iceoryx_posh/popo/port_queue_policies.hpp"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/port__queue__policies_8hpp/#source-code","text":"// Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP #define IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP #include <cstdint> namespace iox { namespace popo { enum class ConsumerTooSlowPolicy : uint8_t { WAIT_FOR_CONSUMER , DISCARD_OLDEST_DATA }; enum class QueueFullPolicy : uint8_t { BLOCK_PRODUCER , DISCARD_OLDEST_DATA }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_PORT_QUEUE_POLICIES_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/","text":"iceoryx_posh/runtime/posh_runtime.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi iox::runtime Classes \ud83d\udd17 Name class iox::runtime::PoshRuntime The runtime that is needed for each application to communicate with the RouDi daemon. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_POSH_RUNTIME_HPP #define IOX_POSH_RUNTIME_POSH_RUNTIME_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\" #include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_user.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_user.hpp\" #include \"iceoryx_posh/internal/runtime/ipc_runtime_interface.hpp\" #include \"iceoryx_posh/internal/runtime/node_property.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/subscriber_options.hpp\" #include \"iceoryx_posh/runtime/port_config_info.hpp\" #include <atomic> namespace iox { namespace roudi { class RuntimeTestInterface ; } // namespace roudi namespace runtime { class Node ; class NodeData ; class PoshRuntime { public : PoshRuntime ( const PoshRuntime & ) = delete ; PoshRuntime & operator = ( const PoshRuntime & ) = delete ; PoshRuntime ( PoshRuntime && ) = delete ; PoshRuntime & operator = ( PoshRuntime && ) = delete ; virtual ~ PoshRuntime () noexcept = default ; static PoshRuntime & getInstance () noexcept ; static PoshRuntime & initRuntime ( const RuntimeName_t & name ) noexcept ; RuntimeName_t getInstanceName () const noexcept ; void shutdown () noexcept ; virtual PublisherPortUserType :: MemberType_t * getMiddlewarePublisher ( const capro :: ServiceDescription & service , const popo :: PublisherOptions & publisherOptions = {}, const PortConfigInfo & portConfigInfo = {}) noexcept = 0 ; virtual SubscriberPortUserType :: MemberType_t * getMiddlewareSubscriber ( const capro :: ServiceDescription & service , const popo :: SubscriberOptions & subscriberOptions = {}, const PortConfigInfo & portConfigInfo = {}) noexcept = 0 ; virtual popo :: ClientPortData * getMiddlewareClient ( const capro :: ServiceDescription & service , const popo :: ClientOptions & clientOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) noexcept = 0 ; virtual popo :: ServerPortData * getMiddlewareServer ( const capro :: ServiceDescription & service , const popo :: ServerOptions & serverOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) noexcept = 0 ; virtual popo :: InterfacePortData * getMiddlewareInterface ( const capro :: Interfaces interface , const NodeName_t & nodeName = {}) noexcept = 0 ; virtual popo :: ConditionVariableData * getMiddlewareConditionVariable () noexcept = 0 ; virtual NodeData * createNode ( const NodeProperty & nodeProperty ) noexcept = 0 ; virtual bool sendRequestToRouDi ( const IpcMessage & msg , IpcMessage & answer ) noexcept = 0 ; protected : friend class roudi :: RuntimeTestInterface ; using factory_t = PoshRuntime & ( * )( cxx :: optional < const RuntimeName_t *> ); // Protected constructor for derived classes PoshRuntime ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; static PoshRuntime & defaultRuntimeFactory ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; static factory_t & getRuntimeFactory () noexcept ; static void setRuntimeFactory ( const factory_t & factory ) noexcept ; static PoshRuntime & getInstance ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; const RuntimeName_t & verifyInstanceName ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; const RuntimeName_t m_appName ; std :: atomic < bool > m_shutdownRequested { false }; }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_POSH_RUNTIME_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/runtime/posh_runtime.hpp"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#iceoryx_poshruntimeposh_runtimehpp","text":"","title":"iceoryx_posh/runtime/posh_runtime.hpp"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#namespaces","text":"Name iox iox::roudi iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#classes","text":"Name class iox::runtime::PoshRuntime The runtime that is needed for each application to communicate with the RouDi daemon.","title":"Classes"},{"location":"API-reference/posh/Files/posh__runtime_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_POSH_RUNTIME_HPP #define IOX_POSH_RUNTIME_POSH_RUNTIME_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\" #include \"iceoryx_posh/internal/popo/ports/interface_port.hpp\" #include \"iceoryx_posh/internal/popo/ports/publisher_port_user.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\" #include \"iceoryx_posh/internal/popo/ports/subscriber_port_user.hpp\" #include \"iceoryx_posh/internal/runtime/ipc_runtime_interface.hpp\" #include \"iceoryx_posh/internal/runtime/node_property.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/subscriber_options.hpp\" #include \"iceoryx_posh/runtime/port_config_info.hpp\" #include <atomic> namespace iox { namespace roudi { class RuntimeTestInterface ; } // namespace roudi namespace runtime { class Node ; class NodeData ; class PoshRuntime { public : PoshRuntime ( const PoshRuntime & ) = delete ; PoshRuntime & operator = ( const PoshRuntime & ) = delete ; PoshRuntime ( PoshRuntime && ) = delete ; PoshRuntime & operator = ( PoshRuntime && ) = delete ; virtual ~ PoshRuntime () noexcept = default ; static PoshRuntime & getInstance () noexcept ; static PoshRuntime & initRuntime ( const RuntimeName_t & name ) noexcept ; RuntimeName_t getInstanceName () const noexcept ; void shutdown () noexcept ; virtual PublisherPortUserType :: MemberType_t * getMiddlewarePublisher ( const capro :: ServiceDescription & service , const popo :: PublisherOptions & publisherOptions = {}, const PortConfigInfo & portConfigInfo = {}) noexcept = 0 ; virtual SubscriberPortUserType :: MemberType_t * getMiddlewareSubscriber ( const capro :: ServiceDescription & service , const popo :: SubscriberOptions & subscriberOptions = {}, const PortConfigInfo & portConfigInfo = {}) noexcept = 0 ; virtual popo :: ClientPortData * getMiddlewareClient ( const capro :: ServiceDescription & service , const popo :: ClientOptions & clientOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) noexcept = 0 ; virtual popo :: ServerPortData * getMiddlewareServer ( const capro :: ServiceDescription & service , const popo :: ServerOptions & serverOptions = {}, const PortConfigInfo & portConfigInfo = PortConfigInfo ()) noexcept = 0 ; virtual popo :: InterfacePortData * getMiddlewareInterface ( const capro :: Interfaces interface , const NodeName_t & nodeName = {}) noexcept = 0 ; virtual popo :: ConditionVariableData * getMiddlewareConditionVariable () noexcept = 0 ; virtual NodeData * createNode ( const NodeProperty & nodeProperty ) noexcept = 0 ; virtual bool sendRequestToRouDi ( const IpcMessage & msg , IpcMessage & answer ) noexcept = 0 ; protected : friend class roudi :: RuntimeTestInterface ; using factory_t = PoshRuntime & ( * )( cxx :: optional < const RuntimeName_t *> ); // Protected constructor for derived classes PoshRuntime ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; static PoshRuntime & defaultRuntimeFactory ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; static factory_t & getRuntimeFactory () noexcept ; static void setRuntimeFactory ( const factory_t & factory ) noexcept ; static PoshRuntime & getInstance ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; const RuntimeName_t & verifyInstanceName ( cxx :: optional < const RuntimeName_t *> name ) noexcept ; const RuntimeName_t m_appName ; std :: atomic < bool > m_shutdownRequested { false }; }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_POSH_RUNTIME_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/","text":"iceoryx_posh/runtime/posh_runtime_single_process.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::runtime Classes \ud83d\udd17 Name class iox::runtime::PoshRuntimeSingleProcess Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_POSH_RUNTIME_SINGLE_PROCESS_HPP #define IOX_POSH_RUNTIME_POSH_RUNTIME_SINGLE_PROCESS_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/runtime/posh_runtime_impl.hpp\" namespace iox { namespace runtime { class PoshRuntimeSingleProcess : public PoshRuntimeImpl { public : PoshRuntimeSingleProcess ( const RuntimeName_t & name ) noexcept ; ~ PoshRuntimeSingleProcess (); }; } // namespace runtime } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/runtime/posh_runtime_single_process.hpp"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#iceoryx_poshruntimeposh_runtime_single_processhpp","text":"","title":"iceoryx_posh/runtime/posh_runtime_single_process.hpp"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#namespaces","text":"Name iox iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#classes","text":"Name class iox::runtime::PoshRuntimeSingleProcess","title":"Classes"},{"location":"API-reference/posh/Files/posh__runtime__single__process_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_POSH_RUNTIME_SINGLE_PROCESS_HPP #define IOX_POSH_RUNTIME_POSH_RUNTIME_SINGLE_PROCESS_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/runtime/posh_runtime_impl.hpp\" namespace iox { namespace runtime { class PoshRuntimeSingleProcess : public PoshRuntimeImpl { public : PoshRuntimeSingleProcess ( const RuntimeName_t & name ) noexcept ; ~ PoshRuntimeSingleProcess (); }; } // namespace runtime } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/","text":"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::PosixShmMemoryProvider Creates the shared memory based on a provided configuration. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP #define IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP #include \"iceoryx_posh/roudi/memory/memory_provider.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/shared_memory_object.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace roudi { class PosixShmMemoryProvider : public MemoryProvider { public : PosixShmMemoryProvider ( const ShmName_t & shmName , const posix :: AccessMode accessMode , const posix :: OpenMode openMode ) noexcept ; ~ PosixShmMemoryProvider () noexcept ; PosixShmMemoryProvider ( PosixShmMemoryProvider && ) = delete ; PosixShmMemoryProvider & operator = ( PosixShmMemoryProvider && ) = delete ; PosixShmMemoryProvider ( const PosixShmMemoryProvider & ) = delete ; PosixShmMemoryProvider & operator = ( const PosixShmMemoryProvider & ) = delete ; protected : cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) noexcept ; cxx :: expected < MemoryProviderError > destroyMemory () noexcept ; private : ShmName_t m_shmName ; posix :: AccessMode m_accessMode { posix :: AccessMode :: READ_ONLY }; posix :: OpenMode m_openMode { posix :: OpenMode :: OPEN_EXISTING }; cxx :: optional < posix :: SharedMemoryObject > m_shmObject ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#iceoryx_poshroudimemoryposix_shm_memory_providerhpp","text":"","title":"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#classes","text":"Name class iox::roudi::PosixShmMemoryProvider Creates the shared memory based on a provided configuration.","title":"Classes"},{"location":"API-reference/posh/Files/posix__shm__memory__provider_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP #define IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP #include \"iceoryx_posh/roudi/memory/memory_provider.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/internal/posix_wrapper/shared_memory_object.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace roudi { class PosixShmMemoryProvider : public MemoryProvider { public : PosixShmMemoryProvider ( const ShmName_t & shmName , const posix :: AccessMode accessMode , const posix :: OpenMode openMode ) noexcept ; ~ PosixShmMemoryProvider () noexcept ; PosixShmMemoryProvider ( PosixShmMemoryProvider && ) = delete ; PosixShmMemoryProvider & operator = ( PosixShmMemoryProvider && ) = delete ; PosixShmMemoryProvider ( const PosixShmMemoryProvider & ) = delete ; PosixShmMemoryProvider & operator = ( const PosixShmMemoryProvider & ) = delete ; protected : cxx :: expected < void * , MemoryProviderError > createMemory ( const uint64_t size , const uint64_t alignment ) noexcept ; cxx :: expected < MemoryProviderError > destroyMemory () noexcept ; private : ShmName_t m_shmName ; posix :: AccessMode m_accessMode { posix :: AccessMode :: READ_ONLY }; posix :: OpenMode m_openMode { posix :: OpenMode :: OPEN_EXISTING }; cxx :: optional < posix :: SharedMemoryObject > m_shmObject ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_POSIX_SHM_MEMORY_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/publisher_8hpp/","text":"iceoryx_posh/popo/publisher.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::Publisher The Publisher class for the publish-subscribe messaging pattern in iceoryx. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_PUBLISHER_HPP #define IOX_POSH_POPO_TYPED_PUBLISHER_HPP #include \"iceoryx_posh/internal/popo/publisher_impl.hpp\" namespace iox { namespace popo { template < typename T , typename H = mepoo :: NoUserHeader > class Publisher : public PublisherImpl < T , H > { public : using PublisherImpl < T , H >:: PublisherImpl ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_TYPED_PUBLISHER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/publisher.hpp"},{"location":"API-reference/posh/Files/publisher_8hpp/#iceoryx_poshpopopublisherhpp","text":"","title":"iceoryx_posh/popo/publisher.hpp"},{"location":"API-reference/posh/Files/publisher_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/publisher_8hpp/#classes","text":"Name class iox::popo::Publisher The Publisher class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/publisher_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_PUBLISHER_HPP #define IOX_POSH_POPO_TYPED_PUBLISHER_HPP #include \"iceoryx_posh/internal/popo/publisher_impl.hpp\" namespace iox { namespace popo { template < typename T , typename H = mepoo :: NoUserHeader > class Publisher : public PublisherImpl < T , H > { public : using PublisherImpl < T , H >:: PublisherImpl ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_TYPED_PUBLISHER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/publisher__impl_8hpp/","text":"iceoryx_posh/internal/popo/publisher_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::PublisherImpl The PublisherImpl class implements the typed publisher API. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_PUBLISHER_IMPL_HPP #define IOX_POSH_POPO_TYPED_PUBLISHER_IMPL_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_posh/internal/popo/base_publisher.hpp\" #include \"iceoryx_posh/internal/popo/publisher_interface.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" namespace iox { namespace popo { template < typename T , typename H = mepoo :: NoUserHeader , typename BasePublisherType = BasePublisher <>> class PublisherImpl : public BasePublisherType , private PublisherInterface < T , H > { using DataTypeAssert = typename TypedPortApiTrait < T >:: Assert ; using HeaderTypeAssert = typename TypedPortApiTrait < H >:: Assert ; public : explicit PublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions ()); PublisherImpl ( const PublisherImpl & other ) = delete ; PublisherImpl & operator = ( const PublisherImpl & ) = delete ; PublisherImpl ( PublisherImpl && rhs ) = delete ; PublisherImpl & operator = ( PublisherImpl && rhs ) = delete ; virtual ~ PublisherImpl () = default ; template < typename ... Args > cxx :: expected < Sample < T , H > , AllocationError > loan ( Args && ... args ) noexcept ; void publish ( Sample < T , H >&& sample ) noexcept override ; cxx :: expected < AllocationError > publishCopyOf ( const T & val ) noexcept ; template < typename Callable , typename ... ArgTypes > cxx :: expected < AllocationError > publishResultOf ( Callable c , ArgTypes ... args ) noexcept ; protected : using BasePublisherType :: port ; private : Sample < T , H > convertChunkHeaderToSample ( mepoo :: ChunkHeader * const header ) noexcept ; cxx :: expected < Sample < T , H > , AllocationError > loanSample () noexcept ; using PublisherSampleDeleter = SampleDeleter < typename BasePublisherType :: PortType > ; PublisherSampleDeleter m_sampleDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/publisher_impl.inl\" #endif // IOX_POSH_POPO_TYPED_PUBLISHER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/publisher_impl.hpp"},{"location":"API-reference/posh/Files/publisher__impl_8hpp/#iceoryx_poshinternalpopopublisher_implhpp","text":"","title":"iceoryx_posh/internal/popo/publisher_impl.hpp"},{"location":"API-reference/posh/Files/publisher__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/publisher__impl_8hpp/#classes","text":"Name class iox::popo::PublisherImpl The PublisherImpl class implements the typed publisher API.","title":"Classes"},{"location":"API-reference/posh/Files/publisher__impl_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_PUBLISHER_IMPL_HPP #define IOX_POSH_POPO_TYPED_PUBLISHER_IMPL_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_posh/internal/popo/base_publisher.hpp\" #include \"iceoryx_posh/internal/popo/publisher_interface.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" namespace iox { namespace popo { template < typename T , typename H = mepoo :: NoUserHeader , typename BasePublisherType = BasePublisher <>> class PublisherImpl : public BasePublisherType , private PublisherInterface < T , H > { using DataTypeAssert = typename TypedPortApiTrait < T >:: Assert ; using HeaderTypeAssert = typename TypedPortApiTrait < H >:: Assert ; public : explicit PublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions ()); PublisherImpl ( const PublisherImpl & other ) = delete ; PublisherImpl & operator = ( const PublisherImpl & ) = delete ; PublisherImpl ( PublisherImpl && rhs ) = delete ; PublisherImpl & operator = ( PublisherImpl && rhs ) = delete ; virtual ~ PublisherImpl () = default ; template < typename ... Args > cxx :: expected < Sample < T , H > , AllocationError > loan ( Args && ... args ) noexcept ; void publish ( Sample < T , H >&& sample ) noexcept override ; cxx :: expected < AllocationError > publishCopyOf ( const T & val ) noexcept ; template < typename Callable , typename ... ArgTypes > cxx :: expected < AllocationError > publishResultOf ( Callable c , ArgTypes ... args ) noexcept ; protected : using BasePublisherType :: port ; private : Sample < T , H > convertChunkHeaderToSample ( mepoo :: ChunkHeader * const header ) noexcept ; cxx :: expected < Sample < T , H > , AllocationError > loanSample () noexcept ; using PublisherSampleDeleter = SampleDeleter < typename BasePublisherType :: PortType > ; PublisherSampleDeleter m_sampleDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/publisher_impl.inl\" #endif // IOX_POSH_POPO_TYPED_PUBLISHER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/publisher__options_8hpp/","text":"iceoryx_posh/popo/publisher_options.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name struct iox::popo::PublisherOptions This struct is used to configure the publisher. Source code \ud83d\udd17 // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP #define IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct PublisherOptions { uint64_t historyCapacity { 0U }; iox :: NodeName_t nodeName { \"\" }; bool offerOnCreate { true }; ConsumerTooSlowPolicy subscriberTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < PublisherOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/publisher_options.hpp"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#iceoryx_poshpopopublisher_optionshpp","text":"","title":"iceoryx_posh/popo/publisher_options.hpp"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#classes","text":"Name struct iox::popo::PublisherOptions This struct is used to configure the publisher.","title":"Classes"},{"location":"API-reference/posh/Files/publisher__options_8hpp/#source-code","text":"// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP #define IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct PublisherOptions { uint64_t historyCapacity { 0U }; iox :: NodeName_t nodeName { \"\" }; bool offerOnCreate { true }; ConsumerTooSlowPolicy subscriberTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < PublisherOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_PUBLISHER_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/request_8hpp/","text":"iceoryx_posh/popo/request.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::RpcInterface class iox::popo::Request The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_REQUEST_HPP #define IOX_POSH_POPO_REQUEST_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\" #include \"iceoryx_posh/internal/popo/smart_chunk.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" #include \"iceoryx_posh/popo/rpc_header.hpp\" namespace iox { namespace popo { template < typename RpcType , typename SendErrorEnum > class RpcInterface ; template < typename T > class Request : public SmartChunk < RpcInterface < Request < T > , ClientSendError > , T , cxx :: add_const_conditionally_t < RequestHeader , T >> { using BaseType = SmartChunk < RpcInterface < Request < T > , ClientSendError > , T , cxx :: add_const_conditionally_t < RequestHeader , T >> ; template < typename S , typename TT > using ForClientOnly = typename BaseType :: template ForProducerOnly < S , TT > ; public : using BaseType :: BaseType ; template < typename S = T , typename = ForClientOnly < S , T >> cxx :: expected < ClientSendError > send () noexcept ; cxx :: add_const_conditionally_t < RequestHeader , T >& getRequestHeader () noexcept ; const RequestHeader & getRequestHeader () const noexcept ; private : template < typename , typename , typename > friend class ClientImpl ; template < typename , typename , typename > friend class ServerImpl ; using BaseType :: release ; using BaseType :: m_members ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/request.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/request.hpp"},{"location":"API-reference/posh/Files/request_8hpp/#iceoryx_poshpoporequesthpp","text":"","title":"iceoryx_posh/popo/request.hpp"},{"location":"API-reference/posh/Files/request_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/request_8hpp/#classes","text":"Name class iox::popo::RpcInterface class iox::popo::Request The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system.","title":"Classes"},{"location":"API-reference/posh/Files/request_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_REQUEST_HPP #define IOX_POSH_POPO_REQUEST_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/internal/popo/ports/client_port_user.hpp\" #include \"iceoryx_posh/internal/popo/smart_chunk.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" #include \"iceoryx_posh/popo/rpc_header.hpp\" namespace iox { namespace popo { template < typename RpcType , typename SendErrorEnum > class RpcInterface ; template < typename T > class Request : public SmartChunk < RpcInterface < Request < T > , ClientSendError > , T , cxx :: add_const_conditionally_t < RequestHeader , T >> { using BaseType = SmartChunk < RpcInterface < Request < T > , ClientSendError > , T , cxx :: add_const_conditionally_t < RequestHeader , T >> ; template < typename S , typename TT > using ForClientOnly = typename BaseType :: template ForProducerOnly < S , TT > ; public : using BaseType :: BaseType ; template < typename S = T , typename = ForClientOnly < S , T >> cxx :: expected < ClientSendError > send () noexcept ; cxx :: add_const_conditionally_t < RequestHeader , T >& getRequestHeader () noexcept ; const RequestHeader & getRequestHeader () const noexcept ; private : template < typename , typename , typename > friend class ClientImpl ; template < typename , typename , typename > friend class ServerImpl ; using BaseType :: release ; using BaseType :: m_members ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/request.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/response_8hpp/","text":"iceoryx_posh/popo/response.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::RpcInterface class iox::popo::Response The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_RESPONSE_HPP #define IOX_POSH_POPO_RESPONSE_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\" #include \"iceoryx_posh/internal/popo/smart_chunk.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" #include \"iceoryx_posh/popo/rpc_header.hpp\" namespace iox { namespace popo { template < typename RpcType , typename SendErrorEnum > class RpcInterface ; template < typename T > class Response : public SmartChunk < RpcInterface < Response < T > , ServerSendError > , T , cxx :: add_const_conditionally_t < ResponseHeader , T >> { using BaseType = SmartChunk < RpcInterface < Response < T > , ServerSendError > , T , cxx :: add_const_conditionally_t < ResponseHeader , T >> ; template < typename S , typename TT > using ForServerOnly = typename BaseType :: template ForProducerOnly < S , TT > ; public : using BaseType :: BaseType ; template < typename S = T , typename = ForServerOnly < S , T >> cxx :: expected < ServerSendError > send () noexcept ; cxx :: add_const_conditionally_t < ResponseHeader , T >& getResponseHeader () noexcept ; const ResponseHeader & getResponseHeader () const noexcept ; private : template < typename , typename , typename > friend class ClientImpl ; template < typename , typename , typename > friend class ServerImpl ; using BaseType :: release ; using BaseType :: m_members ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/response.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/response.hpp"},{"location":"API-reference/posh/Files/response_8hpp/#iceoryx_poshpoporesponsehpp","text":"","title":"iceoryx_posh/popo/response.hpp"},{"location":"API-reference/posh/Files/response_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/response_8hpp/#classes","text":"Name class iox::popo::RpcInterface class iox::popo::Response The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system.","title":"Classes"},{"location":"API-reference/posh/Files/response_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_RESPONSE_HPP #define IOX_POSH_POPO_RESPONSE_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/internal/popo/ports/server_port_user.hpp\" #include \"iceoryx_posh/internal/popo/smart_chunk.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" #include \"iceoryx_posh/popo/rpc_header.hpp\" namespace iox { namespace popo { template < typename RpcType , typename SendErrorEnum > class RpcInterface ; template < typename T > class Response : public SmartChunk < RpcInterface < Response < T > , ServerSendError > , T , cxx :: add_const_conditionally_t < ResponseHeader , T >> { using BaseType = SmartChunk < RpcInterface < Response < T > , ServerSendError > , T , cxx :: add_const_conditionally_t < ResponseHeader , T >> ; template < typename S , typename TT > using ForServerOnly = typename BaseType :: template ForProducerOnly < S , TT > ; public : using BaseType :: BaseType ; template < typename S = T , typename = ForServerOnly < S , T >> cxx :: expected < ServerSendError > send () noexcept ; cxx :: add_const_conditionally_t < ResponseHeader , T >& getResponseHeader () noexcept ; const ResponseHeader & getResponseHeader () const noexcept ; private : template < typename , typename , typename > friend class ClientImpl ; template < typename , typename , typename > friend class ServerImpl ; using BaseType :: release ; using BaseType :: m_members ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/response.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__app_8hpp/","text":"iceoryx_posh/roudi/roudi_app.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::RouDiApp base class for RouDi daemons Source code \ud83d\udd17 // Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_APP_HPP #define IOX_POSH_ROUDI_ROUDI_APP_HPP #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\" #include \"iceoryx_posh/iceoryx_posh_config.hpp\" #include \"iceoryx_posh/mepoo/mepoo_config.hpp\" #include \"iceoryx_posh/roudi/cmd_line_args.hpp\" #include <cstdint> #include <cstdio> namespace iox { namespace roudi { class RouDiApp { public : static void roudiSigHandler ( int32_t signal ) noexcept ; RouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & config ) noexcept ; virtual ~ RouDiApp () noexcept {}; virtual uint8_t run () noexcept = 0 ; protected : void registerSigHandler () noexcept ; bool waitForSignal () noexcept ; iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn }; roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON }; bool m_run { true }; RouDiConfig_t m_config ; posix :: Semaphore m_semaphore = std :: move ( posix :: Semaphore :: create ( posix :: CreateUnnamedSingleProcessSemaphore , 0u ) . or_else ([]( posix :: SemaphoreError & ) { errorHandler ( Error :: kROUDI_APP__FAILED_TO_CREATE_SEMAPHORE , nullptr , ErrorLevel :: FATAL ); }) . value ()); version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; private : bool checkAndOptimizeConfig ( const RouDiConfig_t & config ) noexcept ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/roudi_app.hpp"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#iceoryx_poshroudiroudi_apphpp","text":"","title":"iceoryx_posh/roudi/roudi_app.hpp"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#classes","text":"Name class iox::roudi::RouDiApp base class for RouDi daemons","title":"Classes"},{"location":"API-reference/posh/Files/roudi__app_8hpp/#source-code","text":"// Copyright (c) 2019 - 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_APP_HPP #define IOX_POSH_ROUDI_ROUDI_APP_HPP #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_hoofs/posix_wrapper/semaphore.hpp\" #include \"iceoryx_posh/iceoryx_posh_config.hpp\" #include \"iceoryx_posh/mepoo/mepoo_config.hpp\" #include \"iceoryx_posh/roudi/cmd_line_args.hpp\" #include <cstdint> #include <cstdio> namespace iox { namespace roudi { class RouDiApp { public : static void roudiSigHandler ( int32_t signal ) noexcept ; RouDiApp ( const config :: CmdLineArgs_t & cmdLineArgs , const RouDiConfig_t & config ) noexcept ; virtual ~ RouDiApp () noexcept {}; virtual uint8_t run () noexcept = 0 ; protected : void registerSigHandler () noexcept ; bool waitForSignal () noexcept ; iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn }; roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON }; bool m_run { true }; RouDiConfig_t m_config ; posix :: Semaphore m_semaphore = std :: move ( posix :: Semaphore :: create ( posix :: CreateUnnamedSingleProcessSemaphore , 0u ) . or_else ([]( posix :: SemaphoreError & ) { errorHandler ( Error :: kROUDI_APP__FAILED_TO_CREATE_SEMAPHORE , nullptr , ErrorLevel :: FATAL ); }) . value ()); version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; private : bool checkAndOptimizeConfig ( const RouDiConfig_t & config ) noexcept ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_APP_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/","text":"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name class iox::config::CmdLineParser Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP #define IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/roudi/cmd_line_args.hpp\" #include \"iceoryx_posh/version/compatibility_check_level.hpp\" namespace iox { namespace config { enum class CmdLineParserResult { UNKNOWN_OPTION_USED , INFO_OUTPUT_ONLY }; class CmdLineParser { public : enum class CmdLineArgumentParsingMode { ALL , ONE }; CmdLineParser () noexcept = default ; virtual ~ CmdLineParser () noexcept = default ; CmdLineParser & operator = ( const CmdLineParser & other ) = delete ; CmdLineParser ( const CmdLineParser & other ) = delete ; CmdLineParser & operator = ( CmdLineParser && ) = delete ; CmdLineParser ( CmdLineParser && other ) = delete ; virtual cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) noexcept ; protected : bool m_run { true }; iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn }; roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON }; version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; cxx :: optional < uint16_t > m_uniqueRouDiId ; units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#iceoryx_poshroudiroudi_cmd_line_parserhpp","text":"","title":"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#classes","text":"Name class iox::config::CmdLineParser","title":"Classes"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP #define IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/internal/units/duration.hpp\" #include \"iceoryx_hoofs/log/logcommon.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/roudi/cmd_line_args.hpp\" #include \"iceoryx_posh/version/compatibility_check_level.hpp\" namespace iox { namespace config { enum class CmdLineParserResult { UNKNOWN_OPTION_USED , INFO_OUTPUT_ONLY }; class CmdLineParser { public : enum class CmdLineArgumentParsingMode { ALL , ONE }; CmdLineParser () noexcept = default ; virtual ~ CmdLineParser () noexcept = default ; CmdLineParser & operator = ( const CmdLineParser & other ) = delete ; CmdLineParser ( const CmdLineParser & other ) = delete ; CmdLineParser & operator = ( CmdLineParser && ) = delete ; CmdLineParser ( CmdLineParser && other ) = delete ; virtual cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) noexcept ; protected : bool m_run { true }; iox :: log :: LogLevel m_logLevel { iox :: log :: LogLevel :: kWarn }; roudi :: MonitoringMode m_monitoringMode { roudi :: MonitoringMode :: ON }; version :: CompatibilityCheckLevel m_compatibilityCheckLevel { version :: CompatibilityCheckLevel :: PATCH }; cxx :: optional < uint16_t > m_uniqueRouDiId ; units :: Duration m_processKillDelay { roudi :: PROCESS_DEFAULT_KILL_DELAY }; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/","text":"iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name class iox::config::CmdLineParserConfigFileOption Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP #define IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP #include \"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp\" namespace iox { namespace config { class CmdLineParserConfigFileOption : public CmdLineParser { public : CmdLineParserConfigFileOption () noexcept = default ; virtual ~ CmdLineParserConfigFileOption () noexcept = default ; CmdLineParserConfigFileOption & operator = ( const CmdLineParserConfigFileOption & other ) = delete ; CmdLineParserConfigFileOption ( const CmdLineParserConfigFileOption & other ) = delete ; CmdLineParserConfigFileOption & operator = ( CmdLineParserConfigFileOption && ) = delete ; CmdLineParserConfigFileOption ( CmdLineParserConfigFileOption && other ) = delete ; cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) noexcept override ; protected : roudi :: ConfigFilePathString_t m_customConfigFilePath ; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#iceoryx_poshroudiroudi_cmd_line_parser_config_file_optionhpp","text":"","title":"iceoryx_posh/roudi/roudi_cmd_line_parser_config_file_option.hpp"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#classes","text":"Name class iox::config::CmdLineParserConfigFileOption","title":"Classes"},{"location":"API-reference/posh/Files/roudi__cmd__line__parser__config__file__option_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH, Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP #define IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP #include \"iceoryx_posh/roudi/roudi_cmd_line_parser.hpp\" namespace iox { namespace config { class CmdLineParserConfigFileOption : public CmdLineParser { public : CmdLineParserConfigFileOption () noexcept = default ; virtual ~ CmdLineParserConfigFileOption () noexcept = default ; CmdLineParserConfigFileOption & operator = ( const CmdLineParserConfigFileOption & other ) = delete ; CmdLineParserConfigFileOption ( const CmdLineParserConfigFileOption & other ) = delete ; CmdLineParserConfigFileOption & operator = ( CmdLineParserConfigFileOption && ) = delete ; CmdLineParserConfigFileOption ( CmdLineParserConfigFileOption && other ) = delete ; cxx :: expected < CmdLineArgs_t , CmdLineParserResult > parse ( int argc , char * argv [], const CmdLineArgumentParsingMode cmdLineParsingMode = CmdLineArgumentParsingMode :: ALL ) noexcept override ; protected : roudi :: ConfigFilePathString_t m_customConfigFilePath ; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CMD_LINE_PARSER_CONFIG_FILE_OPTION_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__config_8hpp/","text":"iceoryx_posh/roudi/roudi_config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name struct iox::config::RouDiConfig Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_HPP #define IOX_POSH_ROUDI_ROUDI_CONFIG_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace config { struct RouDiConfig { RouDiConfig & setDefaults () noexcept ; RouDiConfig & optimize () noexcept ; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/roudi_config.hpp"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#iceoryx_poshroudiroudi_confighpp","text":"","title":"iceoryx_posh/roudi/roudi_config.hpp"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#classes","text":"Name struct iox::config::RouDiConfig","title":"Classes"},{"location":"API-reference/posh/Files/roudi__config_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_HPP #define IOX_POSH_ROUDI_ROUDI_CONFIG_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> namespace iox { namespace config { struct RouDiConfig { RouDiConfig & setDefaults () noexcept ; RouDiConfig & optimize () noexcept ; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/","text":"iceoryx_posh/roudi/roudi_config_file_provider.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::RouDiConfigFileProvider Base class for a config file provider. Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP #define IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_posh/iceoryx_posh_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace roudi { enum class RouDiConfigFileParseError { NO_GENERAL_SECTION , INVALID_CONFIG_FILE_VERSION , NO_SEGMENTS , MAX_NUMBER_OF_SEGMENTS_EXCEEDED , SEGMENT_WITHOUT_MEMPOOL , MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED , MEMPOOL_WITHOUT_CHUNK_SIZE , MEMPOOL_WITHOUT_CHUNK_COUNT , EXCEPTION_IN_PARSER }; constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS [] = { \"NO_GENERAL_SECTION\" , \"INVALID_CONFIG_FILE_VERSION\" , \"NO_SEGMENTS\" , \"MAX_NUMBER_OF_SEGMENTS_EXCEEDED\" , \"SEGMENT_WITHOUT_MEMPOOL\" , \"MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED\" , \"MEMPOOL_WITHOUT_CHUNK_SIZE\" , \"MEMPOOL_WITHOUT_CHUNK_COUNT\" , \"EXCEPTION_IN_PARSER\" }; class RouDiConfigFileProvider { public : virtual cxx :: expected < RouDiConfig_t , RouDiConfigFileParseError > parse () noexcept = 0 ; protected : ConfigFilePathString_t m_customConfigFilePath ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/roudi_config_file_provider.hpp"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#iceoryx_poshroudiroudi_config_file_providerhpp","text":"","title":"iceoryx_posh/roudi/roudi_config_file_provider.hpp"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#classes","text":"Name class iox::roudi::RouDiConfigFileProvider Base class for a config file provider.","title":"Classes"},{"location":"API-reference/posh/Files/roudi__config__file__provider_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP #define IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_posh/iceoryx_posh_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace roudi { enum class RouDiConfigFileParseError { NO_GENERAL_SECTION , INVALID_CONFIG_FILE_VERSION , NO_SEGMENTS , MAX_NUMBER_OF_SEGMENTS_EXCEEDED , SEGMENT_WITHOUT_MEMPOOL , MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED , MEMPOOL_WITHOUT_CHUNK_SIZE , MEMPOOL_WITHOUT_CHUNK_COUNT , EXCEPTION_IN_PARSER }; constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS [] = { \"NO_GENERAL_SECTION\" , \"INVALID_CONFIG_FILE_VERSION\" , \"NO_SEGMENTS\" , \"MAX_NUMBER_OF_SEGMENTS_EXCEEDED\" , \"SEGMENT_WITHOUT_MEMPOOL\" , \"MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED\" , \"MEMPOOL_WITHOUT_CHUNK_SIZE\" , \"MEMPOOL_WITHOUT_CHUNK_COUNT\" , \"EXCEPTION_IN_PARSER\" }; class RouDiConfigFileProvider { public : virtual cxx :: expected < RouDiConfig_t , RouDiConfigFileParseError > parse () noexcept = 0 ; protected : ConfigFilePathString_t m_customConfigFilePath ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CONFIG_FILE_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/","text":"iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name class iox::config::TomlRouDiConfigFileProvider Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP #define IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP #include \"iceoryx_posh/roudi/cmd_line_args.hpp\" #include \"iceoryx_posh/roudi/roudi_config_file_provider.hpp\" namespace iox { namespace config { static constexpr char defaultConfigFilePath [] = \"/etc/iceoryx/roudi_config.toml\" ; class TomlRouDiConfigFileProvider : public iox :: roudi :: RouDiConfigFileProvider { public : TomlRouDiConfigFileProvider ( iox :: config :: CmdLineArgs_t & cmdLineArgs ) noexcept ; iox :: cxx :: expected < iox :: RouDiConfig_t , iox :: roudi :: RouDiConfigFileParseError > parse () noexcept override ; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#iceoryx_poshroudiroudi_config_toml_file_providerhpp","text":"","title":"iceoryx_posh/roudi/roudi_config_toml_file_provider.hpp"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#classes","text":"Name class iox::config::TomlRouDiConfigFileProvider","title":"Classes"},{"location":"API-reference/posh/Files/roudi__config__toml__file__provider_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP #define IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP #include \"iceoryx_posh/roudi/cmd_line_args.hpp\" #include \"iceoryx_posh/roudi/roudi_config_file_provider.hpp\" namespace iox { namespace config { static constexpr char defaultConfigFilePath [] = \"/etc/iceoryx/roudi_config.toml\" ; class TomlRouDiConfigFileProvider : public iox :: roudi :: RouDiConfigFileProvider { public : TomlRouDiConfigFileProvider ( iox :: config :: CmdLineArgs_t & cmdLineArgs ) noexcept ; iox :: cxx :: expected < iox :: RouDiConfig_t , iox :: roudi :: RouDiConfigFileParseError > parse () noexcept override ; }; } // namespace config } // namespace iox #endif // IOX_POSH_ROUDI_ROUDI_CONFIG_TOML_FILE_PROVIDER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/","text":"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::RouDiMemoryInterface Source code \ud83d\udd17 // Copyright (c) 2020, 2021 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP #define IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/port_pool_memory_block.hpp\" #include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\" #include \"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp\" #include \"iceoryx_posh/roudi/port_pool.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryProvider ; class RouDiMemoryInterface { public : RouDiMemoryInterface () noexcept = default ; virtual ~ RouDiMemoryInterface () noexcept = default ; RouDiMemoryInterface ( RouDiMemoryInterface && ) = delete ; RouDiMemoryInterface & operator = ( RouDiMemoryInterface && ) = delete ; RouDiMemoryInterface ( const RouDiMemoryInterface & ) = delete ; RouDiMemoryInterface & operator = ( const RouDiMemoryInterface & ) = delete ; virtual cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () noexcept = 0 ; virtual cxx :: expected < RouDiMemoryManagerError > destroyMemory () noexcept = 0 ; virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const noexcept = 0 ; virtual cxx :: optional < PortPool *> portPool () noexcept = 0 ; virtual cxx :: optional < mepoo :: MemoryManager *> introspectionMemoryManager () const noexcept = 0 ; virtual cxx :: optional < mepoo :: SegmentManager <>*> segmentManager () const noexcept = 0 ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#iceoryx_poshroudimemoryroudi_memory_interfacehpp","text":"","title":"iceoryx_posh/roudi/memory/roudi_memory_interface.hpp"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#classes","text":"Name class iox::roudi::RouDiMemoryInterface","title":"Classes"},{"location":"API-reference/posh/Files/roudi__memory__interface_8hpp/#source-code","text":"// Copyright (c) 2020, 2021 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP #define IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/port_pool_memory_block.hpp\" #include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\" #include \"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp\" #include \"iceoryx_posh/roudi/port_pool.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryProvider ; class RouDiMemoryInterface { public : RouDiMemoryInterface () noexcept = default ; virtual ~ RouDiMemoryInterface () noexcept = default ; RouDiMemoryInterface ( RouDiMemoryInterface && ) = delete ; RouDiMemoryInterface & operator = ( RouDiMemoryInterface && ) = delete ; RouDiMemoryInterface ( const RouDiMemoryInterface & ) = delete ; RouDiMemoryInterface & operator = ( const RouDiMemoryInterface & ) = delete ; virtual cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () noexcept = 0 ; virtual cxx :: expected < RouDiMemoryManagerError > destroyMemory () noexcept = 0 ; virtual const PosixShmMemoryProvider * mgmtMemoryProvider () const noexcept = 0 ; virtual cxx :: optional < PortPool *> portPool () noexcept = 0 ; virtual cxx :: optional < mepoo :: MemoryManager *> introspectionMemoryManager () const noexcept = 0 ; virtual cxx :: optional < mepoo :: SegmentManager <>*> segmentManager () const noexcept = 0 ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_INTERFACE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/","text":"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::roudi Classes \ud83d\udd17 Name class iox::roudi::RouDiMemoryManager Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP #define IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/port_pool_memory_block.hpp\" #include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryProvider ; enum class RouDiMemoryManagerError { MEMORY_PROVIDER_EXHAUSTED , NO_MEMORY_PROVIDER_PRESENT , MEMORY_CREATION_FAILED , MEMORY_DESTRUCTION_FAILED , }; iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const RouDiMemoryManagerError & error ) noexcept ; class RouDiMemoryManager { public : RouDiMemoryManager () noexcept = default ; virtual ~ RouDiMemoryManager () noexcept ; RouDiMemoryManager ( RouDiMemoryManager && ) = delete ; RouDiMemoryManager & operator = ( RouDiMemoryManager && ) = delete ; RouDiMemoryManager ( const RouDiMemoryManager & ) = delete ; RouDiMemoryManager & operator = ( const RouDiMemoryManager & ) = delete ; cxx :: expected < RouDiMemoryManagerError > addMemoryProvider ( MemoryProvider * memoryProvider ) noexcept ; cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () noexcept ; cxx :: expected < RouDiMemoryManagerError > destroyMemory () noexcept ; private : mepoo :: MePooConfig introspectionMemPoolConfig () const noexcept ; cxx :: vector < MemoryProvider * , MAX_NUMBER_OF_MEMORY_PROVIDER > m_memoryProvider ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#iceoryx_poshroudimemoryroudi_memory_managerhpp","text":"","title":"iceoryx_posh/roudi/memory/roudi_memory_manager.hpp"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#namespaces","text":"Name iox iox::roudi","title":"Namespaces"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#classes","text":"Name class iox::roudi::RouDiMemoryManager","title":"Classes"},{"location":"API-reference/posh/Files/roudi__memory__manager_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP #define IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_collection_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/mempool_segment_manager_memory_block.hpp\" #include \"iceoryx_posh/internal/roudi/memory/port_pool_memory_block.hpp\" #include \"iceoryx_posh/roudi/memory/posix_shm_memory_provider.hpp\" #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/optional.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include <cstdint> namespace iox { namespace roudi { class MemoryProvider ; enum class RouDiMemoryManagerError { MEMORY_PROVIDER_EXHAUSTED , NO_MEMORY_PROVIDER_PRESENT , MEMORY_CREATION_FAILED , MEMORY_DESTRUCTION_FAILED , }; iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const RouDiMemoryManagerError & error ) noexcept ; class RouDiMemoryManager { public : RouDiMemoryManager () noexcept = default ; virtual ~ RouDiMemoryManager () noexcept ; RouDiMemoryManager ( RouDiMemoryManager && ) = delete ; RouDiMemoryManager & operator = ( RouDiMemoryManager && ) = delete ; RouDiMemoryManager ( const RouDiMemoryManager & ) = delete ; RouDiMemoryManager & operator = ( const RouDiMemoryManager & ) = delete ; cxx :: expected < RouDiMemoryManagerError > addMemoryProvider ( MemoryProvider * memoryProvider ) noexcept ; cxx :: expected < RouDiMemoryManagerError > createAndAnnounceMemory () noexcept ; cxx :: expected < RouDiMemoryManagerError > destroyMemory () noexcept ; private : mepoo :: MePooConfig introspectionMemPoolConfig () const noexcept ; cxx :: vector < MemoryProvider * , MAX_NUMBER_OF_MEMORY_PROVIDER > m_memoryProvider ; }; } // namespace roudi } // namespace iox #endif // IOX_POSH_ROUDI_MEMORY_ROUDI_MEMORY_MANAGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/rpc__header_8hpp/","text":"iceoryx_posh/popo/rpc_header.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::RpcBaseHeader class iox::popo::RequestHeader class iox::popo::ResponseHeader Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_RPC_HEADER_HPP #define IOX_POSH_POPO_RPC_HEADER_HPP #include \"iceoryx_hoofs/internal/cxx/unique_id.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" #include <cstdint> namespace iox { namespace popo { class RpcBaseHeader { public : explicit RpcBaseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId , const uint8_t rpcHeaderVersion ) noexcept ; RpcBaseHeader ( const RpcBaseHeader & other ) = delete ; RpcBaseHeader & operator = ( const RpcBaseHeader & ) = delete ; RpcBaseHeader ( RpcBaseHeader && rhs ) noexcept = default ; RpcBaseHeader & operator = ( RpcBaseHeader && rhs ) noexcept = default ; ~ RpcBaseHeader () noexcept = default ; static constexpr uint8_t RPC_HEADER_VERSION { 1U }; static constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX { std :: numeric_limits < uint32_t >:: max ()}; static constexpr int64_t START_SEQUENCE_ID { 0 }; uint8_t getRpcHeaderVersion () const noexcept ; int64_t getSequenceId () const noexcept ; mepoo :: ChunkHeader * getChunkHeader () noexcept ; const mepoo :: ChunkHeader * getChunkHeader () const noexcept ; void * getUserPayload () noexcept ; const void * getUserPayload () const noexcept ; friend class ServerPortUser ; protected : uint8_t m_rpcHeaderVersion { RPC_HEADER_VERSION }; uint32_t m_lastKnownClientQueueIndex { UNKNOWN_CLIENT_QUEUE_INDEX }; cxx :: UniqueId m_uniqueClientQueueId ; int64_t m_sequenceId { 0 }; }; class RequestHeader : public RpcBaseHeader { public : explicit RequestHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex ) noexcept ; RequestHeader ( const RequestHeader & other ) = delete ; RequestHeader & operator = ( const RequestHeader & ) = delete ; RequestHeader ( RequestHeader && rhs ) noexcept = default ; RequestHeader & operator = ( RequestHeader && rhs ) noexcept = default ; ~ RequestHeader () noexcept = default ; void setSequenceId ( const int64_t sequenceId ) noexcept ; static RequestHeader * fromPayload ( void * const payload ) noexcept ; static const RequestHeader * fromPayload ( const void * const payload ) noexcept ; }; class ResponseHeader : public RpcBaseHeader { public : explicit ResponseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId ) noexcept ; ResponseHeader ( const ResponseHeader & other ) = delete ; ResponseHeader & operator = ( const ResponseHeader & ) = delete ; ResponseHeader ( ResponseHeader && rhs ) noexcept = default ; ResponseHeader & operator = ( ResponseHeader && rhs ) noexcept = default ; ~ ResponseHeader () noexcept = default ; void setServerError () noexcept ; bool hasServerError () const noexcept ; static ResponseHeader * fromPayload ( void * const payload ) noexcept ; static const ResponseHeader * fromPayload ( const void * const payload ) noexcept ; private : bool m_hasServerError { false }; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_RPC_HEADER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/rpc_header.hpp"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#iceoryx_poshpoporpc_headerhpp","text":"","title":"iceoryx_posh/popo/rpc_header.hpp"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#classes","text":"Name class iox::popo::RpcBaseHeader class iox::popo::RequestHeader class iox::popo::ResponseHeader","title":"Classes"},{"location":"API-reference/posh/Files/rpc__header_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_RPC_HEADER_HPP #define IOX_POSH_POPO_RPC_HEADER_HPP #include \"iceoryx_hoofs/internal/cxx/unique_id.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" #include <cstdint> namespace iox { namespace popo { class RpcBaseHeader { public : explicit RpcBaseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId , const uint8_t rpcHeaderVersion ) noexcept ; RpcBaseHeader ( const RpcBaseHeader & other ) = delete ; RpcBaseHeader & operator = ( const RpcBaseHeader & ) = delete ; RpcBaseHeader ( RpcBaseHeader && rhs ) noexcept = default ; RpcBaseHeader & operator = ( RpcBaseHeader && rhs ) noexcept = default ; ~ RpcBaseHeader () noexcept = default ; static constexpr uint8_t RPC_HEADER_VERSION { 1U }; static constexpr uint32_t UNKNOWN_CLIENT_QUEUE_INDEX { std :: numeric_limits < uint32_t >:: max ()}; static constexpr int64_t START_SEQUENCE_ID { 0 }; uint8_t getRpcHeaderVersion () const noexcept ; int64_t getSequenceId () const noexcept ; mepoo :: ChunkHeader * getChunkHeader () noexcept ; const mepoo :: ChunkHeader * getChunkHeader () const noexcept ; void * getUserPayload () noexcept ; const void * getUserPayload () const noexcept ; friend class ServerPortUser ; protected : uint8_t m_rpcHeaderVersion { RPC_HEADER_VERSION }; uint32_t m_lastKnownClientQueueIndex { UNKNOWN_CLIENT_QUEUE_INDEX }; cxx :: UniqueId m_uniqueClientQueueId ; int64_t m_sequenceId { 0 }; }; class RequestHeader : public RpcBaseHeader { public : explicit RequestHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex ) noexcept ; RequestHeader ( const RequestHeader & other ) = delete ; RequestHeader & operator = ( const RequestHeader & ) = delete ; RequestHeader ( RequestHeader && rhs ) noexcept = default ; RequestHeader & operator = ( RequestHeader && rhs ) noexcept = default ; ~ RequestHeader () noexcept = default ; void setSequenceId ( const int64_t sequenceId ) noexcept ; static RequestHeader * fromPayload ( void * const payload ) noexcept ; static const RequestHeader * fromPayload ( const void * const payload ) noexcept ; }; class ResponseHeader : public RpcBaseHeader { public : explicit ResponseHeader ( const cxx :: UniqueId & uniqueClientQueueId , const uint32_t lastKnownClientQueueIndex , const int64_t sequenceId ) noexcept ; ResponseHeader ( const ResponseHeader & other ) = delete ; ResponseHeader & operator = ( const ResponseHeader & ) = delete ; ResponseHeader ( ResponseHeader && rhs ) noexcept = default ; ResponseHeader & operator = ( ResponseHeader && rhs ) noexcept = default ; ~ ResponseHeader () noexcept = default ; void setServerError () noexcept ; bool hasServerError () const noexcept ; static ResponseHeader * fromPayload ( void * const payload ) noexcept ; static const ResponseHeader * fromPayload ( const void * const payload ) noexcept ; private : bool m_hasServerError { false }; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_RPC_HEADER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/sample_8hpp/","text":"iceoryx_posh/popo/sample.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::PublisherInterface class iox::popo::Sample The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SAMPLE_HPP #define IOX_POSH_POPO_SAMPLE_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/internal/popo/smart_chunk.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" namespace iox { namespace popo { template < typename T , typename H > class PublisherInterface ; template < typename T , typename H = cxx :: add_const_conditionally_t < mepoo :: NoUserHeader , T >> class Sample : public SmartChunk < PublisherInterface < T , H > , T , H > { using BaseType = SmartChunk < PublisherInterface < T , H > , T , H > ; public : template < typename T1 , typename T2 > using ForPublisherOnly = typename BaseType :: template ForProducerOnly < T1 , T2 > ; using BaseType :: BaseType ; using BaseType :: getUserHeader ; template < typename S = T , typename = ForPublisherOnly < S , T >> void publish () noexcept ; private : template < typename , typename , typename > friend class PublisherImpl ; using BaseType :: release ; using BaseType :: m_members ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/sample.inl\" #endif // IOX_POSH_POPO_SAMPLE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/sample.hpp"},{"location":"API-reference/posh/Files/sample_8hpp/#iceoryx_poshpoposamplehpp","text":"","title":"iceoryx_posh/popo/sample.hpp"},{"location":"API-reference/posh/Files/sample_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/sample_8hpp/#classes","text":"Name class iox::popo::PublisherInterface class iox::popo::Sample The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system.","title":"Classes"},{"location":"API-reference/posh/Files/sample_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SAMPLE_HPP #define IOX_POSH_POPO_SAMPLE_HPP #include \"iceoryx_hoofs/cxx/type_traits.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/internal/log/posh_logging.hpp\" #include \"iceoryx_posh/internal/popo/smart_chunk.hpp\" #include \"iceoryx_posh/mepoo/chunk_header.hpp\" namespace iox { namespace popo { template < typename T , typename H > class PublisherInterface ; template < typename T , typename H = cxx :: add_const_conditionally_t < mepoo :: NoUserHeader , T >> class Sample : public SmartChunk < PublisherInterface < T , H > , T , H > { using BaseType = SmartChunk < PublisherInterface < T , H > , T , H > ; public : template < typename T1 , typename T2 > using ForPublisherOnly = typename BaseType :: template ForProducerOnly < T1 , T2 > ; using BaseType :: BaseType ; using BaseType :: getUserHeader ; template < typename S = T , typename = ForPublisherOnly < S , T >> void publish () noexcept ; private : template < typename , typename , typename > friend class PublisherImpl ; using BaseType :: release ; using BaseType :: m_members ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/sample.inl\" #endif // IOX_POSH_POPO_SAMPLE_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/segment__config_8hpp/","text":"iceoryx_posh/mepoo/segment_config.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::mepoo Classes \ud83d\udd17 Name struct iox::mepoo::SegmentConfig struct iox::mepoo::SegmentConfig::SegmentEntry Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP #define IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP #include \"iceoryx_posh/mepoo/memory_info.hpp\" #include \"iceoryx_posh/mepoo/mepoo_config.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace mepoo { struct SegmentConfig { struct SegmentEntry { SegmentEntry ( const posix :: PosixGroup :: string_t & readerGroup , const posix :: PosixGroup :: string_t & writerGroup , const MePooConfig & memPoolConfig , iox :: mepoo :: MemoryInfo memoryInfo = iox :: mepoo :: MemoryInfo ()) noexcept : m_readerGroup ( readerGroup ) , m_writerGroup ( writerGroup ) , m_mempoolConfig ( memPoolConfig ) , m_memoryInfo ( memoryInfo ) { } posix :: PosixGroup :: string_t m_readerGroup ; posix :: PosixGroup :: string_t m_writerGroup ; MePooConfig m_mempoolConfig ; iox :: mepoo :: MemoryInfo m_memoryInfo ; }; cxx :: vector < SegmentEntry , MAX_SHM_SEGMENTS > m_sharedMemorySegments ; SegmentConfig & setDefaults () noexcept ; SegmentConfig & optimize () noexcept ; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/mepoo/segment_config.hpp"},{"location":"API-reference/posh/Files/segment__config_8hpp/#iceoryx_poshmepoosegment_confighpp","text":"","title":"iceoryx_posh/mepoo/segment_config.hpp"},{"location":"API-reference/posh/Files/segment__config_8hpp/#namespaces","text":"Name iox iox::mepoo","title":"Namespaces"},{"location":"API-reference/posh/Files/segment__config_8hpp/#classes","text":"Name struct iox::mepoo::SegmentConfig struct iox::mepoo::SegmentConfig::SegmentEntry","title":"Classes"},{"location":"API-reference/posh/Files/segment__config_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP #define IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP #include \"iceoryx_posh/mepoo/memory_info.hpp\" #include \"iceoryx_posh/mepoo/mepoo_config.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/posix_wrapper/posix_access_rights.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" namespace iox { namespace mepoo { struct SegmentConfig { struct SegmentEntry { SegmentEntry ( const posix :: PosixGroup :: string_t & readerGroup , const posix :: PosixGroup :: string_t & writerGroup , const MePooConfig & memPoolConfig , iox :: mepoo :: MemoryInfo memoryInfo = iox :: mepoo :: MemoryInfo ()) noexcept : m_readerGroup ( readerGroup ) , m_writerGroup ( writerGroup ) , m_mempoolConfig ( memPoolConfig ) , m_memoryInfo ( memoryInfo ) { } posix :: PosixGroup :: string_t m_readerGroup ; posix :: PosixGroup :: string_t m_writerGroup ; MePooConfig m_mempoolConfig ; iox :: mepoo :: MemoryInfo m_memoryInfo ; }; cxx :: vector < SegmentEntry , MAX_SHM_SEGMENTS > m_sharedMemorySegments ; SegmentConfig & setDefaults () noexcept ; SegmentConfig & optimize () noexcept ; }; } // namespace mepoo } // namespace iox #endif // IOX_POSH_MEPOO_SEGMENT_CONFIG_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/server_8hpp/","text":"iceoryx_posh/popo/server.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::Server The Server class for the request-response messaging pattern in iceoryx. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SERVER_HPP #define IOX_POSH_POPO_SERVER_HPP #include \"iceoryx_posh/internal/popo/server_impl.hpp\" namespace iox { namespace popo { template < typename Req , typename Res > class Server : public ServerImpl < Req , Res > { using Impl = ServerImpl < Req , Res > ; public : using ServerImpl < Req , Res >:: ServerImpl ; virtual ~ Server () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_SERVER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/server.hpp"},{"location":"API-reference/posh/Files/server_8hpp/#iceoryx_poshpoposerverhpp","text":"","title":"iceoryx_posh/popo/server.hpp"},{"location":"API-reference/posh/Files/server_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/server_8hpp/#classes","text":"Name class iox::popo::Server The Server class for the request-response messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/server_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SERVER_HPP #define IOX_POSH_POPO_SERVER_HPP #include \"iceoryx_posh/internal/popo/server_impl.hpp\" namespace iox { namespace popo { template < typename Req , typename Res > class Server : public ServerImpl < Req , Res > { using Impl = ServerImpl < Req , Res > ; public : using ServerImpl < Req , Res >:: ServerImpl ; virtual ~ Server () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_SERVER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/server__impl_8hpp/","text":"iceoryx_posh/internal/popo/server_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::ServerImpl The ServerImpl class implements the typed server API. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SERVER_IMPL_HPP #define IOX_POSH_POPO_SERVER_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_server.hpp\" #include \"iceoryx_posh/internal/popo/request_deleter.hpp\" #include \"iceoryx_posh/internal/popo/response_deleter.hpp\" #include \"iceoryx_posh/internal/popo/rpc_interface.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" #include \"iceoryx_posh/popo/request.hpp\" #include \"iceoryx_posh/popo/response.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { template < typename Req , typename Res , typename BaseServerT = BaseServer <>> class ServerImpl : public BaseServerT , private RpcInterface < Response < Res > , ServerSendError > { using RequestTypeAssert = typename TypedPortApiTrait < Req >:: Assert ; using ResponseTypeAssert = typename TypedPortApiTrait < Res >:: Assert ; public : explicit ServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {}) noexcept ; virtual ~ ServerImpl () noexcept ; ServerImpl ( const ServerImpl & ) = delete ; ServerImpl ( ServerImpl && ) = delete ; ServerImpl & operator = ( const ServerImpl & ) = delete ; ServerImpl & operator = ( ServerImpl && ) = delete ; cxx :: expected < Request < const Req > , ServerRequestResult > take () noexcept ; template < typename ... Args > cxx :: expected < Response < Res > , AllocationError > loan ( const Request < const Req >& request , Args && ... args ) noexcept ; cxx :: expected < ServerSendError > send ( Response < Res >&& response ) noexcept override ; protected : using BaseServerT :: port ; private : cxx :: expected < Response < Res > , AllocationError > loanUninitialized ( const Request < const Req >& request ) noexcept ; using RequestSampleDeleter = RequestDeleter < typename BaseServerT :: PortType > ; RequestSampleDeleter m_requestDeleter { port ()}; using ResponseSampleDeleter = ResponseDeleter < typename BaseServerT :: PortType > ; ResponseSampleDeleter m_responseDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/server_impl.inl\" #endif // IOX_POSH_POPO_SERVER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/server_impl.hpp"},{"location":"API-reference/posh/Files/server__impl_8hpp/#iceoryx_poshinternalpoposerver_implhpp","text":"","title":"iceoryx_posh/internal/popo/server_impl.hpp"},{"location":"API-reference/posh/Files/server__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/server__impl_8hpp/#classes","text":"Name class iox::popo::ServerImpl The ServerImpl class implements the typed server API.","title":"Classes"},{"location":"API-reference/posh/Files/server__impl_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SERVER_IMPL_HPP #define IOX_POSH_POPO_SERVER_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_server.hpp\" #include \"iceoryx_posh/internal/popo/request_deleter.hpp\" #include \"iceoryx_posh/internal/popo/response_deleter.hpp\" #include \"iceoryx_posh/internal/popo/rpc_interface.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" #include \"iceoryx_posh/popo/request.hpp\" #include \"iceoryx_posh/popo/response.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { template < typename Req , typename Res , typename BaseServerT = BaseServer <>> class ServerImpl : public BaseServerT , private RpcInterface < Response < Res > , ServerSendError > { using RequestTypeAssert = typename TypedPortApiTrait < Req >:: Assert ; using ResponseTypeAssert = typename TypedPortApiTrait < Res >:: Assert ; public : explicit ServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {}) noexcept ; virtual ~ ServerImpl () noexcept ; ServerImpl ( const ServerImpl & ) = delete ; ServerImpl ( ServerImpl && ) = delete ; ServerImpl & operator = ( const ServerImpl & ) = delete ; ServerImpl & operator = ( ServerImpl && ) = delete ; cxx :: expected < Request < const Req > , ServerRequestResult > take () noexcept ; template < typename ... Args > cxx :: expected < Response < Res > , AllocationError > loan ( const Request < const Req >& request , Args && ... args ) noexcept ; cxx :: expected < ServerSendError > send ( Response < Res >&& response ) noexcept override ; protected : using BaseServerT :: port ; private : cxx :: expected < Response < Res > , AllocationError > loanUninitialized ( const Request < const Req >& request ) noexcept ; using RequestSampleDeleter = RequestDeleter < typename BaseServerT :: PortType > ; RequestSampleDeleter m_requestDeleter { port ()}; using ResponseSampleDeleter = ResponseDeleter < typename BaseServerT :: PortType > ; ResponseSampleDeleter m_responseDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/server_impl.inl\" #endif // IOX_POSH_POPO_SERVER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/server__options_8hpp/","text":"iceoryx_posh/popo/server_options.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name struct iox::popo::ServerOptions This struct is used to configure the server. Source code \ud83d\udd17 // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SERVER_OPTIONS_HPP #define IOX_POSH_POPO_SERVER_OPTIONS_HPP #include \"iceoryx_posh/internal/popo/ports/client_server_port_types.hpp\" #include \"iceoryx_posh/popo/port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct ServerOptions { uint64_t requestQueueCapacity { ServerChunkQueueData_t :: MAX_CAPACITY }; iox :: NodeName_t nodeName { \"\" }; bool offerOnCreate { true }; QueueFullPolicy requestQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; ConsumerTooSlowPolicy clientTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < ServerOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; bool operator == ( const ServerOptions & rhs ) const noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_CLIENT_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/server_options.hpp"},{"location":"API-reference/posh/Files/server__options_8hpp/#iceoryx_poshpoposerver_optionshpp","text":"","title":"iceoryx_posh/popo/server_options.hpp"},{"location":"API-reference/posh/Files/server__options_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/server__options_8hpp/#classes","text":"Name struct iox::popo::ServerOptions This struct is used to configure the server.","title":"Classes"},{"location":"API-reference/posh/Files/server__options_8hpp/#source-code","text":"// Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SERVER_OPTIONS_HPP #define IOX_POSH_POPO_SERVER_OPTIONS_HPP #include \"iceoryx_posh/internal/popo/ports/client_server_port_types.hpp\" #include \"iceoryx_posh/popo/port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct ServerOptions { uint64_t requestQueueCapacity { ServerChunkQueueData_t :: MAX_CAPACITY }; iox :: NodeName_t nodeName { \"\" }; bool offerOnCreate { true }; QueueFullPolicy requestQueueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; ConsumerTooSlowPolicy clientTooSlowPolicy { ConsumerTooSlowPolicy :: DISCARD_OLDEST_DATA }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < ServerOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; bool operator == ( const ServerOptions & rhs ) const noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_CLIENT_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/service__description_8hpp/","text":"iceoryx_posh/capro/service_description.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::capro Classes \ud83d\udd17 Name class iox::capro::ServiceDescription class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel. struct iox::capro::ServiceDescription::ClassHash Source code \ud83d\udd17 // Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP #define IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> #include <initializer_list> namespace iox { namespace capro { using Wildcard_t = iox :: cxx :: nullopt_t ; constexpr Wildcard_t Wildcard ; static constexpr int32_t MAX_NUMBER_OF_CHARS = 64 ; static constexpr size_t CLASS_HASH_ELEMENT_COUNT { 4U }; enum class Interfaces : uint16_t { INTERNAL = 0 , ESOC , SOMEIP , AMQP , MQTT , DDS , SIGNAL , MTA , ROS1 , INTERFACE_END }; constexpr const char * INTERFACE_NAMES [] = { \"INTERNAL\" , \"ESOC\" , \"SOMEIP\" , \"AMQP\" , \"DDS\" , \"SIGNAL\" , \"MTA\" , \"ROS1\" , \"END\" }; enum class Scope : uint16_t { WORLDWIDE , LOCAL , INVALID }; constexpr char ScopeTypeString [][ MAX_NUMBER_OF_CHARS ] = { \"WORLDWIDE\" , \"INTERNAL\" , \"INVALID\" }; class ServiceDescription { public : struct ClassHash { ClassHash () noexcept ; ClassHash ( const std :: initializer_list < uint32_t >& values ) noexcept ; uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) noexcept ; const uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) const noexcept ; bool operator == ( const ClassHash & rhs ) const noexcept ; bool operator != ( const ClassHash & rhs ) const noexcept ; private : uint32_t data [ CLASS_HASH_ELEMENT_COUNT ]; }; ServiceDescription () noexcept ; ServiceDescription ( const ServiceDescription & ) noexcept = default ; ServiceDescription ( ServiceDescription && ) noexcept = default ; ~ ServiceDescription () noexcept = default ; ServiceDescription ( const IdString_t & service , const IdString_t & instance , const IdString_t & event , ClassHash m_classHash = { 0U , 0U , 0U , 0U }, Interfaces interfaceSource = Interfaces :: INTERNAL ) noexcept ; bool operator == ( const ServiceDescription & rhs ) const noexcept ; bool operator != ( const ServiceDescription & rhs ) const noexcept ; bool operator < ( const ServiceDescription & rhs ) const noexcept ; ServiceDescription & operator = ( const ServiceDescription & ) noexcept = default ; ServiceDescription & operator = ( ServiceDescription && ) noexcept = default ; explicit operator cxx :: Serialization () const noexcept ; static cxx :: expected < ServiceDescription , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; // @brief Returns if this service description is used for an RouDi-internal channel bool isLocal () const noexcept ; // @brief Set this service description to be is used for an RouDi-internal channel void setLocal () noexcept ; Scope getScope () const noexcept ; const IdString_t & getServiceIDString () const noexcept ; const IdString_t & getInstanceIDString () const noexcept ; const IdString_t & getEventIDString () const noexcept ; ClassHash getClassHash () const noexcept ; Interfaces getSourceInterface () const noexcept ; private : IdString_t m_serviceString ; IdString_t m_instanceString ; IdString_t m_eventString ; ClassHash m_classHash { 0 , 0 , 0 , 0 }; Scope m_scope { Scope :: WORLDWIDE }; Interfaces m_interfaceSource { Interfaces :: INTERNAL }; }; bool serviceMatch ( const ServiceDescription & first , const ServiceDescription & second ) noexcept ; std :: ostream & operator << ( std :: ostream & stream , const ServiceDescription & service ) noexcept ; log :: LogStream & operator << ( log :: LogStream & stream , const ServiceDescription & service ) noexcept ; } // namespace capro } // namespace iox #endif // IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/capro/service_description.hpp"},{"location":"API-reference/posh/Files/service__description_8hpp/#iceoryx_poshcaproservice_descriptionhpp","text":"","title":"iceoryx_posh/capro/service_description.hpp"},{"location":"API-reference/posh/Files/service__description_8hpp/#namespaces","text":"Name iox iox::capro","title":"Namespaces"},{"location":"API-reference/posh/Files/service__description_8hpp/#classes","text":"Name class iox::capro::ServiceDescription class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel. struct iox::capro::ServiceDescription::ClassHash","title":"Classes"},{"location":"API-reference/posh/Files/service__description_8hpp/#source-code","text":"// Copyright (c) 2019, 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP #define IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_hoofs/log/logstream.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cstdint> #include <initializer_list> namespace iox { namespace capro { using Wildcard_t = iox :: cxx :: nullopt_t ; constexpr Wildcard_t Wildcard ; static constexpr int32_t MAX_NUMBER_OF_CHARS = 64 ; static constexpr size_t CLASS_HASH_ELEMENT_COUNT { 4U }; enum class Interfaces : uint16_t { INTERNAL = 0 , ESOC , SOMEIP , AMQP , MQTT , DDS , SIGNAL , MTA , ROS1 , INTERFACE_END }; constexpr const char * INTERFACE_NAMES [] = { \"INTERNAL\" , \"ESOC\" , \"SOMEIP\" , \"AMQP\" , \"DDS\" , \"SIGNAL\" , \"MTA\" , \"ROS1\" , \"END\" }; enum class Scope : uint16_t { WORLDWIDE , LOCAL , INVALID }; constexpr char ScopeTypeString [][ MAX_NUMBER_OF_CHARS ] = { \"WORLDWIDE\" , \"INTERNAL\" , \"INVALID\" }; class ServiceDescription { public : struct ClassHash { ClassHash () noexcept ; ClassHash ( const std :: initializer_list < uint32_t >& values ) noexcept ; uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) noexcept ; const uint32_t & operator []( iox :: cxx :: range < uint64_t , 0 , CLASS_HASH_ELEMENT_COUNT - 1 > index ) const noexcept ; bool operator == ( const ClassHash & rhs ) const noexcept ; bool operator != ( const ClassHash & rhs ) const noexcept ; private : uint32_t data [ CLASS_HASH_ELEMENT_COUNT ]; }; ServiceDescription () noexcept ; ServiceDescription ( const ServiceDescription & ) noexcept = default ; ServiceDescription ( ServiceDescription && ) noexcept = default ; ~ ServiceDescription () noexcept = default ; ServiceDescription ( const IdString_t & service , const IdString_t & instance , const IdString_t & event , ClassHash m_classHash = { 0U , 0U , 0U , 0U }, Interfaces interfaceSource = Interfaces :: INTERNAL ) noexcept ; bool operator == ( const ServiceDescription & rhs ) const noexcept ; bool operator != ( const ServiceDescription & rhs ) const noexcept ; bool operator < ( const ServiceDescription & rhs ) const noexcept ; ServiceDescription & operator = ( const ServiceDescription & ) noexcept = default ; ServiceDescription & operator = ( ServiceDescription && ) noexcept = default ; explicit operator cxx :: Serialization () const noexcept ; static cxx :: expected < ServiceDescription , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; // @brief Returns if this service description is used for an RouDi-internal channel bool isLocal () const noexcept ; // @brief Set this service description to be is used for an RouDi-internal channel void setLocal () noexcept ; Scope getScope () const noexcept ; const IdString_t & getServiceIDString () const noexcept ; const IdString_t & getInstanceIDString () const noexcept ; const IdString_t & getEventIDString () const noexcept ; ClassHash getClassHash () const noexcept ; Interfaces getSourceInterface () const noexcept ; private : IdString_t m_serviceString ; IdString_t m_instanceString ; IdString_t m_eventString ; ClassHash m_classHash { 0 , 0 , 0 , 0 }; Scope m_scope { Scope :: WORLDWIDE }; Interfaces m_interfaceSource { Interfaces :: INTERNAL }; }; bool serviceMatch ( const ServiceDescription & first , const ServiceDescription & second ) noexcept ; std :: ostream & operator << ( std :: ostream & stream , const ServiceDescription & service ) noexcept ; log :: LogStream & operator << ( log :: LogStream & stream , const ServiceDescription & service ) noexcept ; } // namespace capro } // namespace iox #endif // IOX_POSH_CAPRO_SERVICE_DESCRIPTION_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/service__discovery_8hpp/","text":"iceoryx_posh/runtime/service_discovery.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo iox::runtime Classes \ud83d\udd17 Name class iox::runtime::ServiceDiscovery Source code \ud83d\udd17 // Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP #define IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/roudi/service_registry.hpp\" #include \"iceoryx_posh/popo/subscriber.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" #include <memory> #include <mutex> namespace iox { namespace popo { enum class MessagingPattern { PUB_SUB , REQ_RES }; } // namespace popo namespace runtime { enum class ServiceDiscoveryEvent : popo :: EventEnumIdentifier { SERVICE_REGISTRY_CHANGED }; class ServiceDiscovery { public : ServiceDiscovery () noexcept ; ServiceDiscovery ( const ServiceDiscovery & ) = delete ; ServiceDiscovery & operator = ( const ServiceDiscovery & ) = delete ; ServiceDiscovery ( ServiceDiscovery && ) = delete ; ServiceDiscovery & operator = ( ServiceDiscovery && ) = delete ; ~ ServiceDiscovery () noexcept = default ; void findService ( const cxx :: optional < capro :: IdString_t >& service , const cxx :: optional < capro :: IdString_t >& instance , const cxx :: optional < capro :: IdString_t >& event , const cxx :: function_ref < void ( const capro :: ServiceDescription & ) >& callableForEach , const popo :: MessagingPattern pattern ) noexcept ; friend iox :: popo :: NotificationAttorney ; private : void enableEvent ( popo :: TriggerHandle && triggerHandle , const ServiceDiscoveryEvent event ) noexcept ; void disableEvent ( const ServiceDiscoveryEvent event ) noexcept ; void invalidateTrigger ( const uint64_t uniqueTriggerId ); iox :: popo :: WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const popo :: SubscriberState state ); // use dynamic memory to reduce stack usage std :: unique_ptr < roudi :: ServiceRegistry > m_serviceRegistry { new iox :: roudi :: ServiceRegistry }; std :: mutex m_serviceRegistryMutex ; popo :: Subscriber < roudi :: ServiceRegistry > m_serviceRegistrySubscriber { { SERVICE_DISCOVERY_SERVICE_NAME , SERVICE_DISCOVERY_INSTANCE_NAME , SERVICE_DISCOVERY_EVENT_NAME }, { 1U , 1U , iox :: NodeName_t ( \"Service Registry\" ), true }}; void update (); }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/runtime/service_discovery.hpp"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#iceoryx_poshruntimeservice_discoveryhpp","text":"","title":"iceoryx_posh/runtime/service_discovery.hpp"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#namespaces","text":"Name iox iox::popo iox::runtime","title":"Namespaces"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#classes","text":"Name class iox::runtime::ServiceDiscovery","title":"Classes"},{"location":"API-reference/posh/Files/service__discovery_8hpp/#source-code","text":"// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP #define IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/roudi/service_registry.hpp\" #include \"iceoryx_posh/popo/subscriber.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" #include <memory> #include <mutex> namespace iox { namespace popo { enum class MessagingPattern { PUB_SUB , REQ_RES }; } // namespace popo namespace runtime { enum class ServiceDiscoveryEvent : popo :: EventEnumIdentifier { SERVICE_REGISTRY_CHANGED }; class ServiceDiscovery { public : ServiceDiscovery () noexcept ; ServiceDiscovery ( const ServiceDiscovery & ) = delete ; ServiceDiscovery & operator = ( const ServiceDiscovery & ) = delete ; ServiceDiscovery ( ServiceDiscovery && ) = delete ; ServiceDiscovery & operator = ( ServiceDiscovery && ) = delete ; ~ ServiceDiscovery () noexcept = default ; void findService ( const cxx :: optional < capro :: IdString_t >& service , const cxx :: optional < capro :: IdString_t >& instance , const cxx :: optional < capro :: IdString_t >& event , const cxx :: function_ref < void ( const capro :: ServiceDescription & ) >& callableForEach , const popo :: MessagingPattern pattern ) noexcept ; friend iox :: popo :: NotificationAttorney ; private : void enableEvent ( popo :: TriggerHandle && triggerHandle , const ServiceDiscoveryEvent event ) noexcept ; void disableEvent ( const ServiceDiscoveryEvent event ) noexcept ; void invalidateTrigger ( const uint64_t uniqueTriggerId ); iox :: popo :: WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const popo :: SubscriberState state ); // use dynamic memory to reduce stack usage std :: unique_ptr < roudi :: ServiceRegistry > m_serviceRegistry { new iox :: roudi :: ServiceRegistry }; std :: mutex m_serviceRegistryMutex ; popo :: Subscriber < roudi :: ServiceRegistry > m_serviceRegistrySubscriber { { SERVICE_DISCOVERY_SERVICE_NAME , SERVICE_DISCOVERY_INSTANCE_NAME , SERVICE_DISCOVERY_EVENT_NAME }, { 1U , 1U , iox :: NodeName_t ( \"Service Registry\" ), true }}; void update (); }; } // namespace runtime } // namespace iox #endif // IOX_POSH_RUNTIME_SERVICE_DISCOVERY_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/subscriber_8hpp/","text":"iceoryx_posh/popo/subscriber.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::Subscriber The Subscriber class for the publish-subscribe messaging pattern in iceoryx. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP #define IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP #include \"iceoryx_posh/internal/popo/subscriber_impl.hpp\" namespace iox { namespace popo { template < typename T , typename H = mepoo :: NoUserHeader > class Subscriber : public SubscriberImpl < T , H > { using Impl = SubscriberImpl < T , H > ; public : using SubscriberImpl < T , H >:: SubscriberImpl ; virtual ~ Subscriber () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/subscriber.hpp"},{"location":"API-reference/posh/Files/subscriber_8hpp/#iceoryx_poshpoposubscriberhpp","text":"","title":"iceoryx_posh/popo/subscriber.hpp"},{"location":"API-reference/posh/Files/subscriber_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/subscriber_8hpp/#classes","text":"Name class iox::popo::Subscriber The Subscriber class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/subscriber_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP #define IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP #include \"iceoryx_posh/internal/popo/subscriber_impl.hpp\" namespace iox { namespace popo { template < typename T , typename H = mepoo :: NoUserHeader > class Subscriber : public SubscriberImpl < T , H > { using Impl = SubscriberImpl < T , H > ; public : using SubscriberImpl < T , H >:: SubscriberImpl ; virtual ~ Subscriber () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_TYPED_SUBSCRIBER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/subscriber__impl_8hpp/","text":"iceoryx_posh/internal/popo/subscriber_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::SubscriberImpl The SubscriberImpl class implements the typed subscriber API. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_SUBSCRIBER_IMPL_HPP #define IOX_POSH_POPO_TYPED_SUBSCRIBER_IMPL_HPP #include \"iceoryx_posh/internal/popo/base_subscriber.hpp\" #include \"iceoryx_posh/internal/popo/sample_deleter.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" namespace iox { namespace popo { template < typename T , typename H = iox :: mepoo :: NoUserHeader , typename BaseSubscriberType = BaseSubscriber <>> class SubscriberImpl : public BaseSubscriberType { using SelfType = SubscriberImpl < T , H , BaseSubscriberType > ; using DataTypeAssert = typename TypedPortApiTrait < T >:: Assert ; using HeaderTypeAssert = typename TypedPortApiTrait < H >:: Assert ; public : explicit SubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions ()) noexcept ; SubscriberImpl ( const SubscriberImpl & other ) = delete ; SubscriberImpl & operator = ( const SubscriberImpl & ) = delete ; SubscriberImpl ( SubscriberImpl && rhs ) = delete ; SubscriberImpl & operator = ( SubscriberImpl && rhs ) = delete ; virtual ~ SubscriberImpl () noexcept ; cxx :: expected < Sample < const T , const H > , ChunkReceiveResult > take () noexcept ; using PortType = typename BaseSubscriberType :: PortType ; using SubscriberSampleDeleter = SampleDeleter < PortType > ; protected : using BaseSubscriberType :: port ; private : SubscriberSampleDeleter m_sampleDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/subscriber_impl.inl\" #endif // IOX_POSH_POPO_TYPED_SUBSCRIBER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/subscriber_impl.hpp"},{"location":"API-reference/posh/Files/subscriber__impl_8hpp/#iceoryx_poshinternalpoposubscriber_implhpp","text":"","title":"iceoryx_posh/internal/popo/subscriber_impl.hpp"},{"location":"API-reference/posh/Files/subscriber__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/subscriber__impl_8hpp/#classes","text":"Name class iox::popo::SubscriberImpl The SubscriberImpl class implements the typed subscriber API.","title":"Classes"},{"location":"API-reference/posh/Files/subscriber__impl_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TYPED_SUBSCRIBER_IMPL_HPP #define IOX_POSH_POPO_TYPED_SUBSCRIBER_IMPL_HPP #include \"iceoryx_posh/internal/popo/base_subscriber.hpp\" #include \"iceoryx_posh/internal/popo/sample_deleter.hpp\" #include \"iceoryx_posh/internal/popo/typed_port_api_trait.hpp\" namespace iox { namespace popo { template < typename T , typename H = iox :: mepoo :: NoUserHeader , typename BaseSubscriberType = BaseSubscriber <>> class SubscriberImpl : public BaseSubscriberType { using SelfType = SubscriberImpl < T , H , BaseSubscriberType > ; using DataTypeAssert = typename TypedPortApiTrait < T >:: Assert ; using HeaderTypeAssert = typename TypedPortApiTrait < H >:: Assert ; public : explicit SubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions ()) noexcept ; SubscriberImpl ( const SubscriberImpl & other ) = delete ; SubscriberImpl & operator = ( const SubscriberImpl & ) = delete ; SubscriberImpl ( SubscriberImpl && rhs ) = delete ; SubscriberImpl & operator = ( SubscriberImpl && rhs ) = delete ; virtual ~ SubscriberImpl () noexcept ; cxx :: expected < Sample < const T , const H > , ChunkReceiveResult > take () noexcept ; using PortType = typename BaseSubscriberType :: PortType ; using SubscriberSampleDeleter = SampleDeleter < PortType > ; protected : using BaseSubscriberType :: port ; private : SubscriberSampleDeleter m_sampleDeleter { port ()}; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/subscriber_impl.inl\" #endif // IOX_POSH_POPO_TYPED_SUBSCRIBER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/","text":"iceoryx_posh/popo/subscriber_options.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name struct iox::popo::SubscriberOptions This struct is used to configure the subscriber. Source code \ud83d\udd17 // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP #define IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP #include \"iceoryx_posh/internal/popo/ports/pub_sub_port_types.hpp\" #include \"port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct SubscriberOptions { uint64_t queueCapacity { SubscriberChunkQueueData_t :: MAX_CAPACITY }; uint64_t historyRequest { 0U }; iox :: NodeName_t nodeName { \"\" }; bool subscribeOnCreate { true }; QueueFullPolicy queueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; bool requiresPublisherHistorySupport { false }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < SubscriberOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/subscriber_options.hpp"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#iceoryx_poshpoposubscriber_optionshpp","text":"","title":"iceoryx_posh/popo/subscriber_options.hpp"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#classes","text":"Name struct iox::popo::SubscriberOptions This struct is used to configure the subscriber.","title":"Classes"},{"location":"API-reference/posh/Files/subscriber__options_8hpp/#source-code","text":"// Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP #define IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP #include \"iceoryx_posh/internal/popo/ports/pub_sub_port_types.hpp\" #include \"port_queue_policies.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include <cstdint> namespace iox { namespace popo { struct SubscriberOptions { uint64_t queueCapacity { SubscriberChunkQueueData_t :: MAX_CAPACITY }; uint64_t historyRequest { 0U }; iox :: NodeName_t nodeName { \"\" }; bool subscribeOnCreate { true }; QueueFullPolicy queueFullPolicy { QueueFullPolicy :: DISCARD_OLDEST_DATA }; bool requiresPublisherHistorySupport { false }; cxx :: Serialization serialize () const noexcept ; static cxx :: expected < SubscriberOptions , cxx :: Serialization :: Error > deserialize ( const cxx :: Serialization & serialized ) noexcept ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_SUBSCRIBER_OPTIONS_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/","text":"iceoryx_posh/gateway/toml_gateway_config_parser.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::config Classes \ud83d\udd17 Name class iox::config::TomlGatewayConfigParser The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP #define IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/gateway/gateway_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cpptoml.h> #include <limits> // workaround for missing include in cpptoml.h namespace iox { namespace config { enum TomlGatewayConfigParseError { FILE_NOT_FOUND , INCOMPLETE_CONFIGURATION , INCOMPLETE_SERVICE_DESCRIPTION , INVALID_SERVICE_DESCRIPTION , EXCEPTION_IN_PARSER , MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED }; constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS [] = { \"FILE_NOT_FOUND\" , \"INCOMPLETE_CONFIGURATION\" , \"INCOMPLETE_SERVICE_DESCRIPTION\" , \"INVALID_SERVICE_DESCRIPTION\" , \"EXCEPTION_IN_PARSER\" , \"MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\" }; static constexpr const char REGEX_VALID_CHARACTERS [] = \"^[a-zA-Z_][a-zA-Z0-9_]*$\" ; static constexpr const char DEFAULT_CONFIG_FILE_PATH [] = \"/etc/iceoryx/gateway_config.toml\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME [] = \"services\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_NAME [] = \"service\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME [] = \"instance\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME [] = \"event\" ; class TomlGatewayConfigParser { public : static cxx :: expected < GatewayConfig , TomlGatewayConfigParseError > parse ( const roudi :: ConfigFilePathString_t & path = roudi :: ConfigFilePathString_t ( DEFAULT_CONFIG_FILE_PATH )) noexcept ; protected : static cxx :: expected < TomlGatewayConfigParseError > validate ( const cpptoml :: table & parsedToml ) noexcept ; private : static bool hasInvalidCharacter ( const std :: string & s ) noexcept ; }; } // namespace config } // namespace iox #endif // IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/gateway/toml_gateway_config_parser.hpp"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#iceoryx_poshgatewaytoml_gateway_config_parserhpp","text":"","title":"iceoryx_posh/gateway/toml_gateway_config_parser.hpp"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#namespaces","text":"Name iox iox::config","title":"Namespaces"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#classes","text":"Name class iox::config::TomlGatewayConfigParser The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files.","title":"Classes"},{"location":"API-reference/posh/Files/toml__gateway__config__parser_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP #define IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_posh/gateway/gateway_config.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include <cpptoml.h> #include <limits> // workaround for missing include in cpptoml.h namespace iox { namespace config { enum TomlGatewayConfigParseError { FILE_NOT_FOUND , INCOMPLETE_CONFIGURATION , INCOMPLETE_SERVICE_DESCRIPTION , INVALID_SERVICE_DESCRIPTION , EXCEPTION_IN_PARSER , MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED }; constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS [] = { \"FILE_NOT_FOUND\" , \"INCOMPLETE_CONFIGURATION\" , \"INCOMPLETE_SERVICE_DESCRIPTION\" , \"INVALID_SERVICE_DESCRIPTION\" , \"EXCEPTION_IN_PARSER\" , \"MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\" }; static constexpr const char REGEX_VALID_CHARACTERS [] = \"^[a-zA-Z_][a-zA-Z0-9_]*$\" ; static constexpr const char DEFAULT_CONFIG_FILE_PATH [] = \"/etc/iceoryx/gateway_config.toml\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME [] = \"services\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_NAME [] = \"service\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME [] = \"instance\" ; static constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME [] = \"event\" ; class TomlGatewayConfigParser { public : static cxx :: expected < GatewayConfig , TomlGatewayConfigParseError > parse ( const roudi :: ConfigFilePathString_t & path = roudi :: ConfigFilePathString_t ( DEFAULT_CONFIG_FILE_PATH )) noexcept ; protected : static cxx :: expected < TomlGatewayConfigParseError > validate ( const cpptoml :: table & parsedToml ) noexcept ; private : static bool hasInvalidCharacter ( const std :: string & s ) noexcept ; }; } // namespace config } // namespace iox #endif // IOX_POSH_GW_TOML_FILE_CONFIG_PARSER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/trigger_8hpp/","text":"iceoryx_posh/popo/trigger.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name struct iox::popo::StateBasedTrigger_t struct iox::popo::EventBasedTrigger_t class iox::popo::Trigger The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance. Source code \ud83d\udd17 // Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TRIGGER_HPP #define IOX_POSH_POPO_TRIGGER_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include \"iceoryx_posh/popo/notification_info.hpp\" #include <type_traits> #include <typeinfo> namespace iox { namespace popo { struct StateBasedTrigger_t { }; constexpr StateBasedTrigger_t StateBasedTrigger {}; struct EventBasedTrigger_t { }; constexpr EventBasedTrigger_t EventBasedTrigger {}; enum class TriggerType { STATE_BASED , EVENT_BASED , INVALID }; class Trigger { public : static constexpr uint64_t INVALID_TRIGGER_ID = std :: numeric_limits < uint64_t >:: max (); Trigger () noexcept = delete ; Trigger ( const Trigger & ) = delete ; Trigger & operator = ( const Trigger & ) = delete ; template < typename T , typename UserType > Trigger ( StateBasedTrigger_t , T * const stateOrigin , const cxx :: ConstMethodCallback < bool >& hasTriggeredCallback , const cxx :: MethodCallback < void , uint64_t >& resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType >& callback , const uint64_t uniqueId , const uint64_t stateType , const uint64_t stateTypeHash ) noexcept ; template < typename T , typename UserType > Trigger ( EventBasedTrigger_t , T * const notificationOrigin , const cxx :: MethodCallback < void , uint64_t >& resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType >& callback , const uint64_t uniqueId , const uint64_t notificationType , const uint64_t notificationTypeHash ) noexcept ; Trigger ( Trigger && rhs ) noexcept ; Trigger & operator = ( Trigger && rhs ) noexcept ; ~ Trigger () noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; bool isStateConditionSatisfied () const noexcept ; void reset () noexcept ; void invalidate () noexcept ; uint64_t getUniqueId () const noexcept ; bool isLogicalEqualTo ( const void * const notificationOrigin , const uint64_t originTriggerType , const uint64_t originTriggerTypeHash ) const noexcept ; template < typename T > void updateOrigin ( T & newOrigin ) noexcept ; const NotificationInfo & getNotificationInfo () const noexcept ; TriggerType getTriggerType () const noexcept ; private : template < typename T , typename ContextDataType > Trigger ( T * const notificationOrigin , const cxx :: ConstMethodCallback < bool >& hasTriggeredCallback , const cxx :: MethodCallback < void , uint64_t >& resetCallback , const uint64_t notificationId , const NotificationCallback < T , ContextDataType >& callback , const uint64_t uniqueId , const TriggerType triggerType , const uint64_t originTriggerType , const uint64_t originTriggerTypeHash ) noexcept ; private : NotificationInfo m_notificationInfo ; cxx :: ConstMethodCallback < bool > m_hasTriggeredCallback ; cxx :: MethodCallback < void , uint64_t > m_resetCallback ; uint64_t m_uniqueId = INVALID_TRIGGER_ID ; TriggerType m_triggerType = TriggerType :: STATE_BASED ; uint64_t m_originTriggerType = INVALID_TRIGGER_ID ; uint64_t m_originTriggerTypeHash = INVALID_TRIGGER_ID ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/trigger.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/trigger.hpp"},{"location":"API-reference/posh/Files/trigger_8hpp/#iceoryx_poshpopotriggerhpp","text":"","title":"iceoryx_posh/popo/trigger.hpp"},{"location":"API-reference/posh/Files/trigger_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/trigger_8hpp/#classes","text":"Name struct iox::popo::StateBasedTrigger_t struct iox::popo::EventBasedTrigger_t class iox::popo::Trigger The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance.","title":"Classes"},{"location":"API-reference/posh/Files/trigger_8hpp/#source-code","text":"// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TRIGGER_HPP #define IOX_POSH_POPO_TRIGGER_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include \"iceoryx_posh/popo/notification_info.hpp\" #include <type_traits> #include <typeinfo> namespace iox { namespace popo { struct StateBasedTrigger_t { }; constexpr StateBasedTrigger_t StateBasedTrigger {}; struct EventBasedTrigger_t { }; constexpr EventBasedTrigger_t EventBasedTrigger {}; enum class TriggerType { STATE_BASED , EVENT_BASED , INVALID }; class Trigger { public : static constexpr uint64_t INVALID_TRIGGER_ID = std :: numeric_limits < uint64_t >:: max (); Trigger () noexcept = delete ; Trigger ( const Trigger & ) = delete ; Trigger & operator = ( const Trigger & ) = delete ; template < typename T , typename UserType > Trigger ( StateBasedTrigger_t , T * const stateOrigin , const cxx :: ConstMethodCallback < bool >& hasTriggeredCallback , const cxx :: MethodCallback < void , uint64_t >& resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType >& callback , const uint64_t uniqueId , const uint64_t stateType , const uint64_t stateTypeHash ) noexcept ; template < typename T , typename UserType > Trigger ( EventBasedTrigger_t , T * const notificationOrigin , const cxx :: MethodCallback < void , uint64_t >& resetCallback , const uint64_t notificationId , const NotificationCallback < T , UserType >& callback , const uint64_t uniqueId , const uint64_t notificationType , const uint64_t notificationTypeHash ) noexcept ; Trigger ( Trigger && rhs ) noexcept ; Trigger & operator = ( Trigger && rhs ) noexcept ; ~ Trigger () noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; bool isStateConditionSatisfied () const noexcept ; void reset () noexcept ; void invalidate () noexcept ; uint64_t getUniqueId () const noexcept ; bool isLogicalEqualTo ( const void * const notificationOrigin , const uint64_t originTriggerType , const uint64_t originTriggerTypeHash ) const noexcept ; template < typename T > void updateOrigin ( T & newOrigin ) noexcept ; const NotificationInfo & getNotificationInfo () const noexcept ; TriggerType getTriggerType () const noexcept ; private : template < typename T , typename ContextDataType > Trigger ( T * const notificationOrigin , const cxx :: ConstMethodCallback < bool >& hasTriggeredCallback , const cxx :: MethodCallback < void , uint64_t >& resetCallback , const uint64_t notificationId , const NotificationCallback < T , ContextDataType >& callback , const uint64_t uniqueId , const TriggerType triggerType , const uint64_t originTriggerType , const uint64_t originTriggerTypeHash ) noexcept ; private : NotificationInfo m_notificationInfo ; cxx :: ConstMethodCallback < bool > m_hasTriggeredCallback ; cxx :: MethodCallback < void , uint64_t > m_resetCallback ; uint64_t m_uniqueId = INVALID_TRIGGER_ID ; TriggerType m_triggerType = TriggerType :: STATE_BASED ; uint64_t m_originTriggerType = INVALID_TRIGGER_ID ; uint64_t m_originTriggerTypeHash = INVALID_TRIGGER_ID ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/trigger.inl\" #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/","text":"iceoryx_posh/popo/trigger_handle.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::TriggerHandle TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable. Source code \ud83d\udd17 // Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TRIGGER_HANDLE_HPP #define IOX_POSH_POPO_TRIGGER_HANDLE_HPP #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/popo/trigger.hpp\" #include <limits> #include <mutex> namespace iox { namespace popo { class TriggerHandle { public : TriggerHandle () noexcept ; TriggerHandle ( ConditionVariableData & conditionVariableData , const cxx :: MethodCallback < void , uint64_t > resetCallback , const uint64_t uniqueTriggerId ) noexcept ; TriggerHandle ( const TriggerHandle & ) = delete ; TriggerHandle & operator = ( const TriggerHandle & ) = delete ; TriggerHandle ( TriggerHandle && rhs ) noexcept ; TriggerHandle & operator = ( TriggerHandle && rhs ) noexcept ; ~ TriggerHandle () noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; bool wasTriggered () const noexcept ; void trigger () noexcept ; void reset () noexcept ; void invalidate () noexcept ; uint64_t getUniqueId () const noexcept ; ConditionVariableData * getConditionVariableData () noexcept ; private : ConditionVariableData * m_conditionVariableDataPtr = nullptr ; cxx :: MethodCallback < void , uint64_t > m_resetCallback ; uint64_t m_uniqueTriggerId = Trigger :: INVALID_TRIGGER_ID ; mutable std :: recursive_mutex m_mutex ; }; } // namespace popo } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/trigger_handle.hpp"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#iceoryx_poshpopotrigger_handlehpp","text":"","title":"iceoryx_posh/popo/trigger_handle.hpp"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#classes","text":"Name class iox::popo::TriggerHandle TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable.","title":"Classes"},{"location":"API-reference/posh/Files/trigger__handle_8hpp/#source-code","text":"// Copyright (c) 2020, 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_TRIGGER_HANDLE_HPP #define IOX_POSH_POPO_TRIGGER_HANDLE_HPP #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/popo/trigger.hpp\" #include <limits> #include <mutex> namespace iox { namespace popo { class TriggerHandle { public : TriggerHandle () noexcept ; TriggerHandle ( ConditionVariableData & conditionVariableData , const cxx :: MethodCallback < void , uint64_t > resetCallback , const uint64_t uniqueTriggerId ) noexcept ; TriggerHandle ( const TriggerHandle & ) = delete ; TriggerHandle & operator = ( const TriggerHandle & ) = delete ; TriggerHandle ( TriggerHandle && rhs ) noexcept ; TriggerHandle & operator = ( TriggerHandle && rhs ) noexcept ; ~ TriggerHandle () noexcept ; explicit operator bool () const noexcept ; bool isValid () const noexcept ; bool wasTriggered () const noexcept ; void trigger () noexcept ; void reset () noexcept ; void invalidate () noexcept ; uint64_t getUniqueId () const noexcept ; ConditionVariableData * getConditionVariableData () noexcept ; private : ConditionVariableData * m_conditionVariableDataPtr = nullptr ; cxx :: MethodCallback < void , uint64_t > m_resetCallback ; uint64_t m_uniqueTriggerId = Trigger :: INVALID_TRIGGER_ID ; mutable std :: recursive_mutex m_mutex ; }; } // namespace popo } // namespace iox #endif Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__client_8hpp/","text":"iceoryx_posh/popo/untyped_client.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedClient Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_CLIENT_HPP #define IOX_POSH_POPO_UNTYPED_CLIENT_HPP #include \"iceoryx_posh/internal/popo/untyped_client_impl.hpp\" namespace iox { namespace popo { class UntypedClient : public UntypedClientImpl <> { using Impl = UntypedClientImpl <> ; public : using UntypedClientImpl <>:: UntypedClientImpl ; virtual ~ UntypedClient () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_CLIENT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/untyped_client.hpp"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#iceoryx_poshpopountyped_clienthpp","text":"","title":"iceoryx_posh/popo/untyped_client.hpp"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#classes","text":"Name class iox::popo::UntypedClient","title":"Classes"},{"location":"API-reference/posh/Files/untyped__client_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_CLIENT_HPP #define IOX_POSH_POPO_UNTYPED_CLIENT_HPP #include \"iceoryx_posh/internal/popo/untyped_client_impl.hpp\" namespace iox { namespace popo { class UntypedClient : public UntypedClientImpl <> { using Impl = UntypedClientImpl <> ; public : using UntypedClientImpl <>:: UntypedClientImpl ; virtual ~ UntypedClient () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_CLIENT_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__client__impl_8hpp/","text":"iceoryx_posh/internal/popo/untyped_client_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedClientImpl The UntypedClientImpl class implements the untyped client API. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_CLIENT_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_CLIENT_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_client.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { template < typename BaseClientT = BaseClient <>> class UntypedClientImpl : public BaseClientT { public : explicit UntypedClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {}) noexcept ; virtual ~ UntypedClientImpl () noexcept ; UntypedClientImpl ( const UntypedClientImpl & ) = delete ; UntypedClientImpl ( UntypedClientImpl && ) = delete ; UntypedClientImpl & operator = ( const UntypedClientImpl & ) = delete ; UntypedClientImpl & operator = ( UntypedClientImpl && ) = delete ; cxx :: expected < void * , AllocationError > loan ( const uint32_t payloadSize , const uint32_t payloadAlignment ) noexcept ; void releaseRequest ( void * const requestPayload ) noexcept ; cxx :: expected < ClientSendError > send ( void * const requestPayload ) noexcept ; cxx :: expected < const void * , ChunkReceiveResult > take () noexcept ; void releaseResponse ( const void * const responsePayload ) noexcept ; protected : using BaseClientT :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_client_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_CLIENT_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/untyped_client_impl.hpp"},{"location":"API-reference/posh/Files/untyped__client__impl_8hpp/#iceoryx_poshinternalpopountyped_client_implhpp","text":"","title":"iceoryx_posh/internal/popo/untyped_client_impl.hpp"},{"location":"API-reference/posh/Files/untyped__client__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__client__impl_8hpp/#classes","text":"Name class iox::popo::UntypedClientImpl The UntypedClientImpl class implements the untyped client API.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__client__impl_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_CLIENT_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_CLIENT_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_client.hpp\" #include \"iceoryx_posh/popo/client_options.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" namespace iox { namespace popo { template < typename BaseClientT = BaseClient <>> class UntypedClientImpl : public BaseClientT { public : explicit UntypedClientImpl ( const capro :: ServiceDescription & service , const ClientOptions & clientOptions = {}) noexcept ; virtual ~ UntypedClientImpl () noexcept ; UntypedClientImpl ( const UntypedClientImpl & ) = delete ; UntypedClientImpl ( UntypedClientImpl && ) = delete ; UntypedClientImpl & operator = ( const UntypedClientImpl & ) = delete ; UntypedClientImpl & operator = ( UntypedClientImpl && ) = delete ; cxx :: expected < void * , AllocationError > loan ( const uint32_t payloadSize , const uint32_t payloadAlignment ) noexcept ; void releaseRequest ( void * const requestPayload ) noexcept ; cxx :: expected < ClientSendError > send ( void * const requestPayload ) noexcept ; cxx :: expected < const void * , ChunkReceiveResult > take () noexcept ; void releaseResponse ( const void * const responsePayload ) noexcept ; protected : using BaseClientT :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_client_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_CLIENT_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/","text":"iceoryx_posh/popo/untyped_publisher.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedPublisher The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP #define IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP #include \"iceoryx_posh/internal/popo/untyped_publisher_impl.hpp\" namespace iox { namespace popo { class UntypedPublisher : public UntypedPublisherImpl <> { public : using UntypedPublisherImpl <>:: UntypedPublisherImpl ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/untyped_publisher.hpp"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#iceoryx_poshpopountyped_publisherhpp","text":"","title":"iceoryx_posh/popo/untyped_publisher.hpp"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#classes","text":"Name class iox::popo::UntypedPublisher The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__publisher_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP #define IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP #include \"iceoryx_posh/internal/popo/untyped_publisher_impl.hpp\" namespace iox { namespace popo { class UntypedPublisher : public UntypedPublisherImpl <> { public : using UntypedPublisherImpl <>:: UntypedPublisherImpl ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_PUBLISHER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__publisher__impl_8hpp/","text":"iceoryx_posh/internal/popo/untyped_publisher_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedPublisherImpl The UntypedPublisherImpl class implements the untyped publisher API. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_PUBLISHER_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_PUBLISHER_IMPL_HPP #include \"iceoryx_posh/internal/popo/base_publisher.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" namespace iox { namespace popo { template < typename BasePublisherType = BasePublisher <>> class UntypedPublisherImpl : public BasePublisherType { public : explicit UntypedPublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions ()); UntypedPublisherImpl ( const UntypedPublisherImpl & other ) = delete ; UntypedPublisherImpl & operator = ( const UntypedPublisherImpl & ) = delete ; UntypedPublisherImpl ( UntypedPublisherImpl && rhs ) = delete ; UntypedPublisherImpl & operator = ( UntypedPublisherImpl && rhs ) = delete ; virtual ~ UntypedPublisherImpl () = default ; cxx :: expected < void * , AllocationError > loan ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) noexcept ; void publish ( void * const userPayload ) noexcept ; void release ( void * const userPayload ) noexcept ; protected : using BasePublisherType :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_publisher_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_PUBLISHER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/untyped_publisher_impl.hpp"},{"location":"API-reference/posh/Files/untyped__publisher__impl_8hpp/#iceoryx_poshinternalpopountyped_publisher_implhpp","text":"","title":"iceoryx_posh/internal/popo/untyped_publisher_impl.hpp"},{"location":"API-reference/posh/Files/untyped__publisher__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__publisher__impl_8hpp/#classes","text":"Name class iox::popo::UntypedPublisherImpl The UntypedPublisherImpl class implements the untyped publisher API.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__publisher__impl_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_PUBLISHER_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_PUBLISHER_IMPL_HPP #include \"iceoryx_posh/internal/popo/base_publisher.hpp\" #include \"iceoryx_posh/popo/sample.hpp\" namespace iox { namespace popo { template < typename BasePublisherType = BasePublisher <>> class UntypedPublisherImpl : public BasePublisherType { public : explicit UntypedPublisherImpl ( const capro :: ServiceDescription & service , const PublisherOptions & publisherOptions = PublisherOptions ()); UntypedPublisherImpl ( const UntypedPublisherImpl & other ) = delete ; UntypedPublisherImpl & operator = ( const UntypedPublisherImpl & ) = delete ; UntypedPublisherImpl ( UntypedPublisherImpl && rhs ) = delete ; UntypedPublisherImpl & operator = ( UntypedPublisherImpl && rhs ) = delete ; virtual ~ UntypedPublisherImpl () = default ; cxx :: expected < void * , AllocationError > loan ( const uint32_t userPayloadSize , const uint32_t userPayloadAlignment = iox :: CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT , const uint32_t userHeaderSize = iox :: CHUNK_NO_USER_HEADER_SIZE , const uint32_t userHeaderAlignment = iox :: CHUNK_NO_USER_HEADER_ALIGNMENT ) noexcept ; void publish ( void * const userPayload ) noexcept ; void release ( void * const userPayload ) noexcept ; protected : using BasePublisherType :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_publisher_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_PUBLISHER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__server_8hpp/","text":"iceoryx_posh/popo/untyped_server.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedServer Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SERVER_HPP #define IOX_POSH_POPO_UNTYPED_SERVER_HPP #include \"iceoryx_posh/internal/popo/untyped_server_impl.hpp\" namespace iox { namespace popo { class UntypedServer : public UntypedServerImpl <> { using Impl = UntypedServerImpl <> ; public : using UntypedServerImpl <>:: UntypedServerImpl ; virtual ~ UntypedServer () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_SERVER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/untyped_server.hpp"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#iceoryx_poshpopountyped_serverhpp","text":"","title":"iceoryx_posh/popo/untyped_server.hpp"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#classes","text":"Name class iox::popo::UntypedServer","title":"Classes"},{"location":"API-reference/posh/Files/untyped__server_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SERVER_HPP #define IOX_POSH_POPO_UNTYPED_SERVER_HPP #include \"iceoryx_posh/internal/popo/untyped_server_impl.hpp\" namespace iox { namespace popo { class UntypedServer : public UntypedServerImpl <> { using Impl = UntypedServerImpl <> ; public : using UntypedServerImpl <>:: UntypedServerImpl ; virtual ~ UntypedServer () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_SERVER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__server__impl_8hpp/","text":"iceoryx_posh/internal/popo/untyped_server_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedServerImpl The UntypedServerImpl class implements the untyped server API. Source code \ud83d\udd17 // Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SERVER_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_SERVER_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_server.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" namespace iox { namespace popo { template < typename BaseServerT = BaseServer <>> class UntypedServerImpl : public BaseServerT { public : explicit UntypedServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {}) noexcept ; virtual ~ UntypedServerImpl () noexcept ; UntypedServerImpl ( const UntypedServerImpl & ) = delete ; UntypedServerImpl ( UntypedServerImpl && ) = delete ; UntypedServerImpl & operator = ( const UntypedServerImpl & ) = delete ; UntypedServerImpl & operator = ( UntypedServerImpl && ) = delete ; cxx :: expected < const void * , ServerRequestResult > take () noexcept ; void releaseRequest ( const void * const requestPayload ) noexcept ; cxx :: expected < void * , AllocationError > loan ( const RequestHeader * const requestHeader , const uint32_t payloadSize , const uint32_t payloadAlignment ) noexcept ; cxx :: expected < ServerSendError > send ( void * const responsePayload ) noexcept ; void releaseResponse ( void * const responsePayload ) noexcept ; protected : using BaseServerT :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_server_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_SERVER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/untyped_server_impl.hpp"},{"location":"API-reference/posh/Files/untyped__server__impl_8hpp/#iceoryx_poshinternalpopountyped_server_implhpp","text":"","title":"iceoryx_posh/internal/popo/untyped_server_impl.hpp"},{"location":"API-reference/posh/Files/untyped__server__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__server__impl_8hpp/#classes","text":"Name class iox::popo::UntypedServerImpl The UntypedServerImpl class implements the untyped server API.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__server__impl_8hpp/#source-code","text":"// Copyright (c) 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SERVER_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_SERVER_IMPL_HPP #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/internal/popo/base_server.hpp\" #include \"iceoryx_posh/popo/server_options.hpp\" namespace iox { namespace popo { template < typename BaseServerT = BaseServer <>> class UntypedServerImpl : public BaseServerT { public : explicit UntypedServerImpl ( const capro :: ServiceDescription & service , const ServerOptions & serverOptions = {}) noexcept ; virtual ~ UntypedServerImpl () noexcept ; UntypedServerImpl ( const UntypedServerImpl & ) = delete ; UntypedServerImpl ( UntypedServerImpl && ) = delete ; UntypedServerImpl & operator = ( const UntypedServerImpl & ) = delete ; UntypedServerImpl & operator = ( UntypedServerImpl && ) = delete ; cxx :: expected < const void * , ServerRequestResult > take () noexcept ; void releaseRequest ( const void * const requestPayload ) noexcept ; cxx :: expected < void * , AllocationError > loan ( const RequestHeader * const requestHeader , const uint32_t payloadSize , const uint32_t payloadAlignment ) noexcept ; cxx :: expected < ServerSendError > send ( void * const responsePayload ) noexcept ; void releaseResponse ( void * const responsePayload ) noexcept ; protected : using BaseServerT :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_server_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_SERVER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/","text":"iceoryx_posh/popo/untyped_subscriber.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UntypedSubscriber The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP #define IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP #include \"iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp\" namespace iox { namespace popo { class UntypedSubscriber : public UntypedSubscriberImpl <> { using Impl = UntypedSubscriberImpl <> ; public : using UntypedSubscriberImpl <>:: UntypedSubscriberImpl ; virtual ~ UntypedSubscriber () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/untyped_subscriber.hpp"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#iceoryx_poshpopountyped_subscriberhpp","text":"","title":"iceoryx_posh/popo/untyped_subscriber.hpp"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#classes","text":"Name class iox::popo::UntypedSubscriber The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__subscriber_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP #define IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP #include \"iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp\" namespace iox { namespace popo { class UntypedSubscriber : public UntypedSubscriberImpl <> { using Impl = UntypedSubscriberImpl <> ; public : using UntypedSubscriberImpl <>:: UntypedSubscriberImpl ; virtual ~ UntypedSubscriber () noexcept { Impl :: m_trigger . reset (); } }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_UNTYPED_SUBSCRIBER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/untyped__subscriber__impl_8hpp/","text":"iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::Void class iox::popo::UntypedSubscriberImpl The UntypedSubscriberImpl class implements the untyped subscriber API. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SUBSCRIBER_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_SUBSCRIBER_IMPL_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/base_subscriber.hpp\" namespace iox { namespace popo { class Void { }; template < typename BaseSubscriberType = BaseSubscriber <>> class UntypedSubscriberImpl : public BaseSubscriberType { public : using BaseSubscriber = BaseSubscriberType ; using SelfType = UntypedSubscriberImpl < BaseSubscriberType > ; explicit UntypedSubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions ()); UntypedSubscriberImpl ( const UntypedSubscriberImpl & other ) = delete ; UntypedSubscriberImpl & operator = ( const UntypedSubscriberImpl & ) = delete ; UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs ) = delete ; UntypedSubscriberImpl & operator = ( UntypedSubscriberImpl && rhs ) = delete ; virtual ~ UntypedSubscriberImpl () noexcept ; cxx :: expected < const void * , ChunkReceiveResult > take () noexcept ; void release ( const void * const userPayload ) noexcept ; protected : using BaseSubscriber :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_subscriber_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_SUBSCRIBER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp"},{"location":"API-reference/posh/Files/untyped__subscriber__impl_8hpp/#iceoryx_poshinternalpopountyped_subscriber_implhpp","text":"","title":"iceoryx_posh/internal/popo/untyped_subscriber_impl.hpp"},{"location":"API-reference/posh/Files/untyped__subscriber__impl_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/untyped__subscriber__impl_8hpp/#classes","text":"Name class iox::popo::Void class iox::popo::UntypedSubscriberImpl The UntypedSubscriberImpl class implements the untyped subscriber API.","title":"Classes"},{"location":"API-reference/posh/Files/untyped__subscriber__impl_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2022 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_UNTYPED_SUBSCRIBER_IMPL_HPP #define IOX_POSH_POPO_UNTYPED_SUBSCRIBER_IMPL_HPP #include \"iceoryx_hoofs/cxx/expected.hpp\" #include \"iceoryx_hoofs/cxx/unique_ptr.hpp\" #include \"iceoryx_posh/capro/service_description.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/base_subscriber.hpp\" namespace iox { namespace popo { class Void { }; template < typename BaseSubscriberType = BaseSubscriber <>> class UntypedSubscriberImpl : public BaseSubscriberType { public : using BaseSubscriber = BaseSubscriberType ; using SelfType = UntypedSubscriberImpl < BaseSubscriberType > ; explicit UntypedSubscriberImpl ( const capro :: ServiceDescription & service , const SubscriberOptions & subscriberOptions = SubscriberOptions ()); UntypedSubscriberImpl ( const UntypedSubscriberImpl & other ) = delete ; UntypedSubscriberImpl & operator = ( const UntypedSubscriberImpl & ) = delete ; UntypedSubscriberImpl ( UntypedSubscriberImpl && rhs ) = delete ; UntypedSubscriberImpl & operator = ( UntypedSubscriberImpl && rhs ) = delete ; virtual ~ UntypedSubscriberImpl () noexcept ; cxx :: expected < const void * , ChunkReceiveResult > take () noexcept ; void release ( const void * const userPayload ) noexcept ; protected : using BaseSubscriber :: port ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/untyped_subscriber_impl.inl\" #endif // IOX_POSH_POPO_UNTYPED_SUBSCRIBER_IMPL_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/user__trigger_8hpp/","text":"iceoryx_posh/popo/user_trigger.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::UserTrigger An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class. Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_USER_TRIGGER_HPP #define IOX_POSH_POPO_USER_TRIGGER_HPP #include \"iceoryx_posh/popo/trigger.hpp\" #include \"iceoryx_posh/popo/wait_set.hpp\" #include <atomic> #include <mutex> namespace iox { namespace popo { class UserTrigger { public : UserTrigger () noexcept ; UserTrigger ( const UserTrigger & rhs ) = delete ; UserTrigger ( UserTrigger && rhs ) = delete ; UserTrigger & operator = ( const UserTrigger & rhs ) = delete ; UserTrigger & operator = ( UserTrigger && rhs ) = delete ; void trigger () noexcept ; bool hasTriggered () const noexcept ; friend class NotificationAttorney ; private : void invalidateTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle ) noexcept ; void disableEvent () noexcept ; private : TriggerHandle m_trigger ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_USER_TRIGGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/user_trigger.hpp"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#iceoryx_poshpopouser_triggerhpp","text":"","title":"iceoryx_posh/popo/user_trigger.hpp"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#classes","text":"Name class iox::popo::UserTrigger An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class.","title":"Classes"},{"location":"API-reference/posh/Files/user__trigger_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_USER_TRIGGER_HPP #define IOX_POSH_POPO_USER_TRIGGER_HPP #include \"iceoryx_posh/popo/trigger.hpp\" #include \"iceoryx_posh/popo/wait_set.hpp\" #include <atomic> #include <mutex> namespace iox { namespace popo { class UserTrigger { public : UserTrigger () noexcept ; UserTrigger ( const UserTrigger & rhs ) = delete ; UserTrigger ( UserTrigger && rhs ) = delete ; UserTrigger & operator = ( const UserTrigger & rhs ) = delete ; UserTrigger & operator = ( UserTrigger && rhs ) = delete ; void trigger () noexcept ; bool hasTriggered () const noexcept ; friend class NotificationAttorney ; private : void invalidateTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle ) noexcept ; void disableEvent () noexcept ; private : TriggerHandle m_trigger ; }; } // namespace popo } // namespace iox #endif // IOX_POSH_POPO_USER_TRIGGER_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/version__info_8hpp/","text":"iceoryx_posh/version/version_info.hpp \ud83d\udd17 Source code \ud83d\udd17 // Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_VERSION_VERSION_INFO_HPP #define IOX_POSH_VERSION_VERSION_INFO_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/version/compatibility_check_level.hpp\" #include \"iceoryx_versions.hpp\" #include <cstdint> namespace iox { namespace version { class VersionInfo { public : VersionInfo ( const uint16_t versionMajor , const uint16_t versionMinor , const uint16_t versionPatch , const uint16_t versionTweak , const BuildDateString_t & buildDateString , const CommitIdString_t & commitIdString ) noexcept ; VersionInfo ( const cxx :: Serialization & serial ) noexcept ; operator cxx :: Serialization () const noexcept ; bool operator == ( const VersionInfo & rhs ) const noexcept ; bool operator != ( const VersionInfo & rhs ) const noexcept ; bool checkCompatibility ( const VersionInfo & other , const CompatibilityCheckLevel compatibilityCheckLevel ) const noexcept ; bool isValid () noexcept ; static VersionInfo getCurrentVersion () noexcept ; protected : static const uint64_t SERIALIZATION_STRING_SIZE = 100u ; using SerializationString_t = cxx :: string < SERIALIZATION_STRING_SIZE > ; static_assert ( COMMIT_ID_STRING_SIZE <= SERIALIZATION_STRING_SIZE , \"CommitId needs to transfered completely.\" ); static_assert ( COMMIT_ID_STRING_SIZE <= BUILD_DATE_STRING_SIZE , \"BuildDate needs to transfered completely.\" ); static_assert ( cxx :: strlen2 ( ICEORYX_BUILDDATE ) < BUILD_DATE_STRING_SIZE , \"COMMIT_BUILD_DATE_STRING_SIZE needs to be bigger.\" ); protected : bool m_valid { true }; uint16_t m_versionMajor { 0u }; uint16_t m_versionMinor { 0u }; uint16_t m_versionPatch { 0u }; uint16_t m_versionTweak { 0u }; BuildDateString_t m_buildDateString ; CommitIdString_t m_commitIdString ; }; } // namespace version } // namespace iox #endif // IOX_POSH_VERSION_VERSION_INFO_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/version/version_info.hpp"},{"location":"API-reference/posh/Files/version__info_8hpp/#iceoryx_poshversionversion_infohpp","text":"","title":"iceoryx_posh/version/version_info.hpp"},{"location":"API-reference/posh/Files/version__info_8hpp/#source-code","text":"// Copyright (c) 2020 by Robert Bosch GmbH. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_VERSION_VERSION_INFO_HPP #define IOX_POSH_VERSION_VERSION_INFO_HPP #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/serialization.hpp\" #include \"iceoryx_hoofs/cxx/string.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/version/compatibility_check_level.hpp\" #include \"iceoryx_versions.hpp\" #include <cstdint> namespace iox { namespace version { class VersionInfo { public : VersionInfo ( const uint16_t versionMajor , const uint16_t versionMinor , const uint16_t versionPatch , const uint16_t versionTweak , const BuildDateString_t & buildDateString , const CommitIdString_t & commitIdString ) noexcept ; VersionInfo ( const cxx :: Serialization & serial ) noexcept ; operator cxx :: Serialization () const noexcept ; bool operator == ( const VersionInfo & rhs ) const noexcept ; bool operator != ( const VersionInfo & rhs ) const noexcept ; bool checkCompatibility ( const VersionInfo & other , const CompatibilityCheckLevel compatibilityCheckLevel ) const noexcept ; bool isValid () noexcept ; static VersionInfo getCurrentVersion () noexcept ; protected : static const uint64_t SERIALIZATION_STRING_SIZE = 100u ; using SerializationString_t = cxx :: string < SERIALIZATION_STRING_SIZE > ; static_assert ( COMMIT_ID_STRING_SIZE <= SERIALIZATION_STRING_SIZE , \"CommitId needs to transfered completely.\" ); static_assert ( COMMIT_ID_STRING_SIZE <= BUILD_DATE_STRING_SIZE , \"BuildDate needs to transfered completely.\" ); static_assert ( cxx :: strlen2 ( ICEORYX_BUILDDATE ) < BUILD_DATE_STRING_SIZE , \"COMMIT_BUILD_DATE_STRING_SIZE needs to be bigger.\" ); protected : bool m_valid { true }; uint16_t m_versionMajor { 0u }; uint16_t m_versionMinor { 0u }; uint16_t m_versionPatch { 0u }; uint16_t m_versionTweak { 0u }; BuildDateString_t m_buildDateString ; CommitIdString_t m_commitIdString ; }; } // namespace version } // namespace iox #endif // IOX_POSH_VERSION_VERSION_INFO_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Files/wait__set_8hpp/","text":"iceoryx_posh/popo/wait_set.hpp \ud83d\udd17 Namespaces \ud83d\udd17 Name iox iox::popo Classes \ud83d\udd17 Name class iox::popo::WaitSet Logical disjunction of a certain number of Triggers. Source code \ud83d\udd17 // Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_WAIT_SET_HPP #define IOX_POSH_POPO_WAIT_SET_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/list.hpp\" #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_hoofs/cxx/stack.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_listener.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/popo/enum_trigger_type.hpp\" #include \"iceoryx_posh/popo/notification_attorney.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include \"iceoryx_posh/popo/notification_info.hpp\" #include \"iceoryx_posh/popo/trigger.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" #include <typeinfo> namespace iox { namespace popo { class Condition ; enum class WaitSetError : uint8_t { WAIT_SET_FULL , ALREADY_ATTACHED , }; template < uint64_t Capacity = MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET > class WaitSet { public : static constexpr uint64_t CAPACITY = Capacity ; using TriggerArray = cxx :: optional < Trigger > [ Capacity ]; using NotificationInfoVector = cxx :: vector < const NotificationInfo * , CAPACITY > ; WaitSet () noexcept ; ~ WaitSet () noexcept ; WaitSet ( const WaitSet & rhs ) = delete ; WaitSet ( WaitSet && rhs ) = delete ; WaitSet & operator = ( const WaitSet & rhs ) = delete ; WaitSet & operator = ( WaitSet && rhs ) = delete ; void markForDestruction () noexcept ; template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType >& eventCallback = {}) noexcept ; template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value , void >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType >& eventCallback = {}) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType >& stateCallback = {}) noexcept ; template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value , void >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const NotificationCallback < T , ContextDataType >& stateCallback ) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType >& stateCallback = {}) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const NotificationCallback < T , ContextDataType >& stateCallback ) noexcept ; template < typename T , typename ... Targs > void detachEvent ( T & eventOrigin , const Targs & ... args ) noexcept ; template < typename T , typename ... Targs > void detachState ( T & stateOrigin , const Targs & ... args ) noexcept ; NotificationInfoVector timedWait ( const units :: Duration timeout ) noexcept ; NotificationInfoVector wait () noexcept ; uint64_t size () const noexcept ; static constexpr uint64_t capacity () noexcept ; protected : explicit WaitSet ( ConditionVariableData & condVarData ) noexcept ; private : enum class NoStateEnumUsed : StateEnumIdentifier { PLACEHOLDER }; enum class NoEventEnumUsed : EventEnumIdentifier { PLACEHOLDER }; using WaitFunction = cxx :: function_ref < ConditionListener :: NotificationVector_t () > ; template < typename T , typename ContextDataType > cxx :: expected < uint64_t , WaitSetError > attachImpl ( T & eventOrigin , const WaitSetIsConditionSatisfiedCallback & hasTriggeredCallback , const uint64_t notificationId , const NotificationCallback < T , ContextDataType >& eventCallback , const uint64_t originType , const uint64_t originTypeHash ) noexcept ; NotificationInfoVector waitAndReturnTriggeredTriggers ( const WaitFunction & wait ) noexcept ; NotificationInfoVector createVectorWithTriggeredTriggers () noexcept ; void removeTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void removeAllTriggers () noexcept ; void acquireNotifications ( const WaitFunction & wait ) noexcept ; private : TriggerArray m_triggerArray ; ConditionVariableData * m_conditionVariableDataPtr { nullptr }; ConditionListener m_conditionListener ; cxx :: stack < uint64_t , Capacity > m_indexRepository ; ConditionListener :: NotificationVector_t m_activeNotifications ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/wait_set.inl\" #endif // IOX_POSH_POPO_WAIT_SET_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"iceoryx_posh/popo/wait_set.hpp"},{"location":"API-reference/posh/Files/wait__set_8hpp/#iceoryx_poshpopowait_sethpp","text":"","title":"iceoryx_posh/popo/wait_set.hpp"},{"location":"API-reference/posh/Files/wait__set_8hpp/#namespaces","text":"Name iox iox::popo","title":"Namespaces"},{"location":"API-reference/posh/Files/wait__set_8hpp/#classes","text":"Name class iox::popo::WaitSet Logical disjunction of a certain number of Triggers.","title":"Classes"},{"location":"API-reference/posh/Files/wait__set_8hpp/#source-code","text":"// Copyright (c) 2020 - 2021 by Robert Bosch GmbH. All rights reserved. // Copyright (c) 2020 - 2021 by Apex.AI Inc. All rights reserved. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // // SPDX-License-Identifier: Apache-2.0 #ifndef IOX_POSH_POPO_WAIT_SET_HPP #define IOX_POSH_POPO_WAIT_SET_HPP #include \"iceoryx_hoofs/cxx/algorithm.hpp\" #include \"iceoryx_hoofs/cxx/function_ref.hpp\" #include \"iceoryx_hoofs/cxx/helplets.hpp\" #include \"iceoryx_hoofs/cxx/list.hpp\" #include \"iceoryx_hoofs/cxx/method_callback.hpp\" #include \"iceoryx_hoofs/cxx/stack.hpp\" #include \"iceoryx_hoofs/cxx/vector.hpp\" #include \"iceoryx_posh/iceoryx_posh_types.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_listener.hpp\" #include \"iceoryx_posh/internal/popo/building_blocks/condition_variable_data.hpp\" #include \"iceoryx_posh/popo/enum_trigger_type.hpp\" #include \"iceoryx_posh/popo/notification_attorney.hpp\" #include \"iceoryx_posh/popo/notification_callback.hpp\" #include \"iceoryx_posh/popo/notification_info.hpp\" #include \"iceoryx_posh/popo/trigger.hpp\" #include \"iceoryx_posh/popo/trigger_handle.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" #include <typeinfo> namespace iox { namespace popo { class Condition ; enum class WaitSetError : uint8_t { WAIT_SET_FULL , ALREADY_ATTACHED , }; template < uint64_t Capacity = MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET > class WaitSet { public : static constexpr uint64_t CAPACITY = Capacity ; using TriggerArray = cxx :: optional < Trigger > [ Capacity ]; using NotificationInfoVector = cxx :: vector < const NotificationInfo * , CAPACITY > ; WaitSet () noexcept ; ~ WaitSet () noexcept ; WaitSet ( const WaitSet & rhs ) = delete ; WaitSet ( WaitSet && rhs ) = delete ; WaitSet & operator = ( const WaitSet & rhs ) = delete ; WaitSet & operator = ( WaitSet && rhs ) = delete ; void markForDestruction () noexcept ; template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType >& eventCallback = {}) noexcept ; template < typename T , typename EventType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < EventType >:: value , void >> cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const EventType eventType , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const uint64_t notificationId = 0U , const NotificationCallback < T , ContextDataType >& eventCallback = {}) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachEvent ( T & eventOrigin , const NotificationCallback < T , ContextDataType >& eventCallback ) noexcept ; template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType >& stateCallback = {}) noexcept ; template < typename T , typename StateType , typename ContextDataType = internal :: NoType_t , typename = std :: enable_if_t < std :: is_enum < StateType >:: value , void >> cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const StateType stateType , const NotificationCallback < T , ContextDataType >& stateCallback ) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const uint64_t id = 0U , const NotificationCallback < T , ContextDataType >& stateCallback = {}) noexcept ; template < typename T , typename ContextDataType = internal :: NoType_t > cxx :: expected < WaitSetError > attachState ( T & stateOrigin , const NotificationCallback < T , ContextDataType >& stateCallback ) noexcept ; template < typename T , typename ... Targs > void detachEvent ( T & eventOrigin , const Targs & ... args ) noexcept ; template < typename T , typename ... Targs > void detachState ( T & stateOrigin , const Targs & ... args ) noexcept ; NotificationInfoVector timedWait ( const units :: Duration timeout ) noexcept ; NotificationInfoVector wait () noexcept ; uint64_t size () const noexcept ; static constexpr uint64_t capacity () noexcept ; protected : explicit WaitSet ( ConditionVariableData & condVarData ) noexcept ; private : enum class NoStateEnumUsed : StateEnumIdentifier { PLACEHOLDER }; enum class NoEventEnumUsed : EventEnumIdentifier { PLACEHOLDER }; using WaitFunction = cxx :: function_ref < ConditionListener :: NotificationVector_t () > ; template < typename T , typename ContextDataType > cxx :: expected < uint64_t , WaitSetError > attachImpl ( T & eventOrigin , const WaitSetIsConditionSatisfiedCallback & hasTriggeredCallback , const uint64_t notificationId , const NotificationCallback < T , ContextDataType >& eventCallback , const uint64_t originType , const uint64_t originTypeHash ) noexcept ; NotificationInfoVector waitAndReturnTriggeredTriggers ( const WaitFunction & wait ) noexcept ; NotificationInfoVector createVectorWithTriggeredTriggers () noexcept ; void removeTrigger ( const uint64_t uniqueTriggerId ) noexcept ; void removeAllTriggers () noexcept ; void acquireNotifications ( const WaitFunction & wait ) noexcept ; private : TriggerArray m_triggerArray ; ConditionVariableData * m_conditionVariableDataPtr { nullptr }; ConditionListener m_conditionListener ; cxx :: stack < uint64_t , Capacity > m_indexRepository ; ConditionListener :: NotificationVector_t m_activeNotifications ; }; } // namespace popo } // namespace iox #include \"iceoryx_posh/internal/popo/wait_set.inl\" #endif // IOX_POSH_POPO_WAIT_SET_HPP Updated on 18 December 2023 at 13:11:43 CET","title":"Source code"},{"location":"API-reference/posh/Namespaces/namespaceiox/","text":"iox \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::capro iox::config iox::gw iox::helper iox::mepoo iox::popo iox::roudi iox::runtime iox::version Classes \ud83d\udd17 Name struct iox::Config struct iox::DefaultChunkDistributorConfig struct iox::DefaultChunkQueueConfig Types \ud83d\udd17 Name enum uint32_t SubscribeState { NOT_SUBSCRIBED = 0, SUBSCRIBE_REQUESTED, SUBSCRIBED, UNSUBSCRIBE_REQUESTED, WAIT_FOR_OFFER} enum uint32_t ConnectionState { NOT_CONNECTED = 0, CONNECT_REQUESTED, CONNECTED, DISCONNECT_REQUESTED, WAIT_FOR_OFFER} using Config < mepoo::SegmentConfig , config::RouDiConfig > RouDiConfig_t using iox::popo::PublisherPortRouDi PublisherPortRouDiType using iox::popo::PublisherPortUser PublisherPortUserType using iox::popo::SubscriberPortRouDi SubscriberPortRouDiType using iox::popo::SubscriberPortUser SubscriberPortUserType using iox::build::CommunicationPolicy SubscriberPortType using cxx::string< MAX_RUNTIME_NAME_LENGTH > RuntimeName_t using cxx::string< 100 > NodeName_t using cxx::string< 128 > ShmName_t Functions \ud83d\udd17 Name constexpr const char * asStringLiteral (ConnectionState value) Converts the ConnectionState to a string literal. std::ostream & operator<< (std::ostream & stream, ConnectionState value) Convenience stream operator to easily use the asStringLiteral function with std::ostream. log::LogStream & operator<< (log::LogStream & stream, ConnectionState value) Convenience stream operator to easily use the asStringLiteral function with iox::log::LogStream. Attributes \ud83d\udd17 Name constexpr uint32_t MAX_PUBLISHERS constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY constexpr uint64_t MAX_PUBLISHER_HISTORY constexpr uint32_t MAX_SUBSCRIBERS constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS constexpr uint32_t MAX_INTERFACE_NUMBER constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE constexpr uint32_t MAX_CHANNEL_NUMBER constexpr uint32_t MAX_GATEWAY_SERVICES constexpr uint32_t MAX_CLIENTS constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY constexpr uint32_t MAX_SERVERS constexpr uint32_t MAX_CLIENTS_PER_SERVER constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS constexpr uint32_t MAX_SHM_SEGMENTS constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT constexpr uint32_t ROUDI_MAX_MESSAGES constexpr uint32_t ROUDI_MESSAGE_SIZE constexpr uint32_t APP_MAX_MESSAGES constexpr uint32_t APP_MESSAGE_SIZE constexpr uint32_t MAX_PROCESS_NUMBER constexpr uint32_t SERVICE_REGISTRY_CAPACITY constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE constexpr const char SERVICE_DISCOVERY_SERVICE_NAME constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME constexpr const char SERVICE_DISCOVERY_EVENT_NAME constexpr uint32_t MAX_NODE_NUMBER constexpr uint32_t MAX_NODE_PER_PROCESS constexpr uint32_t MAX_RUNTIME_NAME_LENGTH Types Documentation \ud83d\udd17 enum SubscribeState \ud83d\udd17 Enumerator Value Description NOT_SUBSCRIBED 0 SUBSCRIBE_REQUESTED SUBSCRIBED UNSUBSCRIBE_REQUESTED WAIT_FOR_OFFER enum ConnectionState \ud83d\udd17 Enumerator Value Description NOT_CONNECTED 0 CONNECT_REQUESTED CONNECTED DISCONNECT_REQUESTED WAIT_FOR_OFFER using RouDiConfig_t \ud83d\udd17 using iox :: RouDiConfig_t = typedef Config < mepoo :: SegmentConfig , config :: RouDiConfig > ; using PublisherPortRouDiType \ud83d\udd17 using iox :: PublisherPortRouDiType = typedef iox :: popo :: PublisherPortRouDi ; using PublisherPortUserType \ud83d\udd17 using iox :: PublisherPortUserType = typedef iox :: popo :: PublisherPortUser ; using SubscriberPortRouDiType \ud83d\udd17 using iox :: SubscriberPortRouDiType = typedef iox :: popo :: SubscriberPortRouDi ; using SubscriberPortUserType \ud83d\udd17 using iox :: SubscriberPortUserType = typedef iox :: popo :: SubscriberPortUser ; using SubscriberPortType \ud83d\udd17 using iox :: SubscriberPortType = typedef iox :: build :: CommunicationPolicy ; using RuntimeName_t \ud83d\udd17 using iox :: RuntimeName_t = typedef cxx :: string < MAX_RUNTIME_NAME_LENGTH > ; using NodeName_t \ud83d\udd17 using iox :: NodeName_t = typedef cxx :: string < 100 > ; using ShmName_t \ud83d\udd17 using iox :: ShmName_t = typedef cxx :: string < 128 > ; Functions Documentation \ud83d\udd17 function asStringLiteral \ud83d\udd17 inline constexpr const char * asStringLiteral ( ConnectionState value ) Converts the ConnectionState to a string literal. Parameters : value to convert to a string literal Return : pointer to a string literal function operator<< \ud83d\udd17 inline std :: ostream & operator << ( std :: ostream & stream , ConnectionState value ) Convenience stream operator to easily use the asStringLiteral function with std::ostream. Parameters : stream sink to write the message to value to convert to a string literal Return : the reference to stream which was provided as input parameter function operator<< \ud83d\udd17 inline log :: LogStream & operator << ( log :: LogStream & stream , ConnectionState value ) Convenience stream operator to easily use the asStringLiteral function with iox::log::LogStream. Parameters : stream sink to write the message to value to convert to a string literal Return : the reference to stream which was provided as input parameter Attributes Documentation \ud83d\udd17 variable MAX_PUBLISHERS \ud83d\udd17 constexpr uint32_t MAX_PUBLISHERS = build :: IOX_MAX_PUBLISHERS ; variable MAX_SUBSCRIBERS_PER_PUBLISHER \ud83d\udd17 constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER = build :: IOX_MAX_SUBSCRIBERS_PER_PUBLISHER ; variable MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY \ud83d\udd17 constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY ; variable MAX_PUBLISHER_HISTORY \ud83d\udd17 constexpr uint64_t MAX_PUBLISHER_HISTORY = build :: IOX_MAX_PUBLISHER_HISTORY ; variable MAX_SUBSCRIBERS \ud83d\udd17 constexpr uint32_t MAX_SUBSCRIBERS = build :: IOX_MAX_SUBSCRIBERS ; variable MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY \ud83d\udd17 constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ; variable MAX_SUBSCRIBER_QUEUE_CAPACITY \ud83d\udd17 constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ; variable PUBLISHERS_RESERVED_FOR_INTROSPECTION \ud83d\udd17 constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION = 5 ; variable PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY \ud83d\udd17 constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY = 1 ; variable NUMBER_OF_INTERNAL_PUBLISHERS \ud83d\udd17 constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS = PUBLISHERS_RESERVED_FOR_INTROSPECTION + PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY ; variable MAX_INTERFACE_NUMBER \ud83d\udd17 constexpr uint32_t MAX_INTERFACE_NUMBER = build :: IOX_MAX_INTERFACE_NUMBER ; With MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY we couple the maximum number of chunks a user is allowed to hold with the maximum queue capacity. This allows that a polling user can replace all the held chunks in one execution with all new ones from a completely filled queue. Or the other way round, when we have a contract with the user regarding how many chunks they are allowed to hold, then the queue size needs not be bigger. We can provide this number of newest chunks, more the user would not be allowed to hold anyway variable MAX_INTERFACE_CAPRO_FIFO_SIZE \ud83d\udd17 constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE = MAX_PUBLISHERS ; variable MAX_CHANNEL_NUMBER \ud83d\udd17 constexpr uint32_t MAX_CHANNEL_NUMBER = MAX_PUBLISHERS + MAX_SUBSCRIBERS ; variable MAX_GATEWAY_SERVICES \ud83d\udd17 constexpr uint32_t MAX_GATEWAY_SERVICES = 2 * MAX_CHANNEL_NUMBER ; variable MAX_CLIENTS \ud83d\udd17 constexpr uint32_t MAX_CLIENTS = build :: IOX_MAX_SUBSCRIBERS ; variable MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY \ud83d\udd17 constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY = 4U ; Todo : variable MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY \ud83d\udd17 constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY = 16U ; variable MAX_RESPONSE_QUEUE_CAPACITY \ud83d\udd17 constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY = 16U ; variable MAX_SERVERS \ud83d\udd17 constexpr uint32_t MAX_SERVERS = build :: IOX_MAX_PUBLISHERS ; variable MAX_CLIENTS_PER_SERVER \ud83d\udd17 constexpr uint32_t MAX_CLIENTS_PER_SERVER = 256U ; Todo : variable MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY \ud83d\udd17 constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY = 4U ; variable MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY \ud83d\udd17 constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY = MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY ; variable MAX_REQUEST_QUEUE_CAPACITY \ud83d\udd17 constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY = 1024 ; variable MAX_NUMBER_OF_CONDITION_VARIABLES \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES = 1024U ; variable MAX_NUMBER_OF_NOTIFIERS \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS = build :: IOX_MAX_NUMBER_OF_NOTIFIERS ; variable MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET = MAX_NUMBER_OF_NOTIFIERS ; Note : Waitset and Listener share both the max available notifiers, if one of them is running out of of notifiers the variable above must be increased variable MAX_NUMBER_OF_EVENTS_PER_LISTENER \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER = MAX_NUMBER_OF_NOTIFIERS ; variable MAX_NUMBER_OF_MEMPOOLS \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS = 32U ; variable MAX_SHM_SEGMENTS \ud83d\udd17 constexpr uint32_t MAX_SHM_SEGMENTS = 100U ; variable MAX_NUMBER_OF_MEMORY_PROVIDER \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER = 8U ; variable MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER \ud83d\udd17 constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER = 64U ; variable CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT \ud83d\udd17 constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT { 8U }; variable CHUNK_NO_USER_HEADER_SIZE \ud83d\udd17 constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE { 0U }; variable CHUNK_NO_USER_HEADER_ALIGNMENT \ud83d\udd17 constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT { 1U }; variable ROUDI_MAX_MESSAGES \ud83d\udd17 constexpr uint32_t ROUDI_MAX_MESSAGES = 5U ; variable ROUDI_MESSAGE_SIZE \ud83d\udd17 constexpr uint32_t ROUDI_MESSAGE_SIZE = 512U ; variable APP_MAX_MESSAGES \ud83d\udd17 constexpr uint32_t APP_MAX_MESSAGES = 5U ; variable APP_MESSAGE_SIZE \ud83d\udd17 constexpr uint32_t APP_MESSAGE_SIZE = 512U ; variable MAX_PROCESS_NUMBER \ud83d\udd17 constexpr uint32_t MAX_PROCESS_NUMBER = 300U ; variable SERVICE_REGISTRY_CAPACITY \ud83d\udd17 constexpr uint32_t SERVICE_REGISTRY_CAPACITY = MAX_PUBLISHERS + MAX_SERVERS ; variable MAX_FINDSERVICE_RESULT_SIZE \ud83d\udd17 constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE = SERVICE_REGISTRY_CAPACITY ; variable SERVICE_DISCOVERY_SERVICE_NAME \ud83d\udd17 constexpr const char SERVICE_DISCOVERY_SERVICE_NAME = \"ServiceDiscovery\" ; variable SERVICE_DISCOVERY_INSTANCE_NAME \ud83d\udd17 constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME = \"RouDi_ID\" ; variable SERVICE_DISCOVERY_EVENT_NAME \ud83d\udd17 constexpr const char SERVICE_DISCOVERY_EVENT_NAME = \"ServiceRegistry\" ; variable MAX_NODE_NUMBER \ud83d\udd17 constexpr uint32_t MAX_NODE_NUMBER = 1000U ; variable MAX_NODE_PER_PROCESS \ud83d\udd17 constexpr uint32_t MAX_NODE_PER_PROCESS = 50U ; variable MAX_RUNTIME_NAME_LENGTH \ud83d\udd17 constexpr uint32_t MAX_RUNTIME_NAME_LENGTH = MAX_IPC_CHANNEL_NAME_LENGTH ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox"},{"location":"API-reference/posh/Namespaces/namespaceiox/#iox","text":"","title":"iox"},{"location":"API-reference/posh/Namespaces/namespaceiox/#namespaces","text":"Name iox::capro iox::config iox::gw iox::helper iox::mepoo iox::popo iox::roudi iox::runtime iox::version","title":"Namespaces"},{"location":"API-reference/posh/Namespaces/namespaceiox/#classes","text":"Name struct iox::Config struct iox::DefaultChunkDistributorConfig struct iox::DefaultChunkQueueConfig","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox/#types","text":"Name enum uint32_t SubscribeState { NOT_SUBSCRIBED = 0, SUBSCRIBE_REQUESTED, SUBSCRIBED, UNSUBSCRIBE_REQUESTED, WAIT_FOR_OFFER} enum uint32_t ConnectionState { NOT_CONNECTED = 0, CONNECT_REQUESTED, CONNECTED, DISCONNECT_REQUESTED, WAIT_FOR_OFFER} using Config < mepoo::SegmentConfig , config::RouDiConfig > RouDiConfig_t using iox::popo::PublisherPortRouDi PublisherPortRouDiType using iox::popo::PublisherPortUser PublisherPortUserType using iox::popo::SubscriberPortRouDi SubscriberPortRouDiType using iox::popo::SubscriberPortUser SubscriberPortUserType using iox::build::CommunicationPolicy SubscriberPortType using cxx::string< MAX_RUNTIME_NAME_LENGTH > RuntimeName_t using cxx::string< 100 > NodeName_t using cxx::string< 128 > ShmName_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox/#functions","text":"Name constexpr const char * asStringLiteral (ConnectionState value) Converts the ConnectionState to a string literal. std::ostream & operator<< (std::ostream & stream, ConnectionState value) Convenience stream operator to easily use the asStringLiteral function with std::ostream. log::LogStream & operator<< (log::LogStream & stream, ConnectionState value) Convenience stream operator to easily use the asStringLiteral function with iox::log::LogStream.","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox/#attributes","text":"Name constexpr uint32_t MAX_PUBLISHERS constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY constexpr uint64_t MAX_PUBLISHER_HISTORY constexpr uint32_t MAX_SUBSCRIBERS constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS constexpr uint32_t MAX_INTERFACE_NUMBER constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE constexpr uint32_t MAX_CHANNEL_NUMBER constexpr uint32_t MAX_GATEWAY_SERVICES constexpr uint32_t MAX_CLIENTS constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY constexpr uint32_t MAX_SERVERS constexpr uint32_t MAX_CLIENTS_PER_SERVER constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS constexpr uint32_t MAX_SHM_SEGMENTS constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT constexpr uint32_t ROUDI_MAX_MESSAGES constexpr uint32_t ROUDI_MESSAGE_SIZE constexpr uint32_t APP_MAX_MESSAGES constexpr uint32_t APP_MESSAGE_SIZE constexpr uint32_t MAX_PROCESS_NUMBER constexpr uint32_t SERVICE_REGISTRY_CAPACITY constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE constexpr const char SERVICE_DISCOVERY_SERVICE_NAME constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME constexpr const char SERVICE_DISCOVERY_EVENT_NAME constexpr uint32_t MAX_NODE_NUMBER constexpr uint32_t MAX_NODE_PER_PROCESS constexpr uint32_t MAX_RUNTIME_NAME_LENGTH","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox/#enum-subscribestate","text":"Enumerator Value Description NOT_SUBSCRIBED 0 SUBSCRIBE_REQUESTED SUBSCRIBED UNSUBSCRIBE_REQUESTED WAIT_FOR_OFFER","title":"enum SubscribeState"},{"location":"API-reference/posh/Namespaces/namespaceiox/#enum-connectionstate","text":"Enumerator Value Description NOT_CONNECTED 0 CONNECT_REQUESTED CONNECTED DISCONNECT_REQUESTED WAIT_FOR_OFFER","title":"enum ConnectionState"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-roudiconfig_t","text":"using iox :: RouDiConfig_t = typedef Config < mepoo :: SegmentConfig , config :: RouDiConfig > ;","title":"using RouDiConfig_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-publisherportrouditype","text":"using iox :: PublisherPortRouDiType = typedef iox :: popo :: PublisherPortRouDi ;","title":"using PublisherPortRouDiType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-publisherportusertype","text":"using iox :: PublisherPortUserType = typedef iox :: popo :: PublisherPortUser ;","title":"using PublisherPortUserType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-subscriberportrouditype","text":"using iox :: SubscriberPortRouDiType = typedef iox :: popo :: SubscriberPortRouDi ;","title":"using SubscriberPortRouDiType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-subscriberportusertype","text":"using iox :: SubscriberPortUserType = typedef iox :: popo :: SubscriberPortUser ;","title":"using SubscriberPortUserType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-subscriberporttype","text":"using iox :: SubscriberPortType = typedef iox :: build :: CommunicationPolicy ;","title":"using SubscriberPortType"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-runtimename_t","text":"using iox :: RuntimeName_t = typedef cxx :: string < MAX_RUNTIME_NAME_LENGTH > ;","title":"using RuntimeName_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-nodename_t","text":"using iox :: NodeName_t = typedef cxx :: string < 100 > ;","title":"using NodeName_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#using-shmname_t","text":"using iox :: ShmName_t = typedef cxx :: string < 128 > ;","title":"using ShmName_t"},{"location":"API-reference/posh/Namespaces/namespaceiox/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox/#function-asstringliteral","text":"inline constexpr const char * asStringLiteral ( ConnectionState value ) Converts the ConnectionState to a string literal. Parameters : value to convert to a string literal Return : pointer to a string literal","title":"function asStringLiteral"},{"location":"API-reference/posh/Namespaces/namespaceiox/#function-operator","text":"inline std :: ostream & operator << ( std :: ostream & stream , ConnectionState value ) Convenience stream operator to easily use the asStringLiteral function with std::ostream. Parameters : stream sink to write the message to value to convert to a string literal Return : the reference to stream which was provided as input parameter","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox/#function-operator_1","text":"inline log :: LogStream & operator << ( log :: LogStream & stream , ConnectionState value ) Convenience stream operator to easily use the asStringLiteral function with iox::log::LogStream. Parameters : stream sink to write the message to value to convert to a string literal Return : the reference to stream which was provided as input parameter","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_publishers","text":"constexpr uint32_t MAX_PUBLISHERS = build :: IOX_MAX_PUBLISHERS ;","title":"variable MAX_PUBLISHERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_subscribers_per_publisher","text":"constexpr uint32_t MAX_SUBSCRIBERS_PER_PUBLISHER = build :: IOX_MAX_SUBSCRIBERS_PER_PUBLISHER ;","title":"variable MAX_SUBSCRIBERS_PER_PUBLISHER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_chunks_allocated_per_publisher_simultaneously","text":"constexpr uint32_t MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY ;","title":"variable MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_publisher_history","text":"constexpr uint64_t MAX_PUBLISHER_HISTORY = build :: IOX_MAX_PUBLISHER_HISTORY ;","title":"variable MAX_PUBLISHER_HISTORY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_subscribers","text":"constexpr uint32_t MAX_SUBSCRIBERS = build :: IOX_MAX_SUBSCRIBERS ;","title":"variable MAX_SUBSCRIBERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_chunks_held_per_subscriber_simultaneously","text":"constexpr uint32_t MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY = build :: IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ;","title":"variable MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_subscriber_queue_capacity","text":"constexpr uint32_t MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY ;","title":"variable MAX_SUBSCRIBER_QUEUE_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-publishers_reserved_for_introspection","text":"constexpr uint32_t PUBLISHERS_RESERVED_FOR_INTROSPECTION = 5 ;","title":"variable PUBLISHERS_RESERVED_FOR_INTROSPECTION"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-publishers_reserved_for_service_registry","text":"constexpr uint32_t PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY = 1 ;","title":"variable PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-number_of_internal_publishers","text":"constexpr uint32_t NUMBER_OF_INTERNAL_PUBLISHERS = PUBLISHERS_RESERVED_FOR_INTROSPECTION + PUBLISHERS_RESERVED_FOR_SERVICE_REGISTRY ;","title":"variable NUMBER_OF_INTERNAL_PUBLISHERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_interface_number","text":"constexpr uint32_t MAX_INTERFACE_NUMBER = build :: IOX_MAX_INTERFACE_NUMBER ; With MAX_SUBSCRIBER_QUEUE_CAPACITY = MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY we couple the maximum number of chunks a user is allowed to hold with the maximum queue capacity. This allows that a polling user can replace all the held chunks in one execution with all new ones from a completely filled queue. Or the other way round, when we have a contract with the user regarding how many chunks they are allowed to hold, then the queue size needs not be bigger. We can provide this number of newest chunks, more the user would not be allowed to hold anyway","title":"variable MAX_INTERFACE_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_interface_capro_fifo_size","text":"constexpr uint32_t MAX_INTERFACE_CAPRO_FIFO_SIZE = MAX_PUBLISHERS ;","title":"variable MAX_INTERFACE_CAPRO_FIFO_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_channel_number","text":"constexpr uint32_t MAX_CHANNEL_NUMBER = MAX_PUBLISHERS + MAX_SUBSCRIBERS ;","title":"variable MAX_CHANNEL_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_gateway_services","text":"constexpr uint32_t MAX_GATEWAY_SERVICES = 2 * MAX_CHANNEL_NUMBER ;","title":"variable MAX_GATEWAY_SERVICES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_clients","text":"constexpr uint32_t MAX_CLIENTS = build :: IOX_MAX_SUBSCRIBERS ;","title":"variable MAX_CLIENTS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_requests_allocated_simultaneously","text":"constexpr uint32_t MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY = 4U ; Todo :","title":"variable MAX_REQUESTS_ALLOCATED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_responses_processed_simultaneously","text":"constexpr uint32_t MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY = 16U ;","title":"variable MAX_RESPONSES_PROCESSED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_response_queue_capacity","text":"constexpr uint32_t MAX_RESPONSE_QUEUE_CAPACITY = 16U ;","title":"variable MAX_RESPONSE_QUEUE_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_servers","text":"constexpr uint32_t MAX_SERVERS = build :: IOX_MAX_PUBLISHERS ;","title":"variable MAX_SERVERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_clients_per_server","text":"constexpr uint32_t MAX_CLIENTS_PER_SERVER = 256U ; Todo :","title":"variable MAX_CLIENTS_PER_SERVER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_requests_processed_simultaneously","text":"constexpr uint32_t MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY = 4U ;","title":"variable MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_responses_allocated_simultaneously","text":"constexpr uint32_t MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY = MAX_REQUESTS_PROCESSED_SIMULTANEOUSLY ;","title":"variable MAX_RESPONSES_ALLOCATED_SIMULTANEOUSLY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_request_queue_capacity","text":"constexpr uint32_t MAX_REQUEST_QUEUE_CAPACITY = 1024 ;","title":"variable MAX_REQUEST_QUEUE_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_condition_variables","text":"constexpr uint32_t MAX_NUMBER_OF_CONDITION_VARIABLES = 1024U ;","title":"variable MAX_NUMBER_OF_CONDITION_VARIABLES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_notifiers","text":"constexpr uint32_t MAX_NUMBER_OF_NOTIFIERS = build :: IOX_MAX_NUMBER_OF_NOTIFIERS ;","title":"variable MAX_NUMBER_OF_NOTIFIERS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_attachments_per_waitset","text":"constexpr uint32_t MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET = MAX_NUMBER_OF_NOTIFIERS ; Note : Waitset and Listener share both the max available notifiers, if one of them is running out of of notifiers the variable above must be increased","title":"variable MAX_NUMBER_OF_ATTACHMENTS_PER_WAITSET"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_events_per_listener","text":"constexpr uint32_t MAX_NUMBER_OF_EVENTS_PER_LISTENER = MAX_NUMBER_OF_NOTIFIERS ;","title":"variable MAX_NUMBER_OF_EVENTS_PER_LISTENER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_mempools","text":"constexpr uint32_t MAX_NUMBER_OF_MEMPOOLS = 32U ;","title":"variable MAX_NUMBER_OF_MEMPOOLS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_shm_segments","text":"constexpr uint32_t MAX_SHM_SEGMENTS = 100U ;","title":"variable MAX_SHM_SEGMENTS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_memory_provider","text":"constexpr uint32_t MAX_NUMBER_OF_MEMORY_PROVIDER = 8U ;","title":"variable MAX_NUMBER_OF_MEMORY_PROVIDER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_number_of_memory_blocks_per_memory_provider","text":"constexpr uint32_t MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER = 64U ;","title":"variable MAX_NUMBER_OF_MEMORY_BLOCKS_PER_MEMORY_PROVIDER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-chunk_default_user_payload_alignment","text":"constexpr uint32_t CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT { 8U };","title":"variable CHUNK_DEFAULT_USER_PAYLOAD_ALIGNMENT"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-chunk_no_user_header_size","text":"constexpr uint32_t CHUNK_NO_USER_HEADER_SIZE { 0U };","title":"variable CHUNK_NO_USER_HEADER_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-chunk_no_user_header_alignment","text":"constexpr uint32_t CHUNK_NO_USER_HEADER_ALIGNMENT { 1U };","title":"variable CHUNK_NO_USER_HEADER_ALIGNMENT"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-roudi_max_messages","text":"constexpr uint32_t ROUDI_MAX_MESSAGES = 5U ;","title":"variable ROUDI_MAX_MESSAGES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-roudi_message_size","text":"constexpr uint32_t ROUDI_MESSAGE_SIZE = 512U ;","title":"variable ROUDI_MESSAGE_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-app_max_messages","text":"constexpr uint32_t APP_MAX_MESSAGES = 5U ;","title":"variable APP_MAX_MESSAGES"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-app_message_size","text":"constexpr uint32_t APP_MESSAGE_SIZE = 512U ;","title":"variable APP_MESSAGE_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_process_number","text":"constexpr uint32_t MAX_PROCESS_NUMBER = 300U ;","title":"variable MAX_PROCESS_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_registry_capacity","text":"constexpr uint32_t SERVICE_REGISTRY_CAPACITY = MAX_PUBLISHERS + MAX_SERVERS ;","title":"variable SERVICE_REGISTRY_CAPACITY"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_findservice_result_size","text":"constexpr uint32_t MAX_FINDSERVICE_RESULT_SIZE = SERVICE_REGISTRY_CAPACITY ;","title":"variable MAX_FINDSERVICE_RESULT_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_discovery_service_name","text":"constexpr const char SERVICE_DISCOVERY_SERVICE_NAME = \"ServiceDiscovery\" ;","title":"variable SERVICE_DISCOVERY_SERVICE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_discovery_instance_name","text":"constexpr const char SERVICE_DISCOVERY_INSTANCE_NAME = \"RouDi_ID\" ;","title":"variable SERVICE_DISCOVERY_INSTANCE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-service_discovery_event_name","text":"constexpr const char SERVICE_DISCOVERY_EVENT_NAME = \"ServiceRegistry\" ;","title":"variable SERVICE_DISCOVERY_EVENT_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_node_number","text":"constexpr uint32_t MAX_NODE_NUMBER = 1000U ;","title":"variable MAX_NODE_NUMBER"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_node_per_process","text":"constexpr uint32_t MAX_NODE_PER_PROCESS = 50U ;","title":"variable MAX_NODE_PER_PROCESS"},{"location":"API-reference/posh/Namespaces/namespaceiox/#variable-max_runtime_name_length","text":"constexpr uint32_t MAX_RUNTIME_NAME_LENGTH = MAX_IPC_CHANNEL_NAME_LENGTH ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable MAX_RUNTIME_NAME_LENGTH"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/","text":"iox::capro \ud83d\udd17 Classes \ud83d\udd17 Name class iox::capro::ServiceDescription class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel. Types \ud83d\udd17 Name enum uint16_t Interfaces { INTERNAL = 0, ESOC, SOMEIP, AMQP, MQTT, DDS, SIGNAL, MTA, ROS1, INTERFACE_END} Describes from which interface the service is coming from. enum uint16_t Scope { WORLDWIDE, LOCAL, INVALID} Scope of a service description. using iox::cxx::nullopt_t Wildcard_t Used to search for any string. using cxx::string< 100 > IdString_t Functions \ud83d\udd17 Name bool serviceMatch (const ServiceDescription & first, const ServiceDescription & second) Compare two service descriptions via their values in member variables and return bool if match. std::ostream & operator<< (std::ostream & stream, const ServiceDescription & service) Convenience stream operator to easily use the [ServiceDescription]() with std::ostream. log::LogStream & operator<< (log::LogStream & stream, const ServiceDescription & service) Convenience stream operator to easily use the [ServiceDescription]() with log::LogStream. Attributes \ud83d\udd17 Name constexpr Wildcard_t Wildcard constexpr int32_t MAX_NUMBER_OF_CHARS constexpr size_t CLASS_HASH_ELEMENT_COUNT constexpr const char * INTERFACE_NAMES constexpr char ScopeTypeString Types Documentation \ud83d\udd17 enum Interfaces \ud83d\udd17 Enumerator Value Description INTERNAL 0 Used for services, which are locally on this system and not coming over a gateway. ESOC Canonical protocol for CAN Bus. SOMEIP SOME/IP. AMQP Advanced Message Queuing Protocol. MQTT Message Queuing Telemetry Transport. DDS Data Distribution Service. SIGNAL Universal Measurement and Calibration Protocol (XCP) MTA Measurement technology adapter. ROS1 Robot Operating System 1. INTERFACE_END End of enum. Describes from which interface the service is coming from. enum Scope \ud83d\udd17 Enumerator Value Description WORLDWIDE LOCAL INVALID Scope of a service description. using Wildcard_t \ud83d\udd17 using iox :: capro :: Wildcard_t = typedef iox :: cxx :: nullopt_t ; Used to search for any string. using IdString_t \ud83d\udd17 using iox :: capro :: IdString_t = typedef cxx :: string < 100 > ; Functions Documentation \ud83d\udd17 function serviceMatch \ud83d\udd17 bool serviceMatch ( const ServiceDescription & first , const ServiceDescription & second ) Compare two service descriptions via their values in member variables and return bool if match. Parameters : ServiceDescription &first Servicedescription to compare ServiceDescription &second Servicedescription to compare Return : Bool if comparison match or not function operator<< \ud83d\udd17 std :: ostream & operator << ( std :: ostream & stream , const ServiceDescription & service ) Convenience stream operator to easily use the [ServiceDescription]() with std::ostream. Parameters : stream output stream to write the message to service ServiceDescription that shall be converted Return : the reference to stream which was provided as input parameter function operator<< \ud83d\udd17 log :: LogStream & operator << ( log :: LogStream & stream , const ServiceDescription & service ) Convenience stream operator to easily use the [ServiceDescription]() with log::LogStream. Parameters : stream output LogStream to write the message to service ServiceDescription that shall be converted Return : the reference to stream which was provided as input parameter Attributes Documentation \ud83d\udd17 variable Wildcard \ud83d\udd17 constexpr Wildcard_t Wildcard ; variable MAX_NUMBER_OF_CHARS \ud83d\udd17 static constexpr int32_t MAX_NUMBER_OF_CHARS = 64 ; variable CLASS_HASH_ELEMENT_COUNT \ud83d\udd17 static constexpr size_t CLASS_HASH_ELEMENT_COUNT { 4U }; variable INTERFACE_NAMES \ud83d\udd17 constexpr const char * INTERFACE_NAMES = { \"INTERNAL\" , \"ESOC\" , \"SOMEIP\" , \"AMQP\" , \"DDS\" , \"SIGNAL\" , \"MTA\" , \"ROS1\" , \"END\" }; variable ScopeTypeString \ud83d\udd17 constexpr char ScopeTypeString = { \"WORLDWIDE\" , \"INTERNAL\" , \"INVALID\" }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::capro"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#ioxcapro","text":"","title":"iox::capro"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#classes","text":"Name class iox::capro::ServiceDescription class for the identification of a communication event including information on the service, the service instance and the event id. A class object can be serialized/deserialized, so it is possible to send the information e.g. over a IPC channel.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#types","text":"Name enum uint16_t Interfaces { INTERNAL = 0, ESOC, SOMEIP, AMQP, MQTT, DDS, SIGNAL, MTA, ROS1, INTERFACE_END} Describes from which interface the service is coming from. enum uint16_t Scope { WORLDWIDE, LOCAL, INVALID} Scope of a service description. using iox::cxx::nullopt_t Wildcard_t Used to search for any string. using cxx::string< 100 > IdString_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#functions","text":"Name bool serviceMatch (const ServiceDescription & first, const ServiceDescription & second) Compare two service descriptions via their values in member variables and return bool if match. std::ostream & operator<< (std::ostream & stream, const ServiceDescription & service) Convenience stream operator to easily use the [ServiceDescription]() with std::ostream. log::LogStream & operator<< (log::LogStream & stream, const ServiceDescription & service) Convenience stream operator to easily use the [ServiceDescription]() with log::LogStream.","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#attributes","text":"Name constexpr Wildcard_t Wildcard constexpr int32_t MAX_NUMBER_OF_CHARS constexpr size_t CLASS_HASH_ELEMENT_COUNT constexpr const char * INTERFACE_NAMES constexpr char ScopeTypeString","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#enum-interfaces","text":"Enumerator Value Description INTERNAL 0 Used for services, which are locally on this system and not coming over a gateway. ESOC Canonical protocol for CAN Bus. SOMEIP SOME/IP. AMQP Advanced Message Queuing Protocol. MQTT Message Queuing Telemetry Transport. DDS Data Distribution Service. SIGNAL Universal Measurement and Calibration Protocol (XCP) MTA Measurement technology adapter. ROS1 Robot Operating System 1. INTERFACE_END End of enum. Describes from which interface the service is coming from.","title":"enum Interfaces"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#enum-scope","text":"Enumerator Value Description WORLDWIDE LOCAL INVALID Scope of a service description.","title":"enum Scope"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#using-wildcard_t","text":"using iox :: capro :: Wildcard_t = typedef iox :: cxx :: nullopt_t ; Used to search for any string.","title":"using Wildcard_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#using-idstring_t","text":"using iox :: capro :: IdString_t = typedef cxx :: string < 100 > ;","title":"using IdString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#function-servicematch","text":"bool serviceMatch ( const ServiceDescription & first , const ServiceDescription & second ) Compare two service descriptions via their values in member variables and return bool if match. Parameters : ServiceDescription &first Servicedescription to compare ServiceDescription &second Servicedescription to compare Return : Bool if comparison match or not","title":"function serviceMatch"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#function-operator","text":"std :: ostream & operator << ( std :: ostream & stream , const ServiceDescription & service ) Convenience stream operator to easily use the [ServiceDescription]() with std::ostream. Parameters : stream output stream to write the message to service ServiceDescription that shall be converted Return : the reference to stream which was provided as input parameter","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#function-operator_1","text":"log :: LogStream & operator << ( log :: LogStream & stream , const ServiceDescription & service ) Convenience stream operator to easily use the [ServiceDescription]() with log::LogStream. Parameters : stream output LogStream to write the message to service ServiceDescription that shall be converted Return : the reference to stream which was provided as input parameter","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-wildcard","text":"constexpr Wildcard_t Wildcard ;","title":"variable Wildcard"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-max_number_of_chars","text":"static constexpr int32_t MAX_NUMBER_OF_CHARS = 64 ;","title":"variable MAX_NUMBER_OF_CHARS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-class_hash_element_count","text":"static constexpr size_t CLASS_HASH_ELEMENT_COUNT { 4U };","title":"variable CLASS_HASH_ELEMENT_COUNT"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-interface_names","text":"constexpr const char * INTERFACE_NAMES = { \"INTERNAL\" , \"ESOC\" , \"SOMEIP\" , \"AMQP\" , \"DDS\" , \"SIGNAL\" , \"MTA\" , \"ROS1\" , \"END\" };","title":"variable INTERFACE_NAMES"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1capro/#variable-scopetypestring","text":"constexpr char ScopeTypeString = { \"WORLDWIDE\" , \"INTERNAL\" , \"INVALID\" }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable ScopeTypeString"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/","text":"iox::config \ud83d\udd17 Classes \ud83d\udd17 Name struct iox::config::CmdLineArgs_t class iox::config::CmdLineParser class iox::config::CmdLineParserConfigFileOption struct iox::config::GatewayConfig Generic configuration for gateways. struct iox::config::RouDiConfig class iox::config::TomlGatewayConfigParser The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files. class iox::config::TomlRouDiConfigFileProvider Types \ud83d\udd17 Name enum TomlGatewayConfigParseError { FILE_NOT_FOUND, INCOMPLETE_CONFIGURATION, INCOMPLETE_SERVICE_DESCRIPTION, INVALID_SERVICE_DESCRIPTION, EXCEPTION_IN_PARSER, MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED} enum CmdLineParserResult { UNKNOWN_OPTION_USED, INFO_OUTPUT_ONLY} Functions \ud83d\udd17 Name iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const CmdLineArgs_t & cmdLineArgs) Attributes \ud83d\udd17 Name constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS constexpr const char REGEX_VALID_CHARACTERS constexpr const char DEFAULT_CONFIG_FILE_PATH constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME constexpr const char GATEWAY_CONFIG_SERVICE_NAME constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME constexpr char defaultConfigFilePath Types Documentation \ud83d\udd17 enum TomlGatewayConfigParseError \ud83d\udd17 Enumerator Value Description FILE_NOT_FOUND INCOMPLETE_CONFIGURATION INCOMPLETE_SERVICE_DESCRIPTION INVALID_SERVICE_DESCRIPTION EXCEPTION_IN_PARSER MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED enum CmdLineParserResult \ud83d\udd17 Enumerator Value Description UNKNOWN_OPTION_USED INFO_OUTPUT_ONLY Functions Documentation \ud83d\udd17 function operator<< \ud83d\udd17 inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const CmdLineArgs_t & cmdLineArgs ) Attributes Documentation \ud83d\udd17 variable TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS \ud83d\udd17 constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS = { \"FILE_NOT_FOUND\" , \"INCOMPLETE_CONFIGURATION\" , \"INCOMPLETE_SERVICE_DESCRIPTION\" , \"INVALID_SERVICE_DESCRIPTION\" , \"EXCEPTION_IN_PARSER\" , \"MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\" }; variable REGEX_VALID_CHARACTERS \ud83d\udd17 static constexpr const char REGEX_VALID_CHARACTERS = \"^[a-zA-Z_][a-zA-Z0-9_]*$\" ; variable DEFAULT_CONFIG_FILE_PATH \ud83d\udd17 static constexpr const char DEFAULT_CONFIG_FILE_PATH = \"/etc/iceoryx/gateway_config.toml\" ; variable GATEWAY_CONFIG_SERVICE_TABLE_NAME \ud83d\udd17 static constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME = \"services\" ; variable GATEWAY_CONFIG_SERVICE_NAME \ud83d\udd17 static constexpr const char GATEWAY_CONFIG_SERVICE_NAME = \"service\" ; variable GATEWAY_CONFIG_SERVICE_INSTANCE_NAME \ud83d\udd17 static constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME = \"instance\" ; variable GATEWAY_CONFIG_SERVICE_EVENT_NAME \ud83d\udd17 static constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME = \"event\" ; variable defaultConfigFilePath \ud83d\udd17 static constexpr char defaultConfigFilePath = \"/etc/iceoryx/roudi_config.toml\" ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::config"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#ioxconfig","text":"","title":"iox::config"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#classes","text":"Name struct iox::config::CmdLineArgs_t class iox::config::CmdLineParser class iox::config::CmdLineParserConfigFileOption struct iox::config::GatewayConfig Generic configuration for gateways. struct iox::config::RouDiConfig class iox::config::TomlGatewayConfigParser The TomlGatewayConfigParser class provides methods for parsing gateway configs from toml text files. class iox::config::TomlRouDiConfigFileProvider","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#types","text":"Name enum TomlGatewayConfigParseError { FILE_NOT_FOUND, INCOMPLETE_CONFIGURATION, INCOMPLETE_SERVICE_DESCRIPTION, INVALID_SERVICE_DESCRIPTION, EXCEPTION_IN_PARSER, MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED} enum CmdLineParserResult { UNKNOWN_OPTION_USED, INFO_OUTPUT_ONLY}","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#functions","text":"Name iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const CmdLineArgs_t & cmdLineArgs)","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#attributes","text":"Name constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS constexpr const char REGEX_VALID_CHARACTERS constexpr const char DEFAULT_CONFIG_FILE_PATH constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME constexpr const char GATEWAY_CONFIG_SERVICE_NAME constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME constexpr char defaultConfigFilePath","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#enum-tomlgatewayconfigparseerror","text":"Enumerator Value Description FILE_NOT_FOUND INCOMPLETE_CONFIGURATION INCOMPLETE_SERVICE_DESCRIPTION INVALID_SERVICE_DESCRIPTION EXCEPTION_IN_PARSER MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED","title":"enum TomlGatewayConfigParseError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#enum-cmdlineparserresult","text":"Enumerator Value Description UNKNOWN_OPTION_USED INFO_OUTPUT_ONLY","title":"enum CmdLineParserResult"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#function-operator","text":"inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const CmdLineArgs_t & cmdLineArgs )","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-toml_gateway_config_file_parse_error_strings","text":"constexpr const char * TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS = { \"FILE_NOT_FOUND\" , \"INCOMPLETE_CONFIGURATION\" , \"INCOMPLETE_SERVICE_DESCRIPTION\" , \"INVALID_SERVICE_DESCRIPTION\" , \"EXCEPTION_IN_PARSER\" , \"MAXIMUM_NUMBER_OF_ENTRIES_EXCEEDED\" };","title":"variable TOML_GATEWAY_CONFIG_FILE_PARSE_ERROR_STRINGS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-regex_valid_characters","text":"static constexpr const char REGEX_VALID_CHARACTERS = \"^[a-zA-Z_][a-zA-Z0-9_]*$\" ;","title":"variable REGEX_VALID_CHARACTERS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-default_config_file_path","text":"static constexpr const char DEFAULT_CONFIG_FILE_PATH = \"/etc/iceoryx/gateway_config.toml\" ;","title":"variable DEFAULT_CONFIG_FILE_PATH"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_table_name","text":"static constexpr const char GATEWAY_CONFIG_SERVICE_TABLE_NAME = \"services\" ;","title":"variable GATEWAY_CONFIG_SERVICE_TABLE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_name","text":"static constexpr const char GATEWAY_CONFIG_SERVICE_NAME = \"service\" ;","title":"variable GATEWAY_CONFIG_SERVICE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_instance_name","text":"static constexpr const char GATEWAY_CONFIG_SERVICE_INSTANCE_NAME = \"instance\" ;","title":"variable GATEWAY_CONFIG_SERVICE_INSTANCE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-gateway_config_service_event_name","text":"static constexpr const char GATEWAY_CONFIG_SERVICE_EVENT_NAME = \"event\" ;","title":"variable GATEWAY_CONFIG_SERVICE_EVENT_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1config/#variable-defaultconfigfilepath","text":"static constexpr char defaultConfigFilePath = \"/etc/iceoryx/roudi_config.toml\" ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable defaultConfigFilePath"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/","text":"iox::gw \ud83d\udd17 Classes \ud83d\udd17 Name class iox: :Channel A data structure representing a channel between Iceoryx and an external system. class iox: :GatewayBase Generic gateway for communication events. class iox: :GatewayDiscovery Discover the gateway. class iox: :GatewayGeneric A reference generic gateway implementation. Types \ud83d\udd17 Name enum uint8_t ChannelError { OBJECT_POOL_FULL} enum uint8_t GatewayError { UNSUPPORTED_SERVICE_TYPE, UNSUCCESSFUL_CHANNEL_CREATION, NONEXISTANT_CHANNEL} Types Documentation \ud83d\udd17 enum ChannelError \ud83d\udd17 Enumerator Value Description OBJECT_POOL_FULL enum GatewayError \ud83d\udd17 Enumerator Value Description UNSUPPORTED_SERVICE_TYPE UNSUCCESSFUL_CHANNEL_CREATION NONEXISTANT_CHANNEL Updated on 18 December 2023 at 13:11:43 CET","title":"iox::gw"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#ioxgw","text":"","title":"iox::gw"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#classes","text":"Name class iox: :Channel A data structure representing a channel between Iceoryx and an external system. class iox: :GatewayBase Generic gateway for communication events. class iox: :GatewayDiscovery Discover the gateway. class iox: :GatewayGeneric A reference generic gateway implementation.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#types","text":"Name enum uint8_t ChannelError { OBJECT_POOL_FULL} enum uint8_t GatewayError { UNSUPPORTED_SERVICE_TYPE, UNSUCCESSFUL_CHANNEL_CREATION, NONEXISTANT_CHANNEL}","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#enum-channelerror","text":"Enumerator Value Description OBJECT_POOL_FULL","title":"enum ChannelError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1gw/#enum-gatewayerror","text":"Enumerator Value Description UNSUPPORTED_SERVICE_TYPE UNSUCCESSFUL_CHANNEL_CREATION NONEXISTANT_CHANNEL Updated on 18 December 2023 at 13:11:43 CET","title":"enum GatewayError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1helper/","text":"iox::helper \ud83d\udd17 Classes \ud83d\udd17 Name struct iox::helper::Optimize struct iox::helper::Optimize< FinalArg > struct iox::helper::Optimize< FirstArg, RemainderArgs... > struct iox::helper::SetDefaults struct iox::helper::SetDefaults< FinalArg > struct iox::helper::SetDefaults< FirstArg, RemainderArgs... > Updated on 18 December 2023 at 13:11:43 CET","title":"iox::helper"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1helper/#ioxhelper","text":"","title":"iox::helper"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1helper/#classes","text":"Name struct iox::helper::Optimize struct iox::helper::Optimize< FinalArg > struct iox::helper::Optimize< FirstArg, RemainderArgs... > struct iox::helper::SetDefaults struct iox::helper::SetDefaults< FinalArg > struct iox::helper::SetDefaults< FirstArg, RemainderArgs... > Updated on 18 December 2023 at 13:11:43 CET","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/","text":"iox::mepoo \ud83d\udd17 Classes \ud83d\udd17 Name struct iox::mepoo::ChunkHeader class iox::mepoo::ChunkSettings struct iox::mepoo::MemoryInfo Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics. struct iox::mepoo::MePooConfig struct iox::mepoo::NoUserHeader Helper struct to use as default template parameter when no user-header is used. struct iox::mepoo::SegmentConfig Types \ud83d\udd17 Name using std::uint64_t SequenceNumber_t using std::chrono::steady_clock BaseClock_t using std::chrono::duration< std::int64_t, std::nano > DurationNs_t using std::chrono::time_point< BaseClock_t, DurationNs_t > TimePointNs_t Types Documentation \ud83d\udd17 using SequenceNumber_t \ud83d\udd17 using iox :: mepoo :: SequenceNumber_t = typedef std :: uint64_t ; using BaseClock_t \ud83d\udd17 using iox :: mepoo :: BaseClock_t = typedef std :: chrono :: steady_clock ; using DurationNs_t \ud83d\udd17 using iox :: mepoo :: DurationNs_t = typedef std :: chrono :: duration < std :: int64_t , std :: nano > ; using TimePointNs_t \ud83d\udd17 using iox :: mepoo :: TimePointNs_t = typedef std :: chrono :: time_point < BaseClock_t , DurationNs_t > ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::mepoo"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#ioxmepoo","text":"","title":"iox::mepoo"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#classes","text":"Name struct iox::mepoo::ChunkHeader class iox::mepoo::ChunkSettings struct iox::mepoo::MemoryInfo Stores properties of the memory to be used when we distinguish between different types of memory on e.g. different devices with different characteristics. struct iox::mepoo::MePooConfig struct iox::mepoo::NoUserHeader Helper struct to use as default template parameter when no user-header is used. struct iox::mepoo::SegmentConfig","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#types","text":"Name using std::uint64_t SequenceNumber_t using std::chrono::steady_clock BaseClock_t using std::chrono::duration< std::int64_t, std::nano > DurationNs_t using std::chrono::time_point< BaseClock_t, DurationNs_t > TimePointNs_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-sequencenumber_t","text":"using iox :: mepoo :: SequenceNumber_t = typedef std :: uint64_t ;","title":"using SequenceNumber_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-baseclock_t","text":"using iox :: mepoo :: BaseClock_t = typedef std :: chrono :: steady_clock ;","title":"using BaseClock_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-durationns_t","text":"using iox :: mepoo :: DurationNs_t = typedef std :: chrono :: duration < std :: int64_t , std :: nano > ;","title":"using DurationNs_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1mepoo/#using-timepointns_t","text":"using iox :: mepoo :: TimePointNs_t = typedef std :: chrono :: time_point < BaseClock_t , DurationNs_t > ; Updated on 18 December 2023 at 13:11:43 CET","title":"using TimePointNs_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/","text":"iox::popo \ud83d\udd17 Namespaces \ud83d\udd17 Name iox::popo::internal Classes \ud83d\udd17 Name class iox::popo::BaseClient The BaseClient class contains the common implementation for the different clients. class iox::popo::BasePublisher The BasePublisher class contains the common implementation for the different publisher specializations. class iox::popo::BaseServer The BaseServer class contains the common implementation for the different server. class iox::popo::BaseSubscriber base class for all types of subscriber class iox::popo::ChunkSender class iox::popo::Client The Client class for the request-response messaging pattern in iceoryx. class iox::popo::ClientImpl The ClientImpl class implements the typed client API. struct iox::popo::ClientOptions This struct is used to configure the client. struct iox::popo::EventBasedTrigger_t struct iox::popo::EventCallback class iox::popo::Listener class iox::popo::ListenerImpl The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. class iox::popo::NotificationAttorney Class which allows accessing private methods to friends of NotificationAttorney . Used for example by the WaitSet . Implements the Client-Attorney Pattern. struct iox::popo::NotificationCallback the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener class iox::popo::NotificationInfo NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback. class iox::popo::Publisher The Publisher class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::PublisherImpl The PublisherImpl class implements the typed publisher API. class iox::popo::PublisherInterface struct iox::popo::PublisherOptions This struct is used to configure the publisher. class iox::popo::Request The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. class iox::popo::RequestHeader class iox::popo::Response The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. class iox::popo::ResponseHeader class iox::popo::RpcBaseHeader class iox::popo::RpcInterface class iox::popo::Sample The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. class iox::popo::Server The Server class for the request-response messaging pattern in iceoryx. class iox::popo::ServerImpl The ServerImpl class implements the typed server API. struct iox::popo::ServerOptions This struct is used to configure the server. struct iox::popo::StateBasedTrigger_t class iox::popo::Subscriber The Subscriber class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::SubscriberImpl The SubscriberImpl class implements the typed subscriber API. struct iox::popo::SubscriberOptions This struct is used to configure the subscriber. class iox::popo::Trigger The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance. class iox::popo::TriggerHandle TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable. class iox::popo::UntypedClient class iox::popo::UntypedClientImpl The UntypedClientImpl class implements the untyped client API. class iox::popo::UntypedPublisher The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::UntypedPublisherImpl The UntypedPublisherImpl class implements the untyped publisher API. class iox::popo::UntypedServer class iox::popo::UntypedServerImpl The UntypedServerImpl class implements the untyped server API. class iox::popo::UntypedSubscriber The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::UntypedSubscriberImpl The UntypedSubscriberImpl class implements the untyped subscriber API. class iox::popo::UserTrigger An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class. class iox::popo::Void class iox::popo::WaitSet Logical disjunction of a certain number of Triggers. Types \ud83d\udd17 Name enum ListenerError { LISTENER_FULL, EVENT_ALREADY_ATTACHED, EMPTY_EVENT_CALLBACK, EMPTY_INVALIDATION_CALLBACK} enum uint8_t ConsumerTooSlowPolicy { WAIT_FOR_CONSUMER, DISCARD_OLDEST_DATA} Used by producers how to adjust to slow consumer. enum uint8_t QueueFullPolicy { BLOCK_PRODUCER, DISCARD_OLDEST_DATA} Used by consumers to request a specific behavior from the producer. enum TriggerType { STATE_BASED, EVENT_BASED, INVALID} enum uint8_t WaitSetError { WAIT_SET_FULL, ALREADY_ATTACHED} enum MessagingPattern { PUB_SUB, REQ_RES} enum EventEnumIdentifier SubscriberEvent { DATA_RECEIVED} enum StateEnumIdentifier SubscriberState { HAS_DATA} using cxx::ConstMethodCallback< bool > WaitSetIsConditionSatisfiedCallback using uint64_t StateEnumIdentifier used as underlying type it identifies an enum as a state based enum using int64_t EventEnumIdentifier used as underlying type it identifies an enum as an event based enum typedef UniquePortId uid_t Functions \ud83d\udd17 Name template <typename OriginType ,typename ContextDataType =internal::NoType_t> NotificationCallback < OriginType, ContextDataType > createNotificationCallback (void(&)(OriginType *const) callback) creates an NotificationCallback template <typename OriginType ,typename ContextDataType > NotificationCallback < OriginType, ContextDataType > createNotificationCallback (void(&)(OriginType const, ContextDataType const) callback, ContextDataType & userValue) creates an NotificationCallback with a user defined value Attributes \ud83d\udd17 Name constexpr bool IS_EVENT_ENUM contains true when T is an event based enum, otherwise false constexpr bool IS_STATE_ENUM contains true when T is a state based enum, otherwise false constexpr StateBasedTrigger_t StateBasedTrigger constexpr EventBasedTrigger_t EventBasedTrigger Types Documentation \ud83d\udd17 enum ListenerError \ud83d\udd17 Enumerator Value Description LISTENER_FULL EVENT_ALREADY_ATTACHED EMPTY_EVENT_CALLBACK EMPTY_INVALIDATION_CALLBACK enum ConsumerTooSlowPolicy \ud83d\udd17 Enumerator Value Description WAIT_FOR_CONSUMER Waits for the consumer it it's queue is full. DISCARD_OLDEST_DATA Discards the oldest data and pushes the newest one into the queue. Used by producers how to adjust to slow consumer. enum QueueFullPolicy \ud83d\udd17 Enumerator Value Description BLOCK_PRODUCER Requests the producer to block when the consumer queue is full. DISCARD_OLDEST_DATA Request to discard the oldest data and push the newest one into the queue. Used by consumers to request a specific behavior from the producer. enum TriggerType \ud83d\udd17 Enumerator Value Description STATE_BASED EVENT_BASED INVALID enum WaitSetError \ud83d\udd17 Enumerator Value Description WAIT_SET_FULL ALREADY_ATTACHED enum MessagingPattern \ud83d\udd17 Enumerator Value Description PUB_SUB REQ_RES enum SubscriberEvent \ud83d\udd17 Enumerator Value Description DATA_RECEIVED enum SubscriberState \ud83d\udd17 Enumerator Value Description HAS_DATA using WaitSetIsConditionSatisfiedCallback \ud83d\udd17 using iox :: popo :: WaitSetIsConditionSatisfiedCallback = typedef cxx :: ConstMethodCallback < bool > ; using StateEnumIdentifier \ud83d\udd17 using iox :: popo :: StateEnumIdentifier = typedef uint64_t ; used as underlying type it identifies an enum as a state based enum using EventEnumIdentifier \ud83d\udd17 using iox :: popo :: EventEnumIdentifier = typedef int64_t ; used as underlying type it identifies an enum as an event based enum typedef uid_t \ud83d\udd17 typedef UniquePortId iox :: popo :: uid_t ; Functions Documentation \ud83d\udd17 function createNotificationCallback \ud83d\udd17 template < typename OriginType , typename ContextDataType = internal :: NoType_t > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & )( OriginType * const ) callback ) creates an NotificationCallback Parameters : callback reference to a callback with the signature void(OriginType*) Return : the callback stored inside of an NotificationCallback function createNotificationCallback \ud83d\udd17 template < typename OriginType , typename ContextDataType > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & )( OriginType * const , ContextDataType * const ) callback , ContextDataType & userValue ) creates an NotificationCallback with a user defined value Parameters : callback reference to a callback with the signature void(OriginType , ContextDataType ) userValue reference to a user defined value Return : the callback and user value stored inside of an NotificationCallback Attributes Documentation \ud83d\udd17 variable IS_EVENT_ENUM \ud83d\udd17 constexpr bool IS_EVENT_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , EventEnumIdentifier >:: value ; contains true when T is an event based enum, otherwise false variable IS_STATE_ENUM \ud83d\udd17 constexpr bool IS_STATE_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , StateEnumIdentifier >:: value ; contains true when T is a state based enum, otherwise false variable StateBasedTrigger \ud83d\udd17 constexpr StateBasedTrigger_t StateBasedTrigger {}; variable EventBasedTrigger \ud83d\udd17 constexpr EventBasedTrigger_t EventBasedTrigger {}; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#ioxpopo","text":"","title":"iox::popo"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#namespaces","text":"Name iox::popo::internal","title":"Namespaces"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#classes","text":"Name class iox::popo::BaseClient The BaseClient class contains the common implementation for the different clients. class iox::popo::BasePublisher The BasePublisher class contains the common implementation for the different publisher specializations. class iox::popo::BaseServer The BaseServer class contains the common implementation for the different server. class iox::popo::BaseSubscriber base class for all types of subscriber class iox::popo::ChunkSender class iox::popo::Client The Client class for the request-response messaging pattern in iceoryx. class iox::popo::ClientImpl The ClientImpl class implements the typed client API. struct iox::popo::ClientOptions This struct is used to configure the client. struct iox::popo::EventBasedTrigger_t struct iox::popo::EventCallback class iox::popo::Listener class iox::popo::ListenerImpl The Listener is a class which reacts to registered events by executing a corresponding callback concurrently. This is achieved via an encapsulated thread inside this class. class iox::popo::NotificationAttorney Class which allows accessing private methods to friends of NotificationAttorney . Used for example by the WaitSet . Implements the Client-Attorney Pattern. struct iox::popo::NotificationCallback the struct describes a callback with a user defined type which can be attached to a WaitSet or a Listener class iox::popo::NotificationInfo NotificationInfo holds the state of a trigger like the pointer to the triggerOrigin, the notification id and the callback. class iox::popo::Publisher The Publisher class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::PublisherImpl The PublisherImpl class implements the typed publisher API. class iox::popo::PublisherInterface struct iox::popo::PublisherOptions This struct is used to configure the publisher. class iox::popo::Request The Request class is a mutable abstraction over types which are written to loaned shared memory. These requests are sent to the server via the iceoryx system. class iox::popo::RequestHeader class iox::popo::Response The Response class is a mutable abstraction over types which are written to loaned shared memory. These responses are sent to the client via the iceoryx system. class iox::popo::ResponseHeader class iox::popo::RpcBaseHeader class iox::popo::RpcInterface class iox::popo::Sample The Sample class is a mutable abstraction over types which are written to loaned shared memory. These samples are publishable to the iceoryx system. class iox::popo::Server The Server class for the request-response messaging pattern in iceoryx. class iox::popo::ServerImpl The ServerImpl class implements the typed server API. struct iox::popo::ServerOptions This struct is used to configure the server. struct iox::popo::StateBasedTrigger_t class iox::popo::Subscriber The Subscriber class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::SubscriberImpl The SubscriberImpl class implements the typed subscriber API. struct iox::popo::SubscriberOptions This struct is used to configure the subscriber. class iox::popo::Trigger The Trigger class is usually managed by a factory class like a WaitSet and acquired by classes which would like to signal a notification. Multiple Trigger can share a common ConditionVariableData pointer so that multiple Trigger can signal a single instance. class iox::popo::TriggerHandle TriggerHandle is threadsafe without restrictions in a single process. Not qualified for inter process usage. The TriggerHandle is generated by a Notifyable like the WaitSet and handed out to the user when they acquire a trigger. The TriggerHandle corresponds with an internal Trigger and is used to signal an event via the trigger method. When it goes out of scope it cleans up the corresponding trigger in the Notifyable. class iox::popo::UntypedClient class iox::popo::UntypedClientImpl The UntypedClientImpl class implements the untyped client API. class iox::popo::UntypedPublisher The UntypedPublisher class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::UntypedPublisherImpl The UntypedPublisherImpl class implements the untyped publisher API. class iox::popo::UntypedServer class iox::popo::UntypedServerImpl The UntypedServerImpl class implements the untyped server API. class iox::popo::UntypedSubscriber The UntypedSubscriber class for the publish-subscribe messaging pattern in iceoryx. class iox::popo::UntypedSubscriberImpl The UntypedSubscriberImpl class implements the untyped subscriber API. class iox::popo::UserTrigger An event based trigger which can be used by the application developer directly. If you would like to trigger a WaitSet/Listener through an event of your class you should use the Trigger class. class iox::popo::Void class iox::popo::WaitSet Logical disjunction of a certain number of Triggers.","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#types","text":"Name enum ListenerError { LISTENER_FULL, EVENT_ALREADY_ATTACHED, EMPTY_EVENT_CALLBACK, EMPTY_INVALIDATION_CALLBACK} enum uint8_t ConsumerTooSlowPolicy { WAIT_FOR_CONSUMER, DISCARD_OLDEST_DATA} Used by producers how to adjust to slow consumer. enum uint8_t QueueFullPolicy { BLOCK_PRODUCER, DISCARD_OLDEST_DATA} Used by consumers to request a specific behavior from the producer. enum TriggerType { STATE_BASED, EVENT_BASED, INVALID} enum uint8_t WaitSetError { WAIT_SET_FULL, ALREADY_ATTACHED} enum MessagingPattern { PUB_SUB, REQ_RES} enum EventEnumIdentifier SubscriberEvent { DATA_RECEIVED} enum StateEnumIdentifier SubscriberState { HAS_DATA} using cxx::ConstMethodCallback< bool > WaitSetIsConditionSatisfiedCallback using uint64_t StateEnumIdentifier used as underlying type it identifies an enum as a state based enum using int64_t EventEnumIdentifier used as underlying type it identifies an enum as an event based enum typedef UniquePortId uid_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#functions","text":"Name template <typename OriginType ,typename ContextDataType =internal::NoType_t> NotificationCallback < OriginType, ContextDataType > createNotificationCallback (void(&)(OriginType *const) callback) creates an NotificationCallback template <typename OriginType ,typename ContextDataType > NotificationCallback < OriginType, ContextDataType > createNotificationCallback (void(&)(OriginType const, ContextDataType const) callback, ContextDataType & userValue) creates an NotificationCallback with a user defined value","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#attributes","text":"Name constexpr bool IS_EVENT_ENUM contains true when T is an event based enum, otherwise false constexpr bool IS_STATE_ENUM contains true when T is a state based enum, otherwise false constexpr StateBasedTrigger_t StateBasedTrigger constexpr EventBasedTrigger_t EventBasedTrigger","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-listenererror","text":"Enumerator Value Description LISTENER_FULL EVENT_ALREADY_ATTACHED EMPTY_EVENT_CALLBACK EMPTY_INVALIDATION_CALLBACK","title":"enum ListenerError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-consumertooslowpolicy","text":"Enumerator Value Description WAIT_FOR_CONSUMER Waits for the consumer it it's queue is full. DISCARD_OLDEST_DATA Discards the oldest data and pushes the newest one into the queue. Used by producers how to adjust to slow consumer.","title":"enum ConsumerTooSlowPolicy"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-queuefullpolicy","text":"Enumerator Value Description BLOCK_PRODUCER Requests the producer to block when the consumer queue is full. DISCARD_OLDEST_DATA Request to discard the oldest data and push the newest one into the queue. Used by consumers to request a specific behavior from the producer.","title":"enum QueueFullPolicy"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-triggertype","text":"Enumerator Value Description STATE_BASED EVENT_BASED INVALID","title":"enum TriggerType"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-waitseterror","text":"Enumerator Value Description WAIT_SET_FULL ALREADY_ATTACHED","title":"enum WaitSetError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-messagingpattern","text":"Enumerator Value Description PUB_SUB REQ_RES","title":"enum MessagingPattern"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-subscriberevent","text":"Enumerator Value Description DATA_RECEIVED","title":"enum SubscriberEvent"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#enum-subscriberstate","text":"Enumerator Value Description HAS_DATA","title":"enum SubscriberState"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#using-waitsetisconditionsatisfiedcallback","text":"using iox :: popo :: WaitSetIsConditionSatisfiedCallback = typedef cxx :: ConstMethodCallback < bool > ;","title":"using WaitSetIsConditionSatisfiedCallback"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#using-stateenumidentifier","text":"using iox :: popo :: StateEnumIdentifier = typedef uint64_t ; used as underlying type it identifies an enum as a state based enum","title":"using StateEnumIdentifier"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#using-eventenumidentifier","text":"using iox :: popo :: EventEnumIdentifier = typedef int64_t ; used as underlying type it identifies an enum as an event based enum","title":"using EventEnumIdentifier"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#typedef-uid_t","text":"typedef UniquePortId iox :: popo :: uid_t ;","title":"typedef uid_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#function-createnotificationcallback","text":"template < typename OriginType , typename ContextDataType = internal :: NoType_t > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & )( OriginType * const ) callback ) creates an NotificationCallback Parameters : callback reference to a callback with the signature void(OriginType*) Return : the callback stored inside of an NotificationCallback","title":"function createNotificationCallback"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#function-createnotificationcallback_1","text":"template < typename OriginType , typename ContextDataType > NotificationCallback < OriginType , ContextDataType > createNotificationCallback ( void ( & )( OriginType * const , ContextDataType * const ) callback , ContextDataType & userValue ) creates an NotificationCallback with a user defined value Parameters : callback reference to a callback with the signature void(OriginType , ContextDataType ) userValue reference to a user defined value Return : the callback and user value stored inside of an NotificationCallback","title":"function createNotificationCallback"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-is_event_enum","text":"constexpr bool IS_EVENT_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , EventEnumIdentifier >:: value ; contains true when T is an event based enum, otherwise false","title":"variable IS_EVENT_ENUM"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-is_state_enum","text":"constexpr bool IS_STATE_ENUM = std :: is_enum < T >:: value && std :: is_same < std :: underlying_type_t < T > , StateEnumIdentifier >:: value ; contains true when T is a state based enum, otherwise false","title":"variable IS_STATE_ENUM"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-statebasedtrigger","text":"constexpr StateBasedTrigger_t StateBasedTrigger {};","title":"variable StateBasedTrigger"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo/#variable-eventbasedtrigger","text":"constexpr EventBasedTrigger_t EventBasedTrigger {}; Updated on 18 December 2023 at 13:11:43 CET","title":"variable EventBasedTrigger"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/","text":"iox::popo::internal \ud83d\udd17 Types \ud83d\udd17 Name using void(*)() GenericCallbackPtr_t using void(&)() GenericCallbackRef_t using void(&)(void const, void const, GenericCallbackPtr_t const) TranslationCallbackRef_t using void( )(void const, void *const, GenericCallbackPtr_t const) TranslationCallbackPtr_t Types Documentation \ud83d\udd17 using GenericCallbackPtr_t \ud83d\udd17 using iox :: popo :: internal :: GenericCallbackPtr_t = typedef void ( * )(); using GenericCallbackRef_t \ud83d\udd17 using iox :: popo :: internal :: GenericCallbackRef_t = typedef void ( & )(); using TranslationCallbackRef_t \ud83d\udd17 using iox :: popo :: internal :: TranslationCallbackRef_t = typedef void ( & )( void * const , void * const , GenericCallbackPtr_t const ); using TranslationCallbackPtr_t \ud83d\udd17 using iox :: popo :: internal :: TranslationCallbackPtr_t = typedef void ( * )( void * const , void * const , GenericCallbackPtr_t const ); Updated on 18 December 2023 at 13:11:43 CET","title":"iox::popo::internal"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#ioxpopointernal","text":"","title":"iox::popo::internal"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#types","text":"Name using void(*)() GenericCallbackPtr_t using void(&)() GenericCallbackRef_t using void(&)(void const, void const, GenericCallbackPtr_t const) TranslationCallbackRef_t using void( )(void const, void *const, GenericCallbackPtr_t const) TranslationCallbackPtr_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-genericcallbackptr_t","text":"using iox :: popo :: internal :: GenericCallbackPtr_t = typedef void ( * )();","title":"using GenericCallbackPtr_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-genericcallbackref_t","text":"using iox :: popo :: internal :: GenericCallbackRef_t = typedef void ( & )();","title":"using GenericCallbackRef_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-translationcallbackref_t","text":"using iox :: popo :: internal :: TranslationCallbackRef_t = typedef void ( & )( void * const , void * const , GenericCallbackPtr_t const );","title":"using TranslationCallbackRef_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1popo_1_1internal/#using-translationcallbackptr_t","text":"using iox :: popo :: internal :: TranslationCallbackPtr_t = typedef void ( * )( void * const , void * const , GenericCallbackPtr_t const ); Updated on 18 December 2023 at 13:11:43 CET","title":"using TranslationCallbackPtr_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/","text":"iox::roudi \ud83d\udd17 More... Classes \ud83d\udd17 Name struct iox::roudi::DefaultRouDiMemory class iox::roudi::GenericMemoryBlock The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. class iox::roudi::IceOryxRouDiApp struct iox::roudi::IceOryxRouDiComponents class iox::roudi::IceOryxRouDiMemoryManager class iox::roudi::MemoryBlock The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider , which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case. class iox::roudi::MemoryProvider This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider . struct iox::roudi::MemPoolInfo struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools. struct iox::roudi::MemPoolIntrospectionInfo the topic for the mempool introspection that a user can subscribe to struct iox::roudi::PortData container for common port data which is related to the subscriber port as well as the publisher port struct iox::roudi::PortIntrospectionFieldTopic the topic for the port introspection that a user can subscribe to class iox::roudi::PortPool struct iox::roudi::PortThroughputData struct iox::roudi::PortThroughputIntrospectionFieldTopic the topic for the port throughput that a user can subscribe to class iox::roudi::PosixShmMemoryProvider Creates the shared memory based on a provided configuration. struct iox::roudi::ProcessIntrospectionData struct iox::roudi::ProcessIntrospectionFieldTopic the topic for the process introspection that a user can subscribe to struct iox::roudi::PublisherPortData container for publisher port introspection data. class iox::roudi::RouDiApp base class for RouDi daemons class iox::roudi::RouDiConfigFileProvider Base class for a config file provider. class iox::roudi::RouDiMemoryInterface class iox::roudi::RouDiMemoryManager struct iox::roudi::SubscriberPortChangingData struct iox::roudi::SubscriberPortChangingIntrospectionFieldTopic Types \ud83d\udd17 Name enum MonitoringMode { ON, OFF} Controls process alive monitoring. Upon timeout, a monitored process is removed and its resources are made available. The process can then start and register itself again. Contrarily, unmonitored processes can be restarted but registration will fail. Once Runlevel Management is extended, it will detect absent processes. Those processes can register again. ON - all processes are monitored OFF - no process is monitored. enum MemoryProviderError { MEMORY_BLOCKS_EXHAUSTED, NO_MEMORY_BLOCKS_PRESENT, MEMORY_ALREADY_CREATED, MEMORY_CREATION_FAILED, MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE, MEMORY_ALLOCATION_FAILED, MEMORY_MAPPING_FAILED, MEMORY_NOT_AVAILABLE, MEMORY_DESTRUCTION_FAILED, MEMORY_DEALLOCATION_FAILED, MEMORY_UNMAPPING_FAILED, SIGACTION_CALL_FAILED} enum RouDiMemoryManagerError { MEMORY_PROVIDER_EXHAUSTED, NO_MEMORY_PROVIDER_PRESENT, MEMORY_CREATION_FAILED, MEMORY_DESTRUCTION_FAILED} enum uint8_t PortPoolError { UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS, INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN, PUBLISHER_PORT_LIST_FULL, SUBSCRIBER_PORT_LIST_FULL, INTERFACE_PORT_LIST_FULL, CLIENT_PORT_LIST_FULL, UNIQUE_SERVER_PORT_ALREADY_EXISTS, SERVER_PORT_LIST_FULL, NODE_DATA_LIST_FULL, CONDITION_VARIABLE_LIST_FULL, EVENT_VARIABLE_LIST_FULL} enum RouDiConfigFileParseError { NO_GENERAL_SECTION, INVALID_CONFIG_FILE_VERSION, NO_SEGMENTS, MAX_NUMBER_OF_SEGMENTS_EXCEEDED, SEGMENT_WITHOUT_MEMPOOL, MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED, MEMPOOL_WITHOUT_CHUNK_SIZE, MEMPOOL_WITHOUT_CHUNK_COUNT, EXCEPTION_IN_PARSER} This are the errors which can occur when a config file is parsed NO_GENERAL_SECTION - the section for general config was not found INVALID_CONFIG_FILE_VERSION - an invalid config file version was detected NO_SEGMENTS - at least one segment needs to be defined MAX_NUMBER_OF_SEGMENTS_EXCEEDED - max number of segments exceeded SEGMENT_WITHOUT_MEMPOOL - a segment must have at least one mempool MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED - the max number of mempools per segment is exceeded MEMPOOL_WITHOUT_CHUNK_SIZE - chunk size not specified for the mempool MEMPOOL_WITHOUT_CHUNK_COUNT - chunk count not specified for the mempool. using cxx::string< 1024 > ConfigFilePathString_t using cxx::vector< MemPoolInfo , MAX_NUMBER_OF_MEMPOOLS > MemPoolInfoContainer container for MemPoolInfo structs of all available mempools. using cxx::vector< MemPoolIntrospectionInfo , MAX_SHM_SEGMENTS+1 > MemPoolIntrospectionInfoContainer container for MemPoolInfo structs of all available mempools. using PortData SubscriberPortData Functions \ud83d\udd17 Name iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const MonitoringMode & mode) iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const RouDiMemoryManagerError & error) Attributes \ud83d\udd17 Name constexpr const char ROUDI_LOCK_NAME constexpr const char IPC_CHANNEL_ROUDI_NAME constexpr const char SHM_NAME shared memory segment for the iceoryx management data constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID constexpr units::Duration PROCESS_DEFAULT_KILL_DELAY constexpr units::Duration PROCESS_TERMINATED_CHECK_INTERVAL constexpr units::Duration DISCOVERY_INTERVAL constexpr const char INTROSPECTION_SERVICE_ID constexpr const char INTROSPECTION_APP_NAME constexpr const char INTROSPECTION_NODE_NAME const capro::ServiceDescription IntrospectionMempoolService constexpr int MAX_GROUP_NAME_LENGTH const capro::ServiceDescription IntrospectionPortService publisher/subscriber port information consisting of a process name,a capro service description string and a node name const capro::ServiceDescription IntrospectionPortThroughputService const capro::ServiceDescription IntrospectionSubscriberPortChangingDataService const capro::ServiceDescription IntrospectionProcessService constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS Detailed Description \ud83d\udd17 Todo : Move everything in this namespace to iceoryx_roudi_types.hpp once we move RouDi to a separate CMake target Types Documentation \ud83d\udd17 enum MonitoringMode \ud83d\udd17 Enumerator Value Description ON OFF Controls process alive monitoring. Upon timeout, a monitored process is removed and its resources are made available. The process can then start and register itself again. Contrarily, unmonitored processes can be restarted but registration will fail. Once Runlevel Management is extended, it will detect absent processes. Those processes can register again. ON - all processes are monitored OFF - no process is monitored. enum MemoryProviderError \ud83d\udd17 Enumerator Value Description MEMORY_BLOCKS_EXHAUSTED attempt to add more memory blocks than the capacity allows NO_MEMORY_BLOCKS_PRESENT an action was performed which requires memory blocks MEMORY_ALREADY_CREATED attempt to create memory although it already was created MEMORY_CREATION_FAILED generic error if memory creation failed MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE attempt to create memory with an alignment bigger than the page size MEMORY_ALLOCATION_FAILED memory creation failed at allocating memory MEMORY_MAPPING_FAILED memory creation failed at mapping memory MEMORY_NOT_AVAILABLE an action was performed which requires memory MEMORY_DESTRUCTION_FAILED generic error if memory destruction failed MEMORY_DEALLOCATION_FAILED memory destruction failed at deallocating memory MEMORY_UNMAPPING_FAILED memory destruction failed at unmapping memory SIGACTION_CALL_FAILED Setup or teardown of SIGBUS failed. enum RouDiMemoryManagerError \ud83d\udd17 Enumerator Value Description MEMORY_PROVIDER_EXHAUSTED attempt to add more memory provider than the capacity allows NO_MEMORY_PROVIDER_PRESENT an action was performed which requires memory provider MEMORY_CREATION_FAILED generic error if memory creation failed MEMORY_DESTRUCTION_FAILED generic error if memory destruction failed enum PortPoolError \ud83d\udd17 Enumerator Value Description UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN PUBLISHER_PORT_LIST_FULL SUBSCRIBER_PORT_LIST_FULL INTERFACE_PORT_LIST_FULL CLIENT_PORT_LIST_FULL UNIQUE_SERVER_PORT_ALREADY_EXISTS SERVER_PORT_LIST_FULL NODE_DATA_LIST_FULL CONDITION_VARIABLE_LIST_FULL EVENT_VARIABLE_LIST_FULL enum RouDiConfigFileParseError \ud83d\udd17 Enumerator Value Description NO_GENERAL_SECTION INVALID_CONFIG_FILE_VERSION NO_SEGMENTS MAX_NUMBER_OF_SEGMENTS_EXCEEDED SEGMENT_WITHOUT_MEMPOOL MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED MEMPOOL_WITHOUT_CHUNK_SIZE MEMPOOL_WITHOUT_CHUNK_COUNT EXCEPTION_IN_PARSER This are the errors which can occur when a config file is parsed NO_GENERAL_SECTION - the section for general config was not found INVALID_CONFIG_FILE_VERSION - an invalid config file version was detected NO_SEGMENTS - at least one segment needs to be defined MAX_NUMBER_OF_SEGMENTS_EXCEEDED - max number of segments exceeded SEGMENT_WITHOUT_MEMPOOL - a segment must have at least one mempool MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED - the max number of mempools per segment is exceeded MEMPOOL_WITHOUT_CHUNK_SIZE - chunk size not specified for the mempool MEMPOOL_WITHOUT_CHUNK_COUNT - chunk count not specified for the mempool. using ConfigFilePathString_t \ud83d\udd17 using iox :: roudi :: ConfigFilePathString_t = typedef cxx :: string < 1024 > ; using MemPoolInfoContainer \ud83d\udd17 using iox :: roudi :: MemPoolInfoContainer = typedef cxx :: vector < MemPoolInfo , MAX_NUMBER_OF_MEMPOOLS > ; container for MemPoolInfo structs of all available mempools. using MemPoolIntrospectionInfoContainer \ud83d\udd17 using iox :: roudi :: MemPoolIntrospectionInfoContainer = typedef cxx :: vector < MemPoolIntrospectionInfo , MAX_SHM_SEGMENTS + 1 > ; container for MemPoolInfo structs of all available mempools. using SubscriberPortData \ud83d\udd17 using iox :: roudi :: SubscriberPortData = typedef PortData ; Functions Documentation \ud83d\udd17 function operator<< \ud83d\udd17 inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const MonitoringMode & mode ) function operator<< \ud83d\udd17 iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const RouDiMemoryManagerError & error ) Attributes Documentation \ud83d\udd17 variable ROUDI_LOCK_NAME \ud83d\udd17 constexpr const char ROUDI_LOCK_NAME = \"iox-unique-roudi\" ; variable IPC_CHANNEL_ROUDI_NAME \ud83d\udd17 constexpr const char IPC_CHANNEL_ROUDI_NAME = \"roudi\" ; variable SHM_NAME \ud83d\udd17 constexpr const char SHM_NAME = \"iceoryx_mgmt\" ; shared memory segment for the iceoryx management data variable DEFAULT_UNIQUE_ROUDI_ID \ud83d\udd17 constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID { 0U }; variable PROCESS_DEFAULT_KILL_DELAY \ud83d\udd17 constexpr units :: Duration PROCESS_DEFAULT_KILL_DELAY = 45 _s ; variable PROCESS_TERMINATED_CHECK_INTERVAL \ud83d\udd17 constexpr units :: Duration PROCESS_TERMINATED_CHECK_INTERVAL = 250 _ms ; variable DISCOVERY_INTERVAL \ud83d\udd17 constexpr units :: Duration DISCOVERY_INTERVAL = 100 _ms ; variable INTROSPECTION_SERVICE_ID \ud83d\udd17 constexpr const char INTROSPECTION_SERVICE_ID = \"Introspection\" ; variable INTROSPECTION_APP_NAME \ud83d\udd17 constexpr const char INTROSPECTION_APP_NAME = \"introspection\" ; variable INTROSPECTION_NODE_NAME \ud83d\udd17 constexpr const char INTROSPECTION_NODE_NAME = \"introspection\" ; variable IntrospectionMempoolService \ud83d\udd17 const capro :: ServiceDescription IntrospectionMempoolService ; variable MAX_GROUP_NAME_LENGTH \ud83d\udd17 constexpr int MAX_GROUP_NAME_LENGTH = 32 ; variable IntrospectionPortService \ud83d\udd17 const capro :: ServiceDescription IntrospectionPortService ; publisher/subscriber port information consisting of a process name,a capro service description string and a node name variable IntrospectionPortThroughputService \ud83d\udd17 const capro :: ServiceDescription IntrospectionPortThroughputService ; variable IntrospectionSubscriberPortChangingDataService \ud83d\udd17 const capro :: ServiceDescription IntrospectionSubscriberPortChangingDataService ; variable IntrospectionProcessService \ud83d\udd17 const capro :: ServiceDescription IntrospectionProcessService ; variable ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS \ud83d\udd17 constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS = { \"NO_GENERAL_SECTION\" , \"INVALID_CONFIG_FILE_VERSION\" , \"NO_SEGMENTS\" , \"MAX_NUMBER_OF_SEGMENTS_EXCEEDED\" , \"SEGMENT_WITHOUT_MEMPOOL\" , \"MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED\" , \"MEMPOOL_WITHOUT_CHUNK_SIZE\" , \"MEMPOOL_WITHOUT_CHUNK_COUNT\" , \"EXCEPTION_IN_PARSER\" }; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::roudi"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#ioxroudi","text":"More...","title":"iox::roudi"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#classes","text":"Name struct iox::roudi::DefaultRouDiMemory class iox::roudi::GenericMemoryBlock The GenericMemoryBlock is an implementation of a MemoryBlock for a common use case. class iox::roudi::IceOryxRouDiApp struct iox::roudi::IceOryxRouDiComponents class iox::roudi::IceOryxRouDiMemoryManager class iox::roudi::MemoryBlock The MemoryBlock is a container for general purpose memory. It is used to request some memory from a MemoryProvider , which can be POSIX SHM, the stack or something completely different. To be able to use the container, some functions need to be implemented. For most use cases the GenericMemoryBlock can be used, which is a templated class and implements the most common case. class iox::roudi::MemoryProvider This class creates memory which is requested by the MemoryBlocks. Once the memory is available, this is announced to the blocks, so that they can consume the memory for their needs. When the Memory is release, the blocks will also called to handle this appropriately, e.g. calling the destructor of the underlying type. This class is an interface with some default behavior and needs an implementation for real memory supply, e.g. a PosixShmMemoryProvider . struct iox::roudi::MemPoolInfo struct for the storage of mempool usage information. This data container is used by the introstpection::MemPoolInfoContainer array to store information on all available memmpools. struct iox::roudi::MemPoolIntrospectionInfo the topic for the mempool introspection that a user can subscribe to struct iox::roudi::PortData container for common port data which is related to the subscriber port as well as the publisher port struct iox::roudi::PortIntrospectionFieldTopic the topic for the port introspection that a user can subscribe to class iox::roudi::PortPool struct iox::roudi::PortThroughputData struct iox::roudi::PortThroughputIntrospectionFieldTopic the topic for the port throughput that a user can subscribe to class iox::roudi::PosixShmMemoryProvider Creates the shared memory based on a provided configuration. struct iox::roudi::ProcessIntrospectionData struct iox::roudi::ProcessIntrospectionFieldTopic the topic for the process introspection that a user can subscribe to struct iox::roudi::PublisherPortData container for publisher port introspection data. class iox::roudi::RouDiApp base class for RouDi daemons class iox::roudi::RouDiConfigFileProvider Base class for a config file provider. class iox::roudi::RouDiMemoryInterface class iox::roudi::RouDiMemoryManager struct iox::roudi::SubscriberPortChangingData struct iox::roudi::SubscriberPortChangingIntrospectionFieldTopic","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#types","text":"Name enum MonitoringMode { ON, OFF} Controls process alive monitoring. Upon timeout, a monitored process is removed and its resources are made available. The process can then start and register itself again. Contrarily, unmonitored processes can be restarted but registration will fail. Once Runlevel Management is extended, it will detect absent processes. Those processes can register again. ON - all processes are monitored OFF - no process is monitored. enum MemoryProviderError { MEMORY_BLOCKS_EXHAUSTED, NO_MEMORY_BLOCKS_PRESENT, MEMORY_ALREADY_CREATED, MEMORY_CREATION_FAILED, MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE, MEMORY_ALLOCATION_FAILED, MEMORY_MAPPING_FAILED, MEMORY_NOT_AVAILABLE, MEMORY_DESTRUCTION_FAILED, MEMORY_DEALLOCATION_FAILED, MEMORY_UNMAPPING_FAILED, SIGACTION_CALL_FAILED} enum RouDiMemoryManagerError { MEMORY_PROVIDER_EXHAUSTED, NO_MEMORY_PROVIDER_PRESENT, MEMORY_CREATION_FAILED, MEMORY_DESTRUCTION_FAILED} enum uint8_t PortPoolError { UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS, INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN, PUBLISHER_PORT_LIST_FULL, SUBSCRIBER_PORT_LIST_FULL, INTERFACE_PORT_LIST_FULL, CLIENT_PORT_LIST_FULL, UNIQUE_SERVER_PORT_ALREADY_EXISTS, SERVER_PORT_LIST_FULL, NODE_DATA_LIST_FULL, CONDITION_VARIABLE_LIST_FULL, EVENT_VARIABLE_LIST_FULL} enum RouDiConfigFileParseError { NO_GENERAL_SECTION, INVALID_CONFIG_FILE_VERSION, NO_SEGMENTS, MAX_NUMBER_OF_SEGMENTS_EXCEEDED, SEGMENT_WITHOUT_MEMPOOL, MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED, MEMPOOL_WITHOUT_CHUNK_SIZE, MEMPOOL_WITHOUT_CHUNK_COUNT, EXCEPTION_IN_PARSER} This are the errors which can occur when a config file is parsed NO_GENERAL_SECTION - the section for general config was not found INVALID_CONFIG_FILE_VERSION - an invalid config file version was detected NO_SEGMENTS - at least one segment needs to be defined MAX_NUMBER_OF_SEGMENTS_EXCEEDED - max number of segments exceeded SEGMENT_WITHOUT_MEMPOOL - a segment must have at least one mempool MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED - the max number of mempools per segment is exceeded MEMPOOL_WITHOUT_CHUNK_SIZE - chunk size not specified for the mempool MEMPOOL_WITHOUT_CHUNK_COUNT - chunk count not specified for the mempool. using cxx::string< 1024 > ConfigFilePathString_t using cxx::vector< MemPoolInfo , MAX_NUMBER_OF_MEMPOOLS > MemPoolInfoContainer container for MemPoolInfo structs of all available mempools. using cxx::vector< MemPoolIntrospectionInfo , MAX_SHM_SEGMENTS+1 > MemPoolIntrospectionInfoContainer container for MemPoolInfo structs of all available mempools. using PortData SubscriberPortData","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#functions","text":"Name iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const MonitoringMode & mode) iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const RouDiMemoryManagerError & error)","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#attributes","text":"Name constexpr const char ROUDI_LOCK_NAME constexpr const char IPC_CHANNEL_ROUDI_NAME constexpr const char SHM_NAME shared memory segment for the iceoryx management data constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID constexpr units::Duration PROCESS_DEFAULT_KILL_DELAY constexpr units::Duration PROCESS_TERMINATED_CHECK_INTERVAL constexpr units::Duration DISCOVERY_INTERVAL constexpr const char INTROSPECTION_SERVICE_ID constexpr const char INTROSPECTION_APP_NAME constexpr const char INTROSPECTION_NODE_NAME const capro::ServiceDescription IntrospectionMempoolService constexpr int MAX_GROUP_NAME_LENGTH const capro::ServiceDescription IntrospectionPortService publisher/subscriber port information consisting of a process name,a capro service description string and a node name const capro::ServiceDescription IntrospectionPortThroughputService const capro::ServiceDescription IntrospectionSubscriberPortChangingDataService const capro::ServiceDescription IntrospectionProcessService constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#detailed-description","text":"Todo : Move everything in this namespace to iceoryx_roudi_types.hpp once we move RouDi to a separate CMake target","title":"Detailed Description"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-monitoringmode","text":"Enumerator Value Description ON OFF Controls process alive monitoring. Upon timeout, a monitored process is removed and its resources are made available. The process can then start and register itself again. Contrarily, unmonitored processes can be restarted but registration will fail. Once Runlevel Management is extended, it will detect absent processes. Those processes can register again. ON - all processes are monitored OFF - no process is monitored.","title":"enum MonitoringMode"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-memoryprovidererror","text":"Enumerator Value Description MEMORY_BLOCKS_EXHAUSTED attempt to add more memory blocks than the capacity allows NO_MEMORY_BLOCKS_PRESENT an action was performed which requires memory blocks MEMORY_ALREADY_CREATED attempt to create memory although it already was created MEMORY_CREATION_FAILED generic error if memory creation failed MEMORY_ALIGNMENT_EXCEEDS_PAGE_SIZE attempt to create memory with an alignment bigger than the page size MEMORY_ALLOCATION_FAILED memory creation failed at allocating memory MEMORY_MAPPING_FAILED memory creation failed at mapping memory MEMORY_NOT_AVAILABLE an action was performed which requires memory MEMORY_DESTRUCTION_FAILED generic error if memory destruction failed MEMORY_DEALLOCATION_FAILED memory destruction failed at deallocating memory MEMORY_UNMAPPING_FAILED memory destruction failed at unmapping memory SIGACTION_CALL_FAILED Setup or teardown of SIGBUS failed.","title":"enum MemoryProviderError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-roudimemorymanagererror","text":"Enumerator Value Description MEMORY_PROVIDER_EXHAUSTED attempt to add more memory provider than the capacity allows NO_MEMORY_PROVIDER_PRESENT an action was performed which requires memory provider MEMORY_CREATION_FAILED generic error if memory creation failed MEMORY_DESTRUCTION_FAILED generic error if memory destruction failed","title":"enum RouDiMemoryManagerError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-portpoolerror","text":"Enumerator Value Description UNIQUE_PUBLISHER_PORT_ALREADY_EXISTS INTERNAL_SERVICE_DESCRIPTION_IS_FORBIDDEN PUBLISHER_PORT_LIST_FULL SUBSCRIBER_PORT_LIST_FULL INTERFACE_PORT_LIST_FULL CLIENT_PORT_LIST_FULL UNIQUE_SERVER_PORT_ALREADY_EXISTS SERVER_PORT_LIST_FULL NODE_DATA_LIST_FULL CONDITION_VARIABLE_LIST_FULL EVENT_VARIABLE_LIST_FULL","title":"enum PortPoolError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#enum-roudiconfigfileparseerror","text":"Enumerator Value Description NO_GENERAL_SECTION INVALID_CONFIG_FILE_VERSION NO_SEGMENTS MAX_NUMBER_OF_SEGMENTS_EXCEEDED SEGMENT_WITHOUT_MEMPOOL MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED MEMPOOL_WITHOUT_CHUNK_SIZE MEMPOOL_WITHOUT_CHUNK_COUNT EXCEPTION_IN_PARSER This are the errors which can occur when a config file is parsed NO_GENERAL_SECTION - the section for general config was not found INVALID_CONFIG_FILE_VERSION - an invalid config file version was detected NO_SEGMENTS - at least one segment needs to be defined MAX_NUMBER_OF_SEGMENTS_EXCEEDED - max number of segments exceeded SEGMENT_WITHOUT_MEMPOOL - a segment must have at least one mempool MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED - the max number of mempools per segment is exceeded MEMPOOL_WITHOUT_CHUNK_SIZE - chunk size not specified for the mempool MEMPOOL_WITHOUT_CHUNK_COUNT - chunk count not specified for the mempool.","title":"enum RouDiConfigFileParseError"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-configfilepathstring_t","text":"using iox :: roudi :: ConfigFilePathString_t = typedef cxx :: string < 1024 > ;","title":"using ConfigFilePathString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-mempoolinfocontainer","text":"using iox :: roudi :: MemPoolInfoContainer = typedef cxx :: vector < MemPoolInfo , MAX_NUMBER_OF_MEMPOOLS > ; container for MemPoolInfo structs of all available mempools.","title":"using MemPoolInfoContainer"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-mempoolintrospectioninfocontainer","text":"using iox :: roudi :: MemPoolIntrospectionInfoContainer = typedef cxx :: vector < MemPoolIntrospectionInfo , MAX_SHM_SEGMENTS + 1 > ; container for MemPoolInfo structs of all available mempools.","title":"using MemPoolIntrospectionInfoContainer"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#using-subscriberportdata","text":"using iox :: roudi :: SubscriberPortData = typedef PortData ;","title":"using SubscriberPortData"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#function-operator","text":"inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const MonitoringMode & mode )","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#function-operator_1","text":"iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const RouDiMemoryManagerError & error )","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-roudi_lock_name","text":"constexpr const char ROUDI_LOCK_NAME = \"iox-unique-roudi\" ;","title":"variable ROUDI_LOCK_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-ipc_channel_roudi_name","text":"constexpr const char IPC_CHANNEL_ROUDI_NAME = \"roudi\" ;","title":"variable IPC_CHANNEL_ROUDI_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-shm_name","text":"constexpr const char SHM_NAME = \"iceoryx_mgmt\" ; shared memory segment for the iceoryx management data","title":"variable SHM_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-default_unique_roudi_id","text":"constexpr uint16_t DEFAULT_UNIQUE_ROUDI_ID { 0U };","title":"variable DEFAULT_UNIQUE_ROUDI_ID"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-process_default_kill_delay","text":"constexpr units :: Duration PROCESS_DEFAULT_KILL_DELAY = 45 _s ;","title":"variable PROCESS_DEFAULT_KILL_DELAY"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-process_terminated_check_interval","text":"constexpr units :: Duration PROCESS_TERMINATED_CHECK_INTERVAL = 250 _ms ;","title":"variable PROCESS_TERMINATED_CHECK_INTERVAL"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-discovery_interval","text":"constexpr units :: Duration DISCOVERY_INTERVAL = 100 _ms ;","title":"variable DISCOVERY_INTERVAL"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspection_service_id","text":"constexpr const char INTROSPECTION_SERVICE_ID = \"Introspection\" ;","title":"variable INTROSPECTION_SERVICE_ID"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspection_app_name","text":"constexpr const char INTROSPECTION_APP_NAME = \"introspection\" ;","title":"variable INTROSPECTION_APP_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspection_node_name","text":"constexpr const char INTROSPECTION_NODE_NAME = \"introspection\" ;","title":"variable INTROSPECTION_NODE_NAME"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionmempoolservice","text":"const capro :: ServiceDescription IntrospectionMempoolService ;","title":"variable IntrospectionMempoolService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-max_group_name_length","text":"constexpr int MAX_GROUP_NAME_LENGTH = 32 ;","title":"variable MAX_GROUP_NAME_LENGTH"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionportservice","text":"const capro :: ServiceDescription IntrospectionPortService ; publisher/subscriber port information consisting of a process name,a capro service description string and a node name","title":"variable IntrospectionPortService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionportthroughputservice","text":"const capro :: ServiceDescription IntrospectionPortThroughputService ;","title":"variable IntrospectionPortThroughputService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionsubscriberportchangingdataservice","text":"const capro :: ServiceDescription IntrospectionSubscriberPortChangingDataService ;","title":"variable IntrospectionSubscriberPortChangingDataService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-introspectionprocessservice","text":"const capro :: ServiceDescription IntrospectionProcessService ;","title":"variable IntrospectionProcessService"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1roudi/#variable-roudi_config_file_parse_error_strings","text":"constexpr const char * ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS = { \"NO_GENERAL_SECTION\" , \"INVALID_CONFIG_FILE_VERSION\" , \"NO_SEGMENTS\" , \"MAX_NUMBER_OF_SEGMENTS_EXCEEDED\" , \"SEGMENT_WITHOUT_MEMPOOL\" , \"MAX_NUMBER_OF_MEMPOOLS_PER_SEGMENT_EXCEEDED\" , \"MEMPOOL_WITHOUT_CHUNK_SIZE\" , \"MEMPOOL_WITHOUT_CHUNK_COUNT\" , \"EXCEPTION_IN_PARSER\" }; Updated on 18 December 2023 at 13:11:43 CET","title":"variable ROUDI_CONFIG_FILE_PARSE_ERROR_STRINGS"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/","text":"iox::runtime \ud83d\udd17 Classes \ud83d\udd17 Name class iox::runtime::Node class which represents a node struct iox::runtime::PortConfigInfo Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU). class iox::runtime::PoshRuntime The runtime that is needed for each application to communicate with the RouDi daemon. class iox::runtime::PoshRuntimeSingleProcess class iox::runtime::ServiceDiscovery Types \ud83d\udd17 Name enum popo::EventEnumIdentifier ServiceDiscoveryEvent { SERVICE_REGISTRY_CHANGED} using iox::cxx::vector< capro::ServiceDescription , MAX_FINDSERVICE_RESULT_SIZE > ServiceContainer Attributes \ud83d\udd17 Name constexpr units::Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT constexpr units::Duration PROCESS_KEEP_ALIVE_INTERVAL constexpr units::Duration PROCESS_KEEP_ALIVE_TIMEOUT Types Documentation \ud83d\udd17 enum ServiceDiscoveryEvent \ud83d\udd17 Enumerator Value Description SERVICE_REGISTRY_CHANGED using ServiceContainer \ud83d\udd17 using iox :: runtime :: ServiceContainer = typedef iox :: cxx :: vector < capro :: ServiceDescription , MAX_FINDSERVICE_RESULT_SIZE > ; Attributes Documentation \ud83d\udd17 variable PROCESS_WAITING_FOR_ROUDI_TIMEOUT \ud83d\udd17 constexpr units :: Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT = 60 _s ; variable PROCESS_KEEP_ALIVE_INTERVAL \ud83d\udd17 constexpr units :: Duration PROCESS_KEEP_ALIVE_INTERVAL = 3 * roudi :: DISCOVERY_INTERVAL ; variable PROCESS_KEEP_ALIVE_TIMEOUT \ud83d\udd17 constexpr units :: Duration PROCESS_KEEP_ALIVE_TIMEOUT = 5 * PROCESS_KEEP_ALIVE_INTERVAL ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::runtime"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#ioxruntime","text":"","title":"iox::runtime"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#classes","text":"Name class iox::runtime::Node class which represents a node struct iox::runtime::PortConfigInfo Stores information necessary to create the right type of port on RouDi side. Different types of ports are required if e.g. different types of shared memory are used (e.g. on GPU). class iox::runtime::PoshRuntime The runtime that is needed for each application to communicate with the RouDi daemon. class iox::runtime::PoshRuntimeSingleProcess class iox::runtime::ServiceDiscovery","title":"Classes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#types","text":"Name enum popo::EventEnumIdentifier ServiceDiscoveryEvent { SERVICE_REGISTRY_CHANGED} using iox::cxx::vector< capro::ServiceDescription , MAX_FINDSERVICE_RESULT_SIZE > ServiceContainer","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#attributes","text":"Name constexpr units::Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT constexpr units::Duration PROCESS_KEEP_ALIVE_INTERVAL constexpr units::Duration PROCESS_KEEP_ALIVE_TIMEOUT","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#enum-servicediscoveryevent","text":"Enumerator Value Description SERVICE_REGISTRY_CHANGED","title":"enum ServiceDiscoveryEvent"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#using-servicecontainer","text":"using iox :: runtime :: ServiceContainer = typedef iox :: cxx :: vector < capro :: ServiceDescription , MAX_FINDSERVICE_RESULT_SIZE > ;","title":"using ServiceContainer"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#variable-process_waiting_for_roudi_timeout","text":"constexpr units :: Duration PROCESS_WAITING_FOR_ROUDI_TIMEOUT = 60 _s ;","title":"variable PROCESS_WAITING_FOR_ROUDI_TIMEOUT"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#variable-process_keep_alive_interval","text":"constexpr units :: Duration PROCESS_KEEP_ALIVE_INTERVAL = 3 * roudi :: DISCOVERY_INTERVAL ;","title":"variable PROCESS_KEEP_ALIVE_INTERVAL"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1runtime/#variable-process_keep_alive_timeout","text":"constexpr units :: Duration PROCESS_KEEP_ALIVE_TIMEOUT = 5 * PROCESS_KEEP_ALIVE_INTERVAL ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable PROCESS_KEEP_ALIVE_TIMEOUT"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1units_1_1duration__literals/","text":"iox::units::duration_literals \ud83d\udd17 Updated on 18 December 2023 at 13:11:43 CET","title":"iox::units::duration_literals"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1units_1_1duration__literals/#ioxunitsduration_literals","text":"Updated on 18 December 2023 at 13:11:43 CET","title":"iox::units::duration_literals"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/","text":"iox::version \ud83d\udd17 Types \ud83d\udd17 Name enum CompatibilityCheckLevel { OFF, MAJOR, MINOR, PATCH, COMMIT_ID, BUILD_DATE} using cxx::string< COMMIT_ID_STRING_SIZE > CommitIdString_t using cxx::string< BUILD_DATE_STRING_SIZE > BuildDateString_t Functions \ud83d\udd17 Name iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const version::CompatibilityCheckLevel & level) Attributes \ud83d\udd17 Name const uint64_t COMMIT_ID_STRING_SIZE const uint64_t BUILD_DATE_STRING_SIZE Types Documentation \ud83d\udd17 enum CompatibilityCheckLevel \ud83d\udd17 Enumerator Value Description OFF MAJOR MINOR PATCH COMMIT_ID BUILD_DATE using CommitIdString_t \ud83d\udd17 using iox :: version :: CommitIdString_t = typedef cxx :: string < COMMIT_ID_STRING_SIZE > ; using BuildDateString_t \ud83d\udd17 using iox :: version :: BuildDateString_t = typedef cxx :: string < BUILD_DATE_STRING_SIZE > ; Functions Documentation \ud83d\udd17 function operator<< \ud83d\udd17 inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const version :: CompatibilityCheckLevel & level ) Attributes Documentation \ud83d\udd17 variable COMMIT_ID_STRING_SIZE \ud83d\udd17 static const uint64_t COMMIT_ID_STRING_SIZE = 12U ; variable BUILD_DATE_STRING_SIZE \ud83d\udd17 static const uint64_t BUILD_DATE_STRING_SIZE = 36U ; Updated on 18 December 2023 at 13:11:43 CET","title":"iox::version"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#ioxversion","text":"","title":"iox::version"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#types","text":"Name enum CompatibilityCheckLevel { OFF, MAJOR, MINOR, PATCH, COMMIT_ID, BUILD_DATE} using cxx::string< COMMIT_ID_STRING_SIZE > CommitIdString_t using cxx::string< BUILD_DATE_STRING_SIZE > BuildDateString_t","title":"Types"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#functions","text":"Name iox::log::LogStream & operator<< (iox::log::LogStream & logstream, const version::CompatibilityCheckLevel & level)","title":"Functions"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#attributes","text":"Name const uint64_t COMMIT_ID_STRING_SIZE const uint64_t BUILD_DATE_STRING_SIZE","title":"Attributes"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#types-documentation","text":"","title":"Types Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#enum-compatibilitychecklevel","text":"Enumerator Value Description OFF MAJOR MINOR PATCH COMMIT_ID BUILD_DATE","title":"enum CompatibilityCheckLevel"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#using-commitidstring_t","text":"using iox :: version :: CommitIdString_t = typedef cxx :: string < COMMIT_ID_STRING_SIZE > ;","title":"using CommitIdString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#using-builddatestring_t","text":"using iox :: version :: BuildDateString_t = typedef cxx :: string < BUILD_DATE_STRING_SIZE > ;","title":"using BuildDateString_t"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#function-operator","text":"inline iox :: log :: LogStream & operator << ( iox :: log :: LogStream & logstream , const version :: CompatibilityCheckLevel & level )","title":"function operator&lt;&lt;"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#variable-commit_id_string_size","text":"static const uint64_t COMMIT_ID_STRING_SIZE = 12U ;","title":"variable COMMIT_ID_STRING_SIZE"},{"location":"API-reference/posh/Namespaces/namespaceiox_1_1version/#variable-build_date_string_size","text":"static const uint64_t BUILD_DATE_STRING_SIZE = 36U ; Updated on 18 December 2023 at 13:11:43 CET","title":"variable BUILD_DATE_STRING_SIZE"},{"location":"API-reference/posh/Pages/todo/","text":"Todo List \ud83d\udd17 Namespace iox::roudi Move everything in this namespace to iceoryx_roudi_types.hpp once we move RouDi to a separate CMake target Member iox::roudi::PortPool::getPublisherPortDataList () noexcept don't create the vector with each call but only when the data really change there could be a member \"cxx::vector<popo::PublisherPortData* m_publisherPorts;\" and publisherPorts() would just update this member if the publisher ports actually changed Updated on 18 December 2023 at 13:11:43 CET","title":"Todo List"},{"location":"API-reference/posh/Pages/todo/#todo-list","text":"Namespace iox::roudi Move everything in this namespace to iceoryx_roudi_types.hpp once we move RouDi to a separate CMake target Member iox::roudi::PortPool::getPublisherPortDataList () noexcept don't create the vector with each call but only when the data really change there could be a member \"cxx::vector<popo::PublisherPortData* m_publisherPorts;\" and publisherPorts() would just update this member if the publisher ports actually changed Updated on 18 December 2023 at 13:11:43 CET","title":"Todo List"},{"location":"advanced/configuration-guide/","text":"Configuration guide \ud83d\udd17 CMake switches for configuring iceoryx_posh build \ud83d\udd17 When building iceoryx_posh, there are several configuration options set by default. These options adjust the limits of Publisher and Subscriber Ports for resource management. These limits are used to create management structures in the shared memory segment called iceoryx_mgmt when starting up RouDi. switch description IOX_MAX_PUBLISHERS Maximum number of publishers which can be managed by one RouDi instance IOX_MAX_SUBSCRIBERS_PER_PUBLISHER Maximum number of connected subscriber ports per publisher port IOX_MAX_PUBLISHER_HISTORY Maximum number of chunks available for the publisher history IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY Maximum number of chunks a publisher can allocate at a given time IOX_MAX_SUBSCRIBERS Maximum number of subscribers which can be managed by one RouDi instance IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY Maximum number of chunks a subscriber can hold at a given time (subscriber history size) IOX_MAX_INTERFACE_NUMBER Maximum number of interface ports which are used for gateways Have a look at IceoryxPoshDeployment.cmake for the default values of the constants. Hint With the default values set, the size of iceoryx_mgmt is ~64.5 MByte. You can reduce the size by decreasing the values from the table via the CMake options. The current values are printed in the CMake stage when building iceoryx. Example: cmake -Bbuild -Hiceoryx_meta -DIOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY = 64 With that change, the footprint of the management segment is reduced to ~52.7 MBytes. For larger use cases you can increase the value to avoid that samples are dropped on the subscriber side (see also #615 ). Configuring Mempools for RouDi \ud83d\udd17 RouDi supports several shared memory segments with different access rights, to limit the read and write access between different applications. Inside of these segments reside mempools where the user payload data for transfer is stored. Note Actually only the chunk-payload size is configured and the size of the ChunkHeader will be added to the configured size. If a user-header or a user-payload alignment larger than 8 is used, the available size for the user-payload will be smaller than the configured chunk-payload since some space is needed for the other functionality. Please have a look at the chunk_header.md design document for a formula how to determine the necessary chunk-payload size with user-header and extended user-payload alignment. For building RouDi, iceoryx ships a library named iceoryx_posh_roudi . This lib gives you an API for compiling your own RouDi application and is part of iceoryx_posh . Note The chunk size for the mempool needs to follow these restrictions: Chunksize needs to be greater than the alignment Chunksize needs to be a multiple of the alignment The value for the alignment is set to 8. Dynamic configuration \ud83d\udd17 One way is to read a configuration dynamically at RouDi runtime (startup). Using TOML Config in RouDi is not mandatory for configuring segments and mempools, but a comfortable alternative. To enable the TOML config in iceoryx, the CMake option -DTOML_CONFIG=ON must be used (enabled by default). The iox-roudi provided by iceoryx is with TOML support and can be used out of the box. If you create your own RouDi application you need to link against iceoryx_posh_config : target_link_libraries ( custom-roudi PRIVATE iceoryx_posh::iceoryx_posh_roudi iceoryx_posh::iceoryx_posh_config ) The TOML config file can be passed to RouDi with the -c command-line option. ./iox-roudi -c /absolute/path/to/config/file.toml This is a common config file with format version 1: [general] version = 1 [[segment]] [[segment.mempool]] size = 32 count = 10000 [[segment.mempool]] size = 128 count = 10000 [[segment.mempool]] size = 1024 count = 1000 With this configuration, one payload segment will be created. The access rights are set to the RouDi group id. There are three mempools within this segment. One with 10000 chunks of 32 byte payload size, one with 10000 chunks of 128 bytes, and one with 1000 chunks of 1024 bytes. To restrict the access, a reader and writer group can be set: [general] version = 1 [[segment]] reader = \"foo\" writer = \"bar\" [[segment.mempool]] size = 32 count = 10000 [[segment.mempool]] size = 128 count = 10000 [[segment.mempool]] size = 1024 count = 1000 With this configuration, only applications from the bar group have write access and can allocate chunks. Applications from the foo group have only read access. This is an example with multiple segments: [general] version = 1 [[segment]] reader = \"foo\" writer = \"bar\" [[segment.mempool]] size = 32 count = 10000 [[segment]] reader = \"alice\" writer = \"eve\" [[segment.mempool]] size = 1024 count = 100 When no config file is specified, a hard-coded version similar to the default config will be used. Static configuration \ud83d\udd17 Another way is to have a static config that is compile-time dependent, this means that you have to recompile your RouDi application if you want to change your config (not the iceoryx_posh_roudi lib). You can have your source file with main() method where you can create your custom configuration and pass it to a RouDi instantiation. In your CMake file for your custom RouDi you need to ensure that it is not linking against iceoryx_posh_config to have a static config. A good example of a static config can be found here .","title":"Configuration guide"},{"location":"advanced/configuration-guide/#configuration-guide","text":"","title":"Configuration guide"},{"location":"advanced/configuration-guide/#cmake-switches-for-configuring-iceoryx_posh-build","text":"When building iceoryx_posh, there are several configuration options set by default. These options adjust the limits of Publisher and Subscriber Ports for resource management. These limits are used to create management structures in the shared memory segment called iceoryx_mgmt when starting up RouDi. switch description IOX_MAX_PUBLISHERS Maximum number of publishers which can be managed by one RouDi instance IOX_MAX_SUBSCRIBERS_PER_PUBLISHER Maximum number of connected subscriber ports per publisher port IOX_MAX_PUBLISHER_HISTORY Maximum number of chunks available for the publisher history IOX_MAX_CHUNKS_ALLOCATED_PER_PUBLISHER_SIMULTANEOUSLY Maximum number of chunks a publisher can allocate at a given time IOX_MAX_SUBSCRIBERS Maximum number of subscribers which can be managed by one RouDi instance IOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY Maximum number of chunks a subscriber can hold at a given time (subscriber history size) IOX_MAX_INTERFACE_NUMBER Maximum number of interface ports which are used for gateways Have a look at IceoryxPoshDeployment.cmake for the default values of the constants. Hint With the default values set, the size of iceoryx_mgmt is ~64.5 MByte. You can reduce the size by decreasing the values from the table via the CMake options. The current values are printed in the CMake stage when building iceoryx. Example: cmake -Bbuild -Hiceoryx_meta -DIOX_MAX_CHUNKS_HELD_PER_SUBSCRIBER_SIMULTANEOUSLY = 64 With that change, the footprint of the management segment is reduced to ~52.7 MBytes. For larger use cases you can increase the value to avoid that samples are dropped on the subscriber side (see also #615 ).","title":" CMake switches for configuring iceoryx_posh build"},{"location":"advanced/configuration-guide/#configuring-mempools-for-roudi","text":"RouDi supports several shared memory segments with different access rights, to limit the read and write access between different applications. Inside of these segments reside mempools where the user payload data for transfer is stored. Note Actually only the chunk-payload size is configured and the size of the ChunkHeader will be added to the configured size. If a user-header or a user-payload alignment larger than 8 is used, the available size for the user-payload will be smaller than the configured chunk-payload since some space is needed for the other functionality. Please have a look at the chunk_header.md design document for a formula how to determine the necessary chunk-payload size with user-header and extended user-payload alignment. For building RouDi, iceoryx ships a library named iceoryx_posh_roudi . This lib gives you an API for compiling your own RouDi application and is part of iceoryx_posh . Note The chunk size for the mempool needs to follow these restrictions: Chunksize needs to be greater than the alignment Chunksize needs to be a multiple of the alignment The value for the alignment is set to 8.","title":" Configuring Mempools for RouDi"},{"location":"advanced/configuration-guide/#dynamic-configuration","text":"One way is to read a configuration dynamically at RouDi runtime (startup). Using TOML Config in RouDi is not mandatory for configuring segments and mempools, but a comfortable alternative. To enable the TOML config in iceoryx, the CMake option -DTOML_CONFIG=ON must be used (enabled by default). The iox-roudi provided by iceoryx is with TOML support and can be used out of the box. If you create your own RouDi application you need to link against iceoryx_posh_config : target_link_libraries ( custom-roudi PRIVATE iceoryx_posh::iceoryx_posh_roudi iceoryx_posh::iceoryx_posh_config ) The TOML config file can be passed to RouDi with the -c command-line option. ./iox-roudi -c /absolute/path/to/config/file.toml This is a common config file with format version 1: [general] version = 1 [[segment]] [[segment.mempool]] size = 32 count = 10000 [[segment.mempool]] size = 128 count = 10000 [[segment.mempool]] size = 1024 count = 1000 With this configuration, one payload segment will be created. The access rights are set to the RouDi group id. There are three mempools within this segment. One with 10000 chunks of 32 byte payload size, one with 10000 chunks of 128 bytes, and one with 1000 chunks of 1024 bytes. To restrict the access, a reader and writer group can be set: [general] version = 1 [[segment]] reader = \"foo\" writer = \"bar\" [[segment.mempool]] size = 32 count = 10000 [[segment.mempool]] size = 128 count = 10000 [[segment.mempool]] size = 1024 count = 1000 With this configuration, only applications from the bar group have write access and can allocate chunks. Applications from the foo group have only read access. This is an example with multiple segments: [general] version = 1 [[segment]] reader = \"foo\" writer = \"bar\" [[segment.mempool]] size = 32 count = 10000 [[segment]] reader = \"alice\" writer = \"eve\" [[segment.mempool]] size = 1024 count = 100 When no config file is specified, a hard-coded version similar to the default config will be used.","title":" Dynamic configuration"},{"location":"advanced/configuration-guide/#static-configuration","text":"Another way is to have a static config that is compile-time dependent, this means that you have to recompile your RouDi application if you want to change your config (not the iceoryx_posh_roudi lib). You can have your source file with main() method where you can create your custom configuration and pass it to a RouDi instantiation. In your CMake file for your custom RouDi you need to ensure that it is not linking against iceoryx_posh_config to have a static config. A good example of a static config can be found here .","title":"Static configuration"},{"location":"advanced/iceoryx_hoofs/","text":"Eclipse iceoryx hoofs overview \ud83d\udd17 The iceoryx hoofs ( H andy O bjects O ptimised F or S afety) are our basic building blocks - the foundation of iceoryx. There are a wide variety of building blocks grouped together in categories or namespace, depending on where or how they are used. Categories \ud83d\udd17 Namespace Short Description cxx Since we are not allowed to use C++17 as well as the heap or exceptions we implemented constructs like optional , expected or variant so that we can be as modern as possible. Furthermore, you can find here constructs which are mentioned in the C++ Core Guidelines as well as STL re-implementations of container like vector which are relocatable an can be placed into the shared memory. concurrent You should never use concurrent constructs like mutex , semaphores , atomic , etc. directly in our codebase. At the moment we still have some exceptions to this guideline but the idea is that all classes which are using them are stored under concurrent and have to undergo more tests then the usual non concurrent class. For instance we try to provide stress tests for them. This module provides classes like fifo , smart_lock , sofi , trigger_queue and much more. design_pattern Certain code patterns which are repeating themselves all over the code are abstracted and stored in here. At the moment we only have the creation pattern which will be removed in a future release. error-handling The central error handler in iceoryx for cases when no sane further execution is possible, e.g. nullptr access. log The logger used by iceoryx. posix_wrapper Posix constructs like shared memory, threads or semaphores are not used directly in our code base. We abstracted them so that they are following the RAII (Resource Acquisition Is Initialization) idiom and other good practices from the C++ community. units Time units for duration and string literals. other There are even more namespaces inside the iceoryx hoofs but they will either become obsolete in the future, will be integrated into existing names or are established as another namespace and documented here. We are unsure where they will end up in the future. Structure \ud83d\udd17 The following sections have a column labeled internal to indicate that the API is not stable and can change anytime. You should never rely on it and there is no support if it is used and breaks your code after an update. The column maybe obsolete marks classes which can be removed anytime soon. CXX \ud83d\udd17 This contains STL constructs which are not part of the C++14 standard as well as convenience constructs like the NewType . Since the module re-implements some STL constructs, the C++ STL coding guidelines are used for all files in this module, to help the user to have a painless transition from the official STL types to ours. The API should also be identical to the corresponding STL types but we have to make exceptions here. For instance, we do not throw exceptions, try to avoid undefined behavior and we do not use dynamic memory. In these cases we adjusted the API to our use case. Most of the headers are providing some example code on how the class should be used. class/file internal maybe obsolete description algorithm Implements min and max for an arbitrary number of values of the same type. For instance min(1,2,3,4,5); attributes C++17 and C++20 attributes are sometimes available through compiler extensions. The attribute macros defined in here (like IOX_FALLTHROUGH , IOX_MAYBE_UNUSED ... ) make sure that we are able to use them if the compiler supports it. convert Converting a number into a string is easy, converting it back can be hard. You can use functions like strtoll but you still have to handle errors like under- and overflow, or converting invalid strings into number. Here we abstract all the error handling so that you can convert strings into numbers safely. DeadlineTimer Polling based timer to check for an elapsed deadline. expected Our base class used in error handling. Every function which can fail should return an expected. With this the user knows that this function can fail and that they have to do some kind of error handling. We got inspired by the C++ expected proposal and by the rust error handling concept . filesystem Implementation of C++17 filesystem features for instance cxx::perms to abstract file permissions forward_list Heap and exception free, relocatable implementation of std::forward_list function A stack-based std::function replacement based on storable_function function_ref C++11 implementation of the next-gen C++ feature std::function_ref see function_ref proposal . It behaves like std::function but does not own the callable. functional_interface Constructs to easily add functional interfaces like and_then to object container. GenericRAII This is an abstraction of the C++ RAII idiom. Sometimes you have constructs where you would like to perform a certain task on creation and then again when they are getting out of scope, this is where GenericRAII comes in. It is like a std::lock_guard or a std::shared_ptr but more generic. helplets Implementations of C++ Core Guideline concepts like not_null are contained here. Additionally, we are providing some types to verify preconditions at compile time. Think of an int which has to be always greater 5, here we provide types like greater_or_equal<int, 6> . list Heap and exception free, relocatable implementation of std::list MethodCallback X Constructs a callback from a pointer to a specific object and a pointer to a method of that object, also as ConstMethodCallback available NewType<T, Policies> C++11 implementation of Haskells NewType-pattern . optional C++11 implementation of the C++17 feature std::optional pair i X Simplistic re-implementation of an std::pair . poor_mans_heap Acquires memory on the stack for placement new instantiations. All classes must inherit from a base class which has to be known at compile time but the class itself does not have to be known - only the size. ReferenceCounter i Basic building block for classes which are needing some kind of reference counting like a std::shared_ptr requires Base for Expects / Ensures from the C++ Core Guideline scoped_static Helper function to limit lifetime of static or global variables to a scope serialization X Implements a simple serialization concept for classes based on the idea presented here ISOCPP serialization . set i X Templated helper functions to create a fake std::set from a vector. stack Stack implementation with simple push/pop interface. static_storage i Untyped aligned static storage. storable_function i A std::function alternative with configurable backend for memory storage. string Heap and exception free implementation of std::string . Attention, since the string is stack based, std::string or char array which are assigned to this string will be truncated and zero-terminated if they exceed the string capacity. type_traits Extended support for evaluating types on compile-time. types Declares essential building block types like byte_t . UniqueId i Monotonic increasing IDs within a process. unique_ptr Provides a heap-less unique ptr implementation, unlike the STL variant C++11 implementation of the C++17 feature std::variant variant_queue A queue which wraps multiple variants of Queues (FiFo, SoFi, ResizeableLockFreeQueue) vector Heap and exception free implementation of std::vector Concurrent \ud83d\udd17 If you have to write concurrent code, never use concurrency constructs like mutex , atomic , thread , semaphore , etc. directly. Most of the use cases can be solved by using an ActiveObject which uses as building block our FiFo or a queue which is thread-safe when combined with smart_lock . To learn more about active objects see Prefer Using Active Objects Instead Of Naked Threads . class internal maybe obsolete description ActiveObject i X Active object base skeleton implementation inspired by Prefer Using Active Objects Instead Of Naked Threads FiFo i Single producer, single consumer lock-free FiFo LockfreeQueue Multi producer, multi consumer lock-free FiFo with ringbuffer like overflow handling LoFFLi i Lock-free LIFO based index manager (lock-free free list). One building block of our memory manager. After construction it contains the indices PeriodicTask i Periodically executes a callable specified by the template parameter in a configurable time interval. ResizeableLockFreeQueue Resizeable variant of the LockfreeQueue smart_lock i Creates arbitrary thread safe constructs which then can be used like smart pointers. If some STL type should be thread safe use the smart_lock to create the thread safe version in one line. Based on some ideas presented in Wrapping C++ Member Function Calls SoFi i Single producer, single consumer lock-free safely overflowing FiFo (SoFi). TACO i Thread Aware exChange Ownership (TACO). Solution if you would like to use std::atomic with data types larger than 64 bit. Wait free data synchronization mechanism between threads. TriggerQueue i X Queue with a push - pop interface where pop is blocking as long as the queue is empty. Can be used as a building block for active objects. attribute overview of the available Queues: Data Structure Shared Memory usable Thread-Safe Lock-Free Concurrent Producers : Consumers Bounded Capacity Data Type Restriction Use Case FiFo Yes Yes Yes 1:1 Yes Copyable FIFO Data transfer LockfreeQueue Yes Yes Yes n:m Yes Copyable or Movable lock-free transfer of arbitrary data between multiple contexts in FIFO order with overflow handling (ringbuffer) LoFFLi Yes Yes Yes n:m Yes int32 manage memory access, LIFO order smart_lock Yes Yes No n/a n/a None Wrapper to make classes thread-safe (by using a lock) SoFi Yes Yes Yes 1:1 Yes Trivially Copyable lock-free transfer of small data (e.g. pointers) between two contexts in FIFO order with overflow handling (ringbuffer) ResizeableLockFreeQueue Yes Yes Yes n:m Yes Copyable or Movable Resizeable variant of the LockfreeQueue TACO Yes Yes Yes n:m Yes Copyable or Movable fast lock-free exchange data between threads TriggerQueue No Yes No n:m Yes Copyable Process events in a blocking way Design pattern \ud83d\udd17 class internal maybe obsolete description Creation X When implementing resource handling classes which follow the RAII idiom we may have to throw exceptions inside the constructor. As an alternative to exceptions we have the creation pattern, a specialized factory which returns the object inside of an expected . Error handling \ud83d\udd17 The error handler is a central instance for collecting all errors and react to them. The error-handling.hpp contains a list of all error enum values. The error handler has different error levels, for more information see error-handling.md class internal maybe obsolete description errorHandler Free function to call the error handler with a defined error and an error level, see header file for practical example. ErrorHandler i error handler class only for testing purposes, should not be used directly Log \ud83d\udd17 For information about how to use the logger API see error-handling.md class internal maybe obsolete description logger POSIX wrapper \ud83d\udd17 We abstract POSIX resources following the RAII idiom and by using our Creation pattern. Try to exclusively use these abstractions or add a new one when using POSIX resources like semaphores, shared memory, etc. class internal maybe obsolete description AccessController i Interface for Access Control Lists (ACL). FileLock File lock C++ wrapping class. NamedPipe Shared memory based ipc channel. Mainly a UnixDomainSocket replacement on Windows. IpcChannel i Helper types used by the MessageQueue and the UnixDomainSocket . MessageQueue i Interface for Message Queues, see ManPage mq_overview . mutex i Mutex interface, see ManPage pthread_mutex_lock . posix_access_rights Rights and user management interface. posixCall Wrapper around C and POSIX function calls which performs a full error handling. Additionally, this wrapper makes sure that EINTR handling is performed correctly by repeating the system call. SignalGuard Helper class for signal handler registration. SignalWatcher Batteries included signal handling with polling and optional blocking wait for SIGINT and SIGTERM . Semaphore Semaphore interface, see ManPage sem_overview shared_memory_object/Allocator i Helper class for the SharedMemoryObject . shared_memory_object/MemoryMap i Abstraction of mmap , munmap and helper class for the SharedMemoryObject . shared_memory_object/SharedMemory i Abstraction of shared memory, see ManPage shm_overview and helper class for the SharedMemoryObject . SharedMemoryObject i Creates and maps existing shared memory into the application. system_configuration i Collection of free functions which acquire system information like the page-size. thread Wrapper for pthread functions like pthread_setname_np . Timer X Interface for the posix timer, see ManPage timer_create . UnixDomainSocket i Interface for unix domain sockets. Units \ud83d\udd17 Never use physical properties like speed or time directly as integer or float in your code. Otherwise you encounter problems like this function void setTimeout(int timeout) . What is the unit of the argument, seconds? minutes? If you use Duration you see it directly in the code. void setTimeout(const Duration & timeout); setTimeout(11_s); // 11 seconds setTimeout(5_ms); // 5 milliseconds class internal maybe obsolete description Duration i Represents the unit time, is convertible to timespec and timeval . User defined literals are available for convenience and readability. objectpool \ud83d\udd17 class internal maybe obsolete description ObjectPool i Container which stores raw objects without calling the ctor of the objects. graphs \ud83d\udd17 class internal maybe obsolete description DirectedGraph i Creates and manages a directed graph . DirectedAcyclicGraph i Like the DirectedGraph but additional checks prohibit to create edges which have a cyclic dependency. file-reader \ud83d\udd17 class internal maybe obsolete description FileReader i X Wrapper for opening files and reading them. Check out iceoryx_hoofs on GitHub","title":"Safe building blocks"},{"location":"advanced/iceoryx_hoofs/#eclipse-iceoryx-hoofs-overview","text":"The iceoryx hoofs ( H andy O bjects O ptimised F or S afety) are our basic building blocks - the foundation of iceoryx. There are a wide variety of building blocks grouped together in categories or namespace, depending on where or how they are used.","title":"Eclipse iceoryx hoofs overview"},{"location":"advanced/iceoryx_hoofs/#categories","text":"Namespace Short Description cxx Since we are not allowed to use C++17 as well as the heap or exceptions we implemented constructs like optional , expected or variant so that we can be as modern as possible. Furthermore, you can find here constructs which are mentioned in the C++ Core Guidelines as well as STL re-implementations of container like vector which are relocatable an can be placed into the shared memory. concurrent You should never use concurrent constructs like mutex , semaphores , atomic , etc. directly in our codebase. At the moment we still have some exceptions to this guideline but the idea is that all classes which are using them are stored under concurrent and have to undergo more tests then the usual non concurrent class. For instance we try to provide stress tests for them. This module provides classes like fifo , smart_lock , sofi , trigger_queue and much more. design_pattern Certain code patterns which are repeating themselves all over the code are abstracted and stored in here. At the moment we only have the creation pattern which will be removed in a future release. error-handling The central error handler in iceoryx for cases when no sane further execution is possible, e.g. nullptr access. log The logger used by iceoryx. posix_wrapper Posix constructs like shared memory, threads or semaphores are not used directly in our code base. We abstracted them so that they are following the RAII (Resource Acquisition Is Initialization) idiom and other good practices from the C++ community. units Time units for duration and string literals. other There are even more namespaces inside the iceoryx hoofs but they will either become obsolete in the future, will be integrated into existing names or are established as another namespace and documented here. We are unsure where they will end up in the future.","title":"Categories"},{"location":"advanced/iceoryx_hoofs/#structure","text":"The following sections have a column labeled internal to indicate that the API is not stable and can change anytime. You should never rely on it and there is no support if it is used and breaks your code after an update. The column maybe obsolete marks classes which can be removed anytime soon.","title":"Structure"},{"location":"advanced/iceoryx_hoofs/#cxx","text":"This contains STL constructs which are not part of the C++14 standard as well as convenience constructs like the NewType . Since the module re-implements some STL constructs, the C++ STL coding guidelines are used for all files in this module, to help the user to have a painless transition from the official STL types to ours. The API should also be identical to the corresponding STL types but we have to make exceptions here. For instance, we do not throw exceptions, try to avoid undefined behavior and we do not use dynamic memory. In these cases we adjusted the API to our use case. Most of the headers are providing some example code on how the class should be used. class/file internal maybe obsolete description algorithm Implements min and max for an arbitrary number of values of the same type. For instance min(1,2,3,4,5); attributes C++17 and C++20 attributes are sometimes available through compiler extensions. The attribute macros defined in here (like IOX_FALLTHROUGH , IOX_MAYBE_UNUSED ... ) make sure that we are able to use them if the compiler supports it. convert Converting a number into a string is easy, converting it back can be hard. You can use functions like strtoll but you still have to handle errors like under- and overflow, or converting invalid strings into number. Here we abstract all the error handling so that you can convert strings into numbers safely. DeadlineTimer Polling based timer to check for an elapsed deadline. expected Our base class used in error handling. Every function which can fail should return an expected. With this the user knows that this function can fail and that they have to do some kind of error handling. We got inspired by the C++ expected proposal and by the rust error handling concept . filesystem Implementation of C++17 filesystem features for instance cxx::perms to abstract file permissions forward_list Heap and exception free, relocatable implementation of std::forward_list function A stack-based std::function replacement based on storable_function function_ref C++11 implementation of the next-gen C++ feature std::function_ref see function_ref proposal . It behaves like std::function but does not own the callable. functional_interface Constructs to easily add functional interfaces like and_then to object container. GenericRAII This is an abstraction of the C++ RAII idiom. Sometimes you have constructs where you would like to perform a certain task on creation and then again when they are getting out of scope, this is where GenericRAII comes in. It is like a std::lock_guard or a std::shared_ptr but more generic. helplets Implementations of C++ Core Guideline concepts like not_null are contained here. Additionally, we are providing some types to verify preconditions at compile time. Think of an int which has to be always greater 5, here we provide types like greater_or_equal<int, 6> . list Heap and exception free, relocatable implementation of std::list MethodCallback X Constructs a callback from a pointer to a specific object and a pointer to a method of that object, also as ConstMethodCallback available NewType<T, Policies> C++11 implementation of Haskells NewType-pattern . optional C++11 implementation of the C++17 feature std::optional pair i X Simplistic re-implementation of an std::pair . poor_mans_heap Acquires memory on the stack for placement new instantiations. All classes must inherit from a base class which has to be known at compile time but the class itself does not have to be known - only the size. ReferenceCounter i Basic building block for classes which are needing some kind of reference counting like a std::shared_ptr requires Base for Expects / Ensures from the C++ Core Guideline scoped_static Helper function to limit lifetime of static or global variables to a scope serialization X Implements a simple serialization concept for classes based on the idea presented here ISOCPP serialization . set i X Templated helper functions to create a fake std::set from a vector. stack Stack implementation with simple push/pop interface. static_storage i Untyped aligned static storage. storable_function i A std::function alternative with configurable backend for memory storage. string Heap and exception free implementation of std::string . Attention, since the string is stack based, std::string or char array which are assigned to this string will be truncated and zero-terminated if they exceed the string capacity. type_traits Extended support for evaluating types on compile-time. types Declares essential building block types like byte_t . UniqueId i Monotonic increasing IDs within a process. unique_ptr Provides a heap-less unique ptr implementation, unlike the STL variant C++11 implementation of the C++17 feature std::variant variant_queue A queue which wraps multiple variants of Queues (FiFo, SoFi, ResizeableLockFreeQueue) vector Heap and exception free implementation of std::vector","title":"CXX"},{"location":"advanced/iceoryx_hoofs/#concurrent","text":"If you have to write concurrent code, never use concurrency constructs like mutex , atomic , thread , semaphore , etc. directly. Most of the use cases can be solved by using an ActiveObject which uses as building block our FiFo or a queue which is thread-safe when combined with smart_lock . To learn more about active objects see Prefer Using Active Objects Instead Of Naked Threads . class internal maybe obsolete description ActiveObject i X Active object base skeleton implementation inspired by Prefer Using Active Objects Instead Of Naked Threads FiFo i Single producer, single consumer lock-free FiFo LockfreeQueue Multi producer, multi consumer lock-free FiFo with ringbuffer like overflow handling LoFFLi i Lock-free LIFO based index manager (lock-free free list). One building block of our memory manager. After construction it contains the indices PeriodicTask i Periodically executes a callable specified by the template parameter in a configurable time interval. ResizeableLockFreeQueue Resizeable variant of the LockfreeQueue smart_lock i Creates arbitrary thread safe constructs which then can be used like smart pointers. If some STL type should be thread safe use the smart_lock to create the thread safe version in one line. Based on some ideas presented in Wrapping C++ Member Function Calls SoFi i Single producer, single consumer lock-free safely overflowing FiFo (SoFi). TACO i Thread Aware exChange Ownership (TACO). Solution if you would like to use std::atomic with data types larger than 64 bit. Wait free data synchronization mechanism between threads. TriggerQueue i X Queue with a push - pop interface where pop is blocking as long as the queue is empty. Can be used as a building block for active objects. attribute overview of the available Queues: Data Structure Shared Memory usable Thread-Safe Lock-Free Concurrent Producers : Consumers Bounded Capacity Data Type Restriction Use Case FiFo Yes Yes Yes 1:1 Yes Copyable FIFO Data transfer LockfreeQueue Yes Yes Yes n:m Yes Copyable or Movable lock-free transfer of arbitrary data between multiple contexts in FIFO order with overflow handling (ringbuffer) LoFFLi Yes Yes Yes n:m Yes int32 manage memory access, LIFO order smart_lock Yes Yes No n/a n/a None Wrapper to make classes thread-safe (by using a lock) SoFi Yes Yes Yes 1:1 Yes Trivially Copyable lock-free transfer of small data (e.g. pointers) between two contexts in FIFO order with overflow handling (ringbuffer) ResizeableLockFreeQueue Yes Yes Yes n:m Yes Copyable or Movable Resizeable variant of the LockfreeQueue TACO Yes Yes Yes n:m Yes Copyable or Movable fast lock-free exchange data between threads TriggerQueue No Yes No n:m Yes Copyable Process events in a blocking way","title":"Concurrent"},{"location":"advanced/iceoryx_hoofs/#design-pattern","text":"class internal maybe obsolete description Creation X When implementing resource handling classes which follow the RAII idiom we may have to throw exceptions inside the constructor. As an alternative to exceptions we have the creation pattern, a specialized factory which returns the object inside of an expected .","title":"Design pattern"},{"location":"advanced/iceoryx_hoofs/#error-handling","text":"The error handler is a central instance for collecting all errors and react to them. The error-handling.hpp contains a list of all error enum values. The error handler has different error levels, for more information see error-handling.md class internal maybe obsolete description errorHandler Free function to call the error handler with a defined error and an error level, see header file for practical example. ErrorHandler i error handler class only for testing purposes, should not be used directly","title":"Error handling"},{"location":"advanced/iceoryx_hoofs/#log","text":"For information about how to use the logger API see error-handling.md class internal maybe obsolete description logger","title":"Log"},{"location":"advanced/iceoryx_hoofs/#posix-wrapper","text":"We abstract POSIX resources following the RAII idiom and by using our Creation pattern. Try to exclusively use these abstractions or add a new one when using POSIX resources like semaphores, shared memory, etc. class internal maybe obsolete description AccessController i Interface for Access Control Lists (ACL). FileLock File lock C++ wrapping class. NamedPipe Shared memory based ipc channel. Mainly a UnixDomainSocket replacement on Windows. IpcChannel i Helper types used by the MessageQueue and the UnixDomainSocket . MessageQueue i Interface for Message Queues, see ManPage mq_overview . mutex i Mutex interface, see ManPage pthread_mutex_lock . posix_access_rights Rights and user management interface. posixCall Wrapper around C and POSIX function calls which performs a full error handling. Additionally, this wrapper makes sure that EINTR handling is performed correctly by repeating the system call. SignalGuard Helper class for signal handler registration. SignalWatcher Batteries included signal handling with polling and optional blocking wait for SIGINT and SIGTERM . Semaphore Semaphore interface, see ManPage sem_overview shared_memory_object/Allocator i Helper class for the SharedMemoryObject . shared_memory_object/MemoryMap i Abstraction of mmap , munmap and helper class for the SharedMemoryObject . shared_memory_object/SharedMemory i Abstraction of shared memory, see ManPage shm_overview and helper class for the SharedMemoryObject . SharedMemoryObject i Creates and maps existing shared memory into the application. system_configuration i Collection of free functions which acquire system information like the page-size. thread Wrapper for pthread functions like pthread_setname_np . Timer X Interface for the posix timer, see ManPage timer_create . UnixDomainSocket i Interface for unix domain sockets.","title":"POSIX wrapper"},{"location":"advanced/iceoryx_hoofs/#units","text":"Never use physical properties like speed or time directly as integer or float in your code. Otherwise you encounter problems like this function void setTimeout(int timeout) . What is the unit of the argument, seconds? minutes? If you use Duration you see it directly in the code. void setTimeout(const Duration & timeout); setTimeout(11_s); // 11 seconds setTimeout(5_ms); // 5 milliseconds class internal maybe obsolete description Duration i Represents the unit time, is convertible to timespec and timeval . User defined literals are available for convenience and readability.","title":"Units"},{"location":"advanced/iceoryx_hoofs/#objectpool","text":"class internal maybe obsolete description ObjectPool i Container which stores raw objects without calling the ctor of the objects.","title":"objectpool"},{"location":"advanced/iceoryx_hoofs/#graphs","text":"class internal maybe obsolete description DirectedGraph i Creates and manages a directed graph . DirectedAcyclicGraph i Like the DirectedGraph but additional checks prohibit to create edges which have a cyclic dependency.","title":"graphs"},{"location":"advanced/iceoryx_hoofs/#file-reader","text":"class internal maybe obsolete description FileReader i X Wrapper for opening files and reading them. Check out iceoryx_hoofs on GitHub","title":"file-reader"},{"location":"advanced/installation-guide-for-contributors/","text":"Installation guide for contributors \ud83d\udd17 Build and run tests \ud83d\udd17 While developing on iceoryx, you may want to know if your changes will break existing functionality or if your newly written tests will pass. For that purpose, we generate CMake targets that execute the tests. First, we need to build them: cmake -Bbuild -Hiceoryx_meta -DBUILD_TEST = ON cmake --build build CMake automatically installs GoogleTest as a local dependency and builds the tests against it. Please note that if you want to build tests for extensions like the DDS-Gateway you need to enable this extension as well in the CMake build. To build the tests for all extensions simply add -DBUILD_ALL to the CMake command. Hint Before creating a Pull-Request, you should check your code for compiler warnings. The -DBUILD_STRICT CMake option is available for this purpose, which treats compiler warnings as errors. This flag is enabled on the GitHub CI for building Pull-Requests. Now let's execute all tests: cd iceoryx/build make all_tests Some of the tests are time-dependent and need a stable environment. These timing tests are available in separate targets: make timing_module_tests make timing_integration_tests In iceoryx we distinguish between different test levels. The most important are: Module tests and Integration tests. Module or unit tests are basically black box tests that test the public interface of a class. In integration tests the interaction of several classes is tested. The source code of the tests is placed into the folder test within the different iceoryx components. You can find there at least a folder moduletests and sometimes integrationtests . If you now want to create a new test, you can place the source file directly into the right folder. CMake will automatically detect the new file when doing a clean build and will add it to the corresponding executable. There is no need to add a gtest main function because we already provide it. Executables are created for every test level, for example posh_moduletests . They are placed into the corresponding build folder (e.g. iceoryx/build/posh/test/posh_moduletests ). If you want to execute only individual test cases, you can use these executables together with a filter command. Let's assume you want to execute only ServiceDescription_test from posh_moduletests: ./build/posh/test/posh_moduletests --gtest_filter = \"ServiceDescription_test*\" Hint While writing code on iceoryx you should use git hooks that automatically ensure that you follow the coding and style guidelines. See git-hooks . Use Sanitizer Scan \ud83d\udd17 Due to the fact that iceoryx works a lot with system memory, it should be ensured that errors like memory leaks are not introduced. To prevent this, we use the clang toolchain which offers several tools for scanning the codebase. One of them is the AddressSanitizer which checks e.g. for dangling pointers. The below-listed sanitizers are enabled at the moment. Note AddressSanitizer exits on the first detected error, which means there could be more errors in the codebase when this error is reported. LeakSanitizer (LSan) is a run-time memory leak detector. In iceoryx, it runs as part of the AddressSanitizer. UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector. iceoryx uses default behavior i.e. print a verbose error report and continue execution With the iceoryx_build_test.sh script you can run the scan yourself. Additionally, the scans are running on the CI in every Pull-Request. As a prerequisite, you need to install the clang compiler: sudo apt install clang Then you need to compile iceoryx with the sanitizer flags: ./tools/iceoryx_build_test.sh build-strict build-all sanitize clang clean Now we can run the tests with enabled sanitizer options: cd build && ./tools/run_tests.sh If errors occur, an error report is shown with a stack trace to find the place where the leak occurs. If the leak has its origin in an external dependency or shall be handled later then it is possible to set a function on a suppression list. This should be used only rarely and only in coordination with an iceoryx maintainer. Note iceoryx needs to be built as a static library to work with sanitizer flags, which is automatically achieved when using the script. If you want to use the ${ICEORYX_WARNINGS} then you have to call find_package(iceoryx_hoofs) and include(IceoryxPlatform) to make use of the ${ICEORYX_SANITIZER_FLAGS}. iceoryx library build \ud83d\udd17 The iceoryx build consists of several libraries which have dependencies on each other. The goal is to have encapsulated library packages available so that the end-user can easily find them with the CMake command find_package(...) . In the default case, the iceoryx libraries are installed by make install into /usr/lib which requires root access. As an alternative you can install the libs into a custom folder by setting -DCMAKE_INSTALL_PREFIX=/custom/install/path as build flag for the CMake file in iceoryx_meta. iceoryx_meta collects all libraries (hoofs, posh etc.) and extensions (binding_c, dds) and can be a starting point for the CMake build. The provided build script tools/iceoryx_build_test.sh uses iceoryx_meta. Per default, iceoryx is built as static lib for better usability. Additionally, we offer to build as shared library because it is a cleaner solution for resolving dependency issues and it reduces the linker time. This is done by the flag BUILD_SHARED_LIBS which is set to OFF per default in iceoryx_meta. If you want to have shared libraries, just pass -DBUILD_SHARED_LIBS=ON to CMake or use build-shared as a flag in the build script. Note When building with colcon in ROS 2, the packages iceoryx_hoofs , iceoryx_posh and iceoryx_binding_c are built automatically as shared libraries. If iceoryx builds shared libraries you have to copy them into a custom path and set the LD_LIBRARY_PATH to the custom path (e.g. build/install/prefix). export LD_LIBRARY_PATH = /your/path/to/iceoryx/libs or you can set it directly: LD_LIBRARY_PATH = /your/path/to/lib iox-roudi If you want to share iceoryx to other users, you can create a debian package. This can be done by using: ./tools/iceoryx_build_test.sh package where it will be deployed into the build_package folder. Note The CMake libraries export their dependencies for easier integration. This means that you do not need to do a find_package() for all the dependencies. For example, you don't need to call find_package(iceoryx_hoofs) when you already called find_package(iceoryx_posh) since iceoryx_posh includes iceoryx_hoofs. Tips & Tricks \ud83d\udd17 Sometimes one can encounter a failing CI target which is not reproducible locally on the developer machine. With ./tools/scripts/ice_env.sh one can create a docker container with preinstalled dependencies and a configuration similar to the CI target container. When for instance the target ubuntu 18.04 fails we can start the container with ./tools/scripts/ice_env.sh enter ubuntu:18.04 which enters the environment automatically and one can start debugging.","title":"Installation guide for contributors"},{"location":"advanced/installation-guide-for-contributors/#installation-guide-for-contributors","text":"","title":"Installation guide for contributors"},{"location":"advanced/installation-guide-for-contributors/#build-and-run-tests","text":"While developing on iceoryx, you may want to know if your changes will break existing functionality or if your newly written tests will pass. For that purpose, we generate CMake targets that execute the tests. First, we need to build them: cmake -Bbuild -Hiceoryx_meta -DBUILD_TEST = ON cmake --build build CMake automatically installs GoogleTest as a local dependency and builds the tests against it. Please note that if you want to build tests for extensions like the DDS-Gateway you need to enable this extension as well in the CMake build. To build the tests for all extensions simply add -DBUILD_ALL to the CMake command. Hint Before creating a Pull-Request, you should check your code for compiler warnings. The -DBUILD_STRICT CMake option is available for this purpose, which treats compiler warnings as errors. This flag is enabled on the GitHub CI for building Pull-Requests. Now let's execute all tests: cd iceoryx/build make all_tests Some of the tests are time-dependent and need a stable environment. These timing tests are available in separate targets: make timing_module_tests make timing_integration_tests In iceoryx we distinguish between different test levels. The most important are: Module tests and Integration tests. Module or unit tests are basically black box tests that test the public interface of a class. In integration tests the interaction of several classes is tested. The source code of the tests is placed into the folder test within the different iceoryx components. You can find there at least a folder moduletests and sometimes integrationtests . If you now want to create a new test, you can place the source file directly into the right folder. CMake will automatically detect the new file when doing a clean build and will add it to the corresponding executable. There is no need to add a gtest main function because we already provide it. Executables are created for every test level, for example posh_moduletests . They are placed into the corresponding build folder (e.g. iceoryx/build/posh/test/posh_moduletests ). If you want to execute only individual test cases, you can use these executables together with a filter command. Let's assume you want to execute only ServiceDescription_test from posh_moduletests: ./build/posh/test/posh_moduletests --gtest_filter = \"ServiceDescription_test*\" Hint While writing code on iceoryx you should use git hooks that automatically ensure that you follow the coding and style guidelines. See git-hooks .","title":" Build and run tests"},{"location":"advanced/installation-guide-for-contributors/#use-sanitizer-scan","text":"Due to the fact that iceoryx works a lot with system memory, it should be ensured that errors like memory leaks are not introduced. To prevent this, we use the clang toolchain which offers several tools for scanning the codebase. One of them is the AddressSanitizer which checks e.g. for dangling pointers. The below-listed sanitizers are enabled at the moment. Note AddressSanitizer exits on the first detected error, which means there could be more errors in the codebase when this error is reported. LeakSanitizer (LSan) is a run-time memory leak detector. In iceoryx, it runs as part of the AddressSanitizer. UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector. iceoryx uses default behavior i.e. print a verbose error report and continue execution With the iceoryx_build_test.sh script you can run the scan yourself. Additionally, the scans are running on the CI in every Pull-Request. As a prerequisite, you need to install the clang compiler: sudo apt install clang Then you need to compile iceoryx with the sanitizer flags: ./tools/iceoryx_build_test.sh build-strict build-all sanitize clang clean Now we can run the tests with enabled sanitizer options: cd build && ./tools/run_tests.sh If errors occur, an error report is shown with a stack trace to find the place where the leak occurs. If the leak has its origin in an external dependency or shall be handled later then it is possible to set a function on a suppression list. This should be used only rarely and only in coordination with an iceoryx maintainer. Note iceoryx needs to be built as a static library to work with sanitizer flags, which is automatically achieved when using the script. If you want to use the ${ICEORYX_WARNINGS} then you have to call find_package(iceoryx_hoofs) and include(IceoryxPlatform) to make use of the ${ICEORYX_SANITIZER_FLAGS}.","title":" Use Sanitizer Scan"},{"location":"advanced/installation-guide-for-contributors/#iceoryx-library-build","text":"The iceoryx build consists of several libraries which have dependencies on each other. The goal is to have encapsulated library packages available so that the end-user can easily find them with the CMake command find_package(...) . In the default case, the iceoryx libraries are installed by make install into /usr/lib which requires root access. As an alternative you can install the libs into a custom folder by setting -DCMAKE_INSTALL_PREFIX=/custom/install/path as build flag for the CMake file in iceoryx_meta. iceoryx_meta collects all libraries (hoofs, posh etc.) and extensions (binding_c, dds) and can be a starting point for the CMake build. The provided build script tools/iceoryx_build_test.sh uses iceoryx_meta. Per default, iceoryx is built as static lib for better usability. Additionally, we offer to build as shared library because it is a cleaner solution for resolving dependency issues and it reduces the linker time. This is done by the flag BUILD_SHARED_LIBS which is set to OFF per default in iceoryx_meta. If you want to have shared libraries, just pass -DBUILD_SHARED_LIBS=ON to CMake or use build-shared as a flag in the build script. Note When building with colcon in ROS 2, the packages iceoryx_hoofs , iceoryx_posh and iceoryx_binding_c are built automatically as shared libraries. If iceoryx builds shared libraries you have to copy them into a custom path and set the LD_LIBRARY_PATH to the custom path (e.g. build/install/prefix). export LD_LIBRARY_PATH = /your/path/to/iceoryx/libs or you can set it directly: LD_LIBRARY_PATH = /your/path/to/lib iox-roudi If you want to share iceoryx to other users, you can create a debian package. This can be done by using: ./tools/iceoryx_build_test.sh package where it will be deployed into the build_package folder. Note The CMake libraries export their dependencies for easier integration. This means that you do not need to do a find_package() for all the dependencies. For example, you don't need to call find_package(iceoryx_hoofs) when you already called find_package(iceoryx_posh) since iceoryx_posh includes iceoryx_hoofs.","title":" iceoryx library build"},{"location":"advanced/installation-guide-for-contributors/#tips-tricks","text":"Sometimes one can encounter a failing CI target which is not reproducible locally on the developer machine. With ./tools/scripts/ice_env.sh one can create a docker container with preinstalled dependencies and a configuration similar to the CI target container. When for instance the target ubuntu 18.04 fails we can start the container with ./tools/scripts/ice_env.sh enter ubuntu:18.04 which enters the environment automatically and one can start debugging.","title":"Tips &amp; Tricks"},{"location":"concepts/architecture/","text":"Architecture \ud83d\udd17 This article provides an overview of the Eclipse iceoryx architecture and explains the rationale for it. Software layers \ud83d\udd17 The main packages which Eclipse iceoryx is composed of are depicted below. The next sections briefly describe the components and their libraries one by one. Components and libraries \ud83d\udd17 The different libraries and their namespaces are depicted below. iceoryx hoofs \ud83d\udd17 Handy Objects Optimized For Safety (hoofs) is a library and contains various building blocks like fixed size containers, concurrency classes and modern, next-gen C++ constructs from upcoming C++ standard releases. For more information about the components, refer to its detailed description . iceoryx posh \ud83d\udd17 The package iceoryx_posh ( PO SIX SH ared memory) contains everything related to shared memory inter-process communication. Core library \ud83d\udd17 This section describes the namespaces of the core library. popo : The namespace posh ports contains the user-API classes which are used to transfer data. capro : The namespace canonical protocol implements the canonical protocol pattern protocol, which is used by iceoryx_posh to connect and discover popo::Publisher and popo::Server . mepoo : The namespace memory pool contains all memory-related classes. For example the MemoryManager or SharedPointer . version : The namespace version contains ABI compatibilities checks. build : The namespace build contains certain maximium values which can be changed before compilation. Gatway library \ud83d\udd17 The gateway library and its namespace gw contain generic abstractions to create a gateway. They are used by iceoryx_dds . RouDi library \ud83d\udd17 The library RouDi and its namespace roudi contains classes which are used by the RouDi middleware daemon. iceoryx C binding \ud83d\udd17 The module iceoryx_binding_c makes the inter-process communication features of iceoryx_posh available in C. iceoryx DDS \ud83d\udd17 The package iceoryx_dds provides a bi-directional DDS gateway using Eclipse Cyclone DDS . The gateway can be used to send data over a network e.g. via Ethernet. For more information, refer to the Readme . iceoryx introspection \ud83d\udd17 The introspection client can be used for live debugging and provides information of the current system like memory usage and established connections. For more information, refer to the icecrystal example .","title":"Architecture"},{"location":"concepts/architecture/#architecture","text":"This article provides an overview of the Eclipse iceoryx architecture and explains the rationale for it.","title":"Architecture"},{"location":"concepts/architecture/#software-layers","text":"The main packages which Eclipse iceoryx is composed of are depicted below. The next sections briefly describe the components and their libraries one by one.","title":"Software layers"},{"location":"concepts/architecture/#components-and-libraries","text":"The different libraries and their namespaces are depicted below.","title":"Components and libraries"},{"location":"concepts/architecture/#iceoryx-hoofs","text":"Handy Objects Optimized For Safety (hoofs) is a library and contains various building blocks like fixed size containers, concurrency classes and modern, next-gen C++ constructs from upcoming C++ standard releases. For more information about the components, refer to its detailed description .","title":"iceoryx hoofs"},{"location":"concepts/architecture/#iceoryx-posh","text":"The package iceoryx_posh ( PO SIX SH ared memory) contains everything related to shared memory inter-process communication.","title":"iceoryx posh"},{"location":"concepts/architecture/#core-library","text":"This section describes the namespaces of the core library. popo : The namespace posh ports contains the user-API classes which are used to transfer data. capro : The namespace canonical protocol implements the canonical protocol pattern protocol, which is used by iceoryx_posh to connect and discover popo::Publisher and popo::Server . mepoo : The namespace memory pool contains all memory-related classes. For example the MemoryManager or SharedPointer . version : The namespace version contains ABI compatibilities checks. build : The namespace build contains certain maximium values which can be changed before compilation.","title":"Core library"},{"location":"concepts/architecture/#gatway-library","text":"The gateway library and its namespace gw contain generic abstractions to create a gateway. They are used by iceoryx_dds .","title":"Gatway library"},{"location":"concepts/architecture/#roudi-library","text":"The library RouDi and its namespace roudi contains classes which are used by the RouDi middleware daemon.","title":"RouDi library"},{"location":"concepts/architecture/#iceoryx-c-binding","text":"The module iceoryx_binding_c makes the inter-process communication features of iceoryx_posh available in C.","title":"iceoryx C binding"},{"location":"concepts/architecture/#iceoryx-dds","text":"The package iceoryx_dds provides a bi-directional DDS gateway using Eclipse Cyclone DDS . The gateway can be used to send data over a network e.g. via Ethernet. For more information, refer to the Readme .","title":"iceoryx DDS"},{"location":"concepts/architecture/#iceoryx-introspection","text":"The introspection client can be used for live debugging and provides information of the current system like memory usage and established connections. For more information, refer to the icecrystal example .","title":"iceoryx introspection"},{"location":"concepts/best-practice-for-testing/","text":"Best practice for testing \ud83d\udd17 This is a guide on how to write tests for iceoryx. It intends to cover the most common cases which will probably apply to 99% of tests. This shall not encourage to be more royalist than the king and common sense shall be applied when the guidelines don't make sense. But if half of the tests don't follow the guidelines, it's a clear indicator that they need to be refactored. The guide also expects some knowledge on gtest . At least the Googletest Primer document should be read before continuing with this guide. Don't write tests just for the sake of having a high coverage number. First and foremost, tests must be meaningful and verify the code to prevent bugs and regressions. New code shall be created with testability in mind. Legacy code shall be refactored if it is not testable. In general, the Arrange Act Assert pattern shall be used. This makes it trivial to isolate a test failure, since only one state transition is tested at a time. These two blog posts explain the AAA pattern in more detail. While the AAA pattern provides a sensible structure, ZOMBIES help you to find sensible test cases. Z = Zero O = One M = Many (or More complex) B = Boundary Behaviors I = Interface Definition E = Exercise Exceptional Behavior S = Simple Scenarios, Simple Solutions This can be separated into ZOM and BIE with S bridging them together. ZOM are often simple tests, like a vector with zero items is empty or a vector with one item is not empty or a vector with N items has a size of N . The BIE part takes care of edge cases like adding one to Number::max saturates or division by zero returns error . The latter overlaps with a case from the ZOM part, which illustrates that these are not always clearly separated. Exercise Exceptional Behavior means to not only test the happy path, but also the negative one. Basically, you should test silly inputs and check for a graceful behavior like the previous example with division by 0. The linked blog post explains negative testing in a more thorough way. The catchwords can be used to draw simple scenarios which nicely fits to the AAA pattern. A non-exhaustive list of these scenarios are overflow underflow wrap around empty full out of bounds timeouts copy are the objects equal is the copy origin unchanged etc. move is the move destination object cleaning up its resources is the move origin object in a defined but unspecified state etc. etc. Following Hyrum's Law loosely, given enough users, one will find ways to use the software in a way it was never imagined. Therefore, never underestimate the creativity of brilliancy/stupidity. In some cases it might be necessary to instantiate an object on the heap. While that's not allowed in production code, it is fine in test code. To avoid manual memory management with new/delete, smart pointers shall be used if possible. As a reminder, if a method takes a pointer to an object, this object can be instantiated on the stack and the address of this object can be passed to the method. A good reason to use the heap are large objects which might cause a stack overflow. Some operating systems have a rather small stack of only a few kB, so this limit might be closer one might think. In general, the tests should be written in a fashion to not crash the application in case of a faulty implementation. It must be assumed that the implementation is broken and only a successful test run can prove otherwise. The sut (system under test) might return a nullptr instead of the expected valid pointer, so nullptr check has to be done with an ASSERT_* to gracefully abort the current test. Just using an EXPECT_* for the check is not sufficient since the potential nullptr will be dereferenced later on and will crash the application. The same applies to other potential dangerous operations, like accessing the value of a cxx::optional or cxx::expected or an out of bounds access of a cxx::vector . Last but not least, apply the DRY principle (don't repeat yourself) and use typed and parameterized tests to check multiple implementations and variations without repeating much code. Practical Example \ud83d\udd17 Let's test the following class class SingleDigitNumber { public : SingleDigitNumber () noexcept = default ; constexpr SingleDigitNumber ( uint64_t number ) noexcept : m_number ( number ) { } constexpr operator uint64_t () const noexcept { return m_number ; } constexpr SingleDigitNumber operator + ( const SingleDigitNumber rhs ) const noexcept { return m_number + rhs . m_number ; } constexpr SingleDigitNumber operator - ( const SingleDigitNumber rhs ) const noexcept { return m_number - rhs . m_number ; } private : uint64_t m_number ; }; This test fixture will be used class SingleDigitNumber_test : public Test { public : void SetUp () override {}; void TearDown () override {}; }; First Attempt \ud83d\udd17 Well, this is quite a simple class, so the tests must also be simple, right? TEST_F ( SingleDigitNumber_test , TestClass ) { SingleDigitNumber number1 ; SingleDigitNumber number2 ( 3U ); SingleDigitNumber number3 ( 2U ); auto number4 = number2 + number3 ; auto number5 = number2 - number3 ; EXPECT_TRUE ( number4 == 5U ); EXPECT_EQ ( 1U , static_cast < uint64_t > ( number5 )); } Done and we reached 100% coverage. We can clap ourselves on the shoulders and move on. Well, except that we can't. The test above has several major and minor flaws. The first thing that leaps to the eye, it doesn't follow the AAA pattern. When the test fails, we don't know why and have to look in the code to figure out what went wrong. But even if only one aspect of the class would have been tested, there would still be essentially just a [ FAILED ] SingleDigitNumber_test.TestClass output and we would need to look at the code to know what exactly is broken. This test case checks too many state transitions and doesn't have a sensible name. Furthermore, the default constructor is called in the test, but it is never checked to do the right thing. If there was a check, it would have revealed that m_number is not correctly initialized. Then, EXPECT_TRUE is used to compare the values. While this works, when the test fails we just get the information of the failure, but not which values were compared. To get this information EXPECT_EQ or EXPECT_THAT should be used. Furthermore, it's important to easily distinguish between the actual and the expected value, therefore the ordering of the values should be the same as if EXPECT_THAT would be used. The first value should be the actual value and the second one the expected. While the coverage might be 100%, there are no tests for: invalid parameters, e.g. passing 10 to the constructor overflow with operator+ , e.g. adding 7 and 8 underflow with operator- , e.g. subtracting 8 from 7 Here, ZOMBIES comes into play and gives us some guide to identify this cases. Some of this test might made it necessary to define the behavior of the class in the first place, e.g. defining that an operator+ will saturate to the max value instead of overflowing. How To Do It Better \ud83d\udd17 At first, the test is split into multiple test cases according to the AAA pattern TEST_F ( SingleDigitNumber_test , DefaultConstructedObjectIsCorrectlyInitialized ) { constexpr uint64_t EXPECTED_VALUE { 0U }; SingleDigitNumber sut ; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } The test also has a meaningful name. If this fails in the CI, it is immediately clear what is broken. Additionally, the tested object is called sut . This makes it easy to identify the actual test object. Lastly, a constexpr is used for the expected value. This removes a magic value and also makes the output of a failed test more readable, since it is immediately clear what's the actual tested value and what's the expected value. Now let's continue with further tests, applying the ZOMBIES principle TEST_F ( SingleDigitNumber_test , ConstructionWithValidValueCreatesNumberWithSameValue ) { constexpr uint64_t NUMBER_VALUE { 7U }; constexpr uint64_t EXPECTED_VALUE { NUMBER_VALUE }; SingleDigitNumber sut { NUMBER_VALUE }; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } TEST_F ( SingleDigitNumber_test , ConstructionWithInvalidValueResultsInSaturation ) { constexpr uint64_t NUMBER_VALUE { 42U }; constexpr uint64_t EXPECTED_VALUE { 9U }; SingleDigitNumber sut { NUMBER_VALUE }; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } TEST_F ( SingleDigitNumber_test , AddingZeroDoesNotChangeTheNumber ) { constexpr SingleDigitNumber NUMBER { 3U }; constexpr SingleDigitNumber ZERO { 0U }; constexpr uint64_t EXPECTED_VALUE { 3U }; auto sut = NUMBER + ZERO ; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } TEST_F ( SingleDigitNumber_test , AddingOneIncreasesTheNumberByOne ) { constexpr SingleDigitNumber NUMBER { 3U }; constexpr SingleDigitNumber ONE { 1U }; constexpr uint64_t EXPECTED_VALUE { 4U }; auto sut = NUMBER + ONE ; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } // and so on These are some examples showing how to apply the ZOMBIES principle to find good test cases. They also exert all the good practices mentioned previously, like clear and distinct names or avoiding magic numbers. Slightly More Advanced Topics \ud83d\udd17 Typed Tests \ud83d\udd17 There are situations when test cases only vary in the type applied to the sut . In this case typed tests can be used to reduce repetition. The there is a section for typed tests in the advanced gtest documentation. A more thorough example is in the gtest github repository. Parameterized Tests \ud83d\udd17 Similar to typed tests, there are cases where the same test case should run with multiple parameters. One example is the conversion of enum values to strings. While this can be done in a loop, parameterized testing is a better approach. This is quite a good blog post to get into parameterized tests. Additionally, there is a section in the advanced documentation for gtest. The block post mentions tuples to pass multiple parameters at once. Since tuples can become cumbersome to use, especially if parameters are rearranged, it is recommended to create a struct to wrap the parameters instead. Mocks \ud83d\udd17 Some classes are hard to test or to reach a full coverage. This might be due to external access or interaction with the operating system. Mocks can help to have full control over the sut and reliably cause error conditions to test the negative code path. There is an extensive gmock documentation in the gtest github repository. Pitfalls \ud83d\udd17 Some tests require creating dummy classes and it might be that the same name is chosen multiple times, e.g. \u201cclass DummyData {...};\u201d. Usually, at some time the compiler would complain about double definitions. But since the definitions are not in header but source files and therefore confined in a translation unit, this is not the case and the test binary gets created. There might still be issues though, since the binary contains multiple symbols with the same name. One of these issues may arise with the usage of sanitizers, e.g. the address or leak sanitizer. If there are multiple \u201cDummyData\u201d classes with different sizes and they are created on the heap, which is totally fine for tests, the address sanitizer might detect an error since something with a different size than expected will be freed. To prevent such issues, the tests should be placed within an anonymous namespace which makes all the symbols unique. namespace { struct DummyData { uint32_t foo { 0 }; }; class MyTest : public Test { //... }; TEST_F ( MyTest , TestName ) { EXPECT_EQ ( ANSWER , 42 ) } } // namespace Conclusion \ud83d\udd17 apply the AAA pattern to structure the test and check only one state transition per test case (all side effects of that transition must be checked, though) don't test previously tested behavior use the ZOMBIES principle to find sensible test cases use meaningful names for the tests to indicate what the test is supposed to do and the expected outcome, like ...IsSuccessful , ...Fails , ...ResultsIn... , ...LeadsTo... , etc. name the test object sut to make clear which object is tested don't use magic numbers instantiate objects on the stack or use smart pointers for large objects and avoid manual memory management with new/delete use ASSERT_* before doing a potential dangerous action which might crash the test application, like accessing a nullptr or a cxx::optional with a nullopt use mocks to reduce the complexity of the test arrangement apply the DRY principle by using typed and parameterized tests wrap the tests in an anonymous namespace","title":"Best practice for testing"},{"location":"concepts/best-practice-for-testing/#best-practice-for-testing","text":"This is a guide on how to write tests for iceoryx. It intends to cover the most common cases which will probably apply to 99% of tests. This shall not encourage to be more royalist than the king and common sense shall be applied when the guidelines don't make sense. But if half of the tests don't follow the guidelines, it's a clear indicator that they need to be refactored. The guide also expects some knowledge on gtest . At least the Googletest Primer document should be read before continuing with this guide. Don't write tests just for the sake of having a high coverage number. First and foremost, tests must be meaningful and verify the code to prevent bugs and regressions. New code shall be created with testability in mind. Legacy code shall be refactored if it is not testable. In general, the Arrange Act Assert pattern shall be used. This makes it trivial to isolate a test failure, since only one state transition is tested at a time. These two blog posts explain the AAA pattern in more detail. While the AAA pattern provides a sensible structure, ZOMBIES help you to find sensible test cases. Z = Zero O = One M = Many (or More complex) B = Boundary Behaviors I = Interface Definition E = Exercise Exceptional Behavior S = Simple Scenarios, Simple Solutions This can be separated into ZOM and BIE with S bridging them together. ZOM are often simple tests, like a vector with zero items is empty or a vector with one item is not empty or a vector with N items has a size of N . The BIE part takes care of edge cases like adding one to Number::max saturates or division by zero returns error . The latter overlaps with a case from the ZOM part, which illustrates that these are not always clearly separated. Exercise Exceptional Behavior means to not only test the happy path, but also the negative one. Basically, you should test silly inputs and check for a graceful behavior like the previous example with division by 0. The linked blog post explains negative testing in a more thorough way. The catchwords can be used to draw simple scenarios which nicely fits to the AAA pattern. A non-exhaustive list of these scenarios are overflow underflow wrap around empty full out of bounds timeouts copy are the objects equal is the copy origin unchanged etc. move is the move destination object cleaning up its resources is the move origin object in a defined but unspecified state etc. etc. Following Hyrum's Law loosely, given enough users, one will find ways to use the software in a way it was never imagined. Therefore, never underestimate the creativity of brilliancy/stupidity. In some cases it might be necessary to instantiate an object on the heap. While that's not allowed in production code, it is fine in test code. To avoid manual memory management with new/delete, smart pointers shall be used if possible. As a reminder, if a method takes a pointer to an object, this object can be instantiated on the stack and the address of this object can be passed to the method. A good reason to use the heap are large objects which might cause a stack overflow. Some operating systems have a rather small stack of only a few kB, so this limit might be closer one might think. In general, the tests should be written in a fashion to not crash the application in case of a faulty implementation. It must be assumed that the implementation is broken and only a successful test run can prove otherwise. The sut (system under test) might return a nullptr instead of the expected valid pointer, so nullptr check has to be done with an ASSERT_* to gracefully abort the current test. Just using an EXPECT_* for the check is not sufficient since the potential nullptr will be dereferenced later on and will crash the application. The same applies to other potential dangerous operations, like accessing the value of a cxx::optional or cxx::expected or an out of bounds access of a cxx::vector . Last but not least, apply the DRY principle (don't repeat yourself) and use typed and parameterized tests to check multiple implementations and variations without repeating much code.","title":"Best practice for testing"},{"location":"concepts/best-practice-for-testing/#practical-example","text":"Let's test the following class class SingleDigitNumber { public : SingleDigitNumber () noexcept = default ; constexpr SingleDigitNumber ( uint64_t number ) noexcept : m_number ( number ) { } constexpr operator uint64_t () const noexcept { return m_number ; } constexpr SingleDigitNumber operator + ( const SingleDigitNumber rhs ) const noexcept { return m_number + rhs . m_number ; } constexpr SingleDigitNumber operator - ( const SingleDigitNumber rhs ) const noexcept { return m_number - rhs . m_number ; } private : uint64_t m_number ; }; This test fixture will be used class SingleDigitNumber_test : public Test { public : void SetUp () override {}; void TearDown () override {}; };","title":"Practical Example"},{"location":"concepts/best-practice-for-testing/#first-attempt","text":"Well, this is quite a simple class, so the tests must also be simple, right? TEST_F ( SingleDigitNumber_test , TestClass ) { SingleDigitNumber number1 ; SingleDigitNumber number2 ( 3U ); SingleDigitNumber number3 ( 2U ); auto number4 = number2 + number3 ; auto number5 = number2 - number3 ; EXPECT_TRUE ( number4 == 5U ); EXPECT_EQ ( 1U , static_cast < uint64_t > ( number5 )); } Done and we reached 100% coverage. We can clap ourselves on the shoulders and move on. Well, except that we can't. The test above has several major and minor flaws. The first thing that leaps to the eye, it doesn't follow the AAA pattern. When the test fails, we don't know why and have to look in the code to figure out what went wrong. But even if only one aspect of the class would have been tested, there would still be essentially just a [ FAILED ] SingleDigitNumber_test.TestClass output and we would need to look at the code to know what exactly is broken. This test case checks too many state transitions and doesn't have a sensible name. Furthermore, the default constructor is called in the test, but it is never checked to do the right thing. If there was a check, it would have revealed that m_number is not correctly initialized. Then, EXPECT_TRUE is used to compare the values. While this works, when the test fails we just get the information of the failure, but not which values were compared. To get this information EXPECT_EQ or EXPECT_THAT should be used. Furthermore, it's important to easily distinguish between the actual and the expected value, therefore the ordering of the values should be the same as if EXPECT_THAT would be used. The first value should be the actual value and the second one the expected. While the coverage might be 100%, there are no tests for: invalid parameters, e.g. passing 10 to the constructor overflow with operator+ , e.g. adding 7 and 8 underflow with operator- , e.g. subtracting 8 from 7 Here, ZOMBIES comes into play and gives us some guide to identify this cases. Some of this test might made it necessary to define the behavior of the class in the first place, e.g. defining that an operator+ will saturate to the max value instead of overflowing.","title":"First Attempt"},{"location":"concepts/best-practice-for-testing/#how-to-do-it-better","text":"At first, the test is split into multiple test cases according to the AAA pattern TEST_F ( SingleDigitNumber_test , DefaultConstructedObjectIsCorrectlyInitialized ) { constexpr uint64_t EXPECTED_VALUE { 0U }; SingleDigitNumber sut ; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } The test also has a meaningful name. If this fails in the CI, it is immediately clear what is broken. Additionally, the tested object is called sut . This makes it easy to identify the actual test object. Lastly, a constexpr is used for the expected value. This removes a magic value and also makes the output of a failed test more readable, since it is immediately clear what's the actual tested value and what's the expected value. Now let's continue with further tests, applying the ZOMBIES principle TEST_F ( SingleDigitNumber_test , ConstructionWithValidValueCreatesNumberWithSameValue ) { constexpr uint64_t NUMBER_VALUE { 7U }; constexpr uint64_t EXPECTED_VALUE { NUMBER_VALUE }; SingleDigitNumber sut { NUMBER_VALUE }; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } TEST_F ( SingleDigitNumber_test , ConstructionWithInvalidValueResultsInSaturation ) { constexpr uint64_t NUMBER_VALUE { 42U }; constexpr uint64_t EXPECTED_VALUE { 9U }; SingleDigitNumber sut { NUMBER_VALUE }; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } TEST_F ( SingleDigitNumber_test , AddingZeroDoesNotChangeTheNumber ) { constexpr SingleDigitNumber NUMBER { 3U }; constexpr SingleDigitNumber ZERO { 0U }; constexpr uint64_t EXPECTED_VALUE { 3U }; auto sut = NUMBER + ZERO ; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } TEST_F ( SingleDigitNumber_test , AddingOneIncreasesTheNumberByOne ) { constexpr SingleDigitNumber NUMBER { 3U }; constexpr SingleDigitNumber ONE { 1U }; constexpr uint64_t EXPECTED_VALUE { 4U }; auto sut = NUMBER + ONE ; EXPECT_EQ ( static_cast < uint64_t > ( sut ), EXPECTED_VALUE ); } // and so on These are some examples showing how to apply the ZOMBIES principle to find good test cases. They also exert all the good practices mentioned previously, like clear and distinct names or avoiding magic numbers.","title":"How To Do It Better"},{"location":"concepts/best-practice-for-testing/#slightly-more-advanced-topics","text":"","title":"Slightly More Advanced Topics"},{"location":"concepts/best-practice-for-testing/#typed-tests","text":"There are situations when test cases only vary in the type applied to the sut . In this case typed tests can be used to reduce repetition. The there is a section for typed tests in the advanced gtest documentation. A more thorough example is in the gtest github repository.","title":"Typed Tests"},{"location":"concepts/best-practice-for-testing/#parameterized-tests","text":"Similar to typed tests, there are cases where the same test case should run with multiple parameters. One example is the conversion of enum values to strings. While this can be done in a loop, parameterized testing is a better approach. This is quite a good blog post to get into parameterized tests. Additionally, there is a section in the advanced documentation for gtest. The block post mentions tuples to pass multiple parameters at once. Since tuples can become cumbersome to use, especially if parameters are rearranged, it is recommended to create a struct to wrap the parameters instead.","title":"Parameterized Tests"},{"location":"concepts/best-practice-for-testing/#mocks","text":"Some classes are hard to test or to reach a full coverage. This might be due to external access or interaction with the operating system. Mocks can help to have full control over the sut and reliably cause error conditions to test the negative code path. There is an extensive gmock documentation in the gtest github repository.","title":"Mocks"},{"location":"concepts/best-practice-for-testing/#pitfalls","text":"Some tests require creating dummy classes and it might be that the same name is chosen multiple times, e.g. \u201cclass DummyData {...};\u201d. Usually, at some time the compiler would complain about double definitions. But since the definitions are not in header but source files and therefore confined in a translation unit, this is not the case and the test binary gets created. There might still be issues though, since the binary contains multiple symbols with the same name. One of these issues may arise with the usage of sanitizers, e.g. the address or leak sanitizer. If there are multiple \u201cDummyData\u201d classes with different sizes and they are created on the heap, which is totally fine for tests, the address sanitizer might detect an error since something with a different size than expected will be freed. To prevent such issues, the tests should be placed within an anonymous namespace which makes all the symbols unique. namespace { struct DummyData { uint32_t foo { 0 }; }; class MyTest : public Test { //... }; TEST_F ( MyTest , TestName ) { EXPECT_EQ ( ANSWER , 42 ) } } // namespace","title":"Pitfalls"},{"location":"concepts/best-practice-for-testing/#conclusion","text":"apply the AAA pattern to structure the test and check only one state transition per test case (all side effects of that transition must be checked, though) don't test previously tested behavior use the ZOMBIES principle to find sensible test cases use meaningful names for the tests to indicate what the test is supposed to do and the expected outcome, like ...IsSuccessful , ...Fails , ...ResultsIn... , ...LeadsTo... , etc. name the test object sut to make clear which object is tested don't use magic numbers instantiate objects on the stack or use smart pointers for large objects and avoid manual memory management with new/delete use ASSERT_* before doing a potential dangerous action which might crash the test application, like accessing a nullptr or a cxx::optional with a nullopt use mocks to reduce the complexity of the test arrangement apply the DRY principle by using typed and parameterized tests wrap the tests in an anonymous namespace","title":"Conclusion"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/","text":"How optional and error values are returned in iceoryx \ud83d\udd17 Many parts of the iceoryx C++ API follow a functional programming approach and allow the user to specify functions which handle the possible cases, e.g. what should happen when data is received. This is very flexible but requires using the monadic types iox::cxx::expected and iox::cxx::optional , which we introduce in the following sections. Optional \ud83d\udd17 The type iox::cxx::optional<T> is used to indicate that there may or may not be a value of a specific type T available. This is essentially the 'maybe monad ' in functional programming. Assuming we have some optional (usually the result of some computation) optional < int > result = someComputation (); we can check for its value using if ( result . has_value ()) { auto value = result . value (); // do something with the value } else { // handle the case that there is no value } A shorthand to get the value is auto value = * result ; Attention Accessing the value if there is no value terminates the application, so it must be checked beforehand. We can achieve the same with the functional approach by providing a function for both cases. result . and_then ([]( int & value ) { /*do something with the value*/ }) . or_else ([]() { /*handle the case that there is no value*/ }); Notice that we get the value by reference, so if a copy is desired it has to be created explicitly in the lambda expression or function we pass. The optional can be initialized from a value directly optional < int > result = 73 ; result = 37 ; If the optional is default initialized, it is automatically set to its null value of type iox::cxx::nullopt_t . This can be also done directly by using the constant iox::cxx::nullopt result = iox :: cxx :: nullopt ; For a complete list of available functions see optional.hpp . The iox::cxx::optional behaves like the std::optional except that it does not throw exceptions and has no undefined behavior. Expected \ud83d\udd17 iox::cxx::expected<T, E> generalizes iox::cxx::optional by admitting a value of another type E instead of no value at all, i.e. it contains either a value of type T or E . In this way, expected is a special case of the 'either monad'. It is usually used to pass a value of type T or an error that may have occurred, i.e. E is the error type. For more information on how it is used for error handling see error-handling.md . Assume we have E as an error type, then we can create a value iox :: cxx :: expected < int , E > result ( iox :: cxx :: success < int > ( 73 )); and use the value or handle a potential error if ( ! result . has_error ()) { auto value = result . value (); // do something with the value } else { auto error = result . get_error (); // handle the error } If we need an error value, we set result = iox :: cxx :: error < E > ( errorCode ); which assumes that E can be constructed from an errorCode . We again can employ a functional approach like this: auto handleValue = []( int & value ) { /*do something with the value*/ }; auto handleError = []( E & value ) { /*handle the error*/ }; result . and_then ( handleValue ). or_else ( handleError ); There are more convenience functions such as value_or which provides the value or an alternative specified by the user. These can be found in expected.hpp . Note that when we move an expected , the origin contains a moved T or E , depending on the content before the move. This reflects the behavior of moving the content out of the iox::cxx::expected as in auto foo = std::move(bar.value()); with bar being an iox::cxx::expected . Like all objects, T and E must therefore be in a well defined state after the move.","title":"How optional and error values are returned in iceoryx"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/#how-optional-and-error-values-are-returned-in-iceoryx","text":"Many parts of the iceoryx C++ API follow a functional programming approach and allow the user to specify functions which handle the possible cases, e.g. what should happen when data is received. This is very flexible but requires using the monadic types iox::cxx::expected and iox::cxx::optional , which we introduce in the following sections.","title":"How optional and error values are returned in iceoryx"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/#optional","text":"The type iox::cxx::optional<T> is used to indicate that there may or may not be a value of a specific type T available. This is essentially the 'maybe monad ' in functional programming. Assuming we have some optional (usually the result of some computation) optional < int > result = someComputation (); we can check for its value using if ( result . has_value ()) { auto value = result . value (); // do something with the value } else { // handle the case that there is no value } A shorthand to get the value is auto value = * result ; Attention Accessing the value if there is no value terminates the application, so it must be checked beforehand. We can achieve the same with the functional approach by providing a function for both cases. result . and_then ([]( int & value ) { /*do something with the value*/ }) . or_else ([]() { /*handle the case that there is no value*/ }); Notice that we get the value by reference, so if a copy is desired it has to be created explicitly in the lambda expression or function we pass. The optional can be initialized from a value directly optional < int > result = 73 ; result = 37 ; If the optional is default initialized, it is automatically set to its null value of type iox::cxx::nullopt_t . This can be also done directly by using the constant iox::cxx::nullopt result = iox :: cxx :: nullopt ; For a complete list of available functions see optional.hpp . The iox::cxx::optional behaves like the std::optional except that it does not throw exceptions and has no undefined behavior.","title":"Optional"},{"location":"concepts/how-optional-and-error-values-are-returned-in-iceoryx/#expected","text":"iox::cxx::expected<T, E> generalizes iox::cxx::optional by admitting a value of another type E instead of no value at all, i.e. it contains either a value of type T or E . In this way, expected is a special case of the 'either monad'. It is usually used to pass a value of type T or an error that may have occurred, i.e. E is the error type. For more information on how it is used for error handling see error-handling.md . Assume we have E as an error type, then we can create a value iox :: cxx :: expected < int , E > result ( iox :: cxx :: success < int > ( 73 )); and use the value or handle a potential error if ( ! result . has_error ()) { auto value = result . value (); // do something with the value } else { auto error = result . get_error (); // handle the error } If we need an error value, we set result = iox :: cxx :: error < E > ( errorCode ); which assumes that E can be constructed from an errorCode . We again can employ a functional approach like this: auto handleValue = []( int & value ) { /*do something with the value*/ }; auto handleError = []( E & value ) { /*handle the error*/ }; result . and_then ( handleValue ). or_else ( handleError ); There are more convenience functions such as value_or which provides the value or an alternative specified by the user. These can be found in expected.hpp . Note that when we move an expected , the origin contains a moved T or E , depending on the content before the move. This reflects the behavior of moving the content out of the iox::cxx::expected as in auto foo = std::move(bar.value()); with bar being an iox::cxx::expected . Like all objects, T and E must therefore be in a well defined state after the move.","title":"Expected"},{"location":"concepts/qos-policies/","text":"QoS policies \ud83d\udd17 Unlike other middlewares, e.g. DDS used in ROS 2 , iceoryx keeps things simple and offers basic Quality of Service (QoS) settings. The QoS settings are called options and can be used to optimize and tailor the communication. ServerOptions and ClientOptions \ud83d\udd17 The two most important settings are: Option Explanation ServerOptions::requestQueueCapacity This enables servers to store n requests at the users side ClientOptions::responseQueueCapacity This enables clients to store n responses at the users side Compatible policies \ud83d\udd17 The ConsumerTooSlowPolicy and QueueFullPolicy are used to control the behavior for full queues. Since some combinations would be contradicting, not all of them match to connect producer and consumer. ConsumerTooSlowPolicy QueueFullPolicy Behavior Connection WAIT_FOR_CONSUMER BLOCK_PRODUCER Producer blocks and waits for consumers WAIT_FOR_CONSUMER DISCARD_OLDEST_DATA Non-blocking producer DISCARD_OLDEST_DATA DISCARD_OLDEST_DATA Non-blocking producer DISCARD_OLDEST_DATA BLOCK_PRODUCER Not compatible, no connection established Server and client matching criteria \ud83d\udd17 Two criteria have to be fulfilled in order for a server and a client to be connected. Same capro::ServiceDescription Matching ConsumerTooSlowPolicy and QueueFullPolicy in ServerOptions / ClientOptions PublisherOptions and SubscriberOptions \ud83d\udd17 The three most important settings are: Option Explanation PublisherOptions::historyCapacity This enables late-joining subscribers to request the n last samples SubscriberOptions::queueCapacity Size of the subscriber queue where samples are stored at the user side SubscriberOptions::historyRequest The number of samples a late-joining subscriber will request from every offered publisher, should be equal or smaller than historyCapacity otherwise capped Warning In case of n:m communication, the history feature will not provide the overall last n samples based on delivery point in time! The following two scenarios are examples of issues when using n:m together with the history feature: Multiple publishers The last n samples of every publisher are received. This means for m publishers in the worst case m * n samples in random order, not in the order they were published on the topic. Multiple publishers after the publisher called stopOffer() or is removed The last n samples will never be received since they vanished. An arbitrary number of samples or nothing is received. For more information about the options see the corresponding example iceoptions . Info If the PublisherOptions::historyCapacity is larger than SubscriberOptions::queueCapacity and blocking behaviour is active, late-joining subscribers will not receive the latest and greatest sample, effectively loosing some. Publisher and subscriber matching criteria \ud83d\udd17 If requiresPublisherHistorySupport is set, additionally to the matching criteria of server and client, there is a third one for publishers and subscribers: Same capro::ServiceDescription Matching ConsumerTooSlowPolicy and QueueFullPolicy in PublisherOptions / SubscriberOptions PublisherOptions::historyCapacity > 0","title":"QoS policies"},{"location":"concepts/qos-policies/#qos-policies","text":"Unlike other middlewares, e.g. DDS used in ROS 2 , iceoryx keeps things simple and offers basic Quality of Service (QoS) settings. The QoS settings are called options and can be used to optimize and tailor the communication.","title":"QoS policies"},{"location":"concepts/qos-policies/#serveroptions-and-clientoptions","text":"The two most important settings are: Option Explanation ServerOptions::requestQueueCapacity This enables servers to store n requests at the users side ClientOptions::responseQueueCapacity This enables clients to store n responses at the users side","title":"ServerOptions and ClientOptions"},{"location":"concepts/qos-policies/#compatible-policies","text":"The ConsumerTooSlowPolicy and QueueFullPolicy are used to control the behavior for full queues. Since some combinations would be contradicting, not all of them match to connect producer and consumer. ConsumerTooSlowPolicy QueueFullPolicy Behavior Connection WAIT_FOR_CONSUMER BLOCK_PRODUCER Producer blocks and waits for consumers WAIT_FOR_CONSUMER DISCARD_OLDEST_DATA Non-blocking producer DISCARD_OLDEST_DATA DISCARD_OLDEST_DATA Non-blocking producer DISCARD_OLDEST_DATA BLOCK_PRODUCER Not compatible, no connection established","title":"Compatible policies"},{"location":"concepts/qos-policies/#server-and-client-matching-criteria","text":"Two criteria have to be fulfilled in order for a server and a client to be connected. Same capro::ServiceDescription Matching ConsumerTooSlowPolicy and QueueFullPolicy in ServerOptions / ClientOptions","title":"Server and client matching criteria"},{"location":"concepts/qos-policies/#publisheroptions-and-subscriberoptions","text":"The three most important settings are: Option Explanation PublisherOptions::historyCapacity This enables late-joining subscribers to request the n last samples SubscriberOptions::queueCapacity Size of the subscriber queue where samples are stored at the user side SubscriberOptions::historyRequest The number of samples a late-joining subscriber will request from every offered publisher, should be equal or smaller than historyCapacity otherwise capped Warning In case of n:m communication, the history feature will not provide the overall last n samples based on delivery point in time! The following two scenarios are examples of issues when using n:m together with the history feature: Multiple publishers The last n samples of every publisher are received. This means for m publishers in the worst case m * n samples in random order, not in the order they were published on the topic. Multiple publishers after the publisher called stopOffer() or is removed The last n samples will never be received since they vanished. An arbitrary number of samples or nothing is received. For more information about the options see the corresponding example iceoptions . Info If the PublisherOptions::historyCapacity is larger than SubscriberOptions::queueCapacity and blocking behaviour is active, late-joining subscribers will not receive the latest and greatest sample, effectively loosing some.","title":"PublisherOptions and SubscriberOptions"},{"location":"concepts/qos-policies/#publisher-and-subscriber-matching-criteria","text":"If requiresPublisherHistorySupport is set, additionally to the matching criteria of server and client, there is a third one for publishers and subscribers: Same capro::ServiceDescription Matching ConsumerTooSlowPolicy and QueueFullPolicy in PublisherOptions / SubscriberOptions PublisherOptions::historyCapacity > 0","title":"Publisher and subscriber matching criteria"},{"location":"design/design_article/","text":"Design article \ud83d\udd17","title":"Design article"},{"location":"design/design_article/#design-article","text":"","title":"Design article"},{"location":"examples/","text":"List of examples \ud83d\udd17 Example Description Level icehello Sending data to another process icedelivery Sending and receiving data using C++ icedelivery_in_c Sending and receiving data using C icedocker Sending and receiving data across multiple docker instances iceoptions Configuring pub/sub settings like history cache size or startup behaviour complexdata Sending/receiving some of the iceoryx STL container surrogates request_response Delivering data on demand (Client/Server) using C++ request_response_in_c Delivering data on demand (Client/Server) using C callbacks Implementing event triggered callbacks using C++ callbacks_in_c Implementing event triggered callbacks using C waitset Waiting for events like arrival of data using C++ waitset_in_c Waiting for events like arrival of data using C iceensemble Using multiple publishers for one topic singleprocess Communicating in a single process between threads user_header Using a user-header for additional meta-information like timestamps icediscovery Searching for currently available services icediscovery_in_c Searching for currently available services using C ice_access_control Configuring access rights for shared memory segments iceperf Measuring the latency of different IPC mechanisms icecrystal Using the introspection client for debugging","title":"Examples"},{"location":"examples/#list-of-examples","text":"Example Description Level icehello Sending data to another process icedelivery Sending and receiving data using C++ icedelivery_in_c Sending and receiving data using C icedocker Sending and receiving data across multiple docker instances iceoptions Configuring pub/sub settings like history cache size or startup behaviour complexdata Sending/receiving some of the iceoryx STL container surrogates request_response Delivering data on demand (Client/Server) using C++ request_response_in_c Delivering data on demand (Client/Server) using C callbacks Implementing event triggered callbacks using C++ callbacks_in_c Implementing event triggered callbacks using C waitset Waiting for events like arrival of data using C++ waitset_in_c Waiting for events like arrival of data using C iceensemble Using multiple publishers for one topic singleprocess Communicating in a single process between threads user_header Using a user-header for additional meta-information like timestamps icediscovery Searching for currently available services icediscovery_in_c Searching for currently available services using C ice_access_control Configuring access rights for shared memory segments iceperf Measuring the latency of different IPC mechanisms icecrystal Using the introspection client for debugging","title":"List of examples"},{"location":"examples/callbacks/","text":"Listener (or how to use callbacks with iceoryx) \ud83d\udd17 Thread Safety \ud83d\udd17 The Listener is thread-safe and can be used without restrictions. But be aware that all provided callbacks are executed concurrently in the background thread of the Listener. If you access structures inside this callback you have to either ensure that you are the only one accessing it or that it is accessed with a guard like a std::mutex . Introduction \ud83d\udd17 For an introduction into the terminology please read the Glossary in the WaitSet C++ example . The Listener is a completely thread-safe construct that reacts to events by executing registered callbacks in a background thread. Events can be emitted by EventOrigins like a subscriber or a user trigger. Some of the EventOrigins like the subscriber can hereby emit more than one event type. The interface of a listener consists of two methods: attachEvent to attach a new event with a callback and detachEvent . These two methods can be called concurrently, even from inside a callback that was triggered by an event! Expected Output \ud83d\udd17 Code Walkthrough \ud83d\udd17 Attention Please be aware of the thread-safety restrictions of the Listener and read the Thread Safety chapter carefully. Let's say we have an application that offers us two distinct services: Radar.FrontLeft.Counter and Rader.FrontRight.Counter . Every time we have received a sample from left and right we would like to calculate the sum with the newest values and print it out. If we have received only one of the samples, we store it until we received the other side. ice_callbacks_publisher.cpp \ud83d\udd17 The publisher of this example does not contain any new features but if you have some questions take a look at the icedelivery example . ice_callbacks_subscriber.cpp \ud83d\udd17 int main() \ud83d\udd17 The subscriber main function starts as usual and after registering the runtime we create the listener that starts a background thread. iox :: popo :: Listener listener ; Because it is fun, we also create a heartbeat trigger that will be triggered every 4 seconds so that heartbeat received can be printed to the console. Furthermore, we have to create two subscribers to receive samples for the two services. iox :: popo :: UserTrigger heartbeat ; iox :: popo :: Subscriber < CounterTopic > subscriberLeft ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); iox :: popo :: Subscriber < CounterTopic > subscriberRight ({ \"Radar\" , \"FrontRight\" , \"Counter\" }); Next thing is a heartbeatThread which will trigger our heartbeat trigger every 4 seconds. std :: thread heartbeatThread ([ & ] { while ( ! iox :: posix :: hasTerminationRequested ()) { heartbeat . trigger (); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 4 )); } }); Now that everything is set up, we can attach the subscribers to the listener so that every time a new sample ( iox::popo::SubscriberEvent::DATA_RECEIVED ) is received our callback ( onSampleReceivedCallback ) will be called. We also attach our heartbeat user trigger to print the heartbeat message to the console via another callback ( heartbeatCallback ). listener . attachEvent ( heartbeat , iox :: popo :: createNotificationCallback ( heartbeatCallback )). or_else ([]( auto ) { std :: cerr << \"unable to attach heartbeat event\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); // It is possible to attach any c function here with a signature of void(iox::popo::Subscriber<CounterTopic> *). // But please be aware that the listener does not take ownership of the callback, therefore it has to exist as // long as the event is attached. Furthermore, it excludes lambdas which are capturing data since they are not // convertable to a c function pointer. // to simplify the example we attach the same callback onSampleReceivedCallback again listener . attachEvent ( subscriberLeft , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberLeft\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); listener . attachEvent ( subscriberRight , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberRight\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Since a user trigger has only one event, we do not have to specify an event when we attach it to the listener. attachEvent returns a cxx::expected to inform us if the attachment succeeded. When this is not the case the error handling is performed in the .or_else([](auto){ part after each attachEvent call. In this example, we choose to attach the same callback twice to make things easier but you are free to attach any callback with the signature void(iox::popo::Subscriber<CounterTopic> *) . The setup is complete, but it would terminate right away since we have no blocker which waits until SIGINT or SIGTERM was send. In the other examples, we had not that problem since we pulled all the events in a while true loop but working only with callbacks requires something like our SignalWatcher which waits until SIGINT or SIGTERM was signaled. iox :: posix :: waitForTerminationRequest (); When waitForTerminationRequest unblocks we clean up all resources and terminate the process gracefully. listener . detachEvent ( heartbeat ); listener . detachEvent ( subscriberLeft , iox :: popo :: SubscriberEvent :: DATA_RECEIVED ); listener . detachEvent ( subscriberRight , iox :: popo :: SubscriberEvent :: DATA_RECEIVED ); heartbeatThread . join (); Hint: You do not have to detach an EventOrigin like a subscriber or user trigger before it goes out of scope. This also goes for the Listener , the implemented RAII-based design takes care of the resource cleanup. The Callbacks \ud83d\udd17 The callbacks must have a signature like void(PointerToEventOrigin*) . Our heartbeatCallback for instance, just prints the message heartbeat received . void heartbeatCallback ( iox :: popo :: UserTrigger * ) { std :: cout << \"heartbeat received \" << std :: endl ; } The onSampleReceivedCallback is more complex. We first acquire the received sample and check which subscriber signaled the event by acquiring the subscriber's service description. If the instance is equal to FrontLeft we store the sample in the leftCache otherwise in the rightCache . void onSampleReceivedCallback ( iox :: popo :: Subscriber < CounterTopic >* subscriber ) { subscriber -> take (). and_then ([ subscriber ]( auto & sample ) { auto instanceString = subscriber -> getServiceDescription (). getInstanceIDString (); // store the sample in the corresponding cache if ( instanceString == iox :: capro :: IdString_t ( \"FrontLeft\" )) { leftCache . emplace ( * sample ); } else if ( instanceString == iox :: capro :: IdString_t ( \"FrontRight\" )) { rightCache . emplace ( * sample ); } std :: cout << \"received: \" << sample -> counter << std :: endl ; }); // ... } In the next step, we check if both caches are filled. If this is the case, we print an extra message which states the result of the sum of both received values. Afterward, we reset both caches to start fresh again. void onSampleReceivedCallback ( iox :: popo :: Subscriber < CounterTopic >* subscriber ) { // ... // if both caches are filled we can process them if ( leftCache && rightCache ) { std :: cout << \"Received samples from FrontLeft and FrontRight. Sum of \" << leftCache -> counter << \" + \" << rightCache -> counter << \" = \" << leftCache -> counter + rightCache -> counter << std :: endl ; leftCache . reset (); rightCache . reset (); } } Additional context data for callbacks (ice_callbacks_listener_as_class_member.cpp) \ud83d\udd17 Here we demonstrate how you can provide virtually everything as an additional argument to the callbacks. You just have to provide a reference to a value as additional argument in the attachEvent method which is then provided as argument in your callback. One of the use cases is to get access to members and methods of an object inside a static method which we demonstrate here. This example is identical to the ice_callbacks_subscriber.cpp one, except that we left out the cyclic heartbeat trigger. The key difference is that the listener is now a class member and in every callback we would like to change some member variables. For this we require an additional pointer to the object since the listener requires c function references which do not allow the usage of lambda expressions with capturing. Here we can use the userType feature which allows us to provide the this pointer as additional argument to the callback. The main function is now pretty short, we instantiate our object of type CounterService and call waitForTerminationRequest like in the previous example to wait for the control c event from the user. iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); CounterService counterService ; iox :: posix :: waitForTerminationRequest (); Our CounterService has the following members: iox :: popo :: Subscriber < CounterTopic > m_subscriberLeft ; iox :: popo :: Subscriber < CounterTopic > m_subscriberRight ; iox :: cxx :: optional < CounterTopic > m_leftCache ; iox :: cxx :: optional < CounterTopic > m_rightCache ; iox :: popo :: Listener m_listener ; And their purposes are the same as in the previous example. In the constructor we initialize the two subscribers and attach them to our listener. But now we add an additional parameter in the iox::popo::createNotificationCallback , the dereferenced this pointer. It has to be dereferenced since we require a reference as argument. Attention The user has to ensure that the contextData ( *this ) in attachEvent lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling. CounterService () : m_subscriberLeft ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }) , m_subscriberRight ({ \"Radar\" , \"FrontRight\" , \"Counter\" }) { /// Attach the static method onSampleReceivedCallback and provide this as additional argument /// to the callback to gain access to the object whenever the callback is called. /// It is not possible to use a lambda with capturing here since they are not convertable to /// a C function pointer. /// important: the user has to ensure that the contextData (*this) lives as long as /// the subscriber with its callback is attached to the listener m_listener . attachEvent ( m_subscriberLeft , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback , * this )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberLeft\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); m_listener . attachEvent ( m_subscriberRight , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback , * this )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberRight\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } The onSampleReceivedCallback is now a static method instead of a free function. It has to be static since we require a C function reference as callback argument and a static method can be converted into such a type. But in a static method we do not have access to the members of an object, therefore we have to add an additional argument, the pointer to the object itself, called self . static void onSampleReceivedCallback ( iox :: popo :: Subscriber < CounterTopic >* subscriber , CounterService * self ) { subscriber -> take (). and_then ([ subscriber , self ]( auto & sample ) { auto instanceString = subscriber -> getServiceDescription (). getInstanceIDString (); // store the sample in the corresponding cache if ( instanceString == iox :: capro :: IdString_t ( \"FrontLeft\" )) { self -> m_leftCache . emplace ( * sample ); } else if ( instanceString == iox :: capro :: IdString_t ( \"FrontRight\" )) { self -> m_rightCache . emplace ( * sample ); } std :: cout << \"received: \" << sample -> counter << std :: endl ; }); // if both caches are filled we can process them if ( self -> m_leftCache && self -> m_rightCache ) { std :: cout << \"Received samples from FrontLeft and FrontRight. Sum of \" << self -> m_leftCache -> counter << \" + \" << self -> m_rightCache -> counter << \" = \" << self -> m_leftCache -> counter + self -> m_rightCache -> counter << std :: endl ; self -> m_leftCache . reset (); self -> m_rightCache . reset (); } } Check out callbacks on GitHub","title":"Implementing event triggered callbacks using C++"},{"location":"examples/callbacks/#listener-or-how-to-use-callbacks-with-iceoryx","text":"","title":"Listener (or how to use callbacks with iceoryx)"},{"location":"examples/callbacks/#thread-safety","text":"The Listener is thread-safe and can be used without restrictions. But be aware that all provided callbacks are executed concurrently in the background thread of the Listener. If you access structures inside this callback you have to either ensure that you are the only one accessing it or that it is accessed with a guard like a std::mutex .","title":"Thread Safety"},{"location":"examples/callbacks/#introduction","text":"For an introduction into the terminology please read the Glossary in the WaitSet C++ example . The Listener is a completely thread-safe construct that reacts to events by executing registered callbacks in a background thread. Events can be emitted by EventOrigins like a subscriber or a user trigger. Some of the EventOrigins like the subscriber can hereby emit more than one event type. The interface of a listener consists of two methods: attachEvent to attach a new event with a callback and detachEvent . These two methods can be called concurrently, even from inside a callback that was triggered by an event!","title":"Introduction"},{"location":"examples/callbacks/#expected-output","text":"","title":"Expected Output"},{"location":"examples/callbacks/#code-walkthrough","text":"Attention Please be aware of the thread-safety restrictions of the Listener and read the Thread Safety chapter carefully. Let's say we have an application that offers us two distinct services: Radar.FrontLeft.Counter and Rader.FrontRight.Counter . Every time we have received a sample from left and right we would like to calculate the sum with the newest values and print it out. If we have received only one of the samples, we store it until we received the other side.","title":"Code Walkthrough"},{"location":"examples/callbacks/#ice_callbacks_publishercpp","text":"The publisher of this example does not contain any new features but if you have some questions take a look at the icedelivery example .","title":"ice_callbacks_publisher.cpp"},{"location":"examples/callbacks/#ice_callbacks_subscribercpp","text":"","title":"ice_callbacks_subscriber.cpp"},{"location":"examples/callbacks/#int-main","text":"The subscriber main function starts as usual and after registering the runtime we create the listener that starts a background thread. iox :: popo :: Listener listener ; Because it is fun, we also create a heartbeat trigger that will be triggered every 4 seconds so that heartbeat received can be printed to the console. Furthermore, we have to create two subscribers to receive samples for the two services. iox :: popo :: UserTrigger heartbeat ; iox :: popo :: Subscriber < CounterTopic > subscriberLeft ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); iox :: popo :: Subscriber < CounterTopic > subscriberRight ({ \"Radar\" , \"FrontRight\" , \"Counter\" }); Next thing is a heartbeatThread which will trigger our heartbeat trigger every 4 seconds. std :: thread heartbeatThread ([ & ] { while ( ! iox :: posix :: hasTerminationRequested ()) { heartbeat . trigger (); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 4 )); } }); Now that everything is set up, we can attach the subscribers to the listener so that every time a new sample ( iox::popo::SubscriberEvent::DATA_RECEIVED ) is received our callback ( onSampleReceivedCallback ) will be called. We also attach our heartbeat user trigger to print the heartbeat message to the console via another callback ( heartbeatCallback ). listener . attachEvent ( heartbeat , iox :: popo :: createNotificationCallback ( heartbeatCallback )). or_else ([]( auto ) { std :: cerr << \"unable to attach heartbeat event\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); // It is possible to attach any c function here with a signature of void(iox::popo::Subscriber<CounterTopic> *). // But please be aware that the listener does not take ownership of the callback, therefore it has to exist as // long as the event is attached. Furthermore, it excludes lambdas which are capturing data since they are not // convertable to a c function pointer. // to simplify the example we attach the same callback onSampleReceivedCallback again listener . attachEvent ( subscriberLeft , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberLeft\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); listener . attachEvent ( subscriberRight , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberRight\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Since a user trigger has only one event, we do not have to specify an event when we attach it to the listener. attachEvent returns a cxx::expected to inform us if the attachment succeeded. When this is not the case the error handling is performed in the .or_else([](auto){ part after each attachEvent call. In this example, we choose to attach the same callback twice to make things easier but you are free to attach any callback with the signature void(iox::popo::Subscriber<CounterTopic> *) . The setup is complete, but it would terminate right away since we have no blocker which waits until SIGINT or SIGTERM was send. In the other examples, we had not that problem since we pulled all the events in a while true loop but working only with callbacks requires something like our SignalWatcher which waits until SIGINT or SIGTERM was signaled. iox :: posix :: waitForTerminationRequest (); When waitForTerminationRequest unblocks we clean up all resources and terminate the process gracefully. listener . detachEvent ( heartbeat ); listener . detachEvent ( subscriberLeft , iox :: popo :: SubscriberEvent :: DATA_RECEIVED ); listener . detachEvent ( subscriberRight , iox :: popo :: SubscriberEvent :: DATA_RECEIVED ); heartbeatThread . join (); Hint: You do not have to detach an EventOrigin like a subscriber or user trigger before it goes out of scope. This also goes for the Listener , the implemented RAII-based design takes care of the resource cleanup.","title":"int main()"},{"location":"examples/callbacks/#the-callbacks","text":"The callbacks must have a signature like void(PointerToEventOrigin*) . Our heartbeatCallback for instance, just prints the message heartbeat received . void heartbeatCallback ( iox :: popo :: UserTrigger * ) { std :: cout << \"heartbeat received \" << std :: endl ; } The onSampleReceivedCallback is more complex. We first acquire the received sample and check which subscriber signaled the event by acquiring the subscriber's service description. If the instance is equal to FrontLeft we store the sample in the leftCache otherwise in the rightCache . void onSampleReceivedCallback ( iox :: popo :: Subscriber < CounterTopic >* subscriber ) { subscriber -> take (). and_then ([ subscriber ]( auto & sample ) { auto instanceString = subscriber -> getServiceDescription (). getInstanceIDString (); // store the sample in the corresponding cache if ( instanceString == iox :: capro :: IdString_t ( \"FrontLeft\" )) { leftCache . emplace ( * sample ); } else if ( instanceString == iox :: capro :: IdString_t ( \"FrontRight\" )) { rightCache . emplace ( * sample ); } std :: cout << \"received: \" << sample -> counter << std :: endl ; }); // ... } In the next step, we check if both caches are filled. If this is the case, we print an extra message which states the result of the sum of both received values. Afterward, we reset both caches to start fresh again. void onSampleReceivedCallback ( iox :: popo :: Subscriber < CounterTopic >* subscriber ) { // ... // if both caches are filled we can process them if ( leftCache && rightCache ) { std :: cout << \"Received samples from FrontLeft and FrontRight. Sum of \" << leftCache -> counter << \" + \" << rightCache -> counter << \" = \" << leftCache -> counter + rightCache -> counter << std :: endl ; leftCache . reset (); rightCache . reset (); } }","title":"The Callbacks"},{"location":"examples/callbacks/#additional-context-data-for-callbacks-ice_callbacks_listener_as_class_membercpp","text":"Here we demonstrate how you can provide virtually everything as an additional argument to the callbacks. You just have to provide a reference to a value as additional argument in the attachEvent method which is then provided as argument in your callback. One of the use cases is to get access to members and methods of an object inside a static method which we demonstrate here. This example is identical to the ice_callbacks_subscriber.cpp one, except that we left out the cyclic heartbeat trigger. The key difference is that the listener is now a class member and in every callback we would like to change some member variables. For this we require an additional pointer to the object since the listener requires c function references which do not allow the usage of lambda expressions with capturing. Here we can use the userType feature which allows us to provide the this pointer as additional argument to the callback. The main function is now pretty short, we instantiate our object of type CounterService and call waitForTerminationRequest like in the previous example to wait for the control c event from the user. iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); CounterService counterService ; iox :: posix :: waitForTerminationRequest (); Our CounterService has the following members: iox :: popo :: Subscriber < CounterTopic > m_subscriberLeft ; iox :: popo :: Subscriber < CounterTopic > m_subscriberRight ; iox :: cxx :: optional < CounterTopic > m_leftCache ; iox :: cxx :: optional < CounterTopic > m_rightCache ; iox :: popo :: Listener m_listener ; And their purposes are the same as in the previous example. In the constructor we initialize the two subscribers and attach them to our listener. But now we add an additional parameter in the iox::popo::createNotificationCallback , the dereferenced this pointer. It has to be dereferenced since we require a reference as argument. Attention The user has to ensure that the contextData ( *this ) in attachEvent lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling. CounterService () : m_subscriberLeft ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }) , m_subscriberRight ({ \"Radar\" , \"FrontRight\" , \"Counter\" }) { /// Attach the static method onSampleReceivedCallback and provide this as additional argument /// to the callback to gain access to the object whenever the callback is called. /// It is not possible to use a lambda with capturing here since they are not convertable to /// a C function pointer. /// important: the user has to ensure that the contextData (*this) lives as long as /// the subscriber with its callback is attached to the listener m_listener . attachEvent ( m_subscriberLeft , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback , * this )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberLeft\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); m_listener . attachEvent ( m_subscriberRight , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , iox :: popo :: createNotificationCallback ( onSampleReceivedCallback , * this )) . or_else ([]( auto ) { std :: cerr << \"unable to attach subscriberRight\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } The onSampleReceivedCallback is now a static method instead of a free function. It has to be static since we require a C function reference as callback argument and a static method can be converted into such a type. But in a static method we do not have access to the members of an object, therefore we have to add an additional argument, the pointer to the object itself, called self . static void onSampleReceivedCallback ( iox :: popo :: Subscriber < CounterTopic >* subscriber , CounterService * self ) { subscriber -> take (). and_then ([ subscriber , self ]( auto & sample ) { auto instanceString = subscriber -> getServiceDescription (). getInstanceIDString (); // store the sample in the corresponding cache if ( instanceString == iox :: capro :: IdString_t ( \"FrontLeft\" )) { self -> m_leftCache . emplace ( * sample ); } else if ( instanceString == iox :: capro :: IdString_t ( \"FrontRight\" )) { self -> m_rightCache . emplace ( * sample ); } std :: cout << \"received: \" << sample -> counter << std :: endl ; }); // if both caches are filled we can process them if ( self -> m_leftCache && self -> m_rightCache ) { std :: cout << \"Received samples from FrontLeft and FrontRight. Sum of \" << self -> m_leftCache -> counter << \" + \" << self -> m_rightCache -> counter << \" = \" << self -> m_leftCache -> counter + self -> m_rightCache -> counter << std :: endl ; self -> m_leftCache . reset (); self -> m_rightCache . reset (); } } Check out callbacks on GitHub","title":"Additional context data for callbacks (ice_callbacks_listener_as_class_member.cpp)"},{"location":"examples/callbacks_in_c/","text":"Listener in C (or how to use callbacks with iceoryx) \ud83d\udd17 Thread Safety \ud83d\udd17 The Listener is thread-safe and can be used without restrictions. But be aware that all provided callbacks are executed concurrently in the background thread of the Listener. If you access structures inside this callback you have to either ensure that you are the only one accessing it or that it is accessed with a guard like a mutex . Introduction \ud83d\udd17 For a general introduction into the Listener concept please take a look at the first part of the Listener C++ example and at the Glossary of the WaitSet C++ example . Expected Output \ud83d\udd17 Code Walkthrough \ud83d\udd17 Attention Please be aware about the thread-safety restrictions of the Listener and read the Thread Safety chapter carefully. The C version of the callbacks example performs the identical tasks as the C++ version. We have again an application which offers two services called Radar.FrontLeft.Counter and Radar.FrontRight.Counter . Every time we have received a sample from each service we calculate the sum of it. ice_c_callbacks_publisher.c \ud83d\udd17 The publisher contains only already known iceoryx features. If some of them are not known to you please take a look at the icedelivery in C example . ice_c_callbacks_subscriber.c \ud83d\udd17 int main() \ud83d\udd17 The subscriber starts as usual by registering the process at the runtime. In the next step, we set up some listenerStorage and initialize the listener which will start a background thread for the upcoming event-triggered callbacks. iox_listener_storage_t listenerStorage ; iox_listener_t listener = iox_listener_init ( & listenerStorage ); Besides the subscribers we also would like to have an event that will be triggered by our self - the heartbeat . iox_user_trigger_storage_t heartbeatStorage ; heartbeat = iox_user_trigger_init ( & heartbeatStorage ); Both subscribers use the same options which we set up with: iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 10U ; options . queueCapacity = 50U ; options . nodeName = \"iox-c-callback-subscriber-node\" ; and then we can construct the two subscribers subscriberLeft and subscriberRight . iox_sub_t subscriberLeft = iox_sub_init ( & subscriberLeftStorage , \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); iox_sub_t subscriberRight = iox_sub_init ( & subscriberRightStorage , \"Radar\" , \"FrontRight\" , \"Counter\" , & options ); Now that everything is initialized, we start our heartbeatTriggerThread which triggers our heartbeat every 4 seconds. pthread_t heartbeatTriggerThread ; if ( pthread_create ( & heartbeatTriggerThread , NULL , cyclicHeartbeatTrigger , NULL )) { printf ( \"failed to create thread \\n \" ); return -1 ; } Attaching the subscribers and the heartbeat allows the Listener to call the callbacks whenever the event is signaled by the EventOrigin . // from here on the callbacks are called when an event occurs iox_listener_attach_user_trigger_event ( listener , heartbeat , & heartbeatCallback ); iox_listener_attach_subscriber_event ( listener , subscriberLeft , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback ); iox_listener_attach_subscriber_event ( listener , subscriberRight , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback ); A user trigger can emit only one event therefore we do not provide the event type as an argument in the user trigger attach call. Since we are following a push-based approach, i.e. without an event loop that is pulling the events and processing them, we require a blocking call that waits until the process is signaled to terminate. while ( keepRunning ) { sleep_for ( 100 ); } When keepRunning is set to false, we clean up all the resources. First, we detach the events from the Listener. This is an optional step since the Listener detaches all events by itself when it is deinitialized. This applies also for all the EventOrigins , if you for instance deinitialize an attached subscriber it will automatically detach itself from the Listener. iox_listener_detach_user_trigger_event ( listener , heartbeat ); iox_listener_detach_subscriber_event ( listener , subscriberLeft , SubscriberEvent_DATA_RECEIVED ); iox_listener_detach_subscriber_event ( listener , subscriberRight , SubscriberEvent_DATA_RECEIVED ); In a last step we have to release all acquired resources iox_user_trigger_deinit ( heartbeat ); iox_sub_deinit ( subscriberLeft ); iox_sub_deinit ( subscriberRight ); iox_listener_deinit ( listener ); The callbacks \ud83d\udd17 Every callback must have a signature like void (iox_event_origin_t) . Our heartbeatCallback just prints the message heartbeat received onto the console. void heartbeatCallback ( iox_user_trigger_t userTrigger ) { ( void ) userTrigger ; printf ( \"heartbeat received \\n \" ); fflush ( stdout ); } The onSampleReceivedCallback is a little bit more complex. First we acquire the chunk and then we have to find out which subscriber received the chunk. For that we acquire the service description of the subscriber and if its instance equals FrontLeft we store the chunk value in the leftCache otherwise in the rightCache . void onSampleReceivedCallback ( iox_sub_t subscriber ) { const struct CounterTopic * userPayload ; if ( iox_sub_take_chunk ( subscriber , ( const void ** ) & userPayload ) == ChunkReceiveResult_SUCCESS ) { iox_service_description_t serviceDescription = iox_sub_get_service_description ( subscriber ); if ( strcmp ( serviceDescription . instanceString , \"FrontLeft\" ) == 0 ) { leftCache . value = * userPayload ; leftCache . isSet = true ; } else if ( strcmp ( serviceDescription . instanceString , \"FrontRight\" ) == 0 ) { rightCache . value = * userPayload ; rightCache . isSet = true ; } printf ( \"received: %d \\n \" , userPayload -> counter ); fflush ( stdout ); } // ... } If both caches are set, we can calculate the sum of both chunks and print them to the console. To start fresh in the next cycle, we reset the leftCache and the rightCache afterward. void onSampleReceivedCallback ( iox_sub_t subscriber ) { // ... if ( leftCache . isSet && rightCache . isSet ) { printf ( \"Received samples from FrontLeft and FrontRight. Sum of %d + %d = %d \\n \" , leftCache . value . counter , rightCache . value . counter , leftCache . value . counter + rightCache . value . counter ); fflush ( stdout ); leftCache . isSet = false ; rightCache . isSet = false ; } } Additional context data for callbacks (ice_c_callbacks_with_context_data.c) \ud83d\udd17 Sometimes we would like to modify data structures which are not globally available within the callback. To facilitate this we provide the functions called iox_listener_attach_***_event_with_context_data which allow to provide an additional void pointer for the callback as second argument. The following example is a simplified version of the ice_c_callbacks_subscriber.c example where we removed the cyclic heartbeat trigger. The key difference is that we have a local variable called counterService in which we store the leftCache and rightCache and we let the callback update that variable directly. CounterService counterService ; counterService . leftCache . isSet = false ; counterService . rightCache . isSet = false ; The callback takes an additional void pointer argument which we cast then to our CounterService to perform the same tasks as in the previous example but now on CounterService * self . void onSampleReceivedCallback ( iox_sub_t subscriber , void * contextData ) { if ( contextData == NULL ) { fprintf ( stderr , \"aborting onSampleReceivedCallback since contextData is a null pointer \\n \" ); return ; } CounterService * self = ( CounterService * ) contextData ; // ... } Finally, we have to attach both subscribers and provide the pointer to counterService as additional argument so that we can access it in the callback. Attention The user has to ensure that the contextData ( &counterService ) in iox_listener_attach_subscriber_event_with_context_data lives as long as the attachment with its callback is attached, otherwise the callback context data pointer is dangling. iox_listener_attach_subscriber_event_with_context_data ( listener , subscriberLeft , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback , & counterService ); iox_listener_attach_subscriber_event_with_context_data ( listener , subscriberRight , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback , & counterService ); Check out callbacks_in_c on GitHub","title":"Implementing event triggered callbacks using C"},{"location":"examples/callbacks_in_c/#listener-in-c-or-how-to-use-callbacks-with-iceoryx","text":"","title":"Listener in C (or how to use callbacks with iceoryx)"},{"location":"examples/callbacks_in_c/#thread-safety","text":"The Listener is thread-safe and can be used without restrictions. But be aware that all provided callbacks are executed concurrently in the background thread of the Listener. If you access structures inside this callback you have to either ensure that you are the only one accessing it or that it is accessed with a guard like a mutex .","title":"Thread Safety"},{"location":"examples/callbacks_in_c/#introduction","text":"For a general introduction into the Listener concept please take a look at the first part of the Listener C++ example and at the Glossary of the WaitSet C++ example .","title":"Introduction"},{"location":"examples/callbacks_in_c/#expected-output","text":"","title":"Expected Output"},{"location":"examples/callbacks_in_c/#code-walkthrough","text":"Attention Please be aware about the thread-safety restrictions of the Listener and read the Thread Safety chapter carefully. The C version of the callbacks example performs the identical tasks as the C++ version. We have again an application which offers two services called Radar.FrontLeft.Counter and Radar.FrontRight.Counter . Every time we have received a sample from each service we calculate the sum of it.","title":"Code Walkthrough"},{"location":"examples/callbacks_in_c/#ice_c_callbacks_publisherc","text":"The publisher contains only already known iceoryx features. If some of them are not known to you please take a look at the icedelivery in C example .","title":"ice_c_callbacks_publisher.c"},{"location":"examples/callbacks_in_c/#ice_c_callbacks_subscriberc","text":"","title":"ice_c_callbacks_subscriber.c"},{"location":"examples/callbacks_in_c/#int-main","text":"The subscriber starts as usual by registering the process at the runtime. In the next step, we set up some listenerStorage and initialize the listener which will start a background thread for the upcoming event-triggered callbacks. iox_listener_storage_t listenerStorage ; iox_listener_t listener = iox_listener_init ( & listenerStorage ); Besides the subscribers we also would like to have an event that will be triggered by our self - the heartbeat . iox_user_trigger_storage_t heartbeatStorage ; heartbeat = iox_user_trigger_init ( & heartbeatStorage ); Both subscribers use the same options which we set up with: iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 10U ; options . queueCapacity = 50U ; options . nodeName = \"iox-c-callback-subscriber-node\" ; and then we can construct the two subscribers subscriberLeft and subscriberRight . iox_sub_t subscriberLeft = iox_sub_init ( & subscriberLeftStorage , \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); iox_sub_t subscriberRight = iox_sub_init ( & subscriberRightStorage , \"Radar\" , \"FrontRight\" , \"Counter\" , & options ); Now that everything is initialized, we start our heartbeatTriggerThread which triggers our heartbeat every 4 seconds. pthread_t heartbeatTriggerThread ; if ( pthread_create ( & heartbeatTriggerThread , NULL , cyclicHeartbeatTrigger , NULL )) { printf ( \"failed to create thread \\n \" ); return -1 ; } Attaching the subscribers and the heartbeat allows the Listener to call the callbacks whenever the event is signaled by the EventOrigin . // from here on the callbacks are called when an event occurs iox_listener_attach_user_trigger_event ( listener , heartbeat , & heartbeatCallback ); iox_listener_attach_subscriber_event ( listener , subscriberLeft , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback ); iox_listener_attach_subscriber_event ( listener , subscriberRight , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback ); A user trigger can emit only one event therefore we do not provide the event type as an argument in the user trigger attach call. Since we are following a push-based approach, i.e. without an event loop that is pulling the events and processing them, we require a blocking call that waits until the process is signaled to terminate. while ( keepRunning ) { sleep_for ( 100 ); } When keepRunning is set to false, we clean up all the resources. First, we detach the events from the Listener. This is an optional step since the Listener detaches all events by itself when it is deinitialized. This applies also for all the EventOrigins , if you for instance deinitialize an attached subscriber it will automatically detach itself from the Listener. iox_listener_detach_user_trigger_event ( listener , heartbeat ); iox_listener_detach_subscriber_event ( listener , subscriberLeft , SubscriberEvent_DATA_RECEIVED ); iox_listener_detach_subscriber_event ( listener , subscriberRight , SubscriberEvent_DATA_RECEIVED ); In a last step we have to release all acquired resources iox_user_trigger_deinit ( heartbeat ); iox_sub_deinit ( subscriberLeft ); iox_sub_deinit ( subscriberRight ); iox_listener_deinit ( listener );","title":"int main()"},{"location":"examples/callbacks_in_c/#the-callbacks","text":"Every callback must have a signature like void (iox_event_origin_t) . Our heartbeatCallback just prints the message heartbeat received onto the console. void heartbeatCallback ( iox_user_trigger_t userTrigger ) { ( void ) userTrigger ; printf ( \"heartbeat received \\n \" ); fflush ( stdout ); } The onSampleReceivedCallback is a little bit more complex. First we acquire the chunk and then we have to find out which subscriber received the chunk. For that we acquire the service description of the subscriber and if its instance equals FrontLeft we store the chunk value in the leftCache otherwise in the rightCache . void onSampleReceivedCallback ( iox_sub_t subscriber ) { const struct CounterTopic * userPayload ; if ( iox_sub_take_chunk ( subscriber , ( const void ** ) & userPayload ) == ChunkReceiveResult_SUCCESS ) { iox_service_description_t serviceDescription = iox_sub_get_service_description ( subscriber ); if ( strcmp ( serviceDescription . instanceString , \"FrontLeft\" ) == 0 ) { leftCache . value = * userPayload ; leftCache . isSet = true ; } else if ( strcmp ( serviceDescription . instanceString , \"FrontRight\" ) == 0 ) { rightCache . value = * userPayload ; rightCache . isSet = true ; } printf ( \"received: %d \\n \" , userPayload -> counter ); fflush ( stdout ); } // ... } If both caches are set, we can calculate the sum of both chunks and print them to the console. To start fresh in the next cycle, we reset the leftCache and the rightCache afterward. void onSampleReceivedCallback ( iox_sub_t subscriber ) { // ... if ( leftCache . isSet && rightCache . isSet ) { printf ( \"Received samples from FrontLeft and FrontRight. Sum of %d + %d = %d \\n \" , leftCache . value . counter , rightCache . value . counter , leftCache . value . counter + rightCache . value . counter ); fflush ( stdout ); leftCache . isSet = false ; rightCache . isSet = false ; } }","title":"The callbacks"},{"location":"examples/callbacks_in_c/#additional-context-data-for-callbacks-ice_c_callbacks_with_context_datac","text":"Sometimes we would like to modify data structures which are not globally available within the callback. To facilitate this we provide the functions called iox_listener_attach_***_event_with_context_data which allow to provide an additional void pointer for the callback as second argument. The following example is a simplified version of the ice_c_callbacks_subscriber.c example where we removed the cyclic heartbeat trigger. The key difference is that we have a local variable called counterService in which we store the leftCache and rightCache and we let the callback update that variable directly. CounterService counterService ; counterService . leftCache . isSet = false ; counterService . rightCache . isSet = false ; The callback takes an additional void pointer argument which we cast then to our CounterService to perform the same tasks as in the previous example but now on CounterService * self . void onSampleReceivedCallback ( iox_sub_t subscriber , void * contextData ) { if ( contextData == NULL ) { fprintf ( stderr , \"aborting onSampleReceivedCallback since contextData is a null pointer \\n \" ); return ; } CounterService * self = ( CounterService * ) contextData ; // ... } Finally, we have to attach both subscribers and provide the pointer to counterService as additional argument so that we can access it in the callback. Attention The user has to ensure that the contextData ( &counterService ) in iox_listener_attach_subscriber_event_with_context_data lives as long as the attachment with its callback is attached, otherwise the callback context data pointer is dangling. iox_listener_attach_subscriber_event_with_context_data ( listener , subscriberLeft , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback , & counterService ); iox_listener_attach_subscriber_event_with_context_data ( listener , subscriberRight , SubscriberEvent_DATA_RECEIVED , & onSampleReceivedCallback , & counterService ); Check out callbacks_in_c on GitHub","title":"Additional context data for callbacks (ice_c_callbacks_with_context_data.c)"},{"location":"examples/complexdata/","text":"complexdata \ud83d\udd17 Introduction \ud83d\udd17 To implement zero-copy data transfer we use a shared memory approach. This requires that every data structure needs to be entirely contained in the shared memory and must not internally use pointers or references. The complete list of restrictions can be found here . Therefore, most of the STL types cannot be used, but we reimplemented some constructs . This example shows how to send/receive a iox::cxx::vector and how to send/receive a complex data structure containing some of our STL container surrogates. Expected Output \ud83d\udd17 Code Walkthrough \ud83d\udd17 The following examples demonstrate how to send/receive the STL containers that were reimplemented in iceoryx so that they meet our requirements. Publisher application sending a iox::cxx::vector \ud83d\udd17 In this example we want our publisher to send a vector containing double. Since we cannot use dynamic memory, we use the iox::cxx::vector with a capacity of 5. iox :: popo :: Publisher < iox :: cxx :: vector < double , 5 >> publisher ({ \"Radar\" , \"FrontRight\" , \"VectorData\" }); We use a while-loop similar to the one described in the icedelivery example to send the vector to the subscriber. After successfully loaning memory we append elements to the vector until it's full. for ( uint64_t i = 0U ; i < sample -> capacity (); ++ i ) { // we can omit the check of the return value since the loop doesn't exceed the capacity of the // vector sample -> emplace_back ( static_cast < double > ( ct + i )); } The only difference here to the std::vector is that emplace_back returns a bool - true if the appending was successful, false otherwise. emplace_back fails when the vector is already full. In our case, we can omit the check of the return value since the for-loop doesn't exceed the capacity of the vector. Subscriber application receiving a iox::cxx::vector \ud83d\udd17 Our subscriber application iterates over the received vector to print its entries to the console. Note that the separator is only used for a easy to read output. for ( const auto & entry : * sample ) { s << separator << entry ; separator = \", \" ; } Publisher application sending a complex data structure \ud83d\udd17 In this example our publisher will send a more complex data structure. It contains some of the STL containers that are reimplemented in iceoryx. A list of all reimplemented containers can be found here . struct ComplexDataType { forward_list < string < 10 > , 5 > stringForwardList ; list < uint64_t , 10 > integerList ; list < optional < int32_t > , 15 > optionalList ; stack < float , 5 > floatStack ; string < 20 > someString ; vector < double , 5 > doubleVector ; vector < variant < string < 10 > , double > , 10 > variantVector ; }; Contrary to the STL containers, the iceoryx containers have a static size, i.e. you have to provide the capacity (= max. size). We use again a while-loop to loan memory, add data to our containers and send it to the subscriber. Since we must not throw exceptions all used insertion methods return a bool that indicates whether the insertion was successful. It will fail when a container is already full. To handle the return value we introduce a helper function. void handleInsertionReturnVal ( const bool success ) { if ( ! success ) { std :: cerr << \"Failed to insert element.\" << std :: endl ; std :: exit ( EXIT_FAILURE ); } } Now let's add some data to our containers. For the lists we use the push_front methods which can be used similar to the corresponding STL methods. // forward_list<string<10>, 5> handleInsertionReturnVal ( sample -> stringForwardList . push_front ( \"world\" )); handleInsertionReturnVal ( sample -> stringForwardList . push_front ( \"hello\" )); // list<uint64_t, 10>; handleInsertionReturnVal ( sample -> integerList . push_front ( ct )); handleInsertionReturnVal ( sample -> integerList . push_front ( ct * 2 )); handleInsertionReturnVal ( sample -> integerList . push_front ( ct + 4 )); // list<optional<int32_t>, 15> handleInsertionReturnVal ( sample -> optionalList . push_front ( 42 )); handleInsertionReturnVal ( sample -> optionalList . push_front ( nullopt )); Note If you're not familiar with optional , please have a look at How optional and error values are returned in iceoryx . Now we fill the stack for ( uint64_t i = 0U ; i < sample -> floatStack . capacity (); ++ i ) { handleInsertionReturnVal ( sample -> floatStack . push ( static_cast < float > ( ct * i ))); } and assign a greeting to the string. sample -> someString = \"hello iceoryx\" ; For the vectors we use the emplace_back method, which can be used similar to the corresponding std::vector method. for ( uint64_t i = 0U ; i < sample -> doubleVector . capacity (); ++ i ) { handleInsertionReturnVal ( sample -> doubleVector . emplace_back ( static_cast < double > ( ct + i ))); } // vector<variant<string<10>, double>, 10>; handleInsertionReturnVal ( sample -> variantVector . emplace_back ( in_place_index < 0 > (), \"seven\" )); handleInsertionReturnVal ( sample -> variantVector . emplace_back ( in_place_index < 1 > (), 8.0 )); handleInsertionReturnVal ( sample -> variantVector . emplace_back ( in_place_index < 0 > (), \"nine\" )); With in_place_index the passed object is constructed in-place at the given index. Subscriber application receiving a complex data structure \ud83d\udd17 The subscriber application just prints the received data to the console. For the optionalList we have to check whether the optional contains a value. As in the first example, the separator is used for a clear output. for ( const auto & entry : sample -> optionalList ) { ( entry . has_value ()) ? s << separator << entry . value () : s << separator << \"optional is empty\" ; separator = \", \" ; } To print the elements of the floatStack , we pop elements until the stack is empty. auto stackCopy = sample -> floatStack ; while ( stackCopy . size () > 0U ) { auto result = stackCopy . pop (); s << separator << result . value (); separator = \", \" ; } Please note that pop returns a iox::cxx::optional which contains the last pushed element or a nullopt if the stack is empty. Here, we don't have to check whether the optional contains a value since the loop ensures that we only pop elements when the stack contains some. To print the elements of the variantVector we iterate over the vector entries and access the alternative that is held by the variant via its index. We use the not STL compliant get_at_index method which returns a pointer to the type stored at the index. If the variant does not contain any type, index() will return an INVALID_VARIANT_INDEX . for ( const auto & i : sample -> variantVector ) { switch ( i . index ()) { case 0 : s << separator << * i . template get_at_index < 0 > (); break ; case 1 : s << separator << * i . template get_at_index < 1 > (); break ; case INVALID_VARIANT_INDEX : s << separator << \"variant does not contain a type\" ; break ; default : s << separator << \"this is a new type\" ; } separator = \", \" ; } Check out complexdata on GitHub","title":"Sending/receiving some of the iceoryx STL container surrogates"},{"location":"examples/complexdata/#complexdata","text":"","title":"complexdata"},{"location":"examples/complexdata/#introduction","text":"To implement zero-copy data transfer we use a shared memory approach. This requires that every data structure needs to be entirely contained in the shared memory and must not internally use pointers or references. The complete list of restrictions can be found here . Therefore, most of the STL types cannot be used, but we reimplemented some constructs . This example shows how to send/receive a iox::cxx::vector and how to send/receive a complex data structure containing some of our STL container surrogates.","title":"Introduction"},{"location":"examples/complexdata/#expected-output","text":"","title":"Expected Output"},{"location":"examples/complexdata/#code-walkthrough","text":"The following examples demonstrate how to send/receive the STL containers that were reimplemented in iceoryx so that they meet our requirements.","title":"Code Walkthrough"},{"location":"examples/complexdata/#publisher-application-sending-a-ioxcxxvector","text":"In this example we want our publisher to send a vector containing double. Since we cannot use dynamic memory, we use the iox::cxx::vector with a capacity of 5. iox :: popo :: Publisher < iox :: cxx :: vector < double , 5 >> publisher ({ \"Radar\" , \"FrontRight\" , \"VectorData\" }); We use a while-loop similar to the one described in the icedelivery example to send the vector to the subscriber. After successfully loaning memory we append elements to the vector until it's full. for ( uint64_t i = 0U ; i < sample -> capacity (); ++ i ) { // we can omit the check of the return value since the loop doesn't exceed the capacity of the // vector sample -> emplace_back ( static_cast < double > ( ct + i )); } The only difference here to the std::vector is that emplace_back returns a bool - true if the appending was successful, false otherwise. emplace_back fails when the vector is already full. In our case, we can omit the check of the return value since the for-loop doesn't exceed the capacity of the vector.","title":"Publisher application sending a iox::cxx::vector"},{"location":"examples/complexdata/#subscriber-application-receiving-a-ioxcxxvector","text":"Our subscriber application iterates over the received vector to print its entries to the console. Note that the separator is only used for a easy to read output. for ( const auto & entry : * sample ) { s << separator << entry ; separator = \", \" ; }","title":"Subscriber application receiving a iox::cxx::vector"},{"location":"examples/complexdata/#publisher-application-sending-a-complex-data-structure","text":"In this example our publisher will send a more complex data structure. It contains some of the STL containers that are reimplemented in iceoryx. A list of all reimplemented containers can be found here . struct ComplexDataType { forward_list < string < 10 > , 5 > stringForwardList ; list < uint64_t , 10 > integerList ; list < optional < int32_t > , 15 > optionalList ; stack < float , 5 > floatStack ; string < 20 > someString ; vector < double , 5 > doubleVector ; vector < variant < string < 10 > , double > , 10 > variantVector ; }; Contrary to the STL containers, the iceoryx containers have a static size, i.e. you have to provide the capacity (= max. size). We use again a while-loop to loan memory, add data to our containers and send it to the subscriber. Since we must not throw exceptions all used insertion methods return a bool that indicates whether the insertion was successful. It will fail when a container is already full. To handle the return value we introduce a helper function. void handleInsertionReturnVal ( const bool success ) { if ( ! success ) { std :: cerr << \"Failed to insert element.\" << std :: endl ; std :: exit ( EXIT_FAILURE ); } } Now let's add some data to our containers. For the lists we use the push_front methods which can be used similar to the corresponding STL methods. // forward_list<string<10>, 5> handleInsertionReturnVal ( sample -> stringForwardList . push_front ( \"world\" )); handleInsertionReturnVal ( sample -> stringForwardList . push_front ( \"hello\" )); // list<uint64_t, 10>; handleInsertionReturnVal ( sample -> integerList . push_front ( ct )); handleInsertionReturnVal ( sample -> integerList . push_front ( ct * 2 )); handleInsertionReturnVal ( sample -> integerList . push_front ( ct + 4 )); // list<optional<int32_t>, 15> handleInsertionReturnVal ( sample -> optionalList . push_front ( 42 )); handleInsertionReturnVal ( sample -> optionalList . push_front ( nullopt )); Note If you're not familiar with optional , please have a look at How optional and error values are returned in iceoryx . Now we fill the stack for ( uint64_t i = 0U ; i < sample -> floatStack . capacity (); ++ i ) { handleInsertionReturnVal ( sample -> floatStack . push ( static_cast < float > ( ct * i ))); } and assign a greeting to the string. sample -> someString = \"hello iceoryx\" ; For the vectors we use the emplace_back method, which can be used similar to the corresponding std::vector method. for ( uint64_t i = 0U ; i < sample -> doubleVector . capacity (); ++ i ) { handleInsertionReturnVal ( sample -> doubleVector . emplace_back ( static_cast < double > ( ct + i ))); } // vector<variant<string<10>, double>, 10>; handleInsertionReturnVal ( sample -> variantVector . emplace_back ( in_place_index < 0 > (), \"seven\" )); handleInsertionReturnVal ( sample -> variantVector . emplace_back ( in_place_index < 1 > (), 8.0 )); handleInsertionReturnVal ( sample -> variantVector . emplace_back ( in_place_index < 0 > (), \"nine\" )); With in_place_index the passed object is constructed in-place at the given index.","title":"Publisher application sending a complex data structure"},{"location":"examples/complexdata/#subscriber-application-receiving-a-complex-data-structure","text":"The subscriber application just prints the received data to the console. For the optionalList we have to check whether the optional contains a value. As in the first example, the separator is used for a clear output. for ( const auto & entry : sample -> optionalList ) { ( entry . has_value ()) ? s << separator << entry . value () : s << separator << \"optional is empty\" ; separator = \", \" ; } To print the elements of the floatStack , we pop elements until the stack is empty. auto stackCopy = sample -> floatStack ; while ( stackCopy . size () > 0U ) { auto result = stackCopy . pop (); s << separator << result . value (); separator = \", \" ; } Please note that pop returns a iox::cxx::optional which contains the last pushed element or a nullopt if the stack is empty. Here, we don't have to check whether the optional contains a value since the loop ensures that we only pop elements when the stack contains some. To print the elements of the variantVector we iterate over the vector entries and access the alternative that is held by the variant via its index. We use the not STL compliant get_at_index method which returns a pointer to the type stored at the index. If the variant does not contain any type, index() will return an INVALID_VARIANT_INDEX . for ( const auto & i : sample -> variantVector ) { switch ( i . index ()) { case 0 : s << separator << * i . template get_at_index < 0 > (); break ; case 1 : s << separator << * i . template get_at_index < 1 > (); break ; case INVALID_VARIANT_INDEX : s << separator << \"variant does not contain a type\" ; break ; default : s << separator << \"this is a new type\" ; } separator = \", \" ; } Check out complexdata on GitHub","title":"Subscriber application receiving a complex data structure"},{"location":"examples/ice_access_control/","text":"ice_access_control \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates how access rights can be applied to shared memory segments on Linux-based operating systems. It provides a custom RouDi, a radar and a display application. Hint The access right feature is only supported on Linux and QNX Expected output \ud83d\udd17 Code walkthrough \ud83d\udd17 RouDi needs to be able to send a SIGKILL signal to the apps in case RouDi shuts down. Hence, RouDi needs CAP_KILL capability or similar rights on other POSIX operating systems. However, the user roudi does not need root access rights. The system user can be member of multiple system groups. This examples uses the following users and groups: Users privileged group unprivileged group infotainment group iceoryx group perception X X infotainment X X X roudi X notallowed X Hint In order to be able to use iceoryx communication, all apps have to be in the group iceoryx . Overview over the Apps and Shared Memory Segments \ud83d\udd17 RouDi is built with two shared memory segments infotainment and privileged . On startup, it creates these two shared memory segments in the operating system. The privileged segment requires the app to be started with the group privileged if it publishes data or with the unprivileged group when data should only be received. The infotainment segment on the other hand requires only one group for reading and writing called infotainment . See the next chapter for a detailed description on how to configure the shared memory segments. +-----------------------+ +--------------------+ | | +---------------------+ | Radar App | | Privileged Shared | | Cheeky App | | user: perception | | Memory Segment | | user: notallowed | | | publish | | | # # | | # | -------> | r group: unprivileged | | # # | | # | | w group: privileged | | # # | | # | | | | # # | | # # | | | | # # | | # # | | | | # # | +--------------------+ | | +---------------------+ +-----------------------+ | | subscribe +---------------------------+ | | | \\ / +-----------------------+ | | +---------------------+ | Infotainment Shared | | Display App | | Memory Segment | publish | user: infotainment | | | <------ | | | r group: infotainment | | # | | w group: infotainment | | # | | | | # | | | | # # | | | | # # | | | +---------------------+ +-----------------------+ RouDi and Apps \ud83d\udd17 Working setup \ud83d\udd17 Do the following to configure shared memory segments when building a custom RouDi: iox :: RouDiConfig_t roudiConfig ; // Create Mempool Config iox :: mepoo :: MePooConfig mepooConfig ; // We only send very small data, just one mempool per segment mepooConfig . addMemPool ({ 128 , 1000 }); // Create an entry for a new shared memory segment from the mempooConfig and add it to the roudiConfig // Parameters are {\"ReaderGroup\", \"WriterGroup\", MemoryPoolConfig} roudiConfig . m_sharedMemorySegments . push_back ({ \"unprivileged\" , \"privileged\" , mepooConfig }); roudiConfig . m_sharedMemorySegments . push_back ({ \"infotainment\" , \"infotainment\" , mepooConfig }); The roudiConfig is composed of a memory pool config called mepooConfig . When the segment is created, one needs to specify the reader group (first string), writer group (second string) as well as the mepooConfig (last parameter). The access rights are solely based on user groups and not on users itself. All users in the reader group are allowed to read, but don't have write access. Users in the writer group have both read and write access. Tip Shared memory segment can also be configured via a TOML config file. The radar app is started with the user perception , which is in the group privileged . Therefore it has write access to the privileged segment and is sending data into the privileged shared memory segment. The display app is started with the user infotainment , which is in the group infotainment and unprivileged . Therefore it has read access to the privileged segment. It reads the topic {\"Radar\", \"FrontLeft\", \"Object\"} from the privileged segment and forwards it as a slighty modified topic {\"Radar\", \"HMI-Display\", \"Object\"} . Because the user infotainment is only in the infotainment and unprivileged group, it only has write access to the infotainment segment. Hence, the data is written to this segment. Hint It's advised to create only one shared memory segment per writer group (e.g. not two segments with w: infotainment ). In this case it wouldn't be possible to control which segment will be used. The shared memory segments can be found under /dev/shm moss@reynholm:$ getfacl /dev/shm/* # file: dev/shm/iceoryx_mgmt # owner: roudi # group: iceoryx user::rw- group::rw- other::--- # file: dev/shm/infotainment # owner: roudi # group: iceoryx user::rw- group::rw- group:infotainment:rw- mask::rw- other::--- # file: dev/shm/privileged # owner: roudi # group: iceoryx user::rw- group::rw- group:privileged:rw- group:unprivileged:r-- mask::rw- other::-- Note Note the shared memory managment segment ( iceoryx_mgmt ) is always available for everyone in the group iceoryx to read and write . Not-working setup \ud83d\udd17 The cheeky app is started with the user notallowed . This user is not in any group that allow either read or write access to any of the shared memory segments. Hence, RouDi will print a warning in this case. Despite having no read access, subscribers can still be created. iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); When creating and requesting a publisher, RouDi will answer with an error, as there is no write access. Hence, an error will be printed and the cheeky app will stop. iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Check out ice_access_control on GitHub","title":"Configuring access rights for shared memory segments"},{"location":"examples/ice_access_control/#ice_access_control","text":"","title":"ice_access_control"},{"location":"examples/ice_access_control/#introduction","text":"This example demonstrates how access rights can be applied to shared memory segments on Linux-based operating systems. It provides a custom RouDi, a radar and a display application. Hint The access right feature is only supported on Linux and QNX","title":"Introduction"},{"location":"examples/ice_access_control/#expected-output","text":"","title":"Expected output"},{"location":"examples/ice_access_control/#code-walkthrough","text":"RouDi needs to be able to send a SIGKILL signal to the apps in case RouDi shuts down. Hence, RouDi needs CAP_KILL capability or similar rights on other POSIX operating systems. However, the user roudi does not need root access rights. The system user can be member of multiple system groups. This examples uses the following users and groups: Users privileged group unprivileged group infotainment group iceoryx group perception X X infotainment X X X roudi X notallowed X Hint In order to be able to use iceoryx communication, all apps have to be in the group iceoryx .","title":"Code walkthrough"},{"location":"examples/ice_access_control/#overview-over-the-apps-and-shared-memory-segments","text":"RouDi is built with two shared memory segments infotainment and privileged . On startup, it creates these two shared memory segments in the operating system. The privileged segment requires the app to be started with the group privileged if it publishes data or with the unprivileged group when data should only be received. The infotainment segment on the other hand requires only one group for reading and writing called infotainment . See the next chapter for a detailed description on how to configure the shared memory segments. +-----------------------+ +--------------------+ | | +---------------------+ | Radar App | | Privileged Shared | | Cheeky App | | user: perception | | Memory Segment | | user: notallowed | | | publish | | | # # | | # | -------> | r group: unprivileged | | # # | | # | | w group: privileged | | # # | | # | | | | # # | | # # | | | | # # | | # # | | | | # # | +--------------------+ | | +---------------------+ +-----------------------+ | | subscribe +---------------------------+ | | | \\ / +-----------------------+ | | +---------------------+ | Infotainment Shared | | Display App | | Memory Segment | publish | user: infotainment | | | <------ | | | r group: infotainment | | # | | w group: infotainment | | # | | | | # | | | | # # | | | | # # | | | +---------------------+ +-----------------------+","title":"Overview over the Apps and Shared Memory Segments"},{"location":"examples/ice_access_control/#roudi-and-apps","text":"","title":"RouDi and Apps"},{"location":"examples/ice_access_control/#working-setup","text":"Do the following to configure shared memory segments when building a custom RouDi: iox :: RouDiConfig_t roudiConfig ; // Create Mempool Config iox :: mepoo :: MePooConfig mepooConfig ; // We only send very small data, just one mempool per segment mepooConfig . addMemPool ({ 128 , 1000 }); // Create an entry for a new shared memory segment from the mempooConfig and add it to the roudiConfig // Parameters are {\"ReaderGroup\", \"WriterGroup\", MemoryPoolConfig} roudiConfig . m_sharedMemorySegments . push_back ({ \"unprivileged\" , \"privileged\" , mepooConfig }); roudiConfig . m_sharedMemorySegments . push_back ({ \"infotainment\" , \"infotainment\" , mepooConfig }); The roudiConfig is composed of a memory pool config called mepooConfig . When the segment is created, one needs to specify the reader group (first string), writer group (second string) as well as the mepooConfig (last parameter). The access rights are solely based on user groups and not on users itself. All users in the reader group are allowed to read, but don't have write access. Users in the writer group have both read and write access. Tip Shared memory segment can also be configured via a TOML config file. The radar app is started with the user perception , which is in the group privileged . Therefore it has write access to the privileged segment and is sending data into the privileged shared memory segment. The display app is started with the user infotainment , which is in the group infotainment and unprivileged . Therefore it has read access to the privileged segment. It reads the topic {\"Radar\", \"FrontLeft\", \"Object\"} from the privileged segment and forwards it as a slighty modified topic {\"Radar\", \"HMI-Display\", \"Object\"} . Because the user infotainment is only in the infotainment and unprivileged group, it only has write access to the infotainment segment. Hence, the data is written to this segment. Hint It's advised to create only one shared memory segment per writer group (e.g. not two segments with w: infotainment ). In this case it wouldn't be possible to control which segment will be used. The shared memory segments can be found under /dev/shm moss@reynholm:$ getfacl /dev/shm/* # file: dev/shm/iceoryx_mgmt # owner: roudi # group: iceoryx user::rw- group::rw- other::--- # file: dev/shm/infotainment # owner: roudi # group: iceoryx user::rw- group::rw- group:infotainment:rw- mask::rw- other::--- # file: dev/shm/privileged # owner: roudi # group: iceoryx user::rw- group::rw- group:privileged:rw- group:unprivileged:r-- mask::rw- other::-- Note Note the shared memory managment segment ( iceoryx_mgmt ) is always available for everyone in the group iceoryx to read and write .","title":"Working setup"},{"location":"examples/ice_access_control/#not-working-setup","text":"The cheeky app is started with the user notallowed . This user is not in any group that allow either read or write access to any of the shared memory segments. Hence, RouDi will print a warning in this case. Despite having no read access, subscribers can still be created. iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); When creating and requesting a publisher, RouDi will answer with an error, as there is no write access. Hence, an error will be printed and the cheeky app will stop. iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Check out ice_access_control on GitHub","title":"Not-working setup"},{"location":"examples/icecrystal/","text":"icecrystal \ud83d\udd17 Introduction \ud83d\udd17 This example shows you how to use the introspection for debugging purposes. With the introspection you can look into the machine room of RouDi. It shows live information about the memory usage and all registered processes. Additionally, it shows the publisher and subscriber ports that are created inside the shared memory. Expected Output \ud83d\udd17 We re-use the binaries from icedelivery . Feature walkthrough \ud83d\udd17 This example does not contain any additional code. The code of the iceoryx_introspection_client can be found under tools/introspection/ . The introspection can be started with several command line arguments. --mempool Subscribe to mempool introspection data. The memory pool view will show all available shared memory segments and their respective owner. Additionally, the maximum number of available chunks, the number of currently used chunks as well as the minimal value of free chunks are visible. This can be handy for stress tests to find out if your memory configuration is valid. --process Subscribe to process introspection data. The process view will show you the processes (incl. PID), which are currently registered with RouDi. --port Subscribe to port introspection data. The port view shows both publisher and subscriber ports that are created by RouDi in the shared memory. Their respective service description (service, instance, event) is shown to identify them uniquely. The columns Process and Node display to which process and node the ports belong. The service discovery protocol allows you to define the Propagation scope of the data. This can enable data forwarding to other machines e.g. over network or just consume them internally. --all Subscribe to all available introspection data. --all will enable all three views at once. -v, --version Display latest official iceoryx release version and exit. Make sure that the version number of the introspection exactly matches the version number of RouDi. Currently, we don't guarantee binary compatibility between different versions. With different version numbers things might break.","title":"Using the introspection client for debugging"},{"location":"examples/icecrystal/#icecrystal","text":"","title":"icecrystal"},{"location":"examples/icecrystal/#introduction","text":"This example shows you how to use the introspection for debugging purposes. With the introspection you can look into the machine room of RouDi. It shows live information about the memory usage and all registered processes. Additionally, it shows the publisher and subscriber ports that are created inside the shared memory.","title":"Introduction"},{"location":"examples/icecrystal/#expected-output","text":"We re-use the binaries from icedelivery .","title":"Expected Output"},{"location":"examples/icecrystal/#feature-walkthrough","text":"This example does not contain any additional code. The code of the iceoryx_introspection_client can be found under tools/introspection/ . The introspection can be started with several command line arguments. --mempool Subscribe to mempool introspection data. The memory pool view will show all available shared memory segments and their respective owner. Additionally, the maximum number of available chunks, the number of currently used chunks as well as the minimal value of free chunks are visible. This can be handy for stress tests to find out if your memory configuration is valid. --process Subscribe to process introspection data. The process view will show you the processes (incl. PID), which are currently registered with RouDi. --port Subscribe to port introspection data. The port view shows both publisher and subscriber ports that are created by RouDi in the shared memory. Their respective service description (service, instance, event) is shown to identify them uniquely. The columns Process and Node display to which process and node the ports belong. The service discovery protocol allows you to define the Propagation scope of the data. This can enable data forwarding to other machines e.g. over network or just consume them internally. --all Subscribe to all available introspection data. --all will enable all three views at once. -v, --version Display latest official iceoryx release version and exit. Make sure that the version number of the introspection exactly matches the version number of RouDi. Currently, we don't guarantee binary compatibility between different versions. With different version numbers things might break.","title":"Feature walkthrough"},{"location":"examples/icedelivery/","text":"icedelivery \ud83d\udd17 Introduction \ud83d\udd17 This example showcases a data transmission setup with zero-copy inter-process communication (IPC) on iceoryx. It provides publisher and subscriber applications. They come in two C++ API flavors (untyped and typed). Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 This example makes use of two kinds of API flavors. With the untyped API, you have the most flexibility. It enables you to define higher level APIs with a different look and feel on top of iceoryx, e.g. the ara::com API of AUTOSAR Adaptive or the ROS 2 API. It is not meant to be used by developers in daily life, the assumption is that there will always be a higher abstraction. A simple example how such an abstraction could look like is given in the second step with the typed example. The typed API provides type safety combined with RAII . Publisher application (untyped) \ud83d\udd17 First off, let's include the publisher, the runtime and the signal handler: #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/untyped_publisher.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" You might be wondering what the publisher application is sending? It's this struct. struct RadarObject { RadarObject () noexcept { } RadarObject ( double x , double y , double z ) noexcept : x ( x ) , y ( y ) , z ( z ) { } double x = 0.0 ; double y = 0.0 ; double z = 0.0 ; }; It is included by: #include \"topic_data.hpp\" For the communication with RouDi a runtime object is created. The parameter of the method initRuntime() contains a unique string identifier for this publisher. constexpr char APP_NAME [] = \"iox-cpp-publisher-untyped\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Now that RouDi knows our publisher application is existing, let's create a publisher instance for sending our charming struct to everyone: iox :: popo :: UntypedPublisher publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Now comes the work mode. Data needs to be created. But hang on.. we need memory first! Let's reserve a memory chunk which fits our RadarObject struct. publisher . loan ( sizeof ( RadarObject )) . and_then ([ & ]( auto & userPayload ) { // ... }) . or_else ([ & ]( auto & error ) { // ... }); The call to loan() returns a cxx::expected . By concatenating and_then and or_else branches are implicitly taken and your code becomes less error-prone compared to using if() { .. } else { .. } . Well, it's a bit of a lambda jungle. Read it like a story in a book: \"Loan memory and then if it succeeds, fill it with some data or else if it fails, handle the error\". Remember, the untyped API will always be bare-metal! Hence, the RadarObject needs to be constructed with a placement new: RadarObject * data = new ( userPayload ) RadarObject ( ct , ct , ct ); Then, we can write some values: data -> x = ct ; data -> y = ct ; data -> z = ct ; Finally, the value is made available to any subscriber with publisher . publish ( userPayload ); Incrementing the counter and sending the data happens in a loop every second until the user presses Ctrl-C . It is captured with the signal handler and stops the loop. Subscriber application (untyped) \ud83d\udd17 How can the subscriber application receive the data the publisher application just transmitted? Similar to the publisher, we include the topic data, the subscriber, the runtime as well as the signal handler header: #include \"topic_data.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/untyped_subscriber.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" To make RouDi aware of the subscriber a runtime object is created, once again with a unique identifier string: constexpr char APP_NAME [] = \"iox-cpp-subscriber-untyped\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); In the next step a subscriber object is created, matching exactly the capro::ServiceDescription that the publisher offered: iox :: popo :: UntypedSubscriber subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Again in a while-loop we do the following: while ( ! iox :: posix :: hasTerminationRequested ()) { subscriber . take () . and_then ([ & ]( const void * userPayload ) { // ... }) . or_else ([]( auto & result ) { if ( result != iox :: popo :: ChunkReceiveResult :: NO_CHUNK_AVAILABLE ) { std :: cout << \"Error receiving chunk.\" << std :: endl ; } }); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } The program execution is stopped when the user presses Ctrl-C . Let's translate it into a story again: \"Take the data and then if this succeeds, work with the sample, or else if an error other than NO_CHUNK_AVAILABLE occurred, print the string 'Error receiving chunk.'\". Of course, you don't need to take care of all cases, but we advise doing so. In the and_then case the content of the sample is printed to the command line: auto object = static_cast < const RadarObject *> ( userPayload ); std :: cout << APP_NAME << \" got value: \" << object -> x << std :: endl ; Please note the static_cast before reading out the data. It is necessary because the untyped subscriber is unaware of the type of the transmitted data. After accessing the value, the chunk of memory needs to be explicitly released by calling: // note that we explicitly have to release the sample // and afterwards the pointer access is undefined behavior subscriber . release ( userPayload ); The subscriber runs 10x times faster than the publisher, to make sure that all data samples are received. Publisher application (typed) \ud83d\udd17 The typed publisher application is an example for a high-level user API and does the same thing as the untyped publisher described before. In this summary, just the differences to the prior publisher application are described. Starting again with the includes, there is now a different one: #include \"iceoryx_posh/popo/publisher.hpp\" When it comes to the runtime, things are the same as in the untyped publisher. However, a typed publisher object is created and the transmitted data type is provided as template parameter: iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); A similar while-loop is used to send the data to the subscriber. In contrast to the untyped publisher the typed one offers three additional possibilities. #1 Loan and publish \ud83d\udd17 Usage #1 default constructs the data type in-place: // * Retrieve a typed sample from shared memory. // * Sample can be held until ready to publish. // * Data is default constructed during loan publisher . loan () . and_then ([ & ]( auto & sample ) { sample -> x = sampleValue1 ; sample -> y = sampleValue1 ; sample -> z = sampleValue1 ; sample . publish (); }) . or_else ([]( auto & error ) { // Do something with error std :: cerr << \"Unable to loan sample, error: \" << error << std :: endl ; }); #2 Loan, construct in-place and publish \ud83d\udd17 Usage #2 constructs the data type with the values provided in loan: // * Retrieve a typed sample from shared memory and construct data in-place // * Sample can be held until ready to publish. // * Data is constructed with the arguments provided. publisher . loan ( sampleValue2 , sampleValue2 , sampleValue2 ) . and_then ([]( auto & sample ) { sample . publish (); }) . or_else ([]( auto & error ) { // Do something with error std :: cerr << \"Unable to loan sample, error: \" << error << std :: endl ; }); One might wonder what the type of the variable sample is? It is iox::popo::Sample<RadarObject> . This class behaves similar to a std::unique_ptr and makes sure that the ownership handling is done automatically and memory is freed when going out of scope on subscriber side. #3 Publish by copy \ud83d\udd17 Usage #3 does a copy-and-publish in one call. This should only be used for small data types, as otherwise copies can lead to a larger runtime. // * Basic copy-and-publish. Useful for smaller data types. auto object = RadarObject ( sampleValue3 , sampleValue3 , sampleValue3 ); publisher . publishCopyOf ( object ). or_else ([]( auto & error ) { // Do something with error. std :: cerr << \"Unable to publishCopyOf, error: \" << error << std :: endl ; }); #4 Publish the result of a computation \ud83d\udd17 Usage #4 can be useful if you have a callable, e.g. a function or functor that should always be called. The callable needs to have the signature void(SampleType*, ...) . The semantics are as follows: The publisher loans a sample from shared memory and if loaning was successful the callable is called with a pointer to the SampleType as first argument. If loaning was unsuccessful, the callable is not called, but instead the or_else branch is taken. // * Provide a callable that will be used to populate the loaned sample. // * The first argument of the callable must be T* and is the location that the callable should // write its result to. publisher . publishResultOf ( getRadarObject , ct ). or_else ([]( auto & error ) { // Do something with error. std :: cerr << \"Unable to publishResultOf, error: \" << error << std :: endl ; }); publisher . publishResultOf ([ & sampleValue4 ]( RadarObject * object ) { * object = RadarObject ( sampleValue4 , sampleValue4 , sampleValue4 ); }) . or_else ([]( auto & error ) { // Do something with error. std :: cerr << \"Unable to publishResultOf, error: \" << error << std :: endl ; }); Subscriber application (typed) \ud83d\udd17 As with the typed publisher application there is a different include compared to the untyped subscriber: #include \"iceoryx_posh/popo/subscriber.hpp\" An instance of Subscriber is created: iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Everything else is nearly the same. However, there is one crucial difference which makes the Subscriber typed. Compare this line from the UntypedSubscriber . and_then ([ & ]( const void * userPayload ) { // ... }) with . and_then ([]( auto & sample ) { // ... }) In case of the typed Subscriber , auto is deduced to iox::popo::Sample<const RadarObject> . With the UntypedSubscriber the parameter is const void* as no type information is available. Check out icedelivery on GitHub","title":"Sending and receiving data using C++"},{"location":"examples/icedelivery/#icedelivery","text":"","title":"icedelivery"},{"location":"examples/icedelivery/#introduction","text":"This example showcases a data transmission setup with zero-copy inter-process communication (IPC) on iceoryx. It provides publisher and subscriber applications. They come in two C++ API flavors (untyped and typed).","title":"Introduction"},{"location":"examples/icedelivery/#expected-output","text":"","title":"Expected Output"},{"location":"examples/icedelivery/#code-walkthrough","text":"This example makes use of two kinds of API flavors. With the untyped API, you have the most flexibility. It enables you to define higher level APIs with a different look and feel on top of iceoryx, e.g. the ara::com API of AUTOSAR Adaptive or the ROS 2 API. It is not meant to be used by developers in daily life, the assumption is that there will always be a higher abstraction. A simple example how such an abstraction could look like is given in the second step with the typed example. The typed API provides type safety combined with RAII .","title":"Code walkthrough"},{"location":"examples/icedelivery/#publisher-application-untyped","text":"First off, let's include the publisher, the runtime and the signal handler: #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/untyped_publisher.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" You might be wondering what the publisher application is sending? It's this struct. struct RadarObject { RadarObject () noexcept { } RadarObject ( double x , double y , double z ) noexcept : x ( x ) , y ( y ) , z ( z ) { } double x = 0.0 ; double y = 0.0 ; double z = 0.0 ; }; It is included by: #include \"topic_data.hpp\" For the communication with RouDi a runtime object is created. The parameter of the method initRuntime() contains a unique string identifier for this publisher. constexpr char APP_NAME [] = \"iox-cpp-publisher-untyped\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Now that RouDi knows our publisher application is existing, let's create a publisher instance for sending our charming struct to everyone: iox :: popo :: UntypedPublisher publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Now comes the work mode. Data needs to be created. But hang on.. we need memory first! Let's reserve a memory chunk which fits our RadarObject struct. publisher . loan ( sizeof ( RadarObject )) . and_then ([ & ]( auto & userPayload ) { // ... }) . or_else ([ & ]( auto & error ) { // ... }); The call to loan() returns a cxx::expected . By concatenating and_then and or_else branches are implicitly taken and your code becomes less error-prone compared to using if() { .. } else { .. } . Well, it's a bit of a lambda jungle. Read it like a story in a book: \"Loan memory and then if it succeeds, fill it with some data or else if it fails, handle the error\". Remember, the untyped API will always be bare-metal! Hence, the RadarObject needs to be constructed with a placement new: RadarObject * data = new ( userPayload ) RadarObject ( ct , ct , ct ); Then, we can write some values: data -> x = ct ; data -> y = ct ; data -> z = ct ; Finally, the value is made available to any subscriber with publisher . publish ( userPayload ); Incrementing the counter and sending the data happens in a loop every second until the user presses Ctrl-C . It is captured with the signal handler and stops the loop.","title":"Publisher application (untyped)"},{"location":"examples/icedelivery/#subscriber-application-untyped","text":"How can the subscriber application receive the data the publisher application just transmitted? Similar to the publisher, we include the topic data, the subscriber, the runtime as well as the signal handler header: #include \"topic_data.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/untyped_subscriber.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" To make RouDi aware of the subscriber a runtime object is created, once again with a unique identifier string: constexpr char APP_NAME [] = \"iox-cpp-subscriber-untyped\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); In the next step a subscriber object is created, matching exactly the capro::ServiceDescription that the publisher offered: iox :: popo :: UntypedSubscriber subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Again in a while-loop we do the following: while ( ! iox :: posix :: hasTerminationRequested ()) { subscriber . take () . and_then ([ & ]( const void * userPayload ) { // ... }) . or_else ([]( auto & result ) { if ( result != iox :: popo :: ChunkReceiveResult :: NO_CHUNK_AVAILABLE ) { std :: cout << \"Error receiving chunk.\" << std :: endl ; } }); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } The program execution is stopped when the user presses Ctrl-C . Let's translate it into a story again: \"Take the data and then if this succeeds, work with the sample, or else if an error other than NO_CHUNK_AVAILABLE occurred, print the string 'Error receiving chunk.'\". Of course, you don't need to take care of all cases, but we advise doing so. In the and_then case the content of the sample is printed to the command line: auto object = static_cast < const RadarObject *> ( userPayload ); std :: cout << APP_NAME << \" got value: \" << object -> x << std :: endl ; Please note the static_cast before reading out the data. It is necessary because the untyped subscriber is unaware of the type of the transmitted data. After accessing the value, the chunk of memory needs to be explicitly released by calling: // note that we explicitly have to release the sample // and afterwards the pointer access is undefined behavior subscriber . release ( userPayload ); The subscriber runs 10x times faster than the publisher, to make sure that all data samples are received.","title":"Subscriber application (untyped)"},{"location":"examples/icedelivery/#publisher-application-typed","text":"The typed publisher application is an example for a high-level user API and does the same thing as the untyped publisher described before. In this summary, just the differences to the prior publisher application are described. Starting again with the includes, there is now a different one: #include \"iceoryx_posh/popo/publisher.hpp\" When it comes to the runtime, things are the same as in the untyped publisher. However, a typed publisher object is created and the transmitted data type is provided as template parameter: iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); A similar while-loop is used to send the data to the subscriber. In contrast to the untyped publisher the typed one offers three additional possibilities.","title":"Publisher application (typed)"},{"location":"examples/icedelivery/#1-loan-and-publish","text":"Usage #1 default constructs the data type in-place: // * Retrieve a typed sample from shared memory. // * Sample can be held until ready to publish. // * Data is default constructed during loan publisher . loan () . and_then ([ & ]( auto & sample ) { sample -> x = sampleValue1 ; sample -> y = sampleValue1 ; sample -> z = sampleValue1 ; sample . publish (); }) . or_else ([]( auto & error ) { // Do something with error std :: cerr << \"Unable to loan sample, error: \" << error << std :: endl ; });","title":"#1 Loan and publish"},{"location":"examples/icedelivery/#2-loan-construct-in-place-and-publish","text":"Usage #2 constructs the data type with the values provided in loan: // * Retrieve a typed sample from shared memory and construct data in-place // * Sample can be held until ready to publish. // * Data is constructed with the arguments provided. publisher . loan ( sampleValue2 , sampleValue2 , sampleValue2 ) . and_then ([]( auto & sample ) { sample . publish (); }) . or_else ([]( auto & error ) { // Do something with error std :: cerr << \"Unable to loan sample, error: \" << error << std :: endl ; }); One might wonder what the type of the variable sample is? It is iox::popo::Sample<RadarObject> . This class behaves similar to a std::unique_ptr and makes sure that the ownership handling is done automatically and memory is freed when going out of scope on subscriber side.","title":"#2 Loan, construct in-place and publish"},{"location":"examples/icedelivery/#3-publish-by-copy","text":"Usage #3 does a copy-and-publish in one call. This should only be used for small data types, as otherwise copies can lead to a larger runtime. // * Basic copy-and-publish. Useful for smaller data types. auto object = RadarObject ( sampleValue3 , sampleValue3 , sampleValue3 ); publisher . publishCopyOf ( object ). or_else ([]( auto & error ) { // Do something with error. std :: cerr << \"Unable to publishCopyOf, error: \" << error << std :: endl ; });","title":"#3 Publish by copy"},{"location":"examples/icedelivery/#4-publish-the-result-of-a-computation","text":"Usage #4 can be useful if you have a callable, e.g. a function or functor that should always be called. The callable needs to have the signature void(SampleType*, ...) . The semantics are as follows: The publisher loans a sample from shared memory and if loaning was successful the callable is called with a pointer to the SampleType as first argument. If loaning was unsuccessful, the callable is not called, but instead the or_else branch is taken. // * Provide a callable that will be used to populate the loaned sample. // * The first argument of the callable must be T* and is the location that the callable should // write its result to. publisher . publishResultOf ( getRadarObject , ct ). or_else ([]( auto & error ) { // Do something with error. std :: cerr << \"Unable to publishResultOf, error: \" << error << std :: endl ; }); publisher . publishResultOf ([ & sampleValue4 ]( RadarObject * object ) { * object = RadarObject ( sampleValue4 , sampleValue4 , sampleValue4 ); }) . or_else ([]( auto & error ) { // Do something with error. std :: cerr << \"Unable to publishResultOf, error: \" << error << std :: endl ; });","title":"#4 Publish the result of a computation"},{"location":"examples/icedelivery/#subscriber-application-typed","text":"As with the typed publisher application there is a different include compared to the untyped subscriber: #include \"iceoryx_posh/popo/subscriber.hpp\" An instance of Subscriber is created: iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Everything else is nearly the same. However, there is one crucial difference which makes the Subscriber typed. Compare this line from the UntypedSubscriber . and_then ([ & ]( const void * userPayload ) { // ... }) with . and_then ([]( auto & sample ) { // ... }) In case of the typed Subscriber , auto is deduced to iox::popo::Sample<const RadarObject> . With the UntypedSubscriber the parameter is const void* as no type information is available. Check out icedelivery on GitHub","title":"Subscriber application (typed)"},{"location":"examples/icedelivery_in_c/","text":"icedelivery in C \ud83d\udd17 You can find a more detailed description of the C API in the iceoryx_binding_c README.md . Introduction \ud83d\udd17 The behavior and structure is identical to the icedelivery C++ example so that we explain here only the C API differences and not the underlying mechanisms. Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 Subscriber \ud83d\udd17 As in the icedelivery C++ example , we perform the following steps: Create a runtime instance. Create a subscriber with some options. Receive data. C API: Additionally, we have to remove the previously allocated subscriber port! Let's take a look at the receiving function that comes with the ice_c_subscriber.c example. We register our process at RouDi with the name iox-c-subscriber const char APP_NAME [] = \"iox-c-subscriber\" ; iox_runtime_init ( APP_NAME ); We create a subscriber with the service description {\"Radar\", \"FrontLeft\", \"Object\" }. We also set subscriber options. The historyRequest tells the subscriber how many previously sent samples it shall request from all offered and matching publishers and the queueCapacity how many unread samples the subscriber can queue. The nodeName is the name of the node the subscriber is associated with. The subscriberStorage is the place where the subscriber is stored in memory and subscriber is actually a pointer to that location. iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 10U ; options . queueCapacity = 50U ; options . nodeName = \"iox-c-subscriber-node\" ; iox_sub_storage_t subscriberStorage ; iox_sub_t subscriber = iox_sub_init ( & subscriberStorage , \"Radar\" , \"FrontLeft\" , \"Object\" , & options ); We receive samples in a loop and print the received data on the console as long as the killswitch is not set to true by an external signal. while ( ! killswitch ) { if ( SubscribeState_SUBSCRIBED == iox_sub_get_subscription_state ( subscriber )) { const void * userPayload = NULL ; // we will receive more than one sample here since the publisher is sending a // new sample every 400 ms and we check for new samples only every second while ( ChunkReceiveResult_SUCCESS == iox_sub_take_chunk ( subscriber , & userPayload )) { const struct RadarObject * sample = ( const struct RadarObject * )( userPayload ); printf ( \"%s got value: %.0f \\n \" , APP_NAME , sample -> x ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); } printf ( \" \\n \" ); } else { printf ( \"Not subscribed! \\n \" ); } sleep_for ( 1000 ); } When using the C API we have to clean up the subscriber after its usage. iox_sub_deinit ( subscriber ); Publisher \ud83d\udd17 The publisher is implemented in a similar way like in the icedelivery C++ example : Create a runtime instance. Create a publisher with some options. Send data. C API: Additionally, we have to remove the previously allocated publisher port! Let's take a look at the sending function that comes with the ice_c_publisher.c example. We register our process at RouDi with the name iox-c-publisher const char APP_NAME [] = \"iox-c-publisher\" ; iox_runtime_init ( APP_NAME ); We create a publisher with the service description iox_pub_options_t options ; iox_pub_options_init ( & options ); options . historyCapacity = 10U ; options . nodeName = \"iox-c-publisher-node\" ; iox_pub_storage_t publisherStorage ; iox_pub_t publisher = iox_pub_init ( & publisherStorage , \"Radar\" , \"FrontLeft\" , \"Object\" , & options ); Until an external signal sets killswitch to true , we will send an incrementing number to all subscribers in every iteration and print the value of that number to the console. double ct = 0.0 ; while ( ! killswitch ) { void * userPayload = NULL ; if ( AllocationResult_SUCCESS == iox_pub_loan_chunk ( publisher , & userPayload , sizeof ( struct RadarObject ))) { struct RadarObject * sample = ( struct RadarObject * ) userPayload ; sample -> x = ct ; sample -> y = ct ; sample -> z = ct ; printf ( \"%s sent value: %.0f \\n \" , APP_NAME , ct ); fflush ( stdout ); iox_pub_publish_chunk ( publisher , userPayload ); ++ ct ; sleep_for ( 400 ); } else { printf ( \"Failed to allocate chunk!\" ); } } And we clean up our publisher port. iox_pub_deinit ( publisher ); Check out icedelivery_in_c on GitHub","title":"Sending and receiving data using C"},{"location":"examples/icedelivery_in_c/#icedelivery-in-c","text":"You can find a more detailed description of the C API in the iceoryx_binding_c README.md .","title":"icedelivery in C"},{"location":"examples/icedelivery_in_c/#introduction","text":"The behavior and structure is identical to the icedelivery C++ example so that we explain here only the C API differences and not the underlying mechanisms.","title":"Introduction"},{"location":"examples/icedelivery_in_c/#expected-output","text":"","title":"Expected Output"},{"location":"examples/icedelivery_in_c/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icedelivery_in_c/#subscriber","text":"As in the icedelivery C++ example , we perform the following steps: Create a runtime instance. Create a subscriber with some options. Receive data. C API: Additionally, we have to remove the previously allocated subscriber port! Let's take a look at the receiving function that comes with the ice_c_subscriber.c example. We register our process at RouDi with the name iox-c-subscriber const char APP_NAME [] = \"iox-c-subscriber\" ; iox_runtime_init ( APP_NAME ); We create a subscriber with the service description {\"Radar\", \"FrontLeft\", \"Object\" }. We also set subscriber options. The historyRequest tells the subscriber how many previously sent samples it shall request from all offered and matching publishers and the queueCapacity how many unread samples the subscriber can queue. The nodeName is the name of the node the subscriber is associated with. The subscriberStorage is the place where the subscriber is stored in memory and subscriber is actually a pointer to that location. iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 10U ; options . queueCapacity = 50U ; options . nodeName = \"iox-c-subscriber-node\" ; iox_sub_storage_t subscriberStorage ; iox_sub_t subscriber = iox_sub_init ( & subscriberStorage , \"Radar\" , \"FrontLeft\" , \"Object\" , & options ); We receive samples in a loop and print the received data on the console as long as the killswitch is not set to true by an external signal. while ( ! killswitch ) { if ( SubscribeState_SUBSCRIBED == iox_sub_get_subscription_state ( subscriber )) { const void * userPayload = NULL ; // we will receive more than one sample here since the publisher is sending a // new sample every 400 ms and we check for new samples only every second while ( ChunkReceiveResult_SUCCESS == iox_sub_take_chunk ( subscriber , & userPayload )) { const struct RadarObject * sample = ( const struct RadarObject * )( userPayload ); printf ( \"%s got value: %.0f \\n \" , APP_NAME , sample -> x ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); } printf ( \" \\n \" ); } else { printf ( \"Not subscribed! \\n \" ); } sleep_for ( 1000 ); } When using the C API we have to clean up the subscriber after its usage. iox_sub_deinit ( subscriber );","title":"Subscriber"},{"location":"examples/icedelivery_in_c/#publisher","text":"The publisher is implemented in a similar way like in the icedelivery C++ example : Create a runtime instance. Create a publisher with some options. Send data. C API: Additionally, we have to remove the previously allocated publisher port! Let's take a look at the sending function that comes with the ice_c_publisher.c example. We register our process at RouDi with the name iox-c-publisher const char APP_NAME [] = \"iox-c-publisher\" ; iox_runtime_init ( APP_NAME ); We create a publisher with the service description iox_pub_options_t options ; iox_pub_options_init ( & options ); options . historyCapacity = 10U ; options . nodeName = \"iox-c-publisher-node\" ; iox_pub_storage_t publisherStorage ; iox_pub_t publisher = iox_pub_init ( & publisherStorage , \"Radar\" , \"FrontLeft\" , \"Object\" , & options ); Until an external signal sets killswitch to true , we will send an incrementing number to all subscribers in every iteration and print the value of that number to the console. double ct = 0.0 ; while ( ! killswitch ) { void * userPayload = NULL ; if ( AllocationResult_SUCCESS == iox_pub_loan_chunk ( publisher , & userPayload , sizeof ( struct RadarObject ))) { struct RadarObject * sample = ( struct RadarObject * ) userPayload ; sample -> x = ct ; sample -> y = ct ; sample -> z = ct ; printf ( \"%s sent value: %.0f \\n \" , APP_NAME , ct ); fflush ( stdout ); iox_pub_publish_chunk ( publisher , userPayload ); ++ ct ; sleep_for ( 400 ); } else { printf ( \"Failed to allocate chunk!\" ); } } And we clean up our publisher port. iox_pub_deinit ( publisher ); Check out icedelivery_in_c on GitHub","title":"Publisher"},{"location":"examples/icediscovery/","text":"icediscovery \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates how to search for specific services using iceoryx's ServiceDiscovery . It provides two applications - one offering different services and one searching for these making different search queries. A service in iceoryx is defined by a ServiceDescription that represents a topic under which publisher/server and subscriber/client can exchange data. In addition the applications iox-wait-for-service and iox-discovery-monitor demonstrate how to write custom discovery functionality to wait for specific services or monitor the availability of services respectively. Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 Offer services \ud83d\udd17 We create several publishers which offer their services on construction by default. For more dynamism the cameraPublishers offer/stop their services periodically. If you want more information on how to create a publisher, have a look at the icehello , icedelivery , and iceoptions examples. Find services \ud83d\udd17 To be able to search for services, we have to create a ServiceDiscovery object: iox :: runtime :: ServiceDiscovery serviceDiscovery ; It is included via: #include \"iceoryx_posh/runtime/service_discovery.hpp\" On that object we can call the method findService which expects the three service string identifiers and a callable which will be applied to all matching services. In addition we have to specify whether we want to search for publishers ( MessagingPattern::PUB_SUB ) used in publish-subscribe communication or servers ( MessagingPattern::REQ_RES ) used in request-response communication. In this example we pass a function that prints the found services on the console: void printSearchResult ( const iox :: capro :: ServiceDescription & service ) { std :: cout << \"- \" << service << std :: endl ; } We can search for exactly matching services: serviceDiscovery . findService ( iox :: capro :: IdString_t { \"Radar\" }, iox :: capro :: IdString_t { \"FrontLeft\" }, iox :: capro :: IdString_t { \"Image\" }, printSearchResult , iox :: popo :: MessagingPattern :: PUB_SUB ); or add wildcards to our search query: serviceDiscovery . findService ( iox :: capro :: IdString_t { \"Camera\" }, iox :: capro :: Wildcard , iox :: capro :: Wildcard , printSearchResult , iox :: popo :: MessagingPattern :: PUB_SUB ); With the above findService call we look for every Camera service with any instance and any event. Since the cameraPublishers periodically offer/stop their services, you should see sometimes 5 Camera services and sometimes none. Wait for services \ud83d\udd17 Start the applications iox-wait-for-service and iox-offer-service . This can be done in any order, but for demonstration purposes iox-offer-service should be started last. iox-wait-for-service uses a customized service discovery Discovery which supports to wait for services by including #include \"discovery_blocking.hpp\" We then can use our custom discovery class // requires the runtime to be created first Discovery discovery ; which provides a function waitUntil to wait for some discovery-related search query condition. We define the search query auto query = [ & ]() { auto result = discovery . findService ( service , instance , event ); return ! result . empty (); }; This is essentially any callable with bool(void) signature, but it should depend on the discovery somehow (by capture), as it is only checked when the service availability changes in some way. Here we require some specific service to be found before we proceed. iox :: capro :: IdString_t service { \"Camera\" }; iox :: capro :: IdString_t instance { \"FrontLeft\" }; iox :: capro :: IdString_t event { \"Image\" }; Now we can wait until the service discovery changes and the service becomes available. bool serviceWasAvailable = discovery . waitUntil ( query ); This wait is blocking until the service was available. If it already is available we do not block and proceed. It is important that due to the nature of concurrent systems we cannot know that the service is still available once we return from waitUntil , as the application offering the service may have stopped doing so in the meantime. Usually we will assume that the service is available and may continue, e.g. by creating subscribers and running application specific code. We can also block until any unspecified change in the service availability occurs discovery . waitUntilChange (); This change is relative to the last findService call we issued, i.e. if something changed compared to the available services at this point, we wake up and continue. We then can check any condition we like, but usually it will be most useful to again check discovery-related conditions. Here we check whether a particular service becomes unavailable (essentially the negation of our query before) if ( discovery . findService ( service , instance , event ). empty ()) { break ; } Note that we use a customized findService version which returns a result container which can easily be build using the version which takes a function to be applied to all services in the search result. Once the service becomes unavailable, the application exits. Should the service we wait for never become available we can unblock any of the wait calls with if ( discoveryPtr ) { discoveryPtr -> unblockWait (); } Monitor service availability \ud83d\udd17 If we want to continously monitor the availability of some service or check some discovery condition we can do so by using e.g. a listener to conditionally execute callbacks . To do so, we start the applications iox-discovery-monitor and iox-offer-service (again in any order, but for demonstration purposes iox-offer-service should be started last). Again we can use a Discovery customized for this purpose by including #include \"discovery_monitor.hpp\" and creating it like so // requires the runtime to be created first Discovery discovery ; Afterwards we create a callback to be called whenever the service availability changes. auto callback = [ & ]( Discovery & discovery ) -> void { auto result = discovery . findService ( service , instance , event ); if ( ! result . empty ()) { std :: cout << APP_NAME << \" <\" << service << \", \" << instance << \", \" << event << \"> available\" << std :: endl ; } else { std :: cout << APP_NAME << \" <\" << service << \", \" << instance << \", \" << event << \"> unavailable\" << std :: endl ; } printSearchResult ( result ); }; This callback essentially checks whether a specific service is available or unavailable and generates output accordingly. Other reactions are possible as well, such as changing the processing logic of an pplication. To start the monitoring, we register the callback discovery . registerCallback ( callback ); Monitoring happens in a background thread implicitly created by the Discovery , i.e. the callback is executed in this thread. When we want to stop monitoring we have to deregister the callback discovery . deregisterCallback (); Here this is done at the very end where it is technically not required, but in a more complex application it could be done while the application is processing data. The main processing loop of the application is deliberately left empty for simplicty. Usually it would interact with the callback by e.g. changing application behavior whenever the availability of some service changes. While we only can attach one callback to the general event that the service availability changes in some way, we can generalize the mechanism here to check for multiple conditions and react to each of them by e.g. calling a specific function. These conditions would still need to be checked in the callback we defined though. Implementation of Discovery with blocking wait \ud83d\udd17 We build our custom discovery on top of the iox::runtime::ServiceDiscovery by composition. While inheritance is an option, composition has the advantage that we can use ServiceDiscovery as a singleton (to save memory) but our custom Discovery class can be fairly lightweight and does not need to be a singleton. ServiceDiscovery & serviceDiscovery () { static ServiceDiscovery instance ; return instance ; } This is useful as the ServiceDiscovery may be fairly large and in general there is no point in having multiple ServiceDiscovery objects that all have the same purpose and (if updated) same view of the available services. The key idea is to use a waitset and attach to the event that the service availability changes m_waitset . attachEvent ( * m_discovery , iox :: runtime :: ServiceDiscoveryEvent :: SERVICE_REGISTRY_CHANGED ) . or_else ( errorHandler ); Waiting for any availability change is now as simple as waiting on the waitset void Discovery::waitUntilChange () { do { auto notificationVector = m_waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( m_discovery )) { return ; } } } while ( m_blocking ); } If we want to wait for a specific condition, we can do so with template < typename Condition > bool Discovery :: waitUntil ( const Condition & condition ) { do { // 1) does the condition hold? bool result = condition (); if ( result ) { // 2) condition held and we return (without mutex to protect condition changes // there is no way to guarantee it still holds) return true ; } else { if ( ! m_blocking ) { return false ; } } // 3) condition did not hold but it may hold if we use the latest discovery data // which may have arrived in the meantime // 4) this does not wait if there is new discovery data (and hence we try again immediately) waitUntilChange (); // 5) discovery data changed, check condition again (even if unblocked) } while ( true ); return false ; } The condition needs to be evaluable to bool and takes no arguments. While this can be generalized to any variadic arguments, it is not needed as we can use capturing lambda expressions. The wait simply checks for the condition, and if true returns immediately. Otherwise it waits until the available services change using waitUntilChange before checking the condition again. It is also possible to unblock any of the waits even if nothing changes or the condition does not hold void Discovery::unblockWait () { m_blocking = false ; // could also unblock with a dedicated condition to unblock the wait but that requires more code // (additional trigger) and is not necessary if it is only supposed to happen once m_waitset . markForDestruction (); } This is can only be called once and makes all future wait calls non-blocking. It is useful to unblock any wait calls to be able to stop the application. Finally we provide a custom implementation of findService which returns a container of our choice, in this case a std::vector . ServiceContainer Discovery::findService ( const iox :: cxx :: optional < iox :: capro :: IdString_t >& service , const iox :: cxx :: optional < iox :: capro :: IdString_t >& instance , const iox :: cxx :: optional < iox :: capro :: IdString_t >& event ) { ServiceContainer result ; auto filter = [ & ]( const iox :: capro :: ServiceDescription & s ) { result . emplace_back ( s ); }; m_discovery -> findService ( service , instance , event , filter , iox :: popo :: MessagingPattern :: PUB_SUB ); return result ; } It is implemenented by using the native findService call of the ServiceDiscovery with an appropriate filter function. The benefit is that this way we can choose containers which do not necessrily reside on the stack. Implementation of Discovery monitoring \ud83d\udd17 To implement a Discovery where we actively monitor availability of services we employ a listener . Contrary to the blocking solution this does not block the user threads and executes any callback in a background thread created by the listener. The callback will be executed on any change of the available services. To register the callback we call template < typename Callback > bool Discovery :: registerCallback ( const Callback & callback ) which attaches the callback to the listener. auto invoker = iox :: popo :: createNotificationCallback ( invokeCallback , * this ); m_listener . attachEvent ( * m_discovery , iox :: runtime :: ServiceDiscoveryEvent :: SERVICE_REGISTRY_CHANGED , invoker ) . or_else ( errorHandler ); The callback is stored as a cxx::function which does not require dynamic memory (but limits the size of the stored function, which is relvant e.g. for capturing lambdas). If dynamic memory is no concern we can also use a std::function . The callback can be any callable with a (void)(discovery::Discovery&) signature. Again the callback signature can be generalized somewhat but there are constraints to use it with the listener. Since the listener can only call static or free functions, we use an additional indirection to call the actual callback void Discovery::invokeCallback ( ServiceDiscovery * , Discovery * self ) { // discarded discovery argument is required by the listener self -> m_callback ( * self ); } As soon as the callback is registered, the listener thread will invoke it on any service availability change. There is a small caveat though that while callback is called on any change, we can only access the latest discovery information by e.g. calling findService . This means all intermediate changes cannot be detected, in particular we may encounter an ABA problem of service availabilty: the service is availalable, becomes unavailable and available again in quick succession. If the callback issues a findService , it will not observe any change in this case. As one is usually mainly interested in the available services this can be considered a minor limitation. To stop monitoring changes in the availability of services we simply call void Discovery::deregisterCallback () { if ( m_callback ) { m_listener . detachEvent ( * m_discovery , iox :: runtime :: ServiceDiscoveryEvent :: SERVICE_REGISTRY_CHANGED ); } m_callback = nullptr ; } which detaches the callback from the listener. As before we built on an iox::runtime::ServiceDiscovery by composition and define a custom findService function which returns a std::vector . Check out icediscovery on GitHub","title":"Searching for currently available services using C++"},{"location":"examples/icediscovery/#icediscovery","text":"","title":"icediscovery"},{"location":"examples/icediscovery/#introduction","text":"This example demonstrates how to search for specific services using iceoryx's ServiceDiscovery . It provides two applications - one offering different services and one searching for these making different search queries. A service in iceoryx is defined by a ServiceDescription that represents a topic under which publisher/server and subscriber/client can exchange data. In addition the applications iox-wait-for-service and iox-discovery-monitor demonstrate how to write custom discovery functionality to wait for specific services or monitor the availability of services respectively.","title":"Introduction"},{"location":"examples/icediscovery/#expected-output","text":"","title":"Expected Output"},{"location":"examples/icediscovery/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icediscovery/#offer-services","text":"We create several publishers which offer their services on construction by default. For more dynamism the cameraPublishers offer/stop their services periodically. If you want more information on how to create a publisher, have a look at the icehello , icedelivery , and iceoptions examples.","title":"Offer services"},{"location":"examples/icediscovery/#find-services","text":"To be able to search for services, we have to create a ServiceDiscovery object: iox :: runtime :: ServiceDiscovery serviceDiscovery ; It is included via: #include \"iceoryx_posh/runtime/service_discovery.hpp\" On that object we can call the method findService which expects the three service string identifiers and a callable which will be applied to all matching services. In addition we have to specify whether we want to search for publishers ( MessagingPattern::PUB_SUB ) used in publish-subscribe communication or servers ( MessagingPattern::REQ_RES ) used in request-response communication. In this example we pass a function that prints the found services on the console: void printSearchResult ( const iox :: capro :: ServiceDescription & service ) { std :: cout << \"- \" << service << std :: endl ; } We can search for exactly matching services: serviceDiscovery . findService ( iox :: capro :: IdString_t { \"Radar\" }, iox :: capro :: IdString_t { \"FrontLeft\" }, iox :: capro :: IdString_t { \"Image\" }, printSearchResult , iox :: popo :: MessagingPattern :: PUB_SUB ); or add wildcards to our search query: serviceDiscovery . findService ( iox :: capro :: IdString_t { \"Camera\" }, iox :: capro :: Wildcard , iox :: capro :: Wildcard , printSearchResult , iox :: popo :: MessagingPattern :: PUB_SUB ); With the above findService call we look for every Camera service with any instance and any event. Since the cameraPublishers periodically offer/stop their services, you should see sometimes 5 Camera services and sometimes none.","title":"Find services"},{"location":"examples/icediscovery/#wait-for-services","text":"Start the applications iox-wait-for-service and iox-offer-service . This can be done in any order, but for demonstration purposes iox-offer-service should be started last. iox-wait-for-service uses a customized service discovery Discovery which supports to wait for services by including #include \"discovery_blocking.hpp\" We then can use our custom discovery class // requires the runtime to be created first Discovery discovery ; which provides a function waitUntil to wait for some discovery-related search query condition. We define the search query auto query = [ & ]() { auto result = discovery . findService ( service , instance , event ); return ! result . empty (); }; This is essentially any callable with bool(void) signature, but it should depend on the discovery somehow (by capture), as it is only checked when the service availability changes in some way. Here we require some specific service to be found before we proceed. iox :: capro :: IdString_t service { \"Camera\" }; iox :: capro :: IdString_t instance { \"FrontLeft\" }; iox :: capro :: IdString_t event { \"Image\" }; Now we can wait until the service discovery changes and the service becomes available. bool serviceWasAvailable = discovery . waitUntil ( query ); This wait is blocking until the service was available. If it already is available we do not block and proceed. It is important that due to the nature of concurrent systems we cannot know that the service is still available once we return from waitUntil , as the application offering the service may have stopped doing so in the meantime. Usually we will assume that the service is available and may continue, e.g. by creating subscribers and running application specific code. We can also block until any unspecified change in the service availability occurs discovery . waitUntilChange (); This change is relative to the last findService call we issued, i.e. if something changed compared to the available services at this point, we wake up and continue. We then can check any condition we like, but usually it will be most useful to again check discovery-related conditions. Here we check whether a particular service becomes unavailable (essentially the negation of our query before) if ( discovery . findService ( service , instance , event ). empty ()) { break ; } Note that we use a customized findService version which returns a result container which can easily be build using the version which takes a function to be applied to all services in the search result. Once the service becomes unavailable, the application exits. Should the service we wait for never become available we can unblock any of the wait calls with if ( discoveryPtr ) { discoveryPtr -> unblockWait (); }","title":"Wait for services"},{"location":"examples/icediscovery/#monitor-service-availability","text":"If we want to continously monitor the availability of some service or check some discovery condition we can do so by using e.g. a listener to conditionally execute callbacks . To do so, we start the applications iox-discovery-monitor and iox-offer-service (again in any order, but for demonstration purposes iox-offer-service should be started last). Again we can use a Discovery customized for this purpose by including #include \"discovery_monitor.hpp\" and creating it like so // requires the runtime to be created first Discovery discovery ; Afterwards we create a callback to be called whenever the service availability changes. auto callback = [ & ]( Discovery & discovery ) -> void { auto result = discovery . findService ( service , instance , event ); if ( ! result . empty ()) { std :: cout << APP_NAME << \" <\" << service << \", \" << instance << \", \" << event << \"> available\" << std :: endl ; } else { std :: cout << APP_NAME << \" <\" << service << \", \" << instance << \", \" << event << \"> unavailable\" << std :: endl ; } printSearchResult ( result ); }; This callback essentially checks whether a specific service is available or unavailable and generates output accordingly. Other reactions are possible as well, such as changing the processing logic of an pplication. To start the monitoring, we register the callback discovery . registerCallback ( callback ); Monitoring happens in a background thread implicitly created by the Discovery , i.e. the callback is executed in this thread. When we want to stop monitoring we have to deregister the callback discovery . deregisterCallback (); Here this is done at the very end where it is technically not required, but in a more complex application it could be done while the application is processing data. The main processing loop of the application is deliberately left empty for simplicty. Usually it would interact with the callback by e.g. changing application behavior whenever the availability of some service changes. While we only can attach one callback to the general event that the service availability changes in some way, we can generalize the mechanism here to check for multiple conditions and react to each of them by e.g. calling a specific function. These conditions would still need to be checked in the callback we defined though.","title":"Monitor service availability"},{"location":"examples/icediscovery/#implementation-of-discovery-with-blocking-wait","text":"We build our custom discovery on top of the iox::runtime::ServiceDiscovery by composition. While inheritance is an option, composition has the advantage that we can use ServiceDiscovery as a singleton (to save memory) but our custom Discovery class can be fairly lightweight and does not need to be a singleton. ServiceDiscovery & serviceDiscovery () { static ServiceDiscovery instance ; return instance ; } This is useful as the ServiceDiscovery may be fairly large and in general there is no point in having multiple ServiceDiscovery objects that all have the same purpose and (if updated) same view of the available services. The key idea is to use a waitset and attach to the event that the service availability changes m_waitset . attachEvent ( * m_discovery , iox :: runtime :: ServiceDiscoveryEvent :: SERVICE_REGISTRY_CHANGED ) . or_else ( errorHandler ); Waiting for any availability change is now as simple as waiting on the waitset void Discovery::waitUntilChange () { do { auto notificationVector = m_waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( m_discovery )) { return ; } } } while ( m_blocking ); } If we want to wait for a specific condition, we can do so with template < typename Condition > bool Discovery :: waitUntil ( const Condition & condition ) { do { // 1) does the condition hold? bool result = condition (); if ( result ) { // 2) condition held and we return (without mutex to protect condition changes // there is no way to guarantee it still holds) return true ; } else { if ( ! m_blocking ) { return false ; } } // 3) condition did not hold but it may hold if we use the latest discovery data // which may have arrived in the meantime // 4) this does not wait if there is new discovery data (and hence we try again immediately) waitUntilChange (); // 5) discovery data changed, check condition again (even if unblocked) } while ( true ); return false ; } The condition needs to be evaluable to bool and takes no arguments. While this can be generalized to any variadic arguments, it is not needed as we can use capturing lambda expressions. The wait simply checks for the condition, and if true returns immediately. Otherwise it waits until the available services change using waitUntilChange before checking the condition again. It is also possible to unblock any of the waits even if nothing changes or the condition does not hold void Discovery::unblockWait () { m_blocking = false ; // could also unblock with a dedicated condition to unblock the wait but that requires more code // (additional trigger) and is not necessary if it is only supposed to happen once m_waitset . markForDestruction (); } This is can only be called once and makes all future wait calls non-blocking. It is useful to unblock any wait calls to be able to stop the application. Finally we provide a custom implementation of findService which returns a container of our choice, in this case a std::vector . ServiceContainer Discovery::findService ( const iox :: cxx :: optional < iox :: capro :: IdString_t >& service , const iox :: cxx :: optional < iox :: capro :: IdString_t >& instance , const iox :: cxx :: optional < iox :: capro :: IdString_t >& event ) { ServiceContainer result ; auto filter = [ & ]( const iox :: capro :: ServiceDescription & s ) { result . emplace_back ( s ); }; m_discovery -> findService ( service , instance , event , filter , iox :: popo :: MessagingPattern :: PUB_SUB ); return result ; } It is implemenented by using the native findService call of the ServiceDiscovery with an appropriate filter function. The benefit is that this way we can choose containers which do not necessrily reside on the stack.","title":"Implementation of Discovery with blocking wait"},{"location":"examples/icediscovery/#implementation-of-discovery-monitoring","text":"To implement a Discovery where we actively monitor availability of services we employ a listener . Contrary to the blocking solution this does not block the user threads and executes any callback in a background thread created by the listener. The callback will be executed on any change of the available services. To register the callback we call template < typename Callback > bool Discovery :: registerCallback ( const Callback & callback ) which attaches the callback to the listener. auto invoker = iox :: popo :: createNotificationCallback ( invokeCallback , * this ); m_listener . attachEvent ( * m_discovery , iox :: runtime :: ServiceDiscoveryEvent :: SERVICE_REGISTRY_CHANGED , invoker ) . or_else ( errorHandler ); The callback is stored as a cxx::function which does not require dynamic memory (but limits the size of the stored function, which is relvant e.g. for capturing lambdas). If dynamic memory is no concern we can also use a std::function . The callback can be any callable with a (void)(discovery::Discovery&) signature. Again the callback signature can be generalized somewhat but there are constraints to use it with the listener. Since the listener can only call static or free functions, we use an additional indirection to call the actual callback void Discovery::invokeCallback ( ServiceDiscovery * , Discovery * self ) { // discarded discovery argument is required by the listener self -> m_callback ( * self ); } As soon as the callback is registered, the listener thread will invoke it on any service availability change. There is a small caveat though that while callback is called on any change, we can only access the latest discovery information by e.g. calling findService . This means all intermediate changes cannot be detected, in particular we may encounter an ABA problem of service availabilty: the service is availalable, becomes unavailable and available again in quick succession. If the callback issues a findService , it will not observe any change in this case. As one is usually mainly interested in the available services this can be considered a minor limitation. To stop monitoring changes in the availability of services we simply call void Discovery::deregisterCallback () { if ( m_callback ) { m_listener . detachEvent ( * m_discovery , iox :: runtime :: ServiceDiscoveryEvent :: SERVICE_REGISTRY_CHANGED ); } m_callback = nullptr ; } which detaches the callback from the listener. As before we built on an iox::runtime::ServiceDiscovery by composition and define a custom findService function which returns a std::vector . Check out icediscovery on GitHub","title":"Implementation of Discovery monitoring"},{"location":"examples/icediscovery_in_c/","text":"icediscovery in C \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates how to search for specific services using iceoryx's service discovery. It provides two applications - one offering different services and one searching for those with different search queries. The behavior and structure is quite similar to the icediscovery C++ example . Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 Offer services \ud83d\udd17 We create several publishers which offer their services on construction by default. For more dynamism the cameraPublishers offer/stop their services periodically. If you want more information on how to create publishers, have a look at the icedelivery C example . Find services \ud83d\udd17 To be able to search for services, we need to include: #include \"iceoryx_binding_c/service_discovery.h\" We create some storage for the service discovery and initialize it. iox_service_discovery_storage_t storage ; iox_service_discovery_t serviceDiscovery = iox_service_discovery_init ( & storage ); We can now call three different find service functions. Let's start with iox_service_discovery_find_service_apply_callable ( serviceDiscovery , \"Radar\" , \"FrontLeft\" , \"Image\" , printSearchResult , MessagingPattern_PUB_SUB ); which searches for all {Radar, FrontLeft, Image} services offered by publishers and applies the provided function printSearchResult on each of them. The function must have the signature void(const iox_service_description_t) . Here we pass a function that prints the found services on the console: void printSearchResult ( const iox_service_description_t service ) { printf ( \"- Service: %s, Instance: %s, Event: %s \\n \" , service . serviceString , service . instanceString , service . eventString ); } We cannot only search for exact matching services. In combination with wildcards ( NULL ) we can also search for all instances and events with the service Radar : iox_service_discovery_find_service_apply_callable ( serviceDiscovery , \"Radar\" , NULL , NULL , printSearchResult , MessagingPattern_PUB_SUB ); The wildcard can be used for all strings which describe a service, i.e. service, instance and event. Let's now search for all Camera services and store the results in an array: numberFoundServices = iox_service_discovery_find_service ( serviceDiscovery , \"Camera\" , NULL , NULL , searchResult , SEARCH_RESULT_CAPACITY , & missedServices , MessagingPattern_PUB_SUB ); searchResult is a iox_service_description_t array of size SEARCH_RESULT_CAPACITY . The matching services are written into this array, up to a maximum of SEARCH_RESULT_CAPACITY . If the number of found services exceeds the array's capacity, the number of services that could not be stored is written to missedServices . The number of stored services is returned. Since the cameraPublishers periodically offer/stop their services, you should see sometimes 5 Camera services and sometimes none. Finally, let's try out the third find service function. We search again for all Camera services but additionally count the front camera services: iox_service_discovery_find_service_apply_callable_with_context_data ( serviceDiscovery , \"Camera\" , NULL , NULL , searchFrontDevices , & numberFrontCameras , MessagingPattern_PUB_SUB ); This function is quite similar to the first find service function, but we pass an additional argument numberFrontCameras : uint32_t numberFrontCameras = 0U ; We use this variable to store the number of front cameras and provide it as second argument count to the function searchFrontDevices which is applied to all found services: void searchFrontDevices ( const iox_service_description_t service , void * count ) { if ( strncmp ( service . instanceString , \"FrontLeft\" , IOX_CONFIG_SERVICE_STRING_SIZE ) == 0 || strncmp ( service . instanceString , \"FrontRight\" , IOX_CONFIG_SERVICE_STRING_SIZE ) == 0 ) { ++* ( uint32_t * ) count ; } } Check out icediscovery on GitHub","title":"Searching for currently available services using C"},{"location":"examples/icediscovery_in_c/#icediscovery-in-c","text":"","title":"icediscovery in C"},{"location":"examples/icediscovery_in_c/#introduction","text":"This example demonstrates how to search for specific services using iceoryx's service discovery. It provides two applications - one offering different services and one searching for those with different search queries. The behavior and structure is quite similar to the icediscovery C++ example .","title":"Introduction"},{"location":"examples/icediscovery_in_c/#expected-output","text":"","title":"Expected Output"},{"location":"examples/icediscovery_in_c/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icediscovery_in_c/#offer-services","text":"We create several publishers which offer their services on construction by default. For more dynamism the cameraPublishers offer/stop their services periodically. If you want more information on how to create publishers, have a look at the icedelivery C example .","title":"Offer services"},{"location":"examples/icediscovery_in_c/#find-services","text":"To be able to search for services, we need to include: #include \"iceoryx_binding_c/service_discovery.h\" We create some storage for the service discovery and initialize it. iox_service_discovery_storage_t storage ; iox_service_discovery_t serviceDiscovery = iox_service_discovery_init ( & storage ); We can now call three different find service functions. Let's start with iox_service_discovery_find_service_apply_callable ( serviceDiscovery , \"Radar\" , \"FrontLeft\" , \"Image\" , printSearchResult , MessagingPattern_PUB_SUB ); which searches for all {Radar, FrontLeft, Image} services offered by publishers and applies the provided function printSearchResult on each of them. The function must have the signature void(const iox_service_description_t) . Here we pass a function that prints the found services on the console: void printSearchResult ( const iox_service_description_t service ) { printf ( \"- Service: %s, Instance: %s, Event: %s \\n \" , service . serviceString , service . instanceString , service . eventString ); } We cannot only search for exact matching services. In combination with wildcards ( NULL ) we can also search for all instances and events with the service Radar : iox_service_discovery_find_service_apply_callable ( serviceDiscovery , \"Radar\" , NULL , NULL , printSearchResult , MessagingPattern_PUB_SUB ); The wildcard can be used for all strings which describe a service, i.e. service, instance and event. Let's now search for all Camera services and store the results in an array: numberFoundServices = iox_service_discovery_find_service ( serviceDiscovery , \"Camera\" , NULL , NULL , searchResult , SEARCH_RESULT_CAPACITY , & missedServices , MessagingPattern_PUB_SUB ); searchResult is a iox_service_description_t array of size SEARCH_RESULT_CAPACITY . The matching services are written into this array, up to a maximum of SEARCH_RESULT_CAPACITY . If the number of found services exceeds the array's capacity, the number of services that could not be stored is written to missedServices . The number of stored services is returned. Since the cameraPublishers periodically offer/stop their services, you should see sometimes 5 Camera services and sometimes none. Finally, let's try out the third find service function. We search again for all Camera services but additionally count the front camera services: iox_service_discovery_find_service_apply_callable_with_context_data ( serviceDiscovery , \"Camera\" , NULL , NULL , searchFrontDevices , & numberFrontCameras , MessagingPattern_PUB_SUB ); This function is quite similar to the first find service function, but we pass an additional argument numberFrontCameras : uint32_t numberFrontCameras = 0U ; We use this variable to store the number of front cameras and provide it as second argument count to the function searchFrontDevices which is applied to all found services: void searchFrontDevices ( const iox_service_description_t service , void * count ) { if ( strncmp ( service . instanceString , \"FrontLeft\" , IOX_CONFIG_SERVICE_STRING_SIZE ) == 0 || strncmp ( service . instanceString , \"FrontRight\" , IOX_CONFIG_SERVICE_STRING_SIZE ) == 0 ) { ++* ( uint32_t * ) count ; } } Check out icediscovery on GitHub","title":"Find services"},{"location":"examples/icedocker/","text":"Use Iceoryx In A Docker Environment \ud83d\udd17 Introduction \ud83d\udd17 Let's assume we are working on a system in which iox-roudi runs in a docker environment and it should orchestrate two applications which are running again in two different docker containers so that we end up with a system of 3 different docker containers. To demonstrate the setup we use the icedelivery C++ example . +-----------+ | docker 1 | | | | iox-roudi | +-----------+ +-------------------+ +--------------------+ | docker 2 | send | docker 3 | | |------->| | | iox-cpp-publisher | data | iox-cpp-subscriber | +-------------------+ +--------------------+ Requirements \ud83d\udd17 Shared Access to Unix Domain Sockets \ud83d\udd17 Every iceoryx application registers itself at our central broker RouDi by sending a message to the unix domain socket located at IOX_UDS_SOCKET_PATH_PREFIX/roudi which is defined in the corresponding platform settings file platform_settings.hpp . In linux the socket file handle can be found at /tmp/roudi . When the application registers at RouDi it announces its unix domain socket as well to receive responses of requests which will be sent during runtime to RouDi. This socket is stored as well in /tmp/IOX_RUNTIME_NAME . The iox-cpp-publisher runtime has the same name as the binary which leads to the socket /tmp/iox-cpp-publisher . Shared Access to File Locks \ud83d\udd17 Iceoryx applications ensure that every runtime name is unique in the system by creating a file lock before creating the runtime. This is stored in IOX_LOCK_FILE_PATH_PREFIX/IOX_RUNTIME_NAME.lock whereby IOX_LOCK_FILE_PATH_PREFIX is defined in the platform settings file platform_settings.hpp . When running the icedelivery example in a linux environment one can observe the lock files /tmp/roudi.lock , /tmp/iox-cpp-subscriber.lock and /tmp/iox-cpp-publisher.lock . Shared Access to Semaphores and Shared Memory \ud83d\udd17 One of the tasks of the central broker RouDi is to create and distribute shared memory. When the iox-cpp-publisher would like to send data it acquires a pointer to this shared memory, writes the data into it and sends the pointer to the iox-cpp-subscriber which reads the memory at the received memory position. Additionally, it is possible to signal events across process boundaries via semaphores. For instance to signal a subscriber that data has arrived. Implementation \ud83d\udd17 To have shared access to the required resources we have to bind the host filesystem: /tmp /dev into every docker container. Terminal Example \ud83d\udd17 We start in 3 separate terminals 3 docker instances. In this example we use archlinux:latest but one is free to choose any other linux distribution. The iceoryx repository which contains an already built iceoryx can be found at /home/user/iceoryx which is bound to /iceoryx . The usage is explained in detail in the icedelivery C++ example . Terminal 1 (iox-roudi) \ud83d\udd17 docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest cd /iceoryx ./build/iox-roudi Terminal 2 (iox-cpp-publisher) \ud83d\udd17 docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest cd /iceoryx ./build/iceoryx_examples/icedelivery/iox-cpp-publisher Terminal 3 (iox-cpp-subscriber) \ud83d\udd17 docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest cd /iceoryx ./build/iceoryx_examples/icedelivery/iox-cpp-subscriber docker-compose Example \ud83d\udd17 We can also use docker-compose to start our test setup. Our example is coming with a configuration file docker-compose.yml which can be used from the iceoryx root path with the following command: docker-compose -f iceoryx_examples/icedocker/docker-compose.yml --project-directory . up We have to set the project directory explicitly so that the mapping of the iceoryx root path is working as intended.","title":"Sending and receiving data across multiple docker instances"},{"location":"examples/icedocker/#use-iceoryx-in-a-docker-environment","text":"","title":"Use Iceoryx In A Docker Environment"},{"location":"examples/icedocker/#introduction","text":"Let's assume we are working on a system in which iox-roudi runs in a docker environment and it should orchestrate two applications which are running again in two different docker containers so that we end up with a system of 3 different docker containers. To demonstrate the setup we use the icedelivery C++ example . +-----------+ | docker 1 | | | | iox-roudi | +-----------+ +-------------------+ +--------------------+ | docker 2 | send | docker 3 | | |------->| | | iox-cpp-publisher | data | iox-cpp-subscriber | +-------------------+ +--------------------+","title":"Introduction"},{"location":"examples/icedocker/#requirements","text":"","title":"Requirements"},{"location":"examples/icedocker/#shared-access-to-unix-domain-sockets","text":"Every iceoryx application registers itself at our central broker RouDi by sending a message to the unix domain socket located at IOX_UDS_SOCKET_PATH_PREFIX/roudi which is defined in the corresponding platform settings file platform_settings.hpp . In linux the socket file handle can be found at /tmp/roudi . When the application registers at RouDi it announces its unix domain socket as well to receive responses of requests which will be sent during runtime to RouDi. This socket is stored as well in /tmp/IOX_RUNTIME_NAME . The iox-cpp-publisher runtime has the same name as the binary which leads to the socket /tmp/iox-cpp-publisher .","title":"Shared Access to Unix Domain Sockets"},{"location":"examples/icedocker/#shared-access-to-file-locks","text":"Iceoryx applications ensure that every runtime name is unique in the system by creating a file lock before creating the runtime. This is stored in IOX_LOCK_FILE_PATH_PREFIX/IOX_RUNTIME_NAME.lock whereby IOX_LOCK_FILE_PATH_PREFIX is defined in the platform settings file platform_settings.hpp . When running the icedelivery example in a linux environment one can observe the lock files /tmp/roudi.lock , /tmp/iox-cpp-subscriber.lock and /tmp/iox-cpp-publisher.lock .","title":"Shared Access to File Locks"},{"location":"examples/icedocker/#shared-access-to-semaphores-and-shared-memory","text":"One of the tasks of the central broker RouDi is to create and distribute shared memory. When the iox-cpp-publisher would like to send data it acquires a pointer to this shared memory, writes the data into it and sends the pointer to the iox-cpp-subscriber which reads the memory at the received memory position. Additionally, it is possible to signal events across process boundaries via semaphores. For instance to signal a subscriber that data has arrived.","title":"Shared Access to Semaphores and Shared Memory"},{"location":"examples/icedocker/#implementation","text":"To have shared access to the required resources we have to bind the host filesystem: /tmp /dev into every docker container.","title":"Implementation"},{"location":"examples/icedocker/#terminal-example","text":"We start in 3 separate terminals 3 docker instances. In this example we use archlinux:latest but one is free to choose any other linux distribution. The iceoryx repository which contains an already built iceoryx can be found at /home/user/iceoryx which is bound to /iceoryx . The usage is explained in detail in the icedelivery C++ example .","title":"Terminal Example"},{"location":"examples/icedocker/#terminal-1-iox-roudi","text":"docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest cd /iceoryx ./build/iox-roudi","title":"Terminal 1 (iox-roudi)"},{"location":"examples/icedocker/#terminal-2-iox-cpp-publisher","text":"docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest cd /iceoryx ./build/iceoryx_examples/icedelivery/iox-cpp-publisher","title":"Terminal 2 (iox-cpp-publisher)"},{"location":"examples/icedocker/#terminal-3-iox-cpp-subscriber","text":"docker run --mount type=bind,source=\"/dev\",target=/dev --mount type=bind,source=/home/user/iceoryx,target=/iceoryx --mount type=bind,source=/tmp,target=/tmp -it archlinux:latest cd /iceoryx ./build/iceoryx_examples/icedelivery/iox-cpp-subscriber","title":"Terminal 3 (iox-cpp-subscriber)"},{"location":"examples/icedocker/#docker-compose-example","text":"We can also use docker-compose to start our test setup. Our example is coming with a configuration file docker-compose.yml which can be used from the iceoryx root path with the following command: docker-compose -f iceoryx_examples/icedocker/docker-compose.yml --project-directory . up We have to set the project directory explicitly so that the mapping of the iceoryx root path is working as intended.","title":"docker-compose Example"},{"location":"examples/iceensemble/","text":"iceensemble \ud83d\udd17 Introduction \ud83d\udd17 A common use case is that multiple sensors are sending data of the same type, e.g. LIDAR data, and a subscriber is interested in the data of all those sensors. This example demonstrates how you can run multiple publisher applications publishing on the same topic (n:m communication) how to communicate between C and C++ Info The default communication policy is many to many. If you have built iceoryx with the CMake flag -DONE_TO_MANY_ONLY this example will not run. Run iceensemble \ud83d\udd17 The easiest way is to build all examples via ./tools/iceoryx_build_test.sh . Then, create eight terminals and run one command in each of them. ./build/iox-roudi ./build/iceoryx_examples/icehello/iox-cpp-publisher-helloworld ./build/iceoryx_examples/icedelivery/iox-cpp-publisher ./build/iceoryx_examples/icedelivery/iox-cpp-publisher-untyped ./build/iceoryx_examples/iceoptions/iox-cpp-publisher-with-options ./build/iceoryx_examples/icedelivery_in_c/iox-c-publisher ./build/iceoryx_examples/icedelivery/iox-cpp-subscriber ./build/iceoryx_examples/iceoptions/iox-subscriber-with-options Alternatively, you can use the provided tmux script. ./iceoryx_examples/iceensemble/run_iceensemble.sh Info As iox-subscriber-with-options requests the blocking publisher feature, although having the same capro::ServiceDescription {\"Radar\", \"FrontLeft\", \"Object\"} it is only connected to iox-publisher-with-options Expected Output \ud83d\udd17 Check out iceensemble on GitHub","title":"Using multiple publishers for one topic"},{"location":"examples/iceensemble/#iceensemble","text":"","title":"iceensemble"},{"location":"examples/iceensemble/#introduction","text":"A common use case is that multiple sensors are sending data of the same type, e.g. LIDAR data, and a subscriber is interested in the data of all those sensors. This example demonstrates how you can run multiple publisher applications publishing on the same topic (n:m communication) how to communicate between C and C++ Info The default communication policy is many to many. If you have built iceoryx with the CMake flag -DONE_TO_MANY_ONLY this example will not run.","title":"Introduction"},{"location":"examples/iceensemble/#run-iceensemble","text":"The easiest way is to build all examples via ./tools/iceoryx_build_test.sh . Then, create eight terminals and run one command in each of them. ./build/iox-roudi ./build/iceoryx_examples/icehello/iox-cpp-publisher-helloworld ./build/iceoryx_examples/icedelivery/iox-cpp-publisher ./build/iceoryx_examples/icedelivery/iox-cpp-publisher-untyped ./build/iceoryx_examples/iceoptions/iox-cpp-publisher-with-options ./build/iceoryx_examples/icedelivery_in_c/iox-c-publisher ./build/iceoryx_examples/icedelivery/iox-cpp-subscriber ./build/iceoryx_examples/iceoptions/iox-subscriber-with-options Alternatively, you can use the provided tmux script. ./iceoryx_examples/iceensemble/run_iceensemble.sh Info As iox-subscriber-with-options requests the blocking publisher feature, although having the same capro::ServiceDescription {\"Radar\", \"FrontLeft\", \"Object\"} it is only connected to iox-publisher-with-options","title":"Run iceensemble"},{"location":"examples/iceensemble/#expected-output","text":"Check out iceensemble on GitHub","title":"Expected Output"},{"location":"examples/icehello/","text":"icehello \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates a basic data transmission with zero-copy inter-process communication (IPC). It provides a publisher and a subscriber application. Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 Publisher \ud83d\udd17 At first, we need to define what kind of data type the publisher and subscriber application will exchange: struct RadarObject { double x = 0.0 ; double y = 0.0 ; double z = 0.0 ; }; It is included via: #include \"topic_data.hpp\" Next, we include the publisher and the runtime: #include \"iceoryx_posh/popo/publisher.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" We create a runtime object to communicate with the RouDi daemon. We use a unique string for identifying our application: constexpr char APP_NAME [] = \"iox-cpp-publisher-helloworld\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Now we create a publisher instance for our charming struct. Notice that the topic type is passed as a template parameter: iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); The three strings which are passed as parameter to the constructor of iox::popo::Publisher define our capro::ServiceDescription . capro stands for ca nionical pro tocol and is used to abstract different SoA protocols. Radar is the service name, FrontLeft an instance of the service Radar and the third string the specific event Object of the instance. In iceoryx, a publisher and a subscriber are connected only if all three IDs match. For exiting on Ctrl+C, we use the SignalWatcher #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" and loop in our while loop until it states that SIGINT or SIGTERM was sent via the function hasTerminationRequested . while ( ! iox :: posix :: hasTerminationRequested ()) In order to send our sample, we loan some shared memory inside the while loop: auto loanResult = publisher . loan (); If loaning was successful, we assign the incremented counter to all three values in RadarObject and publish() to the subscriber application: if ( ! loanResult . has_error ()) { auto & sample = loanResult . value (); // Sample can be held until ready to publish sample -> x = ct ; sample -> y = ct ; sample -> z = ct ; sample . publish (); } In case an error occurred during loaning, we need to handle it: else { auto error = loanResult . get_error (); // Do something with error std :: cerr << \"Unable to loan sample, error code: \" << error << std :: endl ; } Topics are printed and published every second: std :: cout << APP_NAME << \" sent value: \" << ct << std :: endl ; std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); Subscriber \ud83d\udd17 The subscriber needs to have similar includes, but unlike the publisher subscriber.hpp is included: #include \"topic_data.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/subscriber.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" As well as the publisher, the subscriber needs to register with the daemon RouDi: constexpr char APP_NAME [] = \"iox-cpp-subscriber-helloworld\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Next, the subscriber object is created, again passing the topic type RadarObject as template parameter: iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Publisher and subscriber will only be connected if they both use exactly these same three strings, our capro::ServiceDescription . Inside the while loop, we take the sample from shared memory and print it if we acquired it successfully. auto takeResult = subscriber . take (); if ( ! takeResult . has_error ()) { std :: cout << APP_NAME << \" got value: \" << takeResult . value () -> x << std :: endl ; } In case an error occurred during taking, we need to handle it: if ( takeResult . get_error () == iox :: popo :: ChunkReceiveResult :: NO_CHUNK_AVAILABLE ) { std :: cout << \"No chunk available.\" << std :: endl ; } else { std :: cout << \"Error receiving chunk.\" << std :: endl ; } The subscriber application polls for the sample ten times faster than the publisher is sending it. Therefore no samples should be missed, but not every time the subscriber tries to take a sample, it will get some. In this case, we print \"No chunk available.\". std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); Increasing the polling rate is just one approach for reliable communication. iceoptions explains how to configure the history size of a subscriber. In the WaitSet example you learn how to avoid polling altogether. Check out icehello on GitHub","title":"Sending data to another process"},{"location":"examples/icehello/#icehello","text":"","title":"icehello"},{"location":"examples/icehello/#introduction","text":"This example demonstrates a basic data transmission with zero-copy inter-process communication (IPC). It provides a publisher and a subscriber application.","title":"Introduction"},{"location":"examples/icehello/#expected-output","text":"","title":"Expected Output"},{"location":"examples/icehello/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/icehello/#publisher","text":"At first, we need to define what kind of data type the publisher and subscriber application will exchange: struct RadarObject { double x = 0.0 ; double y = 0.0 ; double z = 0.0 ; }; It is included via: #include \"topic_data.hpp\" Next, we include the publisher and the runtime: #include \"iceoryx_posh/popo/publisher.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" We create a runtime object to communicate with the RouDi daemon. We use a unique string for identifying our application: constexpr char APP_NAME [] = \"iox-cpp-publisher-helloworld\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Now we create a publisher instance for our charming struct. Notice that the topic type is passed as a template parameter: iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); The three strings which are passed as parameter to the constructor of iox::popo::Publisher define our capro::ServiceDescription . capro stands for ca nionical pro tocol and is used to abstract different SoA protocols. Radar is the service name, FrontLeft an instance of the service Radar and the third string the specific event Object of the instance. In iceoryx, a publisher and a subscriber are connected only if all three IDs match. For exiting on Ctrl+C, we use the SignalWatcher #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" and loop in our while loop until it states that SIGINT or SIGTERM was sent via the function hasTerminationRequested . while ( ! iox :: posix :: hasTerminationRequested ()) In order to send our sample, we loan some shared memory inside the while loop: auto loanResult = publisher . loan (); If loaning was successful, we assign the incremented counter to all three values in RadarObject and publish() to the subscriber application: if ( ! loanResult . has_error ()) { auto & sample = loanResult . value (); // Sample can be held until ready to publish sample -> x = ct ; sample -> y = ct ; sample -> z = ct ; sample . publish (); } In case an error occurred during loaning, we need to handle it: else { auto error = loanResult . get_error (); // Do something with error std :: cerr << \"Unable to loan sample, error code: \" << error << std :: endl ; } Topics are printed and published every second: std :: cout << APP_NAME << \" sent value: \" << ct << std :: endl ; std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 ));","title":"Publisher"},{"location":"examples/icehello/#subscriber","text":"The subscriber needs to have similar includes, but unlike the publisher subscriber.hpp is included: #include \"topic_data.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/subscriber.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" As well as the publisher, the subscriber needs to register with the daemon RouDi: constexpr char APP_NAME [] = \"iox-cpp-subscriber-helloworld\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Next, the subscriber object is created, again passing the topic type RadarObject as template parameter: iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }); Publisher and subscriber will only be connected if they both use exactly these same three strings, our capro::ServiceDescription . Inside the while loop, we take the sample from shared memory and print it if we acquired it successfully. auto takeResult = subscriber . take (); if ( ! takeResult . has_error ()) { std :: cout << APP_NAME << \" got value: \" << takeResult . value () -> x << std :: endl ; } In case an error occurred during taking, we need to handle it: if ( takeResult . get_error () == iox :: popo :: ChunkReceiveResult :: NO_CHUNK_AVAILABLE ) { std :: cout << \"No chunk available.\" << std :: endl ; } else { std :: cout << \"Error receiving chunk.\" << std :: endl ; } The subscriber application polls for the sample ten times faster than the publisher is sending it. Therefore no samples should be missed, but not every time the subscriber tries to take a sample, it will get some. In this case, we print \"No chunk available.\". std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); Increasing the polling rate is just one approach for reliable communication. iceoptions explains how to configure the history size of a subscriber. In the WaitSet example you learn how to avoid polling altogether. Check out icehello on GitHub","title":"Subscriber"},{"location":"examples/iceoptions/","text":"iceoptions \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates what kind of quality of service options can be configured on the publisher and subscriber side. The options can be used for the typed and untyped C++ API flavors as well as the C API. Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 Info This example describes a single publisher scenario. Publisher \ud83d\udd17 In order to configure a publisher, we have to supply a struct of the type iox::popo::PublisherOptions as a second parameter. iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }, publisherOptions ); historyCapacity will enable subscribers to read the last n samples e.g. in case they are started later than the publisher: publisherOptions . historyCapacity = 10U ; Topics are automatically offered on creation of a publisher, if you want to disable that feature and control the offering yourself, do: publisherOptions . offerOnCreate = false ; Due to the disabled offerOnCreate feature, don't forget to offer our topic: publisher . offer (); To organize publishers inside an application, they can be associated and grouped by providing a node name. Some frameworks call nodes runnables . publisherOptions . nodeName = \"Pub_Node_With_Options\" ; To ensure that samples are never lost, you have the possibility to busy-wait for the subscriber when publishing. Both publisher and subscriber have to request compatible policies ( ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER and QueueFullPolicy::BLOCK_PRODUCER ). publisherOptions . subscriberTooSlowPolicy = iox :: popo :: ConsumerTooSlowPolicy :: WAIT_FOR_CONSUMER ; With this option set, it is possible that a slow subscriber blocks a publisher indefinitely due to the busy waiting loop. In order to be able to gracefully shut down the application with Ctrl+C , the publisher needs to be unblocked. To achieve this, we publish the data in a background thread so that we can initiate the shutdown of the runtime: iox :: runtime :: PoshRuntime :: getInstance (). shutdown (); Subscriber \ud83d\udd17 To configure a subscriber, we have to supply a struct of the type iox::popo::SubscriberOptions as a second parameter. iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }, subscriberOptions ); The queueCapacity parameter specifies how many samples the queue of the subscriber object can hold. If the queue would encounter an overflow, the oldest sample is released to create space for the newest one, which is then stored. The queue behaves like a circular buffer. subscriberOptions . queueCapacity = 10U ; historyRequest will enable a subscriber to receive the last n samples of matching publishers on subscription e.g. in case it was started later than the publisher. If the publisher does not have a sufficient historyCapacity (smaller than historyRequest ), it will still be connected but we will not be able to receive the requested amount of historical data (if it was available). Instead we will receive the largest amount of historical sample the publisher has available, i.e. best-effort. In particular we will be connected to a publisher with historyCapacity = 0. If we want to enforce the contract that the publisher needs to support a historyCapacity , we can do so by setting requirePublisherHistorySupport to true . In this case, the subscriber will only connect if the publisher history support is at least 1, i.e. historyCapacity > 0. By default this is set to false and best-effort behavior is used. Warning In case of n:m communication, the history feature will not provide the overall last n samples based on delivery point in time! For more information about this limitation see the QoS article . subscriberOptions . historyRequest = 5U ; subscriberOptions . requiresPublisherHistorySupport = false ; Topics are automatically subscribed on creation. If you want to disable that feature and control the subscription yourself, set subscribeOnCreate appropriately: subscriberOptions . subscribeOnCreate = false ; Due to the disabled subscribeOnCreate feature, don't forget to subscribe to our topic: subscriber . subscribe (); Again, for organising subscribers inside an application, a nodeName can be applied: subscriberOptions . nodeName = \"Sub_Node_With_Options\" ; To ensure that samples are never lost, we request the publisher to busy-wait, in case of a full queue: subscriberOptions . queueFullPolicy = iox :: popo :: QueueFullPolicy :: BLOCK_PRODUCER ; Check out iceoptions on GitHub","title":"Configuring pub/sub settings like history cache size or startup behaviour"},{"location":"examples/iceoptions/#iceoptions","text":"","title":"iceoptions"},{"location":"examples/iceoptions/#introduction","text":"This example demonstrates what kind of quality of service options can be configured on the publisher and subscriber side. The options can be used for the typed and untyped C++ API flavors as well as the C API.","title":"Introduction"},{"location":"examples/iceoptions/#expected-output","text":"","title":"Expected Output"},{"location":"examples/iceoptions/#code-walkthrough","text":"Info This example describes a single publisher scenario.","title":"Code walkthrough"},{"location":"examples/iceoptions/#publisher","text":"In order to configure a publisher, we have to supply a struct of the type iox::popo::PublisherOptions as a second parameter. iox :: popo :: Publisher < RadarObject > publisher ({ \"Radar\" , \"FrontLeft\" , \"Object\" }, publisherOptions ); historyCapacity will enable subscribers to read the last n samples e.g. in case they are started later than the publisher: publisherOptions . historyCapacity = 10U ; Topics are automatically offered on creation of a publisher, if you want to disable that feature and control the offering yourself, do: publisherOptions . offerOnCreate = false ; Due to the disabled offerOnCreate feature, don't forget to offer our topic: publisher . offer (); To organize publishers inside an application, they can be associated and grouped by providing a node name. Some frameworks call nodes runnables . publisherOptions . nodeName = \"Pub_Node_With_Options\" ; To ensure that samples are never lost, you have the possibility to busy-wait for the subscriber when publishing. Both publisher and subscriber have to request compatible policies ( ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER and QueueFullPolicy::BLOCK_PRODUCER ). publisherOptions . subscriberTooSlowPolicy = iox :: popo :: ConsumerTooSlowPolicy :: WAIT_FOR_CONSUMER ; With this option set, it is possible that a slow subscriber blocks a publisher indefinitely due to the busy waiting loop. In order to be able to gracefully shut down the application with Ctrl+C , the publisher needs to be unblocked. To achieve this, we publish the data in a background thread so that we can initiate the shutdown of the runtime: iox :: runtime :: PoshRuntime :: getInstance (). shutdown ();","title":"Publisher"},{"location":"examples/iceoptions/#subscriber","text":"To configure a subscriber, we have to supply a struct of the type iox::popo::SubscriberOptions as a second parameter. iox :: popo :: Subscriber < RadarObject > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Object\" }, subscriberOptions ); The queueCapacity parameter specifies how many samples the queue of the subscriber object can hold. If the queue would encounter an overflow, the oldest sample is released to create space for the newest one, which is then stored. The queue behaves like a circular buffer. subscriberOptions . queueCapacity = 10U ; historyRequest will enable a subscriber to receive the last n samples of matching publishers on subscription e.g. in case it was started later than the publisher. If the publisher does not have a sufficient historyCapacity (smaller than historyRequest ), it will still be connected but we will not be able to receive the requested amount of historical data (if it was available). Instead we will receive the largest amount of historical sample the publisher has available, i.e. best-effort. In particular we will be connected to a publisher with historyCapacity = 0. If we want to enforce the contract that the publisher needs to support a historyCapacity , we can do so by setting requirePublisherHistorySupport to true . In this case, the subscriber will only connect if the publisher history support is at least 1, i.e. historyCapacity > 0. By default this is set to false and best-effort behavior is used. Warning In case of n:m communication, the history feature will not provide the overall last n samples based on delivery point in time! For more information about this limitation see the QoS article . subscriberOptions . historyRequest = 5U ; subscriberOptions . requiresPublisherHistorySupport = false ; Topics are automatically subscribed on creation. If you want to disable that feature and control the subscription yourself, set subscribeOnCreate appropriately: subscriberOptions . subscribeOnCreate = false ; Due to the disabled subscribeOnCreate feature, don't forget to subscribe to our topic: subscriber . subscribe (); Again, for organising subscribers inside an application, a nodeName can be applied: subscriberOptions . nodeName = \"Sub_Node_With_Options\" ; To ensure that samples are never lost, we request the publisher to busy-wait, in case of a full queue: subscriberOptions . queueFullPolicy = iox :: popo :: QueueFullPolicy :: BLOCK_PRODUCER ; Check out iceoptions on GitHub","title":"Subscriber"},{"location":"examples/iceperf/","text":"iceperf \ud83d\udd17 Introduction \ud83d\udd17 Note Since not all IPC mechanisms are supported on all platforms the IPC benchmark only runs fully on QNX and Linux. The iceoryx C or C++ API related benchmark is supported on all platforms. This example measures the latency of IPC transmissions between two applications. We compare the latency of iceoryx with message queues and unix domain sockets. The measurement is carried out with several payload sizes. Round trips are performed for each payload size, using either the default setting or the provided command line parameter for the number of round trips to do. The time measurement only considers the time to allocate/release memory and the time to send the data. The construction and initialization of the payload is not part of the measurement. At the end of the benchmark, the average latency for each payload size is printed. Run iceperf \ud83d\udd17 Create three terminals and run one command in each of them. In this setup the leader is doing the ping pong measurements with the follower. You can set the number of measurement iterations (number of round trips) with a command line parameter of iceperf-bench-leader (e.g. ./iceperf-bench-leader -n 100000 ). There are further options which can be printed by calling ./iceperf-bench-leader -h . # If installed and available in PATH environment variable iox-roudi # If build from scratch with script in tools $ICEORYX_ROOT /build/install/prefix/bin/iox-roudi build/iceoryx_examples/iceperf/iceperf-bench-follower build/iceoryx_examples/iceperf/iceperf-bench-leader If you would like to test only the C++ API or the C API you can start iceperf-bench-leader with the parameter -t iceoryx-cpp-api or -t iceoryx-c-api . build/iceoryx_examples/iceperf/iceperf-bench-follower build/iceoryx_examples/iceperf/iceperf-bench-leader -n 100000 -t iceoryx-cpp-api Expected Output \ud83d\udd17 The measured transmission modes depend on the operating system (e.g. no message queue on MacOS). The measurements depend on the benchmark parameters and the hardware. The following shows an example output with Ubuntu 18.04 on Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz. iceperf-bench-leader Application \ud83d\udd17 ****** MESSAGE QUEUE ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 3.1 | | 2 | 3.2 | | 4 | 3.8 | | 8 | 5.2 | | 16 | 7.7 | | 32 | 13 | | 64 | 23 | | 128 | 43 | | 256 | 81 | | 512 | 1.6e+02 | | 1024 | 3e+02 | | 2048 | 5.9e+02 | | 4096 | 1.2e+03 | Finished! ****** UNIX DOMAIN SOCKET ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 4.3 | | 2 | 4.3 | | 4 | 4.6 | | 8 | 6 | | 16 | 8.7 | | 32 | 14 | | 64 | 27 | | 128 | 53 | | 256 | 1.1e+02 | | 512 | 2.1e+02 | | 1024 | 4.2e+02 | | 2048 | 8.4e+02 | | 4096 | 1.7e+03 | Finished! ****** ICEORYX ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 0.73 | | 2 | 0.58 | | 4 | 0.61 | | 8 | 0.61 | | 16 | 0.59 | | 32 | 0.62 | | 64 | 0.6 | | 128 | 0.58 | | 256 | 0.61 | | 512 | 0.61 | | 1024 | 0.58 | | 2048 | 0.61 | | 4096 | 0.61 | Finished! ****** ICEORYX C API ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 0.73 | | 2 | 0.58 | | 4 | 0.61 | | 8 | 0.61 | | 16 | 0.59 | | 32 | 0.62 | | 64 | 0.6 | | 128 | 0.58 | | 256 | 0.61 | | 512 | 0.61 | | 1024 | 0.58 | | 2048 | 0.61 | | 4096 | 0.61 | Finished! iceperf-bench-follower Application \ud83d\udd17 ****** MESSAGE QUEUE ******** registering with the leader ****** UNIX DOMAIN SOCKET ******** registering with the leader ****** ICEORYX ******** Waiting for: subscription, subscriber [ success ] Waiting for: unsubscribe [ finished ] ****** ICEORYX C API ******** Waiting for: subscription, subscriber [ success ] Waiting for: unsubscribe [ finished ] Code Walkthrough \ud83d\udd17 Here we briefly describe the setup for performing the measurements in iceperf_bench_leader.hpp/cpp and iceperf_bench_follower.hpp/cpp . Things like initialization, sending and receiving of data are technology specific and can be found in the respective files (e.g. uds.cpp for unix domain socket). Our focus here is on the top-most abstraction layer which allows us to add new IPC technologies to extend and compare them. iceperf-bench-leader Application Code \ud83d\udd17 Apart from headers for the different IPC technologies, the topic_data.hpp file is included which contains the PerSettings and PerTopic structs. These are used to transfer some information between the applications. The PerTopic struct is used as some kind of header in each transferred sample and is independent of the payload size. struct PerfSettings { Benchmark benchmark { Benchmark :: ALL }; Technology technology { Technology :: ALL }; uint64_t numberOfSamples { 10000U }; }; struct PerfTopic { uint32_t payloadSize { 0 }; uint32_t subPackets { 0 }; RunFlag runFlag { RunFlag :: RUN }; }; The PerfSettings struct is used to synchronize the settings between the leader and the follower application. The PerfTopic struct is used to share some information during the measurement. It contains payloadSize to specify the payload size used for the current measurement. If it is not possible to transmit the payloadSize with a single data transfer (e.g. OS limit for the payload of a single socket send), the payload is divided into several sub-packets. This is indicated with subPackets . The runFlag is used to shut down the iceperf-bench follower at the end of the benchmark. Let's use some constants to prevent magic values and set and names for the communication resources that are used. constexpr const char APP_NAME []{ \"iceperf-bench-leader\" }; constexpr const char PUBLISHER []{ \"Leader\" }; constexpr const char SUBSCRIBER []{ \"Follower\" }; The IcePerfLeader c'tor does a cleanup of potentially outdated resources of technologies which might have left some resources in the file system after an abnormal terminations. #ifndef __APPLE__ MQ :: cleanupOutdatedResources ( PUBLISHER , SUBSCRIBER ); #endif UDS :: cleanupOutdatedResources ( PUBLISHER , SUBSCRIBER ); The doMeasurement() method executes a measurement for the provided IPC technology and number of round trips. To be able to always perform the same steps and avoiding code duplications, we use a base class with technology independent functionality and the technology has to implement the technology dependent part. void IcePerfLeader::doMeasurement ( IcePerfBase & ipcTechnology ) noexcept { ipcTechnology . initLeader (); std :: vector < std :: tuple < uint32_t , iox :: units :: Duration >> latencyMeasurements ; const std :: vector < uint32_t > payloadSizesInKB { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 1024 , 2048 , 4096 }; std :: cout << \"Measurement for:\" ; const char * separator = \" \" ; for ( const auto payloadSizeInKB : payloadSizesInKB ) { std :: cout << separator << payloadSizeInKB << \" kB\" << std :: flush ; separator = \", \" ; auto payloadSizeInBytes = payloadSizeInKB * IcePerfBase :: ONE_KILOBYTE ; ipcTechnology . preLatencyPerfTestLeader ( payloadSizeInBytes ); auto latency = ipcTechnology . latencyPerfTestLeader ( m_settings . numberOfSamples ); latencyMeasurements . push_back ( std :: make_tuple ( payloadSizeInKB , latency )); ipcTechnology . postLatencyPerfTestLeader (); } std :: cout << std :: endl ; ipcTechnology . releaseFollower (); ipcTechnology . shutdown (); std :: cout << std :: endl ; std :: cout << \"#### Measurement Result ####\" << std :: endl ; std :: cout << m_settings . numberOfSamples << \" round trips for each payload.\" << std :: endl ; std :: cout << std :: endl ; std :: cout << \"| Payload Size [kB] | Average Latency [\u00b5s] |\" << std :: endl ; std :: cout << \"|------------------:|---------------------:|\" << std :: endl ; for ( const auto & latencyMeasuement : latencyMeasurements ) { auto payloadSizeInKB = std :: get < 0 > ( latencyMeasuement ); auto latencyInMicroseconds = static_cast < double > ( std :: get < 1 > ( latencyMeasuement ). toNanoseconds ()) / 1000.0 ; std :: cout << \"| \" << std :: setw ( 17 ) << payloadSizeInKB << \" | \" << std :: setw ( 20 ) << std :: setprecision ( 2 ) << latencyInMicroseconds << \" |\" << std :: endl ; } std :: cout << std :: endl ; std :: cout << \"Finished!\" << std :: endl ; } Initialization is different for each IPC technology. Here we have to create sockets, message queues or iceoryx publisher and subscriber. With ipcTechnology.initLeader() we set up these resources on the leader side. After the definition of the different payload sizes to use, we execute a single round trip measurement for each individual payload size. The leader has to orchestrate the whole process and has a pre- and post-step for each round trip measurement. ipcTechnology.preLatencyPerfTestLeader(...) sets the payload size for the upcoming measurement. ipcTechnology.latencyPerfTestLeader(m_settings.numberOfSamples) performs the data exchange between leader and follower and returns the time it took to transmit the number of samples in a round trip. After the measurements are taken for each payload size, ipcTechnology.releaseFollower() releases the follower. This is required since the follower is not aware of the benchmark settings, e.g. how many payload sizes are considered and hence we need to issue a shutdown. We clean up the communication resources with ipcTechnology.shutdown() before we print the results. In the run() method we create instances for the different IPC technologies we want to compare. Each technology is implemented in its own class and implements the pure virtual functions provided with the IcePerfBase class. Before this is done, we send the PerfSettings to the follower application. int IcePerfLeader::run () noexcept { iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); iox :: capro :: ServiceDescription serviceDescription { \"IcePerf\" , \"Settings\" , \"Generic\" }; iox :: popo :: PublisherOptions options ; options . historyCapacity = 1U ; iox :: popo :: Publisher < PerfSettings > settingsPublisher { serviceDescription , options }; if ( ! settingsPublisher . publishCopyOf ( m_settings )) { std :: cerr << \"Could not send settings to follower!\" << std :: endl ; return EXIT_FAILURE ; } // ... return EXIT_SUCCESS ; } Now we can create an object for each IPC technology that we want to evaluate and call the doMeasurement() method. int IcePerfLeader::run () noexcept { iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); // ... if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: POSIX_MESSAGE_QUEUE ) { #ifndef __APPLE__ std :: cout << std :: endl << \"****** MESSAGE QUEUE ********\" << std :: endl ; MQ mq ( PUBLISHER , SUBSCRIBER ); doMeasurement ( mq ); #else if ( m_settings . technology == Technology :: POSIX_MESSAGE_QUEUE ) { std :: cout << \"The message queue is not supported on macOS and will be skipped!\" << std :: endl ; } #endif } if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: UNIX_DOMAIN_SOCKET ) { std :: cout << std :: endl << \"****** UNIX DOMAIN SOCKET ********\" << std :: endl ; UDS uds ( PUBLISHER , SUBSCRIBER ); doMeasurement ( uds ); } if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: ICEORYX_CPP_API ) { std :: cout << std :: endl << \"****** ICEORYX ********\" << std :: endl ; Iceoryx iceoryx ( PUBLISHER , SUBSCRIBER ); doMeasurement ( iceoryx ); } if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: ICEORYX_C_API ) { std :: cout << std :: endl << \"****** ICEORYX C API ********\" << std :: endl ; IceoryxC iceoryxc ( PUBLISHER , SUBSCRIBER ); doMeasurement ( iceoryxc ); } return EXIT_SUCCESS ; } iceperf_bench_follower Application \ud83d\udd17 The iceperf-bench-follower application is similar to iceperf-bench-leader . The first change is that the SUBSCRIBER and PUBLISHER switch their names. constexpr const char APP_NAME []{ \"iceperf-bench-follower\" }; constexpr const char PUBLISHER []{ \"Follower\" }; constexpr const char SUBSCRIBER []{ \"Leader\" }; While the run() method of the leader publishes the PerfSettings , the follower is subscribed to those settings and waits for them before the technologies are created, which is done similarly as for the leader. int IcePerfFollower::run () noexcept { iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); iox :: capro :: ServiceDescription serviceDescription { \"IcePerf\" , \"Settings\" , \"Generic\" }; iox :: popo :: SubscriberOptions options ; options . historyRequest = 1U ; iox :: popo :: Subscriber < PerfSettings > settingsSubscriber { serviceDescription , options }; m_settings = getSettings ( settingsSubscriber ); // ... return EXIT_SUCCESS ; } The doMeasurement() method is much simpler than the one from the leader, since it only has to react on incoming data. Apart from ipcTechnology.initFollower() and ipcTechnology.shutdown() all the functionality to perform the round trip for different payload sizes is contained in ipcTechnology.latencyPerfTestFollower() void IcePerfFollower::doMeasurement ( IcePerfBase & ipcTechnology ) noexcept { ipcTechnology . initFollower (); ipcTechnology . latencyPerfTestFollower (); ipcTechnology . shutdown (); } Check out iceperf on GitHub","title":"Measuring the latency of different IPC mechanisms"},{"location":"examples/iceperf/#iceperf","text":"","title":"iceperf"},{"location":"examples/iceperf/#introduction","text":"Note Since not all IPC mechanisms are supported on all platforms the IPC benchmark only runs fully on QNX and Linux. The iceoryx C or C++ API related benchmark is supported on all platforms. This example measures the latency of IPC transmissions between two applications. We compare the latency of iceoryx with message queues and unix domain sockets. The measurement is carried out with several payload sizes. Round trips are performed for each payload size, using either the default setting or the provided command line parameter for the number of round trips to do. The time measurement only considers the time to allocate/release memory and the time to send the data. The construction and initialization of the payload is not part of the measurement. At the end of the benchmark, the average latency for each payload size is printed.","title":"Introduction"},{"location":"examples/iceperf/#run-iceperf","text":"Create three terminals and run one command in each of them. In this setup the leader is doing the ping pong measurements with the follower. You can set the number of measurement iterations (number of round trips) with a command line parameter of iceperf-bench-leader (e.g. ./iceperf-bench-leader -n 100000 ). There are further options which can be printed by calling ./iceperf-bench-leader -h . # If installed and available in PATH environment variable iox-roudi # If build from scratch with script in tools $ICEORYX_ROOT /build/install/prefix/bin/iox-roudi build/iceoryx_examples/iceperf/iceperf-bench-follower build/iceoryx_examples/iceperf/iceperf-bench-leader If you would like to test only the C++ API or the C API you can start iceperf-bench-leader with the parameter -t iceoryx-cpp-api or -t iceoryx-c-api . build/iceoryx_examples/iceperf/iceperf-bench-follower build/iceoryx_examples/iceperf/iceperf-bench-leader -n 100000 -t iceoryx-cpp-api","title":"Run iceperf"},{"location":"examples/iceperf/#expected-output","text":"The measured transmission modes depend on the operating system (e.g. no message queue on MacOS). The measurements depend on the benchmark parameters and the hardware. The following shows an example output with Ubuntu 18.04 on Intel(R) Xeon(R) CPU E3-1505M v5 @ 2.80GHz.","title":"Expected Output"},{"location":"examples/iceperf/#iceperf-bench-leader-application","text":"****** MESSAGE QUEUE ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 3.1 | | 2 | 3.2 | | 4 | 3.8 | | 8 | 5.2 | | 16 | 7.7 | | 32 | 13 | | 64 | 23 | | 128 | 43 | | 256 | 81 | | 512 | 1.6e+02 | | 1024 | 3e+02 | | 2048 | 5.9e+02 | | 4096 | 1.2e+03 | Finished! ****** UNIX DOMAIN SOCKET ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 4.3 | | 2 | 4.3 | | 4 | 4.6 | | 8 | 6 | | 16 | 8.7 | | 32 | 14 | | 64 | 27 | | 128 | 53 | | 256 | 1.1e+02 | | 512 | 2.1e+02 | | 1024 | 4.2e+02 | | 2048 | 8.4e+02 | | 4096 | 1.7e+03 | Finished! ****** ICEORYX ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 0.73 | | 2 | 0.58 | | 4 | 0.61 | | 8 | 0.61 | | 16 | 0.59 | | 32 | 0.62 | | 64 | 0.6 | | 128 | 0.58 | | 256 | 0.61 | | 512 | 0.61 | | 1024 | 0.58 | | 2048 | 0.61 | | 4096 | 0.61 | Finished! ****** ICEORYX C API ******** Waiting for: subscription, subscriber [ success ] Measurement for: 1 kB, 2 kB, 4 kB, 8 kB, 16 kB, 32 kB, 64 kB, 128 kB, 256 kB, 512 kB, 1024 kB, 2048 kB, 4096 kB Waiting for: unsubscribe [ finished ] #### Measurement Result #### 100000 round trips for each payload. | Payload Size [kB] | Average Latency [\u00b5s] | |------------------:|---------------------:| | 1 | 0.73 | | 2 | 0.58 | | 4 | 0.61 | | 8 | 0.61 | | 16 | 0.59 | | 32 | 0.62 | | 64 | 0.6 | | 128 | 0.58 | | 256 | 0.61 | | 512 | 0.61 | | 1024 | 0.58 | | 2048 | 0.61 | | 4096 | 0.61 | Finished!","title":"iceperf-bench-leader Application"},{"location":"examples/iceperf/#iceperf-bench-follower-application","text":"****** MESSAGE QUEUE ******** registering with the leader ****** UNIX DOMAIN SOCKET ******** registering with the leader ****** ICEORYX ******** Waiting for: subscription, subscriber [ success ] Waiting for: unsubscribe [ finished ] ****** ICEORYX C API ******** Waiting for: subscription, subscriber [ success ] Waiting for: unsubscribe [ finished ]","title":"iceperf-bench-follower Application"},{"location":"examples/iceperf/#code-walkthrough","text":"Here we briefly describe the setup for performing the measurements in iceperf_bench_leader.hpp/cpp and iceperf_bench_follower.hpp/cpp . Things like initialization, sending and receiving of data are technology specific and can be found in the respective files (e.g. uds.cpp for unix domain socket). Our focus here is on the top-most abstraction layer which allows us to add new IPC technologies to extend and compare them.","title":"Code Walkthrough"},{"location":"examples/iceperf/#iceperf-bench-leader-application-code","text":"Apart from headers for the different IPC technologies, the topic_data.hpp file is included which contains the PerSettings and PerTopic structs. These are used to transfer some information between the applications. The PerTopic struct is used as some kind of header in each transferred sample and is independent of the payload size. struct PerfSettings { Benchmark benchmark { Benchmark :: ALL }; Technology technology { Technology :: ALL }; uint64_t numberOfSamples { 10000U }; }; struct PerfTopic { uint32_t payloadSize { 0 }; uint32_t subPackets { 0 }; RunFlag runFlag { RunFlag :: RUN }; }; The PerfSettings struct is used to synchronize the settings between the leader and the follower application. The PerfTopic struct is used to share some information during the measurement. It contains payloadSize to specify the payload size used for the current measurement. If it is not possible to transmit the payloadSize with a single data transfer (e.g. OS limit for the payload of a single socket send), the payload is divided into several sub-packets. This is indicated with subPackets . The runFlag is used to shut down the iceperf-bench follower at the end of the benchmark. Let's use some constants to prevent magic values and set and names for the communication resources that are used. constexpr const char APP_NAME []{ \"iceperf-bench-leader\" }; constexpr const char PUBLISHER []{ \"Leader\" }; constexpr const char SUBSCRIBER []{ \"Follower\" }; The IcePerfLeader c'tor does a cleanup of potentially outdated resources of technologies which might have left some resources in the file system after an abnormal terminations. #ifndef __APPLE__ MQ :: cleanupOutdatedResources ( PUBLISHER , SUBSCRIBER ); #endif UDS :: cleanupOutdatedResources ( PUBLISHER , SUBSCRIBER ); The doMeasurement() method executes a measurement for the provided IPC technology and number of round trips. To be able to always perform the same steps and avoiding code duplications, we use a base class with technology independent functionality and the technology has to implement the technology dependent part. void IcePerfLeader::doMeasurement ( IcePerfBase & ipcTechnology ) noexcept { ipcTechnology . initLeader (); std :: vector < std :: tuple < uint32_t , iox :: units :: Duration >> latencyMeasurements ; const std :: vector < uint32_t > payloadSizesInKB { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 1024 , 2048 , 4096 }; std :: cout << \"Measurement for:\" ; const char * separator = \" \" ; for ( const auto payloadSizeInKB : payloadSizesInKB ) { std :: cout << separator << payloadSizeInKB << \" kB\" << std :: flush ; separator = \", \" ; auto payloadSizeInBytes = payloadSizeInKB * IcePerfBase :: ONE_KILOBYTE ; ipcTechnology . preLatencyPerfTestLeader ( payloadSizeInBytes ); auto latency = ipcTechnology . latencyPerfTestLeader ( m_settings . numberOfSamples ); latencyMeasurements . push_back ( std :: make_tuple ( payloadSizeInKB , latency )); ipcTechnology . postLatencyPerfTestLeader (); } std :: cout << std :: endl ; ipcTechnology . releaseFollower (); ipcTechnology . shutdown (); std :: cout << std :: endl ; std :: cout << \"#### Measurement Result ####\" << std :: endl ; std :: cout << m_settings . numberOfSamples << \" round trips for each payload.\" << std :: endl ; std :: cout << std :: endl ; std :: cout << \"| Payload Size [kB] | Average Latency [\u00b5s] |\" << std :: endl ; std :: cout << \"|------------------:|---------------------:|\" << std :: endl ; for ( const auto & latencyMeasuement : latencyMeasurements ) { auto payloadSizeInKB = std :: get < 0 > ( latencyMeasuement ); auto latencyInMicroseconds = static_cast < double > ( std :: get < 1 > ( latencyMeasuement ). toNanoseconds ()) / 1000.0 ; std :: cout << \"| \" << std :: setw ( 17 ) << payloadSizeInKB << \" | \" << std :: setw ( 20 ) << std :: setprecision ( 2 ) << latencyInMicroseconds << \" |\" << std :: endl ; } std :: cout << std :: endl ; std :: cout << \"Finished!\" << std :: endl ; } Initialization is different for each IPC technology. Here we have to create sockets, message queues or iceoryx publisher and subscriber. With ipcTechnology.initLeader() we set up these resources on the leader side. After the definition of the different payload sizes to use, we execute a single round trip measurement for each individual payload size. The leader has to orchestrate the whole process and has a pre- and post-step for each round trip measurement. ipcTechnology.preLatencyPerfTestLeader(...) sets the payload size for the upcoming measurement. ipcTechnology.latencyPerfTestLeader(m_settings.numberOfSamples) performs the data exchange between leader and follower and returns the time it took to transmit the number of samples in a round trip. After the measurements are taken for each payload size, ipcTechnology.releaseFollower() releases the follower. This is required since the follower is not aware of the benchmark settings, e.g. how many payload sizes are considered and hence we need to issue a shutdown. We clean up the communication resources with ipcTechnology.shutdown() before we print the results. In the run() method we create instances for the different IPC technologies we want to compare. Each technology is implemented in its own class and implements the pure virtual functions provided with the IcePerfBase class. Before this is done, we send the PerfSettings to the follower application. int IcePerfLeader::run () noexcept { iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); iox :: capro :: ServiceDescription serviceDescription { \"IcePerf\" , \"Settings\" , \"Generic\" }; iox :: popo :: PublisherOptions options ; options . historyCapacity = 1U ; iox :: popo :: Publisher < PerfSettings > settingsPublisher { serviceDescription , options }; if ( ! settingsPublisher . publishCopyOf ( m_settings )) { std :: cerr << \"Could not send settings to follower!\" << std :: endl ; return EXIT_FAILURE ; } // ... return EXIT_SUCCESS ; } Now we can create an object for each IPC technology that we want to evaluate and call the doMeasurement() method. int IcePerfLeader::run () noexcept { iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); // ... if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: POSIX_MESSAGE_QUEUE ) { #ifndef __APPLE__ std :: cout << std :: endl << \"****** MESSAGE QUEUE ********\" << std :: endl ; MQ mq ( PUBLISHER , SUBSCRIBER ); doMeasurement ( mq ); #else if ( m_settings . technology == Technology :: POSIX_MESSAGE_QUEUE ) { std :: cout << \"The message queue is not supported on macOS and will be skipped!\" << std :: endl ; } #endif } if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: UNIX_DOMAIN_SOCKET ) { std :: cout << std :: endl << \"****** UNIX DOMAIN SOCKET ********\" << std :: endl ; UDS uds ( PUBLISHER , SUBSCRIBER ); doMeasurement ( uds ); } if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: ICEORYX_CPP_API ) { std :: cout << std :: endl << \"****** ICEORYX ********\" << std :: endl ; Iceoryx iceoryx ( PUBLISHER , SUBSCRIBER ); doMeasurement ( iceoryx ); } if ( m_settings . technology == Technology :: ALL || m_settings . technology == Technology :: ICEORYX_C_API ) { std :: cout << std :: endl << \"****** ICEORYX C API ********\" << std :: endl ; IceoryxC iceoryxc ( PUBLISHER , SUBSCRIBER ); doMeasurement ( iceoryxc ); } return EXIT_SUCCESS ; }","title":"iceperf-bench-leader Application Code"},{"location":"examples/iceperf/#iceperf_bench_follower-application","text":"The iceperf-bench-follower application is similar to iceperf-bench-leader . The first change is that the SUBSCRIBER and PUBLISHER switch their names. constexpr const char APP_NAME []{ \"iceperf-bench-follower\" }; constexpr const char PUBLISHER []{ \"Follower\" }; constexpr const char SUBSCRIBER []{ \"Leader\" }; While the run() method of the leader publishes the PerfSettings , the follower is subscribed to those settings and waits for them before the technologies are created, which is done similarly as for the leader. int IcePerfFollower::run () noexcept { iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); iox :: capro :: ServiceDescription serviceDescription { \"IcePerf\" , \"Settings\" , \"Generic\" }; iox :: popo :: SubscriberOptions options ; options . historyRequest = 1U ; iox :: popo :: Subscriber < PerfSettings > settingsSubscriber { serviceDescription , options }; m_settings = getSettings ( settingsSubscriber ); // ... return EXIT_SUCCESS ; } The doMeasurement() method is much simpler than the one from the leader, since it only has to react on incoming data. Apart from ipcTechnology.initFollower() and ipcTechnology.shutdown() all the functionality to perform the round trip for different payload sizes is contained in ipcTechnology.latencyPerfTestFollower() void IcePerfFollower::doMeasurement ( IcePerfBase & ipcTechnology ) noexcept { ipcTechnology . initFollower (); ipcTechnology . latencyPerfTestFollower (); ipcTechnology . shutdown (); } Check out iceperf on GitHub","title":"iceperf_bench_follower Application"},{"location":"examples/request_response/","text":"Request response \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates how to use iceoryx in a client-server architecture using the request-response communication pattern. The client sends a request with two consecutive fibonacci numbers and the server responds with the next number in the sequence. We provide three examples, the very basic typed and untyped examples and the most natural setup combining a server with a Listener and a client using a WaitSet. Since you can find the general setup and functionality of the client and the server also in the Listener/WaitSet example, we will describe only this one. Expected output \ud83d\udd17 Code walkthrough \ud83d\udd17 In the following scenario the client (client_cxx_waitset.cpp) uses the WaitSet to wait for a response from the server (server_cxx_listener.cpp). The server uses the Listener API to take and process the requests from the client. The client is inspired by the iox-cpp-waitset-basic example from the WaitSet example and the server from the iox-cpp-callbacks-subscriber in the Listener example. This is the most recommended way to create an efficient client-server combination with iceoryx. Client using WaitSet \ud83d\udd17 At first, the includes for the client port, request-response types, WaitSet, and runtime are needed. #include \"request_and_response_types.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/client.hpp\" #include \"iceoryx_posh/popo/wait_set.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" Afterwards we prepare some ContextData where we can store the Fibonacci numbers and the sequence ids that we use to ensure the correct ordering of the responses. struct ContextData { uint64_t fibonacciLast = 0 ; uint64_t fibonacciCurrent = 1 ; int64_t requestSequenceId = 0 ; int64_t expectedResponseSequenceId = requestSequenceId ; }; Next, the iceoryx runtime is initialized. With this call, the application will be registered at RouDi , the routing and discovery daemon. iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); After creating the runtime, the client is created and attached to the WaitSet. The options can be used to alter the behavior of the client, like setting the response queue capacity or blocking behavior when the response queue is full or the server is too slow. The ClientOptions are similar to PublisherOptions / SubscriberOptions . iox :: popo :: WaitSet <> waitset ; iox :: popo :: ClientOptions options ; options . responseQueueCapacity = 2U ; iox :: popo :: Client < AddRequest , AddResponse > client ({ \"Example\" , \"Request-Response\" , \"Add\" }, options ); // attach client to waitset waitset . attachState ( client , iox :: popo :: ClientState :: HAS_RESPONSE ). or_else ([]( auto ) { std :: cerr << \"failed to attach client\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Since the client requests the sum of two numbers from the server, we provide the structs AddRequest and AddResponse as template parameters. When the sum is received, it is re-used as the addend of the next request to send. This calculates a Fibonacci sequence. struct AddRequest { uint64_t augend { 0 }; uint64_t addend { 0 }; }; struct AddResponse { uint64_t sum { 0 }; }; In the main loop, the client prepares first a request using the loan() API. The request is a sample consisting of the two numbers augend and addend that the server shall sum up. Additionally, the sample is marked with a sequence id that is incremented before every send cycle to ensure a correct ordering of the messages. The request is transmitted to the server via the send() API. client . loan () . and_then ([ & ]( auto & request ) { request . getRequestHeader (). setSequenceId ( ctx . requestSequenceId ); ctx . expectedResponseSequenceId = ctx . requestSequenceId ; ctx . requestSequenceId += 1 ; request -> augend = ctx . fibonacciLast ; request -> addend = ctx . fibonacciCurrent ; std :: cout << APP_NAME << \" Send Request: \" << ctx . fibonacciLast << \" + \" << ctx . fibonacciCurrent << std :: endl ; request . send (). or_else ( [ & ]( auto & error ) { std :: cout << \"Could not send Request! Error: \" << error << std :: endl ; }); }) . or_else ([]( auto & error ) { std :: cout << \"Could not allocate Request! Error: \" << error << std :: endl ; }); Once the request has been sent, we block and wait for samples to arrive. Then we iterate over the notification vector to check if we were triggered from our client: auto notificationVector = waitset . timedWait ( iox :: units :: Duration :: fromSeconds ( 5 )); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & client )) { // ... } } The client receives the responses from the server using take() and extracts the sequence id with response.getResponseHeader().getSequenceId() . When the server response comes in the correct order, the received sum is stored in the ContextData struct ctx for usage in the next request. while ( client . take (). and_then ([ & ]( const auto & response ) { auto receivedSequenceId = response . getResponseHeader (). getSequenceId (); if ( receivedSequenceId == ctx . expectedResponseSequenceId ) { ctx . fibonacciLast = ctx . fibonacciCurrent ; ctx . fibonacciCurrent = response -> sum ; std :: cout << APP_NAME << \" Got Response : \" << ctx . fibonacciCurrent << std :: endl ; } else { std :: cout << \"Got Response with outdated sequence ID! Expected = \" << ctx . expectedResponseSequenceId << \"; Actual = \" << receivedSequenceId << \"! -> skip\" << std :: endl ; } })) { } Server using Listener \ud83d\udd17 At first, the includes for the server port, Listener, request-response types and runtime are needed. #include \"request_and_response_types.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/listener.hpp\" #include \"iceoryx_posh/popo/server.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" Then a callback is created that shall be called when the server receives a request. In this case the calculation and the sending of the response is done in the Listener callback. If there are more resource-consuming tasks, this could also be outsourced with a thread pool to handle the requests. void onRequestReceived ( iox :: popo :: Server < AddRequest , AddResponse >* server ) { while ( server -> take (). and_then ([ & ]( const auto & request ) { std :: cout << APP_NAME << \" Got Request: \" << request -> augend << \" + \" << request -> addend << std :: endl ; server -> loan ( request ) . and_then ([ & ]( auto & response ) { response -> sum = request -> augend + request -> addend ; std :: cout << APP_NAME << \" Send Response: \" << response -> sum << std :: endl ; response . send (). or_else ( [ & ]( auto & error ) { std :: cout << \"Could not send Response! Error: \" << error << std :: endl ; }); }) . or_else ([]( auto & error ) { std :: cout << \"Could not allocate Response! Error: \" << error << std :: endl ; }); })) { } } The server provides the take() method for receiving requests and the loan() and send() methods for sending the responses with the sum of the two numbers. Next, the iceoryx runtime is initialized. iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); After creating the runtime, the server port is created based on a ServiceDescription . Similar to the client, the options are used to alter the behavior of the server, like setting the request queue capacity or blocking behavior when the request queue is full or the client is too slow. iox :: popo :: ServerOptions options ; options . requestQueueCapacity = 10U ; iox :: popo :: Server < AddRequest , AddResponse > server ({ \"Example\" , \"Request-Response\" , \"Add\" }, options ); Now we want to listen to an incoming server event and call the previously created callback whenever a request has been received. This is done with the following call: listener . attachEvent ( server , iox :: popo :: ServerEvent :: REQUEST_RECEIVED , iox :: popo :: createNotificationCallback ( onRequestReceived )) . or_else ([]( auto ) { std :: cerr << \"unable to attach server\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); With that the preparation is done and the main thread can just sleep or do other things: iox :: posix :: waitForTerminationRequest (); Once the user wants to shutdown the server, the server event is detached from the listener: listener . detachEvent ( server , iox :: popo :: ServerEvent :: REQUEST_RECEIVED ); Check out request_response on GitHub","title":"Delivering data on demand (Client/Server) using C++"},{"location":"examples/request_response/#request-response","text":"","title":"Request response"},{"location":"examples/request_response/#introduction","text":"This example demonstrates how to use iceoryx in a client-server architecture using the request-response communication pattern. The client sends a request with two consecutive fibonacci numbers and the server responds with the next number in the sequence. We provide three examples, the very basic typed and untyped examples and the most natural setup combining a server with a Listener and a client using a WaitSet. Since you can find the general setup and functionality of the client and the server also in the Listener/WaitSet example, we will describe only this one.","title":"Introduction"},{"location":"examples/request_response/#expected-output","text":"","title":"Expected output"},{"location":"examples/request_response/#code-walkthrough","text":"In the following scenario the client (client_cxx_waitset.cpp) uses the WaitSet to wait for a response from the server (server_cxx_listener.cpp). The server uses the Listener API to take and process the requests from the client. The client is inspired by the iox-cpp-waitset-basic example from the WaitSet example and the server from the iox-cpp-callbacks-subscriber in the Listener example. This is the most recommended way to create an efficient client-server combination with iceoryx.","title":"Code walkthrough"},{"location":"examples/request_response/#client-using-waitset","text":"At first, the includes for the client port, request-response types, WaitSet, and runtime are needed. #include \"request_and_response_types.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/client.hpp\" #include \"iceoryx_posh/popo/wait_set.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" Afterwards we prepare some ContextData where we can store the Fibonacci numbers and the sequence ids that we use to ensure the correct ordering of the responses. struct ContextData { uint64_t fibonacciLast = 0 ; uint64_t fibonacciCurrent = 1 ; int64_t requestSequenceId = 0 ; int64_t expectedResponseSequenceId = requestSequenceId ; }; Next, the iceoryx runtime is initialized. With this call, the application will be registered at RouDi , the routing and discovery daemon. iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); After creating the runtime, the client is created and attached to the WaitSet. The options can be used to alter the behavior of the client, like setting the response queue capacity or blocking behavior when the response queue is full or the server is too slow. The ClientOptions are similar to PublisherOptions / SubscriberOptions . iox :: popo :: WaitSet <> waitset ; iox :: popo :: ClientOptions options ; options . responseQueueCapacity = 2U ; iox :: popo :: Client < AddRequest , AddResponse > client ({ \"Example\" , \"Request-Response\" , \"Add\" }, options ); // attach client to waitset waitset . attachState ( client , iox :: popo :: ClientState :: HAS_RESPONSE ). or_else ([]( auto ) { std :: cerr << \"failed to attach client\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Since the client requests the sum of two numbers from the server, we provide the structs AddRequest and AddResponse as template parameters. When the sum is received, it is re-used as the addend of the next request to send. This calculates a Fibonacci sequence. struct AddRequest { uint64_t augend { 0 }; uint64_t addend { 0 }; }; struct AddResponse { uint64_t sum { 0 }; }; In the main loop, the client prepares first a request using the loan() API. The request is a sample consisting of the two numbers augend and addend that the server shall sum up. Additionally, the sample is marked with a sequence id that is incremented before every send cycle to ensure a correct ordering of the messages. The request is transmitted to the server via the send() API. client . loan () . and_then ([ & ]( auto & request ) { request . getRequestHeader (). setSequenceId ( ctx . requestSequenceId ); ctx . expectedResponseSequenceId = ctx . requestSequenceId ; ctx . requestSequenceId += 1 ; request -> augend = ctx . fibonacciLast ; request -> addend = ctx . fibonacciCurrent ; std :: cout << APP_NAME << \" Send Request: \" << ctx . fibonacciLast << \" + \" << ctx . fibonacciCurrent << std :: endl ; request . send (). or_else ( [ & ]( auto & error ) { std :: cout << \"Could not send Request! Error: \" << error << std :: endl ; }); }) . or_else ([]( auto & error ) { std :: cout << \"Could not allocate Request! Error: \" << error << std :: endl ; }); Once the request has been sent, we block and wait for samples to arrive. Then we iterate over the notification vector to check if we were triggered from our client: auto notificationVector = waitset . timedWait ( iox :: units :: Duration :: fromSeconds ( 5 )); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & client )) { // ... } } The client receives the responses from the server using take() and extracts the sequence id with response.getResponseHeader().getSequenceId() . When the server response comes in the correct order, the received sum is stored in the ContextData struct ctx for usage in the next request. while ( client . take (). and_then ([ & ]( const auto & response ) { auto receivedSequenceId = response . getResponseHeader (). getSequenceId (); if ( receivedSequenceId == ctx . expectedResponseSequenceId ) { ctx . fibonacciLast = ctx . fibonacciCurrent ; ctx . fibonacciCurrent = response -> sum ; std :: cout << APP_NAME << \" Got Response : \" << ctx . fibonacciCurrent << std :: endl ; } else { std :: cout << \"Got Response with outdated sequence ID! Expected = \" << ctx . expectedResponseSequenceId << \"; Actual = \" << receivedSequenceId << \"! -> skip\" << std :: endl ; } })) { }","title":"Client using WaitSet"},{"location":"examples/request_response/#server-using-listener","text":"At first, the includes for the server port, Listener, request-response types and runtime are needed. #include \"request_and_response_types.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/listener.hpp\" #include \"iceoryx_posh/popo/server.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" Then a callback is created that shall be called when the server receives a request. In this case the calculation and the sending of the response is done in the Listener callback. If there are more resource-consuming tasks, this could also be outsourced with a thread pool to handle the requests. void onRequestReceived ( iox :: popo :: Server < AddRequest , AddResponse >* server ) { while ( server -> take (). and_then ([ & ]( const auto & request ) { std :: cout << APP_NAME << \" Got Request: \" << request -> augend << \" + \" << request -> addend << std :: endl ; server -> loan ( request ) . and_then ([ & ]( auto & response ) { response -> sum = request -> augend + request -> addend ; std :: cout << APP_NAME << \" Send Response: \" << response -> sum << std :: endl ; response . send (). or_else ( [ & ]( auto & error ) { std :: cout << \"Could not send Response! Error: \" << error << std :: endl ; }); }) . or_else ([]( auto & error ) { std :: cout << \"Could not allocate Response! Error: \" << error << std :: endl ; }); })) { } } The server provides the take() method for receiving requests and the loan() and send() methods for sending the responses with the sum of the two numbers. Next, the iceoryx runtime is initialized. iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); After creating the runtime, the server port is created based on a ServiceDescription . Similar to the client, the options are used to alter the behavior of the server, like setting the request queue capacity or blocking behavior when the request queue is full or the client is too slow. iox :: popo :: ServerOptions options ; options . requestQueueCapacity = 10U ; iox :: popo :: Server < AddRequest , AddResponse > server ({ \"Example\" , \"Request-Response\" , \"Add\" }, options ); Now we want to listen to an incoming server event and call the previously created callback whenever a request has been received. This is done with the following call: listener . attachEvent ( server , iox :: popo :: ServerEvent :: REQUEST_RECEIVED , iox :: popo :: createNotificationCallback ( onRequestReceived )) . or_else ([]( auto ) { std :: cerr << \"unable to attach server\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); With that the preparation is done and the main thread can just sleep or do other things: iox :: posix :: waitForTerminationRequest (); Once the user wants to shutdown the server, the server event is detached from the listener: listener . detachEvent ( server , iox :: popo :: ServerEvent :: REQUEST_RECEIVED ); Check out request_response on GitHub","title":"Server using Listener"},{"location":"examples/request_response_in_c/","text":"Request response in C \ud83d\udd17 You can find a more detailed description of the C API in the iceoryx_binding_c README.md . Introduction \ud83d\udd17 The behavior and structure is very close to the request response C++ example so that we explain here only the C API differences and not the underlying mechanisms. The rough idea is that the client sends two fibonacci numbers to the server which then sends the sum of those numbers back. Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 Client Basic \ud83d\udd17 Like with most iceoryx C applications we start with: Registering a signal handler Initialize the runtime signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); iox_runtime_init ( APP_NAME ); We continue with initializing our client to send requests to the server. First of all, we need some memory in which the client can be stored called clientStorage . iox_client_init will create an object in this memory location, sets the service description and uses the default client options which is indicated by the NULL argument at the end. iox_client_storage_t clientStorage ; iox_client_t client = iox_client_init ( & clientStorage , \"Example\" , \"Request-Response\" , \"Add\" , NULL ); Like in the C++ version of our example we implement a client/server based fibonacci algorithm and store the first two fibonacci numbers in fibonacciLast and fibonacciCurrent . requestSequenceId and expectedResponseSequenceId are helping us to keep track of the sequence number which we increase with every sent request and then verify it again in the server's response. uint64_t fibonacciLast = 0U ; uint64_t fibonacciCurrent = 1U ; int64_t requestSequenceId = 0 ; int64_t expectedResponseSequenceId = requestSequenceId ; We enter our main loop and continue sending requests as long as keepRunning is true . When the users presses Control+C the term signal is emitted and keepRunning is set to false via the signal handler callback. We start by loaning memory to send out our request . struct AddRequest * request = NULL ; enum iox_AllocationResult loanResult = iox_client_loan_request ( client , ( void ** ) & request , sizeof ( struct AddRequest )); To set the sequence id we have to acquire the request header first from the payload. Additionally, we set expectedResponseSequenceId so that we can verify the response later and increment the requestSequenceId for the next run. iox_request_header_t requestHeader = iox_request_header_from_payload ( request ); iox_request_header_set_sequence_id ( requestHeader , requestSequenceId ); expectedResponseSequenceId = requestSequenceId ; requestSequenceId += 1 ; Before we can send out the request we have to set the two fibonacci numbers. request -> augend = fibonacciLast ; request -> addend = fibonacciCurrent ; printf ( \"%s Send Request: %lu + %lu \\n \" , APP_NAME , ( unsigned long ) fibonacciLast , ( unsigned long ) fibonacciCurrent ); enum iox_ClientSendResult sendResult = iox_client_send ( client , request ); if ( sendResult != ClientSendResult_SUCCESS ) { printf ( \"Error sending Request! Error code: %d \\n \" , sendResult ); } Now we give the server a little time to process the request . const uint32_t DELAY_TIME_IN_MS = 150U ; sleep_for ( DELAY_TIME_IN_MS ); We process the response by acquiring it first with iox_client_take_response . If this is successful we verify the sequence number, adjust our fibonacci numbers and print our response to the console. When the sequence number does not fulfill our expectation we print an error message. const struct AddResponse * response = NULL ; while ( iox_client_take_response ( client , ( const void ** ) & response ) == ChunkReceiveResult_SUCCESS ) { iox_const_response_header_t responseHeader = iox_response_header_from_payload_const ( response ); int64_t receivedSequenceId = iox_response_header_get_sequence_id_const ( responseHeader ); if ( receivedSequenceId == expectedResponseSequenceId ) { fibonacciLast = fibonacciCurrent ; fibonacciCurrent = response -> sum ; printf ( \"%s Got Response: %lu \\n \" , APP_NAME , ( unsigned long ) fibonacciCurrent ); } else { printf ( \"Got Response with outdated sequence ID! Expected = %lu; Actual = %lu! -> skip \\n \" , ( unsigned long ) expectedResponseSequenceId , ( unsigned long ) receivedSequenceId ); } iox_client_release_response ( client , response ); } Please do not forget to call iox_client_release_response to release the response again. If you forget this you won't be able to receive response s anymore after a certain time since you hold to many responses in parallel. As final step we cleanup the used resources and deinitialize the client. iox_client_deinit ( client ); Client WaitSet \ud83d\udd17 The server and client or both attachable to either a listener or a waitset. In this example we demonstrate how one can implement the client basic example with a waitset. For deeper insights into the WaitSet take a look at the WaitSet C++ example or when you would like to know more about the listener, see the Callbacks C++ example . The startup phase is identical to the client basic version, we register the signal handlers, initialize the runtime, create a client and initialize our variables. Afterwards we create our waitset and attach the client state ClientState_HAS_RESPONSE to it. iox_ws_storage_t waitsetStorage ; iox_ws_t waitset = iox_ws_init ( & waitsetStorage ); if ( iox_ws_attach_client_state ( waitset , client , ClientState_HAS_RESPONSE , 0U , NULL ) != WaitSetResult_SUCCESS ) { printf ( \"failed to attach client \\n \" ); _exit ( -1 ); } Again we perform the same task like in the client basic example. We enter our main loop, loan a request and set it up. But after we sent the request to our server we do not sleep for some time, we wait on the waitset until the request was received. We use iox_ws_timed_wait to wait for at most 2 seconds. iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; uint64_t missedNotifications = 0U ; struct timespec timeout ; timeout . tv_sec = 2 ; timeout . tv_nsec = 0 ; uint64_t numberOfNotifications = iox_ws_timed_wait ( waitset , timeout , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedNotifications ); When this blocking call returns we iterate over the notificationArray and when one triggered originated from our client we acquire all responses in a while loop and print them to the console. for ( uint64_t i = 0 ; i < numberOfNotifications ; ++ i ) { if ( iox_notification_info_does_originate_from_client ( notificationArray [ i ], client )) { const struct AddResponse * response = NULL ; while ( iox_client_take_response ( client , ( const void ** ) & response ) == ChunkReceiveResult_SUCCESS ) { iox_const_response_header_t responseHeader = iox_response_header_from_payload_const ( response ); int64_t receivedSequenceId = iox_response_header_get_sequence_id_const ( responseHeader ); if ( receivedSequenceId == expectedResponseSequenceId ) { fibonacciLast = fibonacciCurrent ; fibonacciCurrent = response -> sum ; printf ( \"%s Got Response: %lu \\n \" , APP_NAME , ( unsigned long ) fibonacciCurrent ); } else { printf ( \"Got Response with outdated sequence ID! Expected = %lu; Actual = %lu! -> skip \\n \" , ( unsigned long ) expectedResponseSequenceId , ( unsigned long ) receivedSequenceId ); } iox_client_release_response ( client , response ); } } } The cleanup is done when we exit our mainloop. We detach the client state from the waitset first and then deinitialize the waitset and the client. iox_ws_detach_client_state ( waitset , client , ClientState_HAS_RESPONSE ); iox_ws_deinit ( waitset ); iox_client_deinit ( client ); Server Basic \ud83d\udd17 We again start with registering the signal handler and the runtime. signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); iox_runtime_init ( APP_NAME ); As next step we initialize the server . Like the client the server requires some memory where it can be stored, the serverStorage . The server is also initialized with the default options which is indicated via the last NULL argument. iox_server_storage_t serverStorage ; iox_server_t server = iox_server_init ( & serverStorage , \"Example\" , \"Request-Response\" , \"Add\" , NULL ); We enter the main loop and start it by taking a request . If it was taken successfully, we print an info message to the console and loan a response . We require the request for the loan so that the response can be delivered to the corresponding client. When the iox_server_loan_response was successful we calculate the sum of the two received fibonacci numbers and send it. const struct AddRequest * request = NULL ; if ( iox_server_take_request ( server , ( const void ** ) & request ) == ServerRequestResult_SUCCESS ) { printf ( \"%s Got Request: %lu + %lu \\n \" , APP_NAME , ( unsigned long ) request -> augend , ( unsigned long ) request -> addend ); struct AddResponse * response = NULL ; enum iox_AllocationResult loanResult = iox_server_loan_response ( server , request , ( void ** ) & response , sizeof ( struct AddResponse )); if ( loanResult == AllocationResult_SUCCESS ) { response -> sum = request -> augend + request -> addend ; printf ( \"%s Send Response: %lu \\n \" , APP_NAME , ( unsigned long ) response -> sum ); enum iox_ServerSendResult sendResult = iox_server_send ( server , response ); if ( sendResult != ServerSendResult_SUCCESS ) { printf ( \"Error sending Response! Error code: %d \\n \" , sendResult ); } } else { printf ( \"%s Could not allocate Response! Error code: %d \\n \" , APP_NAME , loanResult ); } iox_server_release_request ( server , request ); } Again, it is important that one releases the request with iox_server_release_request otherwise iox_server_take_request will fail since one holds to many requests in parallel. The final step is again the resource cleanup where we deinitialize the server. iox_server_deinit ( server ); Server Listener \ud83d\udd17 The server and client or both attachable to either a listener or a waitset. In this example we demonstrate how one can implement the server basic example with a listener. For deeper insights into the WaitSet take a look at the WaitSet C++ example or when you would like to know more about the listener, see the Callbacks C++ example . The listener example starts like the basic example by registering the signal handler, initializing the runtime and creating a server. In the next step we create a listener and attach the server event ServerEvent_REQUEST_RECEIVED with iox_listener_attach_server_event . One parameter of that call is onRequestReceived a pointer to a function which handles the logic whenever we receive a request. iox_server_storage_t serverStorage ; iox_server_t server = iox_server_init ( & serverStorage , \"Example\" , \"Request-Response\" , \"Add\" , NULL ); iox_listener_storage_t listenerStorage ; iox_listener_t listener = iox_listener_init ( & listenerStorage ); if ( iox_listener_attach_server_event ( listener , server , ServerEvent_REQUEST_RECEIVED , onRequestReceived ) != ListenerResult_SUCCESS ) { printf ( \"unable to attach server \\n \" ); _exit ( -1 ); } In the next step we run into our main loop which waits until the user terminates the process. while ( keepRunning ) { const uint32_t SLEEP_TIME_IN_MS = 500U ; sleep_for ( SLEEP_TIME_IN_MS ); } The actual logic behind processing a request is handled in the function onRequestReceived which is called in a thread inside the listener whenever our server receives a request. The code again looks identical to the server basic example. We take the request with iox_server_take_request , print a message to the console and then loan a response with iox_server_loan_response which is populated and send to the client with iox_server_send . void onRequestReceived ( iox_server_t server ) { const struct AddRequest * request = NULL ; while ( iox_server_take_request ( server , ( const void ** ) & request ) == ServerRequestResult_SUCCESS ) { printf ( \"%s Got Request: %lu + %lu \\n \" , APP_NAME , ( unsigned long ) request -> augend , ( unsigned long ) request -> addend ); struct AddResponse * response = NULL ; enum iox_AllocationResult loanResult = iox_server_loan_response ( server , request , ( void ** ) & response , sizeof ( struct AddResponse )); if ( loanResult == AllocationResult_SUCCESS ) { response -> sum = request -> augend + request -> addend ; printf ( \"%s Send Response: %lu \\n \" , APP_NAME , ( unsigned long ) response -> sum ); enum iox_ServerSendResult sendResult = iox_server_send ( server , response ); if ( sendResult != ServerSendResult_SUCCESS ) { printf ( \"Error sending Response! Error code: %d \\n \" , sendResult ); } } else { printf ( \"Could not allocate Response! Error code: %d \\n \" , loanResult ); } iox_server_release_request ( server , request ); } } The resource cleanup is done after our mainloop has ended. We detach the server event from the listener first and then deinitialize the listener and server. iox_listener_detach_server_event ( listener , server , ServerEvent_REQUEST_RECEIVED ); iox_listener_deinit ( listener ); iox_server_deinit ( server ); Check out request response in c on GitHub","title":"Delivering data on demand (Client/Server) using C"},{"location":"examples/request_response_in_c/#request-response-in-c","text":"You can find a more detailed description of the C API in the iceoryx_binding_c README.md .","title":"Request response in C"},{"location":"examples/request_response_in_c/#introduction","text":"The behavior and structure is very close to the request response C++ example so that we explain here only the C API differences and not the underlying mechanisms. The rough idea is that the client sends two fibonacci numbers to the server which then sends the sum of those numbers back.","title":"Introduction"},{"location":"examples/request_response_in_c/#expected-output","text":"","title":"Expected Output"},{"location":"examples/request_response_in_c/#code-walkthrough","text":"","title":"Code walkthrough"},{"location":"examples/request_response_in_c/#client-basic","text":"Like with most iceoryx C applications we start with: Registering a signal handler Initialize the runtime signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); iox_runtime_init ( APP_NAME ); We continue with initializing our client to send requests to the server. First of all, we need some memory in which the client can be stored called clientStorage . iox_client_init will create an object in this memory location, sets the service description and uses the default client options which is indicated by the NULL argument at the end. iox_client_storage_t clientStorage ; iox_client_t client = iox_client_init ( & clientStorage , \"Example\" , \"Request-Response\" , \"Add\" , NULL ); Like in the C++ version of our example we implement a client/server based fibonacci algorithm and store the first two fibonacci numbers in fibonacciLast and fibonacciCurrent . requestSequenceId and expectedResponseSequenceId are helping us to keep track of the sequence number which we increase with every sent request and then verify it again in the server's response. uint64_t fibonacciLast = 0U ; uint64_t fibonacciCurrent = 1U ; int64_t requestSequenceId = 0 ; int64_t expectedResponseSequenceId = requestSequenceId ; We enter our main loop and continue sending requests as long as keepRunning is true . When the users presses Control+C the term signal is emitted and keepRunning is set to false via the signal handler callback. We start by loaning memory to send out our request . struct AddRequest * request = NULL ; enum iox_AllocationResult loanResult = iox_client_loan_request ( client , ( void ** ) & request , sizeof ( struct AddRequest )); To set the sequence id we have to acquire the request header first from the payload. Additionally, we set expectedResponseSequenceId so that we can verify the response later and increment the requestSequenceId for the next run. iox_request_header_t requestHeader = iox_request_header_from_payload ( request ); iox_request_header_set_sequence_id ( requestHeader , requestSequenceId ); expectedResponseSequenceId = requestSequenceId ; requestSequenceId += 1 ; Before we can send out the request we have to set the two fibonacci numbers. request -> augend = fibonacciLast ; request -> addend = fibonacciCurrent ; printf ( \"%s Send Request: %lu + %lu \\n \" , APP_NAME , ( unsigned long ) fibonacciLast , ( unsigned long ) fibonacciCurrent ); enum iox_ClientSendResult sendResult = iox_client_send ( client , request ); if ( sendResult != ClientSendResult_SUCCESS ) { printf ( \"Error sending Request! Error code: %d \\n \" , sendResult ); } Now we give the server a little time to process the request . const uint32_t DELAY_TIME_IN_MS = 150U ; sleep_for ( DELAY_TIME_IN_MS ); We process the response by acquiring it first with iox_client_take_response . If this is successful we verify the sequence number, adjust our fibonacci numbers and print our response to the console. When the sequence number does not fulfill our expectation we print an error message. const struct AddResponse * response = NULL ; while ( iox_client_take_response ( client , ( const void ** ) & response ) == ChunkReceiveResult_SUCCESS ) { iox_const_response_header_t responseHeader = iox_response_header_from_payload_const ( response ); int64_t receivedSequenceId = iox_response_header_get_sequence_id_const ( responseHeader ); if ( receivedSequenceId == expectedResponseSequenceId ) { fibonacciLast = fibonacciCurrent ; fibonacciCurrent = response -> sum ; printf ( \"%s Got Response: %lu \\n \" , APP_NAME , ( unsigned long ) fibonacciCurrent ); } else { printf ( \"Got Response with outdated sequence ID! Expected = %lu; Actual = %lu! -> skip \\n \" , ( unsigned long ) expectedResponseSequenceId , ( unsigned long ) receivedSequenceId ); } iox_client_release_response ( client , response ); } Please do not forget to call iox_client_release_response to release the response again. If you forget this you won't be able to receive response s anymore after a certain time since you hold to many responses in parallel. As final step we cleanup the used resources and deinitialize the client. iox_client_deinit ( client );","title":"Client Basic"},{"location":"examples/request_response_in_c/#client-waitset","text":"The server and client or both attachable to either a listener or a waitset. In this example we demonstrate how one can implement the client basic example with a waitset. For deeper insights into the WaitSet take a look at the WaitSet C++ example or when you would like to know more about the listener, see the Callbacks C++ example . The startup phase is identical to the client basic version, we register the signal handlers, initialize the runtime, create a client and initialize our variables. Afterwards we create our waitset and attach the client state ClientState_HAS_RESPONSE to it. iox_ws_storage_t waitsetStorage ; iox_ws_t waitset = iox_ws_init ( & waitsetStorage ); if ( iox_ws_attach_client_state ( waitset , client , ClientState_HAS_RESPONSE , 0U , NULL ) != WaitSetResult_SUCCESS ) { printf ( \"failed to attach client \\n \" ); _exit ( -1 ); } Again we perform the same task like in the client basic example. We enter our main loop, loan a request and set it up. But after we sent the request to our server we do not sleep for some time, we wait on the waitset until the request was received. We use iox_ws_timed_wait to wait for at most 2 seconds. iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; uint64_t missedNotifications = 0U ; struct timespec timeout ; timeout . tv_sec = 2 ; timeout . tv_nsec = 0 ; uint64_t numberOfNotifications = iox_ws_timed_wait ( waitset , timeout , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedNotifications ); When this blocking call returns we iterate over the notificationArray and when one triggered originated from our client we acquire all responses in a while loop and print them to the console. for ( uint64_t i = 0 ; i < numberOfNotifications ; ++ i ) { if ( iox_notification_info_does_originate_from_client ( notificationArray [ i ], client )) { const struct AddResponse * response = NULL ; while ( iox_client_take_response ( client , ( const void ** ) & response ) == ChunkReceiveResult_SUCCESS ) { iox_const_response_header_t responseHeader = iox_response_header_from_payload_const ( response ); int64_t receivedSequenceId = iox_response_header_get_sequence_id_const ( responseHeader ); if ( receivedSequenceId == expectedResponseSequenceId ) { fibonacciLast = fibonacciCurrent ; fibonacciCurrent = response -> sum ; printf ( \"%s Got Response: %lu \\n \" , APP_NAME , ( unsigned long ) fibonacciCurrent ); } else { printf ( \"Got Response with outdated sequence ID! Expected = %lu; Actual = %lu! -> skip \\n \" , ( unsigned long ) expectedResponseSequenceId , ( unsigned long ) receivedSequenceId ); } iox_client_release_response ( client , response ); } } } The cleanup is done when we exit our mainloop. We detach the client state from the waitset first and then deinitialize the waitset and the client. iox_ws_detach_client_state ( waitset , client , ClientState_HAS_RESPONSE ); iox_ws_deinit ( waitset ); iox_client_deinit ( client );","title":"Client WaitSet"},{"location":"examples/request_response_in_c/#server-basic","text":"We again start with registering the signal handler and the runtime. signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); iox_runtime_init ( APP_NAME ); As next step we initialize the server . Like the client the server requires some memory where it can be stored, the serverStorage . The server is also initialized with the default options which is indicated via the last NULL argument. iox_server_storage_t serverStorage ; iox_server_t server = iox_server_init ( & serverStorage , \"Example\" , \"Request-Response\" , \"Add\" , NULL ); We enter the main loop and start it by taking a request . If it was taken successfully, we print an info message to the console and loan a response . We require the request for the loan so that the response can be delivered to the corresponding client. When the iox_server_loan_response was successful we calculate the sum of the two received fibonacci numbers and send it. const struct AddRequest * request = NULL ; if ( iox_server_take_request ( server , ( const void ** ) & request ) == ServerRequestResult_SUCCESS ) { printf ( \"%s Got Request: %lu + %lu \\n \" , APP_NAME , ( unsigned long ) request -> augend , ( unsigned long ) request -> addend ); struct AddResponse * response = NULL ; enum iox_AllocationResult loanResult = iox_server_loan_response ( server , request , ( void ** ) & response , sizeof ( struct AddResponse )); if ( loanResult == AllocationResult_SUCCESS ) { response -> sum = request -> augend + request -> addend ; printf ( \"%s Send Response: %lu \\n \" , APP_NAME , ( unsigned long ) response -> sum ); enum iox_ServerSendResult sendResult = iox_server_send ( server , response ); if ( sendResult != ServerSendResult_SUCCESS ) { printf ( \"Error sending Response! Error code: %d \\n \" , sendResult ); } } else { printf ( \"%s Could not allocate Response! Error code: %d \\n \" , APP_NAME , loanResult ); } iox_server_release_request ( server , request ); } Again, it is important that one releases the request with iox_server_release_request otherwise iox_server_take_request will fail since one holds to many requests in parallel. The final step is again the resource cleanup where we deinitialize the server. iox_server_deinit ( server );","title":"Server Basic"},{"location":"examples/request_response_in_c/#server-listener","text":"The server and client or both attachable to either a listener or a waitset. In this example we demonstrate how one can implement the server basic example with a listener. For deeper insights into the WaitSet take a look at the WaitSet C++ example or when you would like to know more about the listener, see the Callbacks C++ example . The listener example starts like the basic example by registering the signal handler, initializing the runtime and creating a server. In the next step we create a listener and attach the server event ServerEvent_REQUEST_RECEIVED with iox_listener_attach_server_event . One parameter of that call is onRequestReceived a pointer to a function which handles the logic whenever we receive a request. iox_server_storage_t serverStorage ; iox_server_t server = iox_server_init ( & serverStorage , \"Example\" , \"Request-Response\" , \"Add\" , NULL ); iox_listener_storage_t listenerStorage ; iox_listener_t listener = iox_listener_init ( & listenerStorage ); if ( iox_listener_attach_server_event ( listener , server , ServerEvent_REQUEST_RECEIVED , onRequestReceived ) != ListenerResult_SUCCESS ) { printf ( \"unable to attach server \\n \" ); _exit ( -1 ); } In the next step we run into our main loop which waits until the user terminates the process. while ( keepRunning ) { const uint32_t SLEEP_TIME_IN_MS = 500U ; sleep_for ( SLEEP_TIME_IN_MS ); } The actual logic behind processing a request is handled in the function onRequestReceived which is called in a thread inside the listener whenever our server receives a request. The code again looks identical to the server basic example. We take the request with iox_server_take_request , print a message to the console and then loan a response with iox_server_loan_response which is populated and send to the client with iox_server_send . void onRequestReceived ( iox_server_t server ) { const struct AddRequest * request = NULL ; while ( iox_server_take_request ( server , ( const void ** ) & request ) == ServerRequestResult_SUCCESS ) { printf ( \"%s Got Request: %lu + %lu \\n \" , APP_NAME , ( unsigned long ) request -> augend , ( unsigned long ) request -> addend ); struct AddResponse * response = NULL ; enum iox_AllocationResult loanResult = iox_server_loan_response ( server , request , ( void ** ) & response , sizeof ( struct AddResponse )); if ( loanResult == AllocationResult_SUCCESS ) { response -> sum = request -> augend + request -> addend ; printf ( \"%s Send Response: %lu \\n \" , APP_NAME , ( unsigned long ) response -> sum ); enum iox_ServerSendResult sendResult = iox_server_send ( server , response ); if ( sendResult != ServerSendResult_SUCCESS ) { printf ( \"Error sending Response! Error code: %d \\n \" , sendResult ); } } else { printf ( \"Could not allocate Response! Error code: %d \\n \" , loanResult ); } iox_server_release_request ( server , request ); } } The resource cleanup is done after our mainloop has ended. We detach the server event from the listener first and then deinitialize the listener and server. iox_listener_detach_server_event ( listener , server , ServerEvent_REQUEST_RECEIVED ); iox_listener_deinit ( listener ); iox_server_deinit ( server ); Check out request response in c on GitHub","title":"Server Listener"},{"location":"examples/singleprocess/","text":"Single process \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates how iceoryx can be used in a single process for inter-thread communication. This is for instance helpful if you would like to establish a simple communication API in a 3D engine with a multitude of threads that are interacting without starting RouDi every time separately. Run singleprocess \ud83d\udd17 The first lines until RouDi is ready for clients are coming from the RouDi startup in which the shared memory management segment and user data segment are created. Afterward, the publisher and subscriber thread are started and are beginning to transmit and receive data. Code Walkthrough \ud83d\udd17 Creating a Single Process RouDi, Publisher and Subscriber \ud83d\udd17 We start by setting the log level to error since we do not want to see all the debug messages. iox :: log :: LogManager :: GetLogManager (). SetDefaultLogLevel ( iox :: log :: LogLevel :: kError ); To start RouDi we have to create a configuration for him. We are choosing the default config. Additionally, RouDi needs some other components like a memory management unit which handles how the memory is created in which the transmission data is stored. The IceOryxRouDiComponents class is handling them for us iox :: RouDiConfig_t defaultRouDiConfig = iox :: RouDiConfig_t (). setDefaults (); iox :: roudi :: IceOryxRouDiComponents roudiComponents ( defaultRouDiConfig ); We are starting RouDi, provide the required components and disable monitoring. The last bool parameter TERMINATE_APP_IN_ROUDI_DTOR_FLAG states that RouDi does not terminate all registered processes when RouDi goes out of scope. If we would set it to true , our application would self terminate in the destructor of roudi . constexpr bool TERMINATE_APP_IN_ROUDI_DTOR_FLAG = false ; iox :: roudi :: RouDi roudi ( roudiComponents . rouDiMemoryManager , roudiComponents . portManager , iox :: roudi :: RouDi :: RoudiStartupParameters { iox :: roudi :: MonitoringMode :: OFF , TERMINATE_APP_IN_ROUDI_DTOR_FLAG }); Here comes a key difference to an inter-process application. If you would like to communicate within one process, you have to use PoshRuntimeSingleProcess . You can create only one runtime at a time! iox :: runtime :: PoshRuntimeSingleProcess runtime ( \"singleProcessDemo\" ); Now that everything is up and running, we can start the publisher and subscriber thread and wait until the user terminates the application. std :: thread publisherThread ( publisher ), subscriberThread ( subscriber ); iox :: posix :: waitForTerminationRequest (); publisherThread . join (); subscriberThread . join (); std :: cout << \"Finished\" << std :: endl ; Implementation of Publisher and Subscriber \ud83d\udd17 Since there are no differences to the inter-process ports you can take a look at the icedelivery example for a detailed documentation. We only provide here a short overview. Publisher \ud83d\udd17 We create a typed publisher with the following service description (Service = Single , Instance = Process , Event = Demo ) and a historyCapacity of 10. iox :: popo :: PublisherOptions publisherOptions ; publisherOptions . historyCapacity = 10U ; iox :: popo :: Publisher < TransmissionData_t > publisher ({ \"Single\" , \"Process\" , \"Demo\" }, publisherOptions ); After that, we are sending numbers in ascending order with a 100ms interval in a while loop. uint64_t counter { 0 }; constexpr const char GREEN_RIGHT_ARROW [] = \" \\033 [32m-> \\033 [m \" ; while ( ! iox :: posix :: hasTerminationRequested ()) { publisher . loan (). and_then ([ & ]( auto & sample ) { sample -> counter = counter ++ ; consoleOutput ( \"Sending \" , GREEN_RIGHT_ARROW , sample -> counter ); sample . publish (); }); std :: this_thread :: sleep_for ( CYCLE_TIME ); } Subscriber \ud83d\udd17 We create a subscriber port with the same service description, a queueCapacity of 10 and request to get the last 5 samples when we connect ( historyRequest ). iox :: popo :: SubscriberOptions options ; options . queueCapacity = 10U ; options . historyRequest = 5U ; iox :: popo :: Subscriber < TransmissionData_t > subscriber ({ \"Single\" , \"Process\" , \"Demo\" }, options ); Now we can receive the data in a while loop when our SubscribeState is SUBSCRIBED until someone terminates the application. constexpr const char ORANGE_LEFT_ARROW [] = \" \\033 [33m<- \\033 [m \" ; while ( ! iox :: posix :: hasTerminationRequested ()) { if ( iox :: SubscribeState :: SUBSCRIBED == subscriber . getSubscriptionState ()) { bool hasMoreSamples { true }; do { subscriber . take () . and_then ([ & ]( auto & sample ) { consoleOutput ( \"Receiving \" , ORANGE_LEFT_ARROW , sample -> counter ); }) . or_else ([ & ]( auto & result ) { hasMoreSamples = false ; if ( result != iox :: popo :: ChunkReceiveResult :: NO_CHUNK_AVAILABLE ) { std :: cout << \"Error receiving chunk.\" << std :: endl ; } }); } while ( hasMoreSamples ); } std :: this_thread :: sleep_for ( CYCLE_TIME ); } Check out singleprocess on GitHub","title":"Communicating in a single process between threads"},{"location":"examples/singleprocess/#single-process","text":"","title":"Single process"},{"location":"examples/singleprocess/#introduction","text":"This example demonstrates how iceoryx can be used in a single process for inter-thread communication. This is for instance helpful if you would like to establish a simple communication API in a 3D engine with a multitude of threads that are interacting without starting RouDi every time separately.","title":"Introduction"},{"location":"examples/singleprocess/#run-singleprocess","text":"The first lines until RouDi is ready for clients are coming from the RouDi startup in which the shared memory management segment and user data segment are created. Afterward, the publisher and subscriber thread are started and are beginning to transmit and receive data.","title":"Run singleprocess"},{"location":"examples/singleprocess/#code-walkthrough","text":"","title":"Code Walkthrough"},{"location":"examples/singleprocess/#creating-a-single-process-roudi-publisher-and-subscriber","text":"We start by setting the log level to error since we do not want to see all the debug messages. iox :: log :: LogManager :: GetLogManager (). SetDefaultLogLevel ( iox :: log :: LogLevel :: kError ); To start RouDi we have to create a configuration for him. We are choosing the default config. Additionally, RouDi needs some other components like a memory management unit which handles how the memory is created in which the transmission data is stored. The IceOryxRouDiComponents class is handling them for us iox :: RouDiConfig_t defaultRouDiConfig = iox :: RouDiConfig_t (). setDefaults (); iox :: roudi :: IceOryxRouDiComponents roudiComponents ( defaultRouDiConfig ); We are starting RouDi, provide the required components and disable monitoring. The last bool parameter TERMINATE_APP_IN_ROUDI_DTOR_FLAG states that RouDi does not terminate all registered processes when RouDi goes out of scope. If we would set it to true , our application would self terminate in the destructor of roudi . constexpr bool TERMINATE_APP_IN_ROUDI_DTOR_FLAG = false ; iox :: roudi :: RouDi roudi ( roudiComponents . rouDiMemoryManager , roudiComponents . portManager , iox :: roudi :: RouDi :: RoudiStartupParameters { iox :: roudi :: MonitoringMode :: OFF , TERMINATE_APP_IN_ROUDI_DTOR_FLAG }); Here comes a key difference to an inter-process application. If you would like to communicate within one process, you have to use PoshRuntimeSingleProcess . You can create only one runtime at a time! iox :: runtime :: PoshRuntimeSingleProcess runtime ( \"singleProcessDemo\" ); Now that everything is up and running, we can start the publisher and subscriber thread and wait until the user terminates the application. std :: thread publisherThread ( publisher ), subscriberThread ( subscriber ); iox :: posix :: waitForTerminationRequest (); publisherThread . join (); subscriberThread . join (); std :: cout << \"Finished\" << std :: endl ;","title":"Creating a Single Process RouDi, Publisher and Subscriber"},{"location":"examples/singleprocess/#implementation-of-publisher-and-subscriber","text":"Since there are no differences to the inter-process ports you can take a look at the icedelivery example for a detailed documentation. We only provide here a short overview.","title":"Implementation of Publisher and Subscriber"},{"location":"examples/singleprocess/#publisher","text":"We create a typed publisher with the following service description (Service = Single , Instance = Process , Event = Demo ) and a historyCapacity of 10. iox :: popo :: PublisherOptions publisherOptions ; publisherOptions . historyCapacity = 10U ; iox :: popo :: Publisher < TransmissionData_t > publisher ({ \"Single\" , \"Process\" , \"Demo\" }, publisherOptions ); After that, we are sending numbers in ascending order with a 100ms interval in a while loop. uint64_t counter { 0 }; constexpr const char GREEN_RIGHT_ARROW [] = \" \\033 [32m-> \\033 [m \" ; while ( ! iox :: posix :: hasTerminationRequested ()) { publisher . loan (). and_then ([ & ]( auto & sample ) { sample -> counter = counter ++ ; consoleOutput ( \"Sending \" , GREEN_RIGHT_ARROW , sample -> counter ); sample . publish (); }); std :: this_thread :: sleep_for ( CYCLE_TIME ); }","title":"Publisher"},{"location":"examples/singleprocess/#subscriber","text":"We create a subscriber port with the same service description, a queueCapacity of 10 and request to get the last 5 samples when we connect ( historyRequest ). iox :: popo :: SubscriberOptions options ; options . queueCapacity = 10U ; options . historyRequest = 5U ; iox :: popo :: Subscriber < TransmissionData_t > subscriber ({ \"Single\" , \"Process\" , \"Demo\" }, options ); Now we can receive the data in a while loop when our SubscribeState is SUBSCRIBED until someone terminates the application. constexpr const char ORANGE_LEFT_ARROW [] = \" \\033 [33m<- \\033 [m \" ; while ( ! iox :: posix :: hasTerminationRequested ()) { if ( iox :: SubscribeState :: SUBSCRIBED == subscriber . getSubscriptionState ()) { bool hasMoreSamples { true }; do { subscriber . take () . and_then ([ & ]( auto & sample ) { consoleOutput ( \"Receiving \" , ORANGE_LEFT_ARROW , sample -> counter ); }) . or_else ([ & ]( auto & result ) { hasMoreSamples = false ; if ( result != iox :: popo :: ChunkReceiveResult :: NO_CHUNK_AVAILABLE ) { std :: cout << \"Error receiving chunk.\" << std :: endl ; } }); } while ( hasMoreSamples ); } std :: this_thread :: sleep_for ( CYCLE_TIME ); } Check out singleprocess on GitHub","title":"Subscriber"},{"location":"examples/user_header/","text":"user-header \ud83d\udd17 Introduction \ud83d\udd17 This example demonstrates how to leverage the user-header to send custom meta-information with each sample. Specifically, we want to send a timestamp alongside the sample. The example contains code for the typed and untyped C++ API as well as for the C language binding. Expected Output \ud83d\udd17 Code walkthrough \ud83d\udd17 The examples uses the user-header and user-payload which is defined in user_header_and_payload_types.hpp for the C++ API and in user_header_and_payload_types.h for the C API. The user-header consists of a simple uint64_t which is used to transmit a timestamp and the user-payload is a Fibonacci number. This are the definitions for the C++ API: struct Header { uint64_t publisherTimestamp { 0 }; }; struct Data { uint64_t fibonacci { 0 }; }; This are the definitions for the C API: typedef struct { uint64_t publisherTimestamp ; } Header ; typedef struct { uint64_t fibonacci ; } Data ; Publisher Typed C++ API \ud83d\udd17 At first, there are includes for the user-header and user-payload types and the iceoryx includes for publisher and runtime. #include \"user_header_and_payload_types.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/publisher.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" Next, the iceoryx runtime is initialized. With this call, the application will be registered at RouDi , the routing and discovery daemon. constexpr char APP_NAME [] = \"iox-cpp-user-header-publisher\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Now, we create the publisher. Unlike the other examples, this uses the second template parameter to define the user-header. This is the only change compared to the other examples with the typed C++ API. iox :: popo :: Publisher < Data , Header > publisher ({ \"Example\" , \"User-Header\" , \"Timestamp\" }); In the main loop, a Fibonacci sequence is created and every second a number is published. The Fibonacci number is passed to the loan method which construct the Data object if the loaning was successful. This example uses the functional approach with and_then and or_else . Please have a look at the icehello example if you prefer a more traditional approach. uint64_t timestamp = 42 ; uint64_t fibonacciLast = 0 ; uint64_t fibonacciCurrent = 1 ; while ( ! iox :: posix :: hasTerminationRequested ()) { auto fibonacciNext = fibonacciCurrent + fibonacciLast ; fibonacciLast = fibonacciCurrent ; fibonacciCurrent = fibonacciNext ; publisher . loan ( Data { fibonacciCurrent }) . and_then ([ & ]( auto & sample ) { // ... }) . or_else ([ & ]( auto & error ) { // ... }); constexpr uint64_t MILLISECONDS_SLEEP { 1000U }; std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( MILLISECONDS_SLEEP )); timestamp += MILLISECONDS_SLEEP ; } When the loaning was successful, we get a sample and can access it in the and_then branch. The sample has a getUserHeader method which returns a reference to the user-header we specified with the template parameter. In this case it's the Header struct and we set the publisherTimestamp . sample . getUserHeader (). publisherTimestamp = timestamp ; sample . publish (); std :: cout << APP_NAME << \" sent data: \" << fibonacciCurrent << \" with timestamp \" << timestamp << \"ms\" << std :: endl ; If the loaning fails, the or_else branch is executed, which prints an error message std :: cout << APP_NAME << \" could not loan sample! Error code: \" << error << std :: endl ; Publisher Untyped C++ API \ud83d\udd17 The example with the untyped C++ publisher is quite similar to the one with the typed publisher. The few differences will be discussed in this section. At first there is a different include #include \"iceoryx_posh/popo/untyped_publisher.hpp\" When the publisher is created, there is also no notion of a user-header and it looks exactly the same like already shown in other examples. iox :: popo :: UntypedPublisher publisher ({ \"Example\" , \"User-Header\" , \"Timestamp\" }); Variations come again into play when the chunk is loaned. Since the API is untyped, the parameter for the user-header have to be provided with the loan call. These are optional parameter and are set to values indicating no user-header by default. publisher . loan ( sizeof ( Data ), alignof ( Data ), sizeof ( Header ), alignof ( Header )) . and_then ([ & ]( auto & userPayload ) { // ... }) . or_else ([ & ]( auto & error ) { // ... }); Lastly, since the untyped C++ API returns a void pointer to the user-payload, there is an intermediate step to access the user-header by obtaining a ChunkHeader first, which provides a method to get the user-header. This also return a void pointer, which makes a cast to the actual type necessary. auto header = static_cast < Header *> ( iox :: mepoo :: ChunkHeader :: fromUserPayload ( userPayload ) -> userHeader ()); header -> publisherTimestamp = timestamp ; auto data = static_cast < Data *> ( userPayload ); data -> fibonacci = fibonacciCurrent ; publisher . publish ( userPayload ); std :: cout << APP_NAME << \" sent data: \" << fibonacciCurrent << \" with timestamp \" << timestamp << \"ms\" << std :: endl ; Publisher C API \ud83d\udd17 The example for the C API is similar to the one in icedelivery_in_c and therefore only the user-header related parts are looked into. The overall structure is the same like in the typed and untyped C++ API counterparts. The functions to access the user-header are located in the following include #include \"iceoryx_binding_c/chunk.h\" Similar to the untyped C++ API, the user-header parameter are specified with the loan function. Since C does not have overloading, this is done by a different function void * userPayload ; const uint32_t ALIGNMENT = 8 ; enum iox_AllocationResult res = iox_pub_loan_aligned_chunk_with_user_header ( publisher , & userPayload , sizeof ( Data ), ALIGNMENT , sizeof ( Header ), ALIGNMENT ); Like with the untyped C++ API, the path to the user-header needs an intermediate step with the iox_chunk_header_t and explicit casting to since the functions return void pointer. iox_chunk_header_t * chunkHeader = iox_chunk_header_from_user_payload ( userPayload ); Header * header = ( Header * ) iox_chunk_header_to_user_header ( chunkHeader ); header -> publisherTimestamp = timestamp ; Data * data = ( Data * ) userPayload ; data -> fibonacci = fibonacciCurrent ; iox_pub_publish_chunk ( publisher , userPayload ); // explicit cast to unsigned long since on macOS an uint64_t is a different built-in type than on Linux printf ( \"%s sent data: %lu with timestamp %ldms \\n \" , APP_NAME , ( unsigned long ) fibonacciCurrent , ( unsigned long ) timestamp ); fflush ( stdout ); Subscriber Typed C++ API \ud83d\udd17 The boilerplate code for the subscriber is the same like for the publisher, therefore only the specific subscriber code is discussed in this section. To use the subscriber, subscriber.hpp needs to be included. Similar to the publisher, the subscriber requires the same additional template parameter when it is used with a user header. iox :: popo :: Subscriber < Data , Header > subscriber ({ \"Example\" , \"User-Header\" , \"Timestamp\" }); The main loop is quite simple. The publisher is periodically polled and the data of the received sample is printed. Again, the user-header is accessed by the getUserHeader method of the sample. while ( ! iox :: posix :: hasTerminationRequested ()) { subscriber . take (). and_then ([ & ]( auto & sample ) { std :: cout << APP_NAME << \" got value: \" << sample -> fibonacci << \" with timestamp \" << sample . getUserHeader (). publisherTimestamp << \"ms\" << std :: endl ; }); constexpr std :: chrono :: milliseconds SLEEP_TIME { 100U }; std :: this_thread :: sleep_for ( SLEEP_TIME ); } Subscriber Untyped C++ API \ud83d\udd17 On the subscriber side, the typed and untyped examples are even closer in similarity than the publisher example. The notable difference is the take method, which returns a void pointer to the user-payload. Like with the untyped publisher, in order to get the user-header the ChunkHeader must be obtained. Contrary to the untyped publisher, we must cast to a const T* type, like const Header* since we are not allowed to mutate the header from a subscriber. At the end, the chunk must be released to prevent chunk leaks. This is done by calling the release method with user-payload pointer. subscriber . take (). and_then ([ & ]( auto & userPayload ) { auto header = static_cast < const Header *> ( iox :: mepoo :: ChunkHeader :: fromUserPayload ( userPayload ) -> userHeader ()); auto data = static_cast < const Data *> ( userPayload ); std :: cout << APP_NAME << \" got value: \" << data -> fibonacci << \" with timestamp \" << header -> publisherTimestamp << \"ms\" << std :: endl ; subscriber . release ( userPayload ); }); Subscriber C API \ud83d\udd17 Finally there is the C API example. Like with the publisher example for the C API we just take a look at the user-header specific parts. The overall structure is the same like in the typed and untyped C++ API counterparts. As we already have seen with the untyped C++ example, the call to take the sample is independent of the usage of a user-header. Likewise, the access to the user-header is done by the intermediate step of getting an iox_chunk_header_t first. Since we are not allowed to mutate the user-header from a subscriber, the respective functions with a _const suffix must be used. At last, the chunk is released in order to prevent chunk leaks. const void * userPayload ; if ( iox_sub_take_chunk ( subscriber , & userPayload ) == ChunkReceiveResult_SUCCESS ) { const iox_chunk_header_t * chunkHeader = iox_chunk_header_from_user_payload_const ( userPayload ); const Header * header = ( const Header * )( iox_chunk_header_to_user_header_const ( chunkHeader )); const Data * data = ( const Data * ) userPayload ; // explicit cast to unsigned long since on macOS an uint64_t is a different built-in type than on Linux printf ( \"%s got value: %lu with timestamp %ldms \\n \" , APP_NAME , ( unsigned long ) data -> fibonacci , ( unsigned long ) header -> publisherTimestamp ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); } Check out User-Header on GitHub","title":"Using a user-header for additional meta-information like timestamps"},{"location":"examples/user_header/#user-header","text":"","title":"user-header"},{"location":"examples/user_header/#introduction","text":"This example demonstrates how to leverage the user-header to send custom meta-information with each sample. Specifically, we want to send a timestamp alongside the sample. The example contains code for the typed and untyped C++ API as well as for the C language binding.","title":"Introduction"},{"location":"examples/user_header/#expected-output","text":"","title":"Expected Output"},{"location":"examples/user_header/#code-walkthrough","text":"The examples uses the user-header and user-payload which is defined in user_header_and_payload_types.hpp for the C++ API and in user_header_and_payload_types.h for the C API. The user-header consists of a simple uint64_t which is used to transmit a timestamp and the user-payload is a Fibonacci number. This are the definitions for the C++ API: struct Header { uint64_t publisherTimestamp { 0 }; }; struct Data { uint64_t fibonacci { 0 }; }; This are the definitions for the C API: typedef struct { uint64_t publisherTimestamp ; } Header ; typedef struct { uint64_t fibonacci ; } Data ;","title":"Code walkthrough"},{"location":"examples/user_header/#publisher-typed-c-api","text":"At first, there are includes for the user-header and user-payload types and the iceoryx includes for publisher and runtime. #include \"user_header_and_payload_types.hpp\" #include \"iceoryx_hoofs/posix_wrapper/signal_watcher.hpp\" #include \"iceoryx_posh/popo/publisher.hpp\" #include \"iceoryx_posh/runtime/posh_runtime.hpp\" Next, the iceoryx runtime is initialized. With this call, the application will be registered at RouDi , the routing and discovery daemon. constexpr char APP_NAME [] = \"iox-cpp-user-header-publisher\" ; iox :: runtime :: PoshRuntime :: initRuntime ( APP_NAME ); Now, we create the publisher. Unlike the other examples, this uses the second template parameter to define the user-header. This is the only change compared to the other examples with the typed C++ API. iox :: popo :: Publisher < Data , Header > publisher ({ \"Example\" , \"User-Header\" , \"Timestamp\" }); In the main loop, a Fibonacci sequence is created and every second a number is published. The Fibonacci number is passed to the loan method which construct the Data object if the loaning was successful. This example uses the functional approach with and_then and or_else . Please have a look at the icehello example if you prefer a more traditional approach. uint64_t timestamp = 42 ; uint64_t fibonacciLast = 0 ; uint64_t fibonacciCurrent = 1 ; while ( ! iox :: posix :: hasTerminationRequested ()) { auto fibonacciNext = fibonacciCurrent + fibonacciLast ; fibonacciLast = fibonacciCurrent ; fibonacciCurrent = fibonacciNext ; publisher . loan ( Data { fibonacciCurrent }) . and_then ([ & ]( auto & sample ) { // ... }) . or_else ([ & ]( auto & error ) { // ... }); constexpr uint64_t MILLISECONDS_SLEEP { 1000U }; std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( MILLISECONDS_SLEEP )); timestamp += MILLISECONDS_SLEEP ; } When the loaning was successful, we get a sample and can access it in the and_then branch. The sample has a getUserHeader method which returns a reference to the user-header we specified with the template parameter. In this case it's the Header struct and we set the publisherTimestamp . sample . getUserHeader (). publisherTimestamp = timestamp ; sample . publish (); std :: cout << APP_NAME << \" sent data: \" << fibonacciCurrent << \" with timestamp \" << timestamp << \"ms\" << std :: endl ; If the loaning fails, the or_else branch is executed, which prints an error message std :: cout << APP_NAME << \" could not loan sample! Error code: \" << error << std :: endl ;","title":"Publisher Typed C++ API"},{"location":"examples/user_header/#publisher-untyped-c-api","text":"The example with the untyped C++ publisher is quite similar to the one with the typed publisher. The few differences will be discussed in this section. At first there is a different include #include \"iceoryx_posh/popo/untyped_publisher.hpp\" When the publisher is created, there is also no notion of a user-header and it looks exactly the same like already shown in other examples. iox :: popo :: UntypedPublisher publisher ({ \"Example\" , \"User-Header\" , \"Timestamp\" }); Variations come again into play when the chunk is loaned. Since the API is untyped, the parameter for the user-header have to be provided with the loan call. These are optional parameter and are set to values indicating no user-header by default. publisher . loan ( sizeof ( Data ), alignof ( Data ), sizeof ( Header ), alignof ( Header )) . and_then ([ & ]( auto & userPayload ) { // ... }) . or_else ([ & ]( auto & error ) { // ... }); Lastly, since the untyped C++ API returns a void pointer to the user-payload, there is an intermediate step to access the user-header by obtaining a ChunkHeader first, which provides a method to get the user-header. This also return a void pointer, which makes a cast to the actual type necessary. auto header = static_cast < Header *> ( iox :: mepoo :: ChunkHeader :: fromUserPayload ( userPayload ) -> userHeader ()); header -> publisherTimestamp = timestamp ; auto data = static_cast < Data *> ( userPayload ); data -> fibonacci = fibonacciCurrent ; publisher . publish ( userPayload ); std :: cout << APP_NAME << \" sent data: \" << fibonacciCurrent << \" with timestamp \" << timestamp << \"ms\" << std :: endl ;","title":"Publisher Untyped C++ API"},{"location":"examples/user_header/#publisher-c-api","text":"The example for the C API is similar to the one in icedelivery_in_c and therefore only the user-header related parts are looked into. The overall structure is the same like in the typed and untyped C++ API counterparts. The functions to access the user-header are located in the following include #include \"iceoryx_binding_c/chunk.h\" Similar to the untyped C++ API, the user-header parameter are specified with the loan function. Since C does not have overloading, this is done by a different function void * userPayload ; const uint32_t ALIGNMENT = 8 ; enum iox_AllocationResult res = iox_pub_loan_aligned_chunk_with_user_header ( publisher , & userPayload , sizeof ( Data ), ALIGNMENT , sizeof ( Header ), ALIGNMENT ); Like with the untyped C++ API, the path to the user-header needs an intermediate step with the iox_chunk_header_t and explicit casting to since the functions return void pointer. iox_chunk_header_t * chunkHeader = iox_chunk_header_from_user_payload ( userPayload ); Header * header = ( Header * ) iox_chunk_header_to_user_header ( chunkHeader ); header -> publisherTimestamp = timestamp ; Data * data = ( Data * ) userPayload ; data -> fibonacci = fibonacciCurrent ; iox_pub_publish_chunk ( publisher , userPayload ); // explicit cast to unsigned long since on macOS an uint64_t is a different built-in type than on Linux printf ( \"%s sent data: %lu with timestamp %ldms \\n \" , APP_NAME , ( unsigned long ) fibonacciCurrent , ( unsigned long ) timestamp ); fflush ( stdout );","title":"Publisher C API"},{"location":"examples/user_header/#subscriber-typed-c-api","text":"The boilerplate code for the subscriber is the same like for the publisher, therefore only the specific subscriber code is discussed in this section. To use the subscriber, subscriber.hpp needs to be included. Similar to the publisher, the subscriber requires the same additional template parameter when it is used with a user header. iox :: popo :: Subscriber < Data , Header > subscriber ({ \"Example\" , \"User-Header\" , \"Timestamp\" }); The main loop is quite simple. The publisher is periodically polled and the data of the received sample is printed. Again, the user-header is accessed by the getUserHeader method of the sample. while ( ! iox :: posix :: hasTerminationRequested ()) { subscriber . take (). and_then ([ & ]( auto & sample ) { std :: cout << APP_NAME << \" got value: \" << sample -> fibonacci << \" with timestamp \" << sample . getUserHeader (). publisherTimestamp << \"ms\" << std :: endl ; }); constexpr std :: chrono :: milliseconds SLEEP_TIME { 100U }; std :: this_thread :: sleep_for ( SLEEP_TIME ); }","title":"Subscriber Typed C++ API"},{"location":"examples/user_header/#subscriber-untyped-c-api","text":"On the subscriber side, the typed and untyped examples are even closer in similarity than the publisher example. The notable difference is the take method, which returns a void pointer to the user-payload. Like with the untyped publisher, in order to get the user-header the ChunkHeader must be obtained. Contrary to the untyped publisher, we must cast to a const T* type, like const Header* since we are not allowed to mutate the header from a subscriber. At the end, the chunk must be released to prevent chunk leaks. This is done by calling the release method with user-payload pointer. subscriber . take (). and_then ([ & ]( auto & userPayload ) { auto header = static_cast < const Header *> ( iox :: mepoo :: ChunkHeader :: fromUserPayload ( userPayload ) -> userHeader ()); auto data = static_cast < const Data *> ( userPayload ); std :: cout << APP_NAME << \" got value: \" << data -> fibonacci << \" with timestamp \" << header -> publisherTimestamp << \"ms\" << std :: endl ; subscriber . release ( userPayload ); });","title":"Subscriber Untyped C++ API"},{"location":"examples/user_header/#subscriber-c-api","text":"Finally there is the C API example. Like with the publisher example for the C API we just take a look at the user-header specific parts. The overall structure is the same like in the typed and untyped C++ API counterparts. As we already have seen with the untyped C++ example, the call to take the sample is independent of the usage of a user-header. Likewise, the access to the user-header is done by the intermediate step of getting an iox_chunk_header_t first. Since we are not allowed to mutate the user-header from a subscriber, the respective functions with a _const suffix must be used. At last, the chunk is released in order to prevent chunk leaks. const void * userPayload ; if ( iox_sub_take_chunk ( subscriber , & userPayload ) == ChunkReceiveResult_SUCCESS ) { const iox_chunk_header_t * chunkHeader = iox_chunk_header_from_user_payload_const ( userPayload ); const Header * header = ( const Header * )( iox_chunk_header_to_user_header_const ( chunkHeader )); const Data * data = ( const Data * ) userPayload ; // explicit cast to unsigned long since on macOS an uint64_t is a different built-in type than on Linux printf ( \"%s got value: %lu with timestamp %ldms \\n \" , APP_NAME , ( unsigned long ) data -> fibonacci , ( unsigned long ) header -> publisherTimestamp ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); } Check out User-Header on GitHub","title":"Subscriber C API"},{"location":"examples/waitset/","text":"WaitSet \ud83d\udd17 Thread Safety \ud83d\udd17 The WaitSet is not thread-safe! It is not allowed to attach or detach Triggerable classes with attachEvent or detachEvent when another thread is currently waiting for notifications with wait or timedWait . Do not call any of the WaitSet methods concurrently. The TriggerHandle on the other hand, is thread-safe! Therefore you are allowed to attach/detach a TriggerHandle to a Triggerable while another thread may trigger the TriggerHandle . Introduction \ud83d\udd17 The WaitSet is a set to which you can attach objects so that they can signal a wide variety of events to one single notifiable. The typical approach is that one creates a WaitSet, attaches multiple subscribers, user triggers or other Triggerables to it and then wait until one or many of the attached entities signal an event. If that happens one receives a list of NotificationInfos which is corresponding to all occurred events. Events and States \ud83d\udd17 In this context, we define the state of an object as a specified set of values to which the members of that object are set. An event on the other hand is defined as a state change. Usually, an event changes the state of the corresponding object but this is not mandatory. States and events can be attached to a WaitSet. The user will be informed only once by the WaitSet for every event which occurred. If the event occurred multiple times before the user has requested an event update from the WaitSet the user will still be informed only once. State changes are induced by events and the user will be informed about a specific state as long as the state persists. The subscriber for instance has the state SubscriberState::HAS_DATA and the event SubscriberEvent::DATA_RECEIVED . If you attach the subscriber event SubscriberEvent::DATA_RECEIVED to a WaitSet you will be notified about every new incoming sample whenever you call WaitSet::wait or WaitSet::timedWait . If multiple samples were sent before you called those methods you will still receive only one notification. If you attach the state SubscriberState::HAS_DATA you will be notified by WaitSet::wait or WaitSet::timedWait as long as there are received samples present in the subscriber queue. Expected Output \ud83d\udd17 Glossary \ud83d\udd17 Event a state change of an object; a Triggerable will signal an event via a TriggerHandle to a Notifyable . For instance one can attach the subscriber event DATA_RECEIVED to WaitSet . This will cause the subscriber to notify the WaitSet via the TriggerHandle everytime a sample was received. NotificationCallback a callback attached to a NotificationInfo . It must have the following signature void ( NotificationOrigin ) . Any free function, static class method and non capturing lambda expression is allowed. You have to ensure the lifetime of that callback. This can become important when you would like to use lambda expressions. NotificationId an id which is tagged to an event. It does not need to be unique or follow any restrictions. The user can choose any arbitrary uint64_t . Assigning the same NotificationId to multiple Events can be useful when you would like to group Events . NotificationInfo a class that corresponds to Triggers and is used to inform the user which Event occurred. You can use the NotificationInfo to acquire the NotificationId , call the NotificationCallback or acquire the NotificationOrigin . NotificationOrigin the pointer to the class where the Event originated from, short pointer to the Triggerable . Notifyable is a class which listens to events. A TriggerHandle which corresponds to a Trigger is used to notify the Notifyable that an event occurred. The WaitSet is a Notifyable . State a specified set of values to which the members of an object are set. Trigger a class which is used by the Notifyable to acquire the information which events were signalled. It corresponds to a TriggerHandle . If the Notifyable goes out of scope the corresponding TriggerHandle will be invalidated and if the Triggerable goes out of scope the corresponding Trigger will be invalidated. Triggerable a class which has attached a TriggerHandle to itself to signal certain Events to a Notifyable . TriggerHandle a thread-safe class which can be used to trigger a Notifyable . If a TriggerHandle goes out of scope it will detach itself from the Notifyable . A TriggerHandle is logical equal to another Trigger if they: are attached to the same Notifyable (or in other words they are using the same ConditionVariable ) they have the same NotificationOrigin they have the same callback to verify that they were triggered ( hasNotificationCallback ) they have the same NotificationId WaitSet a Notifyable which manages a set of Triggers which are corresponding to Events . A user may attach or detach events. The Waitset is listening to the whole set of Triggers and if one or more Triggers are triggered by an event it will notify the user. If a WaitSet goes out of scope all attached Triggers will be invalidated. Quick Overview \ud83d\udd17 Events or States can be attached to a Notifyable like the WaitSet . The WaitSet will listen on Triggers for a signal that an Event has occurred and it hands out TriggerHandles to Triggerable objects. The TriggerHandle is used to inform the WaitSet about the occurrence of an Event . When returning from WaitSet::wait() the user is provided with a vector of NotificationInfos associated with Events which had occurred and States which persists. The NotificationOrigin , NotificationId and NotificationCallback are stored inside of the NotificationInfo and can be acquired by the user. Warning Please be aware of the thread-safety restrictions of the WaitSet and read the Thread Safety chapter carefully. Reference \ud83d\udd17 task call attach subscriber event to a WaitSet waitset.attachEvent(subscriber, iox::popo::SubscriberEvent::DATA_RECEIVED, 123, &mySubscriberCallback) attach subscriber state to a WaitSet waitset.attachState(subscriber, iox::popo::SubscriberState::HAS_DATA, 123, &mySubscriberCallback) attach user trigger to a WaitSet waitset.attachEvent(userTrigger, 456, &myUserTriggerCallback) wait for triggers auto triggerVector = myWaitSet.wait(); wait for triggers with timeout auto triggerVector = myWaitSet.timedWait(1_s); check if event/state originated from some object notification->doesOriginateFrom(ptrToSomeObject) get id of the event/state notification->getNotificationId() call eventCallback (*notification)() acquire NotificationOrigin notification->getOrigin<OriginType>(); Use Cases \ud83d\udd17 This example consists of 6 use cases. ice_waitset_basic : A single subscriber is notified by the WaitSet if data arrives. ice_waitset_gateway.cpp : We build a gateway to forward data to another network. A list of subscriber events are handled in an uniform way by defining a callback which is executed for every subscriber who has received data. ice_waitset_grouping : We would like to group multiple subscribers into 2 distinct groups and handle them whenever they have a specified state according to their group membership. ice_waitset_individual : A list of subscribers where every subscriber is handled differently. ice_waitset_timer_driven_execution : We use the WaitSet to trigger a cyclic call which should execute an algorithm every 1 s. ice_waitset_trigger : We create our own class which can be attached to a WaitSet to signal states and events. Examples \ud83d\udd17 All our examples require a running iox-roudi and some data to receive which will be send by iox-cpp-waitset-publisher . The publisher does not contain any WaitSet specific logic and is explained in detail in the icedelivery example . Basic \ud83d\udd17 We create one subscriber and attach it to the WaitSet. Afterwards we wait for data in a loop and process it on arrival. To leave the loop and exit the application we have to register a signal handler that calls waitset.markForDestruction() which wakes up the blocking waitset->wait() whenever Ctrl+C is pressed. std :: atomic_bool keepRunning { true }; iox :: cxx :: optional < iox :: popo :: WaitSet <>> waitset ; static void sigHandler ( int sig IOX_MAYBE_UNUSED ) { keepRunning = false ; if ( waitset ) { waitset -> markForDestruction (); } } In the beginning we create the WaitSet. It is important to construct it only after the runtime has already been initialized since it internally depends on facilities set up by the runtime. Afterwards we register our signal handler which will unblock the WaitSet. Finally we attach the subscriber to the WaitSet stating that we want to be notified when it has data (indicated by iox::popo::SubscriberState::HAS_DATA ). It is good practice to handle potential failure while attaching, otherwise warnings will emerge since the return value cxx::expected is marked to require handling. In our case no errors should occur since the WaitSet can accomodate the two triggers we want to attach. waitset . emplace (); // register signal handler to handle termination of the loop auto signalGuard = iox :: posix :: registerSignalHandler ( iox :: posix :: Signal :: INT , sigHandler ); auto signalTermGuard = iox :: posix :: registerSignalHandler ( iox :: posix :: Signal :: TERM , sigHandler ); // create subscriber iox :: popo :: Subscriber < CounterTopic > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); // attach subscriber to waitset waitset -> attachState ( subscriber , iox :: popo :: SubscriberState :: HAS_DATA ). or_else ([]( auto ) { std :: cerr << \"failed to attach subscriber\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); We create a loop which we will exit as soon as someone presses CTRL+C and our signal handler sets keepRunning to false. If this happens markForDestruction turns the waitset->wait() into an empty non-blocking method and makes sure that we do not wait indefinitely. while ( keepRunning ) { // We block and wait for samples to arrive. auto notificationVector = waitset -> wait (); for ( auto & notification : notificationVector ) { // We woke up and hence there must be at least one sample. When the sigHandler has called // markForDestruction the notificationVector is empty otherwise we know which subscriber received samples // since we only attached one. // Best practice is to always acquire the notificationVector and iterate over all elements and then react // accordingly. When this is not done and more elements are attached to the WaitSet it can cause // problems since we either miss events or handle events for objects which never occurred. if ( notification -> doesOriginateFrom ( & subscriber )) { // Consume a sample subscriber . take () . and_then ([]( auto & sample ) { std :: cout << \" got value: \" << sample -> counter << std :: endl ; }) . or_else ([]( auto & reason ) { std :: cout << \"got no data, return code: \" << static_cast < uint64_t > ( reason ) << std :: endl ; }); // We could consume all samples but do not need to. // If there is more than one sample we will wake up again since the state of the subscriber is still // iox::popo::SubscriberState::HAS_DATA in this case. } } } Processing just one sample even if more might have arrived will cause wait to unblock again immediately to process the next sample (or shut down if requested). Due to the overhead of the wait call it may still be more efficient to process all samples in a loop until there are none left before waiting again, but it is not required. It would be required if we attach via attachEvent instead of attachState , since we might wake up due to the arrival of a second sample, only process the first and will not receive a wake up until a third sample arrives (which could be much later or never). Gateway \ud83d\udd17 We have a list of subscribers which can be subscribed to any arbitrary topic and everytime we receive a sample we would like to send the bytestream to a socket, write it into a file or print it to the console. But whatever we choose to do we perform the same task for all the subscribers. And since we process all incoming data right away we attach the SubscriberEvent::DATA_RECEIVED which notifies us only once. Let's start by implementing our callback which prints the subscriber pointer, the payload size and the payload pointer to the console. We have to process all samples as long as there are samples in the subscriber queue since we attached an event that notifies us only once. But it is impossible to miss samples since the notification is reset right after wait or timedWait is returned - this means if a sample arrives after those calls we will be notified again. Additionally, since we would like to count the sum of all processed samples, we add a second argument called sumOfAllSamples to the user defined context data. void subscriberCallback ( iox :: popo :: UntypedSubscriber * const subscriber , uint64_t * const sumOfAllSamples ) { while ( subscriber -> hasData ()) { subscriber -> take (). and_then ([ & ]( auto & userPayload ) { auto chunkHeader = iox :: mepoo :: ChunkHeader :: fromUserPayload ( userPayload ); auto flags = std :: cout . flags (); std :: cout << \"subscriber: \" << std :: hex << subscriber << \" length: \" << std :: dec << chunkHeader -> userPayloadSize () << \" ptr: \" << std :: hex << chunkHeader -> userPayload () << std :: dec << std :: endl ; std :: cout . setf ( flags ); }); // no nullptr check required since it is guaranteed != nullptr ++ ( * sumOfAllSamples ); } } The Event callback requires a signature of either void (NotificationOrigin) or void(NotificationOrigin, ContextDataType *) when one would like to provide an additional data pointer to the callback. In our example the NotificationOrigin is a iox::popo::UntypedSubscriber pointer which we use to acquire the latest sample by calling take() and the ContextDataType is an uint64_t used to count the processed samples. When take() was successful we print our message to the console inside of the and_then lambda. The shutdownTrigger uses a simpler callback which just informs us that we are exiting the program. Therefore we do not need an additional ContextDataType pointer. void shutdownCallback ( iox :: popo :: UserTrigger * ) { std :: cout << \"CTRL+C pressed - exiting now\" << std :: endl ; } In our main function we create a WaitSet which has storage capacity for 3 events, 2 subscribers and one shutdown trigger, after we registered us at our central broker RouDi. Then we attach our shutdownTrigger to handle CTRL+C events. iox :: popo :: WaitSet < NUMBER_OF_SUBSCRIBERS + ONE_SHUTDOWN_TRIGGER > waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger , iox :: popo :: createNotificationCallback ( shutdownCallback )). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); After that we define our sumOfAllSamples variable and create a vector to hold our subscribers. We create and then attach the subscribers to our WaitSet with the SubscriberEvent::DATA_RECEIVED event and the subscriberCallback . Everytime one of the subscribers is receiving a new sample it will trigger the WaitSet . Attention The user has to ensure that the contextData ( sumOfAllSamples ) in attachEvent lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling. uint64_t sumOfAllSamples = 0U ; // create subscribers and subscribe them to our service iox :: cxx :: vector < iox :: popo :: UntypedSubscriber , NUMBER_OF_SUBSCRIBERS > subscriberVector ; for ( auto i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriberVector . emplace_back ( iox :: capro :: ServiceDescription { \"Radar\" , \"FrontLeft\" , \"Counter\" }); auto & subscriber = subscriberVector . back (); /// important: the user has to ensure that the contextData (sumOfAllSamples) lives as long as /// the subscriber with its callback is attached to the listener waitset . attachEvent ( subscriber , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , 0 , createNotificationCallback ( subscriberCallback , sumOfAllSamples )) . or_else ([ & ]( auto ) { std :: cerr << \"failed to attach subscriber\" << i << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } attachEvent is returning a cxx::expected which informs us if attaching the event succeeded. In the .or_else([&](auto){/*...*/}) part we perform the error handling whenever attachEvent fails. Now our system is prepared and ready to work. We enter the event loop which starts with a call to our WaitSet ( waitset.wait() ). This call will block until one or more events triggered the WaitSet . After the call returned we get a vector filled with NotificationInfos which are corresponding to all the events which triggered the WaitSet . We iterate through this vector. If an Event originated from the shutdownTrigger we exit the program, otherwise we just call the assigned callback by calling the trigger. This will then call the subscriberCallback with the NotificationOrigin (the pointer to the untyped subscriber) and the contextData ( sumOfAllSamples ) as parameters. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { ( * notification )(); keepRunning = false ; } else { // call the callback which was assigned to the notification ( * notification )(); } } auto flags = std :: cout . flags (); std :: cout << \"sum of all samples: \" << std :: dec << sumOfAllSamples << std :: endl ; std :: cout . setf ( flags ); } Grouping \ud83d\udd17 In our next use case we would like to divide the subscribers into two groups and we do not want to attach a callback to them. Instead we perform the calls on the subscribers directly. Additionally, we would like to be notified as long as there are samples in the subscriber queue therefore we have to attach the SubscriberState::HAS_DATA . We again start by creating a WaitSet with a capacity of 5 (4 subscribers and 1 shutdownTrigger), and attach the shutdownTrigger to handle CTRL+C . iox :: popo :: WaitSet < NUMBER_OF_SUBSCRIBERS + ONE_SHUTDOWN_TRIGGER > waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger ). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Now we create a vector of 4 subscribers. iox :: cxx :: vector < iox :: popo :: UntypedSubscriber , NUMBER_OF_SUBSCRIBERS > subscriberVector ; for ( auto i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriberVector . emplace_back ( iox :: capro :: ServiceDescription { \"Radar\" , \"FrontLeft\" , \"Counter\" }); } After that, we define our two groups with the ids FIRST_GROUP_ID and SECOND_GROUP_ID and attach the first two subscribers with the state SubscriberState::HAS_DATA to the first group and the remaining subscribers to the second group. // attach the first two subscribers to waitset with a id of FIRST_GROUP_ID for ( auto i = 0U ; i < NUMBER_OF_SUBSCRIBERS / 2 ; ++ i ) { waitset . attachState ( subscriberVector [ i ], iox :: popo :: SubscriberState :: HAS_DATA , FIRST_GROUP_ID ) . or_else ([ & ]( auto ) { std :: cerr << \"failed to attach subscriber\" << i << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } // attach the remaining subscribers to waitset with a id of SECOND_GROUP_ID for ( auto i = NUMBER_OF_SUBSCRIBERS / 2 ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { waitset . attachState ( subscriberVector [ i ], iox :: popo :: SubscriberState :: HAS_DATA , SECOND_GROUP_ID ) . or_else ([ & ]( auto ) { std :: cerr << \"failed to attach subscriber\" << i << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } The event loop calls auto notificationVector = waitset.wait() in a blocking call to receive a vector of all the NotificationInfos which are corresponding to the occurred events. If the Event originated from the shutdownTrigger we terminate the program. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { keepRunning = false ; } // ... } std :: cout << std :: endl ; } The remaining part of the loop is handling the subscribers. In the first group we would like to print the received data to the console and in the second group we just dismiss the received data. // we print the received data for the first group else if ( notification -> getNotificationId () == FIRST_GROUP_ID ) { auto subscriber = notification -> getOrigin < iox :: popo :: UntypedSubscriber > (); subscriber -> take (). and_then ([ & ]( auto & userPayload ) { const CounterTopic * data = static_cast < const CounterTopic *> ( userPayload ); auto flags = std :: cout . flags (); std :: cout << \"received: \" << std :: dec << data -> counter << std :: endl ; std :: cout . setf ( flags ); subscriber -> release ( userPayload ); }); } // dismiss the received data for the second group else if ( notification -> getNotificationId () == SECOND_GROUP_ID ) { std :: cout << \"dismiss data \\n \" ; auto subscriber = notification -> getOrigin < iox :: popo :: UntypedSubscriber > (); // We need to release the data to reset the trigger hasData // otherwise the WaitSet would notify us in `waitset.wait()` again // instantly. subscriber -> releaseQueuedData (); } Attention For the second group we have to call releaseQueuedData to release the unread data. Otherwise we would be notified by the WaitSet immediately again since the subscriber has still the state HAS_DATA . Individual \ud83d\udd17 When every Triggerable requires a different reaction we need to know the origin of an Event . We can call event.doesOriginateFrom(NotificationOrigin) which will return true if the event originated from NotificationOrigin and otherwise false. We start this example by creating a WaitSet with the default capacity and attaching the shutdownTrigger to handle CTRL+C . iox :: popo :: WaitSet <> waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger ). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Additionally, we create two subscribers and attach them with the state SubscriberState::HAS_DATA to the WaitSet to let them inform us whenever they have samples in their queue. iox :: popo :: Subscriber < CounterTopic > subscriber1 ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); iox :: popo :: Subscriber < CounterTopic > subscriber2 ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); waitset . attachState ( subscriber1 , iox :: popo :: SubscriberState :: HAS_DATA ). or_else ([]( auto ) { std :: cerr << \"failed to attach subscriber1\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); waitset . attachState ( subscriber2 , iox :: popo :: SubscriberState :: HAS_DATA ). or_else ([]( auto ) { std :: cerr << \"failed to attach subscriber2\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); With that set up we enter the event loop and handle the program termination first. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { keepRunning = false ; } // ... } std :: cout << std :: endl ; } When the origin is subscriber1 we would like to print the received data to the console. But for subscriber2 we just dismiss the received samples. We accomplish this by asking the event if it originated from the corresponding subscriber. If so, we act. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { // ... // process sample received by subscriber1 else if ( notification -> doesOriginateFrom ( & subscriber1 )) { subscriber1 . take (). and_then ( [ & ]( auto & sample ) { std :: cout << \"subscriber 1 received: \" << sample -> counter << std :: endl ; }); } // dismiss sample received by subscriber2 if ( notification -> doesOriginateFrom ( & subscriber2 )) { // We need to release the samples to reset the trigger hasSamples // otherwise the WaitSet would notify us in `waitset.wait()` again // instantly. subscriber2 . releaseQueuedData (); std :: cout << \"subscriber 2 received something - dont care \\n \" ; } } std :: cout << std :: endl ; } Timer Driven Execution \ud83d\udd17 Let's say we have SomeClass and would like to execute a cyclic static method cyclicRun every second. We could execute any arbitrary algorithm in there but for now we just print activation callback . The class could look like class SomeClass { public : static void cyclicRun ( iox :: popo :: UserTrigger * ) { std :: cout << \"activation callback \\n \" ; } }; Attention The user trigger is event based and always reset after the WaitSet has acquired all triggered objects. As always, we begin by creating a WaitSet with the default capacity and by attaching the shutdownTrigger to it. In this case we do not set an event id when calling attachEvent which means the default event id NotificationInfo::INVALID_ID is set. iox :: popo :: WaitSet <> waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger ). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); After that we require a cyclicTrigger to trigger our cyclicRun every second. Therefore, we attach it to the waitset with eventId 0 and the callback SomeClass::cyclicRun iox :: popo :: UserTrigger cyclicTrigger ; waitset . attachEvent ( cyclicTrigger , 0U , createNotificationCallback ( SomeClass :: cyclicRun )). or_else ([]( auto ) { std :: cerr << \"failed to attach cyclic trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); The next thing we need is something which will trigger our cyclicTrigger every second. We use an infinite loop packed inside of a thread. std :: thread cyclicTriggerThread ([ & ] { while ( keepRunning . load ()) { cyclicTrigger . trigger (); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); } }); Everything is set up and we can implement the event loop. As usual we handle CTRL+C which is indicated by the shutdownTrigger . while ( keepRunning . load ()) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning . store ( false ); } // ... } std :: cout << std :: endl ; } The cyclicTrigger callback is called in the else part. while ( keepRunning . load ()) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { // ... else { // call SomeClass::cyclicRun ( * notification )(); } } std :: cout << std :: endl ; } Trigger \ud83d\udd17 In this example we describe how you would implement a Triggerable class which can be attached to a WaitSet or a Listener . Our class in this example will be called MyTriggerClass and it can signal the WaitSet the two states HAS_PERFORMED_ACTION and IS_ACTIVATED . Furthermore, we can also attach the two corresponding events PERFORM_ACTION_CALLED and ACTIVATE_CALLED . The PERFORM_ACTION_CALLED event is triggered whenever the method performAction is called and the state HAS_PERFORMED_ACTION persists until someone resets the state with the method reset() . The same applies to the event ACTIVATE_CALLED which is triggered by an activate() call and the corresponding state IS_ACTIVATED which stays until someone resets it with reset() . MyTriggerClass \ud83d\udd17 Attaching States \ud83d\udd17 A class that would like to attach states to a WaitSet has to implement the following methods. void enableState(iox::popo::TriggerHandle&&, const UserDefinedStateEnum ) Used by the WaitSet to attach a trigger handle to the object so that the object can notify the WaitSet that it entered a certain state. void disableState(const UserDefinedStateEnum) Called whenever the user detaches the state from the WaitSet . void invalidateTrigger(const uint64_t uniqueTriggerId) If the WaitSet goes out of scope it calls this method to invalidate the loan trigger. iox::popo::WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied(const UserDefinedStateEnum) With every iteration the WaitSet has to ask the object if the attached state still persists. This is done with the isStateConditionSatisfied callback which will be returned here. The UserDefinedStateEnum can be some arbitrary enum class which requires iox::popo::StateEnumIdentifier as underlying type so that it can be identified as an enum which describes certain states. In our example it is called MyTriggerClassStates . enum class MyTriggerClassStates : iox :: popo :: StateEnumIdentifier { HAS_PERFORMED_ACTION , IS_ACTIVATED }; Attaching Events \ud83d\udd17 Events can be attached to WaitSets and Listeners . For this to work the class has to implement the following methods. void enableEvent(iox::popo::TriggerHandle&&, const UserDefinedEventEnum) Used by the WaitSet or the Listener to attach a trigger handle which signals certain events to them. void disableEvent(const UserDefinedEventEnum) Called whenever the user detaches the event from the WaitSet or the Listener . void invalidateTrigger(const uint64_t uniqueTriggerId) Used to clean up all loan trigger handles when the WaitSet or Listener goes out of scope. Like with the state enum the event enum can be also any arbitrary enum class which has iox::popo::EventEnumIdentifier as an underlying type. In our example it is called MyTriggerClassEvents . enum class MyTriggerClassEvents : iox :: popo :: EventEnumIdentifier { PERFORM_ACTION_CALLED , ACTIVATE_CALLED }; Further Requirements \ud83d\udd17 friend iox::popo::NotificationAttorney Methods like enableEvent , disableEvent etc. should never be accessible via the public API and should be therefore private. To avoid that every class has to befriend the WaitSet , Listener and other internal structures we implemented the client attorney pattern and the class has only to befriend the iox::popo::NotificationAttorney . Deleted move and copy operations At the moment the WaitSet does not support Triggerable classes which are movable or copyable. This is caused by the resetCallback and the isStateConditionSatisfied callback which are pointing to the Triggerable . After a move the callbacks inside of the WaitSet would point to the wrong memory location and a copy could lead to an unattached object if there is no more space left in the WaitSet . Therefore we have to delete the move and copy operations for now. MyTriggerClass ( const MyTriggerClass & ) = delete ; MyTriggerClass ( MyTriggerClass && ) = delete ; MyTriggerClass & operator = ( const MyTriggerClass & ) = delete ; MyTriggerClass & operator = ( MyTriggerClass && ) = delete ; Implementation \ud83d\udd17 The method implementation of the two actions activate and performAction which trigger an event and causing a state change look like the following. // When you call this method you will trigger the ACTIVATE event void activate ( const uint64_t activationCode ) noexcept { m_activationCode = activationCode ; m_isActivated = true ; m_activateTrigger . trigger (); } // Calling this method will trigger the PERFORMED_ACTION event void performAction () noexcept { m_hasPerformedAction = true ; m_onActionTrigger . trigger (); } As you can see we perform some internal action and when they are finished we signal the corresponding Trigger via our stored TriggerHandle that we performed the task. Internally we just set a boolean to signal that the method was called. Every state based Trigger requires a corresponding class method which returns a boolean stating if the state which led to the trigger still persists. In our case these are the two const methods hasPerformedAction and isActivated . // required by the m_onActionTrigger to ask the class if it was triggered bool hasPerformedAction () const noexcept { return m_hasPerformedAction ; } // required by the m_activateTrigger to ask the class if it was triggered bool isActivated () const noexcept { return m_isActivated ; } Since the following methods should not be accessible by the public but must be accessible by any Notifyable like the WaitSet and to avoid that we have to befriend every possible Notifyable we created the NotificationAttorney . Every Triggerable has to befriend the NotificationAttorney which provides access to the private methods enableEvent / enableState , disableEvent / disableState , invalidateTrigger and getCallbackForIsStateConditionSatisfied to all Notifyables . friend iox :: popo :: NotificationAttorney ; The method enableEvent is called by the WaitSet when a MyTriggerClass event is being attached to it. During that process the WaitSet creates a triggerHandle and forwards the event to which this handle belongs. In the switch case statement we assign the triggerHandle to the corresponding internal trigger handle. void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle , const MyTriggerClassEvents event ) noexcept { switch ( event ) { case MyTriggerClassEvents :: PERFORM_ACTION_CALLED : m_onActionTrigger = std :: move ( triggerHandle ); break ; case MyTriggerClassEvents :: ACTIVATE_CALLED : m_activateTrigger = std :: move ( triggerHandle ); break ; } } Attaching a state works in a similar way. void enableState ( iox :: popo :: TriggerHandle && triggerHandle , const MyTriggerClassStates state ) noexcept { switch ( state ) { case MyTriggerClassStates :: HAS_PERFORMED_ACTION : m_onActionTrigger = std :: move ( triggerHandle ); break ; case MyTriggerClassStates :: IS_ACTIVATED : m_activateTrigger = std :: move ( triggerHandle ); break ; } } It is possible to use the same trigger for either a state or an event attachment but then we loose the ability to attach the state and the corresponding event at the same time to a WaitSet . In most cases it is not a problem and when you attach an event when the corresponding state is already attached you will get a warning message on the terminal and the already attached event is detached so that the state can be attached. This is realized via the RAII idiom. The next thing on our checklist is the invalidateTrigger method used by the WaitSet to reset the Trigger when it goes out of scope. Therefore we look up the correct unique trigger id first and then invalidate it to make them unusable in the future. void invalidateTrigger ( const uint64_t uniqueTriggerId ) { if ( m_onActionTrigger . getUniqueId () == uniqueTriggerId ) { m_onActionTrigger . invalidate (); } else if ( m_activateTrigger . getUniqueId () == uniqueTriggerId ) { m_activateTrigger . invalidate (); } } Detaching an event in the WaitSet will lead to a call to disableEvent in our class. In this case we have to reset the corresponding trigger to invalidate and release it from the WaitSet . Like before we use a switch case statement to find the trigger corresponding to the event. void disableEvent ( const MyTriggerClassEvents event ) noexcept { switch ( event ) { case MyTriggerClassEvents :: PERFORM_ACTION_CALLED : m_onActionTrigger . reset (); break ; case MyTriggerClassEvents :: ACTIVATE_CALLED : m_activateTrigger . reset (); break ; } } The same idea is used when detaching a state. void disableState ( const MyTriggerClassStates state ) noexcept { switch ( state ) { case MyTriggerClassStates :: HAS_PERFORMED_ACTION : m_onActionTrigger . reset (); break ; case MyTriggerClassStates :: IS_ACTIVATED : m_activateTrigger . reset (); break ; } } The last method we have to implement is getCallbackForIsStateConditionSatisfied . The WaitSet can handle state based attachments and therefore it requires, beside the condition variable which only states that something has happened, a callback to find the object where it happened. This is the isStateConditionSatisfied callback. In our case we either return the method pointer to hasPerformedAction or isActivated depending on which state was requested. iox :: popo :: WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const MyTriggerClassStates event ) const noexcept { switch ( event ) { case MyTriggerClassStates :: HAS_PERFORMED_ACTION : return { * this , & MyTriggerClass :: hasPerformedAction }; case MyTriggerClassStates :: IS_ACTIVATED : return { * this , & MyTriggerClass :: isActivated }; } return {}; } Using MyTriggerClass \ud83d\udd17 The next thing we define is a free function, our eventLoop , which will handle all events of our WaitSet . Since we would like to attach the IS_ACTIVATED state we have to reset the state whenever it occurs otherwise the WaitSet will notify us right away since the state still persists. The second attachment will be an event attachment and the WaitSet informs us just once that the event has occurred which makes the reset call obsolete. void eventLoop () { while ( keepRunning ) { auto notificationVector = waitset -> wait (); for ( auto & notification : notificationVector ) { if ( notification -> getNotificationId () == ACTIVATE_ID ) { // reset MyTriggerClass instance state notification -> getOrigin < MyTriggerClass > () -> reset ( MyTriggerClassStates :: IS_ACTIVATED ); // call the callback attached to the trigger ( * notification )(); } else if ( notification -> getNotificationId () == ACTION_ID ) { // reset is not required since we attached an notification here. we will be notified once ( * notification )(); } } } } We start like in every other example by creating the waitset first. In this case the waitset and the triggerClass are stored inside of two global optional 's and have to be created with an emplace call. waitset . emplace (); triggerClass . emplace (); After that we can attach the IS_ACTIVATED state and PERFORM_ACTION_CALLED event to the waitset and provide a callback for them. // attach the IS_ACTIVATED state to the waitset and assign a callback waitset -> attachState ( * triggerClass , MyTriggerClassStates :: IS_ACTIVATED , ACTIVATE_ID , iox :: popo :: createNotificationCallback ( callOnActivate )) . or_else ([]( auto ) { std :: cerr << \"failed to attach MyTriggerClassStates::IS_ACTIVATED state \" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); // attach the PERFORM_ACTION_CALLED event to the waitset and assign a callback waitset -> attachEvent ( * triggerClass , MyTriggerClassEvents :: PERFORM_ACTION_CALLED , ACTION_ID , iox :: popo :: createNotificationCallback ( MyTriggerClass :: callOnAction )) . or_else ([]( auto ) { std :: cerr << \"failed to attach MyTriggerClassEvents::PERFORM_ACTION_CALLED event \" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Now that everything is set up we can start our eventLoop in a new thread. std :: thread eventLoopThread ( eventLoop ); A thread which will trigger an event every second is started with the following lines. std :: thread triggerThread ([ & ] { uint64_t activationCode = 1U ; for ( auto i = 0U ; i < 10 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); triggerClass -> activate ( activationCode ++ ); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); triggerClass -> performAction (); } std :: cout << \"Sending final trigger\" << std :: endl ; keepRunning = false ; triggerClass -> activate ( activationCode ++ ); triggerClass -> performAction (); }); Check out waitset on GitHub","title":"Waiting for events like arrival of data using C++"},{"location":"examples/waitset/#waitset","text":"","title":"WaitSet"},{"location":"examples/waitset/#thread-safety","text":"The WaitSet is not thread-safe! It is not allowed to attach or detach Triggerable classes with attachEvent or detachEvent when another thread is currently waiting for notifications with wait or timedWait . Do not call any of the WaitSet methods concurrently. The TriggerHandle on the other hand, is thread-safe! Therefore you are allowed to attach/detach a TriggerHandle to a Triggerable while another thread may trigger the TriggerHandle .","title":"Thread Safety"},{"location":"examples/waitset/#introduction","text":"The WaitSet is a set to which you can attach objects so that they can signal a wide variety of events to one single notifiable. The typical approach is that one creates a WaitSet, attaches multiple subscribers, user triggers or other Triggerables to it and then wait until one or many of the attached entities signal an event. If that happens one receives a list of NotificationInfos which is corresponding to all occurred events.","title":"Introduction"},{"location":"examples/waitset/#events-and-states","text":"In this context, we define the state of an object as a specified set of values to which the members of that object are set. An event on the other hand is defined as a state change. Usually, an event changes the state of the corresponding object but this is not mandatory. States and events can be attached to a WaitSet. The user will be informed only once by the WaitSet for every event which occurred. If the event occurred multiple times before the user has requested an event update from the WaitSet the user will still be informed only once. State changes are induced by events and the user will be informed about a specific state as long as the state persists. The subscriber for instance has the state SubscriberState::HAS_DATA and the event SubscriberEvent::DATA_RECEIVED . If you attach the subscriber event SubscriberEvent::DATA_RECEIVED to a WaitSet you will be notified about every new incoming sample whenever you call WaitSet::wait or WaitSet::timedWait . If multiple samples were sent before you called those methods you will still receive only one notification. If you attach the state SubscriberState::HAS_DATA you will be notified by WaitSet::wait or WaitSet::timedWait as long as there are received samples present in the subscriber queue.","title":"Events and States"},{"location":"examples/waitset/#expected-output","text":"","title":"Expected Output"},{"location":"examples/waitset/#glossary","text":"Event a state change of an object; a Triggerable will signal an event via a TriggerHandle to a Notifyable . For instance one can attach the subscriber event DATA_RECEIVED to WaitSet . This will cause the subscriber to notify the WaitSet via the TriggerHandle everytime a sample was received. NotificationCallback a callback attached to a NotificationInfo . It must have the following signature void ( NotificationOrigin ) . Any free function, static class method and non capturing lambda expression is allowed. You have to ensure the lifetime of that callback. This can become important when you would like to use lambda expressions. NotificationId an id which is tagged to an event. It does not need to be unique or follow any restrictions. The user can choose any arbitrary uint64_t . Assigning the same NotificationId to multiple Events can be useful when you would like to group Events . NotificationInfo a class that corresponds to Triggers and is used to inform the user which Event occurred. You can use the NotificationInfo to acquire the NotificationId , call the NotificationCallback or acquire the NotificationOrigin . NotificationOrigin the pointer to the class where the Event originated from, short pointer to the Triggerable . Notifyable is a class which listens to events. A TriggerHandle which corresponds to a Trigger is used to notify the Notifyable that an event occurred. The WaitSet is a Notifyable . State a specified set of values to which the members of an object are set. Trigger a class which is used by the Notifyable to acquire the information which events were signalled. It corresponds to a TriggerHandle . If the Notifyable goes out of scope the corresponding TriggerHandle will be invalidated and if the Triggerable goes out of scope the corresponding Trigger will be invalidated. Triggerable a class which has attached a TriggerHandle to itself to signal certain Events to a Notifyable . TriggerHandle a thread-safe class which can be used to trigger a Notifyable . If a TriggerHandle goes out of scope it will detach itself from the Notifyable . A TriggerHandle is logical equal to another Trigger if they: are attached to the same Notifyable (or in other words they are using the same ConditionVariable ) they have the same NotificationOrigin they have the same callback to verify that they were triggered ( hasNotificationCallback ) they have the same NotificationId WaitSet a Notifyable which manages a set of Triggers which are corresponding to Events . A user may attach or detach events. The Waitset is listening to the whole set of Triggers and if one or more Triggers are triggered by an event it will notify the user. If a WaitSet goes out of scope all attached Triggers will be invalidated.","title":"Glossary"},{"location":"examples/waitset/#quick-overview","text":"Events or States can be attached to a Notifyable like the WaitSet . The WaitSet will listen on Triggers for a signal that an Event has occurred and it hands out TriggerHandles to Triggerable objects. The TriggerHandle is used to inform the WaitSet about the occurrence of an Event . When returning from WaitSet::wait() the user is provided with a vector of NotificationInfos associated with Events which had occurred and States which persists. The NotificationOrigin , NotificationId and NotificationCallback are stored inside of the NotificationInfo and can be acquired by the user. Warning Please be aware of the thread-safety restrictions of the WaitSet and read the Thread Safety chapter carefully.","title":"Quick Overview"},{"location":"examples/waitset/#reference","text":"task call attach subscriber event to a WaitSet waitset.attachEvent(subscriber, iox::popo::SubscriberEvent::DATA_RECEIVED, 123, &mySubscriberCallback) attach subscriber state to a WaitSet waitset.attachState(subscriber, iox::popo::SubscriberState::HAS_DATA, 123, &mySubscriberCallback) attach user trigger to a WaitSet waitset.attachEvent(userTrigger, 456, &myUserTriggerCallback) wait for triggers auto triggerVector = myWaitSet.wait(); wait for triggers with timeout auto triggerVector = myWaitSet.timedWait(1_s); check if event/state originated from some object notification->doesOriginateFrom(ptrToSomeObject) get id of the event/state notification->getNotificationId() call eventCallback (*notification)() acquire NotificationOrigin notification->getOrigin<OriginType>();","title":"Reference"},{"location":"examples/waitset/#use-cases","text":"This example consists of 6 use cases. ice_waitset_basic : A single subscriber is notified by the WaitSet if data arrives. ice_waitset_gateway.cpp : We build a gateway to forward data to another network. A list of subscriber events are handled in an uniform way by defining a callback which is executed for every subscriber who has received data. ice_waitset_grouping : We would like to group multiple subscribers into 2 distinct groups and handle them whenever they have a specified state according to their group membership. ice_waitset_individual : A list of subscribers where every subscriber is handled differently. ice_waitset_timer_driven_execution : We use the WaitSet to trigger a cyclic call which should execute an algorithm every 1 s. ice_waitset_trigger : We create our own class which can be attached to a WaitSet to signal states and events.","title":"Use Cases"},{"location":"examples/waitset/#examples","text":"All our examples require a running iox-roudi and some data to receive which will be send by iox-cpp-waitset-publisher . The publisher does not contain any WaitSet specific logic and is explained in detail in the icedelivery example .","title":"Examples"},{"location":"examples/waitset/#basic","text":"We create one subscriber and attach it to the WaitSet. Afterwards we wait for data in a loop and process it on arrival. To leave the loop and exit the application we have to register a signal handler that calls waitset.markForDestruction() which wakes up the blocking waitset->wait() whenever Ctrl+C is pressed. std :: atomic_bool keepRunning { true }; iox :: cxx :: optional < iox :: popo :: WaitSet <>> waitset ; static void sigHandler ( int sig IOX_MAYBE_UNUSED ) { keepRunning = false ; if ( waitset ) { waitset -> markForDestruction (); } } In the beginning we create the WaitSet. It is important to construct it only after the runtime has already been initialized since it internally depends on facilities set up by the runtime. Afterwards we register our signal handler which will unblock the WaitSet. Finally we attach the subscriber to the WaitSet stating that we want to be notified when it has data (indicated by iox::popo::SubscriberState::HAS_DATA ). It is good practice to handle potential failure while attaching, otherwise warnings will emerge since the return value cxx::expected is marked to require handling. In our case no errors should occur since the WaitSet can accomodate the two triggers we want to attach. waitset . emplace (); // register signal handler to handle termination of the loop auto signalGuard = iox :: posix :: registerSignalHandler ( iox :: posix :: Signal :: INT , sigHandler ); auto signalTermGuard = iox :: posix :: registerSignalHandler ( iox :: posix :: Signal :: TERM , sigHandler ); // create subscriber iox :: popo :: Subscriber < CounterTopic > subscriber ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); // attach subscriber to waitset waitset -> attachState ( subscriber , iox :: popo :: SubscriberState :: HAS_DATA ). or_else ([]( auto ) { std :: cerr << \"failed to attach subscriber\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); We create a loop which we will exit as soon as someone presses CTRL+C and our signal handler sets keepRunning to false. If this happens markForDestruction turns the waitset->wait() into an empty non-blocking method and makes sure that we do not wait indefinitely. while ( keepRunning ) { // We block and wait for samples to arrive. auto notificationVector = waitset -> wait (); for ( auto & notification : notificationVector ) { // We woke up and hence there must be at least one sample. When the sigHandler has called // markForDestruction the notificationVector is empty otherwise we know which subscriber received samples // since we only attached one. // Best practice is to always acquire the notificationVector and iterate over all elements and then react // accordingly. When this is not done and more elements are attached to the WaitSet it can cause // problems since we either miss events or handle events for objects which never occurred. if ( notification -> doesOriginateFrom ( & subscriber )) { // Consume a sample subscriber . take () . and_then ([]( auto & sample ) { std :: cout << \" got value: \" << sample -> counter << std :: endl ; }) . or_else ([]( auto & reason ) { std :: cout << \"got no data, return code: \" << static_cast < uint64_t > ( reason ) << std :: endl ; }); // We could consume all samples but do not need to. // If there is more than one sample we will wake up again since the state of the subscriber is still // iox::popo::SubscriberState::HAS_DATA in this case. } } } Processing just one sample even if more might have arrived will cause wait to unblock again immediately to process the next sample (or shut down if requested). Due to the overhead of the wait call it may still be more efficient to process all samples in a loop until there are none left before waiting again, but it is not required. It would be required if we attach via attachEvent instead of attachState , since we might wake up due to the arrival of a second sample, only process the first and will not receive a wake up until a third sample arrives (which could be much later or never).","title":"Basic"},{"location":"examples/waitset/#gateway","text":"We have a list of subscribers which can be subscribed to any arbitrary topic and everytime we receive a sample we would like to send the bytestream to a socket, write it into a file or print it to the console. But whatever we choose to do we perform the same task for all the subscribers. And since we process all incoming data right away we attach the SubscriberEvent::DATA_RECEIVED which notifies us only once. Let's start by implementing our callback which prints the subscriber pointer, the payload size and the payload pointer to the console. We have to process all samples as long as there are samples in the subscriber queue since we attached an event that notifies us only once. But it is impossible to miss samples since the notification is reset right after wait or timedWait is returned - this means if a sample arrives after those calls we will be notified again. Additionally, since we would like to count the sum of all processed samples, we add a second argument called sumOfAllSamples to the user defined context data. void subscriberCallback ( iox :: popo :: UntypedSubscriber * const subscriber , uint64_t * const sumOfAllSamples ) { while ( subscriber -> hasData ()) { subscriber -> take (). and_then ([ & ]( auto & userPayload ) { auto chunkHeader = iox :: mepoo :: ChunkHeader :: fromUserPayload ( userPayload ); auto flags = std :: cout . flags (); std :: cout << \"subscriber: \" << std :: hex << subscriber << \" length: \" << std :: dec << chunkHeader -> userPayloadSize () << \" ptr: \" << std :: hex << chunkHeader -> userPayload () << std :: dec << std :: endl ; std :: cout . setf ( flags ); }); // no nullptr check required since it is guaranteed != nullptr ++ ( * sumOfAllSamples ); } } The Event callback requires a signature of either void (NotificationOrigin) or void(NotificationOrigin, ContextDataType *) when one would like to provide an additional data pointer to the callback. In our example the NotificationOrigin is a iox::popo::UntypedSubscriber pointer which we use to acquire the latest sample by calling take() and the ContextDataType is an uint64_t used to count the processed samples. When take() was successful we print our message to the console inside of the and_then lambda. The shutdownTrigger uses a simpler callback which just informs us that we are exiting the program. Therefore we do not need an additional ContextDataType pointer. void shutdownCallback ( iox :: popo :: UserTrigger * ) { std :: cout << \"CTRL+C pressed - exiting now\" << std :: endl ; } In our main function we create a WaitSet which has storage capacity for 3 events, 2 subscribers and one shutdown trigger, after we registered us at our central broker RouDi. Then we attach our shutdownTrigger to handle CTRL+C events. iox :: popo :: WaitSet < NUMBER_OF_SUBSCRIBERS + ONE_SHUTDOWN_TRIGGER > waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger , iox :: popo :: createNotificationCallback ( shutdownCallback )). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); After that we define our sumOfAllSamples variable and create a vector to hold our subscribers. We create and then attach the subscribers to our WaitSet with the SubscriberEvent::DATA_RECEIVED event and the subscriberCallback . Everytime one of the subscribers is receiving a new sample it will trigger the WaitSet . Attention The user has to ensure that the contextData ( sumOfAllSamples ) in attachEvent lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling. uint64_t sumOfAllSamples = 0U ; // create subscribers and subscribe them to our service iox :: cxx :: vector < iox :: popo :: UntypedSubscriber , NUMBER_OF_SUBSCRIBERS > subscriberVector ; for ( auto i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriberVector . emplace_back ( iox :: capro :: ServiceDescription { \"Radar\" , \"FrontLeft\" , \"Counter\" }); auto & subscriber = subscriberVector . back (); /// important: the user has to ensure that the contextData (sumOfAllSamples) lives as long as /// the subscriber with its callback is attached to the listener waitset . attachEvent ( subscriber , iox :: popo :: SubscriberEvent :: DATA_RECEIVED , 0 , createNotificationCallback ( subscriberCallback , sumOfAllSamples )) . or_else ([ & ]( auto ) { std :: cerr << \"failed to attach subscriber\" << i << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } attachEvent is returning a cxx::expected which informs us if attaching the event succeeded. In the .or_else([&](auto){/*...*/}) part we perform the error handling whenever attachEvent fails. Now our system is prepared and ready to work. We enter the event loop which starts with a call to our WaitSet ( waitset.wait() ). This call will block until one or more events triggered the WaitSet . After the call returned we get a vector filled with NotificationInfos which are corresponding to all the events which triggered the WaitSet . We iterate through this vector. If an Event originated from the shutdownTrigger we exit the program, otherwise we just call the assigned callback by calling the trigger. This will then call the subscriberCallback with the NotificationOrigin (the pointer to the untyped subscriber) and the contextData ( sumOfAllSamples ) as parameters. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { ( * notification )(); keepRunning = false ; } else { // call the callback which was assigned to the notification ( * notification )(); } } auto flags = std :: cout . flags (); std :: cout << \"sum of all samples: \" << std :: dec << sumOfAllSamples << std :: endl ; std :: cout . setf ( flags ); }","title":"Gateway"},{"location":"examples/waitset/#grouping","text":"In our next use case we would like to divide the subscribers into two groups and we do not want to attach a callback to them. Instead we perform the calls on the subscribers directly. Additionally, we would like to be notified as long as there are samples in the subscriber queue therefore we have to attach the SubscriberState::HAS_DATA . We again start by creating a WaitSet with a capacity of 5 (4 subscribers and 1 shutdownTrigger), and attach the shutdownTrigger to handle CTRL+C . iox :: popo :: WaitSet < NUMBER_OF_SUBSCRIBERS + ONE_SHUTDOWN_TRIGGER > waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger ). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Now we create a vector of 4 subscribers. iox :: cxx :: vector < iox :: popo :: UntypedSubscriber , NUMBER_OF_SUBSCRIBERS > subscriberVector ; for ( auto i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriberVector . emplace_back ( iox :: capro :: ServiceDescription { \"Radar\" , \"FrontLeft\" , \"Counter\" }); } After that, we define our two groups with the ids FIRST_GROUP_ID and SECOND_GROUP_ID and attach the first two subscribers with the state SubscriberState::HAS_DATA to the first group and the remaining subscribers to the second group. // attach the first two subscribers to waitset with a id of FIRST_GROUP_ID for ( auto i = 0U ; i < NUMBER_OF_SUBSCRIBERS / 2 ; ++ i ) { waitset . attachState ( subscriberVector [ i ], iox :: popo :: SubscriberState :: HAS_DATA , FIRST_GROUP_ID ) . or_else ([ & ]( auto ) { std :: cerr << \"failed to attach subscriber\" << i << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } // attach the remaining subscribers to waitset with a id of SECOND_GROUP_ID for ( auto i = NUMBER_OF_SUBSCRIBERS / 2 ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { waitset . attachState ( subscriberVector [ i ], iox :: popo :: SubscriberState :: HAS_DATA , SECOND_GROUP_ID ) . or_else ([ & ]( auto ) { std :: cerr << \"failed to attach subscriber\" << i << std :: endl ; std :: exit ( EXIT_FAILURE ); }); } The event loop calls auto notificationVector = waitset.wait() in a blocking call to receive a vector of all the NotificationInfos which are corresponding to the occurred events. If the Event originated from the shutdownTrigger we terminate the program. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { keepRunning = false ; } // ... } std :: cout << std :: endl ; } The remaining part of the loop is handling the subscribers. In the first group we would like to print the received data to the console and in the second group we just dismiss the received data. // we print the received data for the first group else if ( notification -> getNotificationId () == FIRST_GROUP_ID ) { auto subscriber = notification -> getOrigin < iox :: popo :: UntypedSubscriber > (); subscriber -> take (). and_then ([ & ]( auto & userPayload ) { const CounterTopic * data = static_cast < const CounterTopic *> ( userPayload ); auto flags = std :: cout . flags (); std :: cout << \"received: \" << std :: dec << data -> counter << std :: endl ; std :: cout . setf ( flags ); subscriber -> release ( userPayload ); }); } // dismiss the received data for the second group else if ( notification -> getNotificationId () == SECOND_GROUP_ID ) { std :: cout << \"dismiss data \\n \" ; auto subscriber = notification -> getOrigin < iox :: popo :: UntypedSubscriber > (); // We need to release the data to reset the trigger hasData // otherwise the WaitSet would notify us in `waitset.wait()` again // instantly. subscriber -> releaseQueuedData (); } Attention For the second group we have to call releaseQueuedData to release the unread data. Otherwise we would be notified by the WaitSet immediately again since the subscriber has still the state HAS_DATA .","title":"Grouping"},{"location":"examples/waitset/#individual","text":"When every Triggerable requires a different reaction we need to know the origin of an Event . We can call event.doesOriginateFrom(NotificationOrigin) which will return true if the event originated from NotificationOrigin and otherwise false. We start this example by creating a WaitSet with the default capacity and attaching the shutdownTrigger to handle CTRL+C . iox :: popo :: WaitSet <> waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger ). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Additionally, we create two subscribers and attach them with the state SubscriberState::HAS_DATA to the WaitSet to let them inform us whenever they have samples in their queue. iox :: popo :: Subscriber < CounterTopic > subscriber1 ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); iox :: popo :: Subscriber < CounterTopic > subscriber2 ({ \"Radar\" , \"FrontLeft\" , \"Counter\" }); waitset . attachState ( subscriber1 , iox :: popo :: SubscriberState :: HAS_DATA ). or_else ([]( auto ) { std :: cerr << \"failed to attach subscriber1\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); waitset . attachState ( subscriber2 , iox :: popo :: SubscriberState :: HAS_DATA ). or_else ([]( auto ) { std :: cerr << \"failed to attach subscriber2\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); With that set up we enter the event loop and handle the program termination first. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { keepRunning = false ; } // ... } std :: cout << std :: endl ; } When the origin is subscriber1 we would like to print the received data to the console. But for subscriber2 we just dismiss the received samples. We accomplish this by asking the event if it originated from the corresponding subscriber. If so, we act. while ( keepRunning ) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { // ... // process sample received by subscriber1 else if ( notification -> doesOriginateFrom ( & subscriber1 )) { subscriber1 . take (). and_then ( [ & ]( auto & sample ) { std :: cout << \"subscriber 1 received: \" << sample -> counter << std :: endl ; }); } // dismiss sample received by subscriber2 if ( notification -> doesOriginateFrom ( & subscriber2 )) { // We need to release the samples to reset the trigger hasSamples // otherwise the WaitSet would notify us in `waitset.wait()` again // instantly. subscriber2 . releaseQueuedData (); std :: cout << \"subscriber 2 received something - dont care \\n \" ; } } std :: cout << std :: endl ; }","title":"Individual"},{"location":"examples/waitset/#timer-driven-execution","text":"Let's say we have SomeClass and would like to execute a cyclic static method cyclicRun every second. We could execute any arbitrary algorithm in there but for now we just print activation callback . The class could look like class SomeClass { public : static void cyclicRun ( iox :: popo :: UserTrigger * ) { std :: cout << \"activation callback \\n \" ; } }; Attention The user trigger is event based and always reset after the WaitSet has acquired all triggered objects. As always, we begin by creating a WaitSet with the default capacity and by attaching the shutdownTrigger to it. In this case we do not set an event id when calling attachEvent which means the default event id NotificationInfo::INVALID_ID is set. iox :: popo :: WaitSet <> waitset ; // attach shutdownTrigger to handle CTRL+C waitset . attachEvent ( shutdownTrigger ). or_else ([]( auto ) { std :: cerr << \"failed to attach shutdown trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); After that we require a cyclicTrigger to trigger our cyclicRun every second. Therefore, we attach it to the waitset with eventId 0 and the callback SomeClass::cyclicRun iox :: popo :: UserTrigger cyclicTrigger ; waitset . attachEvent ( cyclicTrigger , 0U , createNotificationCallback ( SomeClass :: cyclicRun )). or_else ([]( auto ) { std :: cerr << \"failed to attach cyclic trigger\" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); The next thing we need is something which will trigger our cyclicTrigger every second. We use an infinite loop packed inside of a thread. std :: thread cyclicTriggerThread ([ & ] { while ( keepRunning . load ()) { cyclicTrigger . trigger (); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); } }); Everything is set up and we can implement the event loop. As usual we handle CTRL+C which is indicated by the shutdownTrigger . while ( keepRunning . load ()) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { if ( notification -> doesOriginateFrom ( & shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning . store ( false ); } // ... } std :: cout << std :: endl ; } The cyclicTrigger callback is called in the else part. while ( keepRunning . load ()) { auto notificationVector = waitset . wait (); for ( auto & notification : notificationVector ) { // ... else { // call SomeClass::cyclicRun ( * notification )(); } } std :: cout << std :: endl ; }","title":"Timer Driven Execution"},{"location":"examples/waitset/#trigger","text":"In this example we describe how you would implement a Triggerable class which can be attached to a WaitSet or a Listener . Our class in this example will be called MyTriggerClass and it can signal the WaitSet the two states HAS_PERFORMED_ACTION and IS_ACTIVATED . Furthermore, we can also attach the two corresponding events PERFORM_ACTION_CALLED and ACTIVATE_CALLED . The PERFORM_ACTION_CALLED event is triggered whenever the method performAction is called and the state HAS_PERFORMED_ACTION persists until someone resets the state with the method reset() . The same applies to the event ACTIVATE_CALLED which is triggered by an activate() call and the corresponding state IS_ACTIVATED which stays until someone resets it with reset() .","title":"Trigger"},{"location":"examples/waitset/#mytriggerclass","text":"","title":"MyTriggerClass"},{"location":"examples/waitset/#attaching-states","text":"A class that would like to attach states to a WaitSet has to implement the following methods. void enableState(iox::popo::TriggerHandle&&, const UserDefinedStateEnum ) Used by the WaitSet to attach a trigger handle to the object so that the object can notify the WaitSet that it entered a certain state. void disableState(const UserDefinedStateEnum) Called whenever the user detaches the state from the WaitSet . void invalidateTrigger(const uint64_t uniqueTriggerId) If the WaitSet goes out of scope it calls this method to invalidate the loan trigger. iox::popo::WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied(const UserDefinedStateEnum) With every iteration the WaitSet has to ask the object if the attached state still persists. This is done with the isStateConditionSatisfied callback which will be returned here. The UserDefinedStateEnum can be some arbitrary enum class which requires iox::popo::StateEnumIdentifier as underlying type so that it can be identified as an enum which describes certain states. In our example it is called MyTriggerClassStates . enum class MyTriggerClassStates : iox :: popo :: StateEnumIdentifier { HAS_PERFORMED_ACTION , IS_ACTIVATED };","title":"Attaching States"},{"location":"examples/waitset/#attaching-events","text":"Events can be attached to WaitSets and Listeners . For this to work the class has to implement the following methods. void enableEvent(iox::popo::TriggerHandle&&, const UserDefinedEventEnum) Used by the WaitSet or the Listener to attach a trigger handle which signals certain events to them. void disableEvent(const UserDefinedEventEnum) Called whenever the user detaches the event from the WaitSet or the Listener . void invalidateTrigger(const uint64_t uniqueTriggerId) Used to clean up all loan trigger handles when the WaitSet or Listener goes out of scope. Like with the state enum the event enum can be also any arbitrary enum class which has iox::popo::EventEnumIdentifier as an underlying type. In our example it is called MyTriggerClassEvents . enum class MyTriggerClassEvents : iox :: popo :: EventEnumIdentifier { PERFORM_ACTION_CALLED , ACTIVATE_CALLED };","title":"Attaching Events"},{"location":"examples/waitset/#further-requirements","text":"friend iox::popo::NotificationAttorney Methods like enableEvent , disableEvent etc. should never be accessible via the public API and should be therefore private. To avoid that every class has to befriend the WaitSet , Listener and other internal structures we implemented the client attorney pattern and the class has only to befriend the iox::popo::NotificationAttorney . Deleted move and copy operations At the moment the WaitSet does not support Triggerable classes which are movable or copyable. This is caused by the resetCallback and the isStateConditionSatisfied callback which are pointing to the Triggerable . After a move the callbacks inside of the WaitSet would point to the wrong memory location and a copy could lead to an unattached object if there is no more space left in the WaitSet . Therefore we have to delete the move and copy operations for now. MyTriggerClass ( const MyTriggerClass & ) = delete ; MyTriggerClass ( MyTriggerClass && ) = delete ; MyTriggerClass & operator = ( const MyTriggerClass & ) = delete ; MyTriggerClass & operator = ( MyTriggerClass && ) = delete ;","title":"Further Requirements"},{"location":"examples/waitset/#implementation","text":"The method implementation of the two actions activate and performAction which trigger an event and causing a state change look like the following. // When you call this method you will trigger the ACTIVATE event void activate ( const uint64_t activationCode ) noexcept { m_activationCode = activationCode ; m_isActivated = true ; m_activateTrigger . trigger (); } // Calling this method will trigger the PERFORMED_ACTION event void performAction () noexcept { m_hasPerformedAction = true ; m_onActionTrigger . trigger (); } As you can see we perform some internal action and when they are finished we signal the corresponding Trigger via our stored TriggerHandle that we performed the task. Internally we just set a boolean to signal that the method was called. Every state based Trigger requires a corresponding class method which returns a boolean stating if the state which led to the trigger still persists. In our case these are the two const methods hasPerformedAction and isActivated . // required by the m_onActionTrigger to ask the class if it was triggered bool hasPerformedAction () const noexcept { return m_hasPerformedAction ; } // required by the m_activateTrigger to ask the class if it was triggered bool isActivated () const noexcept { return m_isActivated ; } Since the following methods should not be accessible by the public but must be accessible by any Notifyable like the WaitSet and to avoid that we have to befriend every possible Notifyable we created the NotificationAttorney . Every Triggerable has to befriend the NotificationAttorney which provides access to the private methods enableEvent / enableState , disableEvent / disableState , invalidateTrigger and getCallbackForIsStateConditionSatisfied to all Notifyables . friend iox :: popo :: NotificationAttorney ; The method enableEvent is called by the WaitSet when a MyTriggerClass event is being attached to it. During that process the WaitSet creates a triggerHandle and forwards the event to which this handle belongs. In the switch case statement we assign the triggerHandle to the corresponding internal trigger handle. void enableEvent ( iox :: popo :: TriggerHandle && triggerHandle , const MyTriggerClassEvents event ) noexcept { switch ( event ) { case MyTriggerClassEvents :: PERFORM_ACTION_CALLED : m_onActionTrigger = std :: move ( triggerHandle ); break ; case MyTriggerClassEvents :: ACTIVATE_CALLED : m_activateTrigger = std :: move ( triggerHandle ); break ; } } Attaching a state works in a similar way. void enableState ( iox :: popo :: TriggerHandle && triggerHandle , const MyTriggerClassStates state ) noexcept { switch ( state ) { case MyTriggerClassStates :: HAS_PERFORMED_ACTION : m_onActionTrigger = std :: move ( triggerHandle ); break ; case MyTriggerClassStates :: IS_ACTIVATED : m_activateTrigger = std :: move ( triggerHandle ); break ; } } It is possible to use the same trigger for either a state or an event attachment but then we loose the ability to attach the state and the corresponding event at the same time to a WaitSet . In most cases it is not a problem and when you attach an event when the corresponding state is already attached you will get a warning message on the terminal and the already attached event is detached so that the state can be attached. This is realized via the RAII idiom. The next thing on our checklist is the invalidateTrigger method used by the WaitSet to reset the Trigger when it goes out of scope. Therefore we look up the correct unique trigger id first and then invalidate it to make them unusable in the future. void invalidateTrigger ( const uint64_t uniqueTriggerId ) { if ( m_onActionTrigger . getUniqueId () == uniqueTriggerId ) { m_onActionTrigger . invalidate (); } else if ( m_activateTrigger . getUniqueId () == uniqueTriggerId ) { m_activateTrigger . invalidate (); } } Detaching an event in the WaitSet will lead to a call to disableEvent in our class. In this case we have to reset the corresponding trigger to invalidate and release it from the WaitSet . Like before we use a switch case statement to find the trigger corresponding to the event. void disableEvent ( const MyTriggerClassEvents event ) noexcept { switch ( event ) { case MyTriggerClassEvents :: PERFORM_ACTION_CALLED : m_onActionTrigger . reset (); break ; case MyTriggerClassEvents :: ACTIVATE_CALLED : m_activateTrigger . reset (); break ; } } The same idea is used when detaching a state. void disableState ( const MyTriggerClassStates state ) noexcept { switch ( state ) { case MyTriggerClassStates :: HAS_PERFORMED_ACTION : m_onActionTrigger . reset (); break ; case MyTriggerClassStates :: IS_ACTIVATED : m_activateTrigger . reset (); break ; } } The last method we have to implement is getCallbackForIsStateConditionSatisfied . The WaitSet can handle state based attachments and therefore it requires, beside the condition variable which only states that something has happened, a callback to find the object where it happened. This is the isStateConditionSatisfied callback. In our case we either return the method pointer to hasPerformedAction or isActivated depending on which state was requested. iox :: popo :: WaitSetIsConditionSatisfiedCallback getCallbackForIsStateConditionSatisfied ( const MyTriggerClassStates event ) const noexcept { switch ( event ) { case MyTriggerClassStates :: HAS_PERFORMED_ACTION : return { * this , & MyTriggerClass :: hasPerformedAction }; case MyTriggerClassStates :: IS_ACTIVATED : return { * this , & MyTriggerClass :: isActivated }; } return {}; }","title":"Implementation"},{"location":"examples/waitset/#using-mytriggerclass","text":"The next thing we define is a free function, our eventLoop , which will handle all events of our WaitSet . Since we would like to attach the IS_ACTIVATED state we have to reset the state whenever it occurs otherwise the WaitSet will notify us right away since the state still persists. The second attachment will be an event attachment and the WaitSet informs us just once that the event has occurred which makes the reset call obsolete. void eventLoop () { while ( keepRunning ) { auto notificationVector = waitset -> wait (); for ( auto & notification : notificationVector ) { if ( notification -> getNotificationId () == ACTIVATE_ID ) { // reset MyTriggerClass instance state notification -> getOrigin < MyTriggerClass > () -> reset ( MyTriggerClassStates :: IS_ACTIVATED ); // call the callback attached to the trigger ( * notification )(); } else if ( notification -> getNotificationId () == ACTION_ID ) { // reset is not required since we attached an notification here. we will be notified once ( * notification )(); } } } } We start like in every other example by creating the waitset first. In this case the waitset and the triggerClass are stored inside of two global optional 's and have to be created with an emplace call. waitset . emplace (); triggerClass . emplace (); After that we can attach the IS_ACTIVATED state and PERFORM_ACTION_CALLED event to the waitset and provide a callback for them. // attach the IS_ACTIVATED state to the waitset and assign a callback waitset -> attachState ( * triggerClass , MyTriggerClassStates :: IS_ACTIVATED , ACTIVATE_ID , iox :: popo :: createNotificationCallback ( callOnActivate )) . or_else ([]( auto ) { std :: cerr << \"failed to attach MyTriggerClassStates::IS_ACTIVATED state \" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); // attach the PERFORM_ACTION_CALLED event to the waitset and assign a callback waitset -> attachEvent ( * triggerClass , MyTriggerClassEvents :: PERFORM_ACTION_CALLED , ACTION_ID , iox :: popo :: createNotificationCallback ( MyTriggerClass :: callOnAction )) . or_else ([]( auto ) { std :: cerr << \"failed to attach MyTriggerClassEvents::PERFORM_ACTION_CALLED event \" << std :: endl ; std :: exit ( EXIT_FAILURE ); }); Now that everything is set up we can start our eventLoop in a new thread. std :: thread eventLoopThread ( eventLoop ); A thread which will trigger an event every second is started with the following lines. std :: thread triggerThread ([ & ] { uint64_t activationCode = 1U ; for ( auto i = 0U ; i < 10 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); triggerClass -> activate ( activationCode ++ ); std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 1 )); triggerClass -> performAction (); } std :: cout << \"Sending final trigger\" << std :: endl ; keepRunning = false ; triggerClass -> activate ( activationCode ++ ); triggerClass -> performAction (); }); Check out waitset on GitHub","title":"Using MyTriggerClass"},{"location":"examples/waitset_in_c/","text":"WaitSet in C \ud83d\udd17 Thread Safety \ud83d\udd17 The WaitSet is not thread-safe! It is not allowed to attach or detach Triggerable classes with iox_ws_attach_** or iox_ws_detach_** when another thread is currently waiting for notifications with iox_ws_wait or iox_ws_timed_wait . Do not call any of the iox_ws_ functions concurrently. The TriggerHandle on the other hand, is thread-safe! Therefore you are allowed to attach/detach a TriggerHandle to a Triggerable while another thread may trigger the TriggerHandle . Introduction \ud83d\udd17 A detailed introduction into the WaitSet nomenclature and topic can be found in the waitset C++ example . Here we will only introduce the C API and not the WaitSet in general. For this, we will take a look at the same use case as the waitset C++ example . The examples are structured in the same way as the C++ ones. Expected Output \ud83d\udd17 Code Walkthrough \ud83d\udd17 Warning Please be aware of the thread-safety restrictions of the WaitSet and read the Thread Safety chapter carefully. To run an example you need a running iox-roudi and the waitset publisher iox-c-waitset-publisher . They are identical to the ones introduced in the icedelivery C example . Gateway \ud83d\udd17 Let's say we would like to write a gateway and would like to forward every incoming message from a subscriber with the same callback. For instance we could perform a memcopy of the received data into a specific struct. Additionally, we would like to count all processed samples. Therefore we provide an extra void pointer argument called contextData which is a pointer to an uint64_t . This could be performed by a function that we attach to an event as a callback. In our case, we have the function subscriberCallback that prints out the subscriber pointer and the content of the received sample. void subscriberCallback ( iox_sub_t const subscriber , void * const contextData ) { if ( contextData == NULL ) { fprintf ( stderr , \"aborting subscriberCallback since contextData is a null pointer \\n \" ); return ; } uint64_t * sumOfAllSamples = ( uint64_t * ) contextData ; const void * userPayload = NULL ; while ( iox_sub_take_chunk ( subscriber , & userPayload ) == ChunkReceiveResult_SUCCESS ) { printf ( \"subscriber: %p received %u \\n \" , ( void * ) subscriber , (( struct CounterTopic * ) userPayload ) -> counter ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); ++ ( * sumOfAllSamples ); } } The shutdownTrigger gets a simplified callback where it just states that the program will be terminated. For this we do not need any context data. void shutdownCallback ( iox_user_trigger_t userTrigger ) { ( void ) userTrigger ; printf ( \"CTRL+C pressed - exiting now \\n \" ); fflush ( stdout ); } Since we attach the SubscriberEvent_DATA_RECEIVED event to the WaitSet that notifies us just once when data was received we have to gather and process all chunks. One will never miss chunks since the event notification is reset after a call to iox_ws_wait or iox_ws_timed_wait which we introduce below. After we registered our runtime we set up some waitSetStorage , initialize the WaitSet and attach a shutdownTrigger to handle CTRL+C . iox_runtime_init ( \"iox-c-waitset-gateway\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0U , shutdownCallback ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); In the next steps, we define sumOfAllSamples , create two subscribers with iox_sub_init , subscribe them to our topic and attach the event SubscriberEvent_DATA_RECEIVED to the WaitSet with the subscriberCallback , an event id 1U and a pointer to our user defined context data sumOfAllSamples which is then provided as argument for the callback. Attention The user has to ensure that the contextData ( sumOfAllSamples ) in iox_ws_attach_subscriber_event_with_context_data lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling. uint64_t sumOfAllSamples = 0U ; // array where the subscriber are stored iox_sub_storage_t subscriberStorage [ NUMBER_OF_SUBSCRIBERS ]; iox_sub_t subscriber [ NUMBER_OF_SUBSCRIBERS ]; // create subscriber and subscribe them to our service iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 1U ; options . queueCapacity = 256U ; options . nodeName = \"iox-c-waitSet-gateway-node\" ; for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriber [ i ] = iox_sub_init ( & ( subscriberStorage [ i ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); iox_ws_attach_subscriber_event_with_context_data ( waitSet , subscriber [ i ], SubscriberEvent_DATA_RECEIVED , 1U , subscriberCallback , & sumOfAllSamples ); } Now that everything is set up we enter the event loop. It always starts with a call to iox_ws_wait , a blocking call which returns us the number of occurred notifications. uint64_t missedElements = 0U ; uint64_t numberOfNotifications = 0U ; // array where all notification infos from iox_ws_wait will be stored iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; bool keepRunning = true ; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } The events which have occurred are stored in the notificationArray . We iterate through it, if the shutdownTrigger was triggered we terminate the program otherwise we call the callback with iox_notification_info_call(notification) . for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } else { // call the callback which was assigned to the event iox_notification_info_call ( notification ); printf ( \"sum of all samples: %lu \\n \" , ( unsigned long ) sumOfAllSamples ); fflush ( stdout ); } } Before we can close the program, we cleanup all resources. for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { // not mandatory since iox_sub_deinit will detach the subscriber automatically // only added to present the full API iox_ws_detach_subscriber_event ( waitSet , subscriber [ i ], SubscriberEvent_DATA_RECEIVED ); iox_sub_deinit ( subscriber [ i ]); } iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger ); Grouping \ud83d\udd17 In this scenario, we have two groups of subscribers. We are interested in the data of the first group and would like to print them onto the console and the data of the second group should be discarded. We start like in every example with creating the WaitSet and attaching the shutdownTrigger . iox_runtime_init ( \"iox-c-waitset-grouping\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0U , NULL ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); After that we can create a list of subscribers and subscribe them to our topic. // array where the subscribers are stored iox_sub_storage_t subscriberStorage [ NUMBER_OF_SUBSCRIBERS ]; iox_sub_t subscriber [ NUMBER_OF_SUBSCRIBERS ]; // create subscriber and subscribe them to our service iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 1U ; options . queueCapacity = 256U ; options . nodeName = \"iox-c-waitset-grouping-node\" ; for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriber [ i ] = iox_sub_init ( & ( subscriberStorage [ i ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); } To distinct our two groups we set the eventId of the first group to 123 and of the second group to 456 . The first two subscribers are attached with the SubscriberState_HAS_DATA state and the event id of the first group to our waitset. The third and forth subscriber are attached to the same waitset under the second group id. const uint64_t FIRST_GROUP_ID = 123U ; const uint64_t SECOND_GROUP_ID = 456U ; // attach the first two subscribers to the waitset with a triggerid of FIRST_GROUP_ID for ( uint64_t i = 0U ; i < 2U ; ++ i ) { iox_ws_attach_subscriber_state ( waitSet , subscriber [ i ], SubscriberState_HAS_DATA , FIRST_GROUP_ID , NULL ); } // attach the remaining subscribers to the waitset with a triggerid of SECOND_GROUP_ID for ( uint64_t i = 2U ; i < 4U ; ++ i ) { iox_ws_attach_subscriber_state ( waitSet , subscriber [ i ], SubscriberState_HAS_DATA , SECOND_GROUP_ID , NULL ); } We are again ready for our event loop. We start as usual by setting the array of notifications by calling iox_ws_wait . bool keepRunning = true ; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } When we iterate through the array we handle the shutdownTrigger first. We check if an event is from the first group by calling iox_notification_info_get_event_id and compare the result with FIRST_GROUP_ID . If that is the case we acquire the subscriber handle with iox_notification_info_get_subscriber_origin . This allows us to receive the new sample and to print the result to the console. The second group is handled in the same way. But we do not print the new samples to screen, we just discard them. for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } // we print the received data for the first group else if ( iox_notification_info_get_notification_id ( notification ) == FIRST_GROUP_ID ) { iox_sub_t subscriber = iox_notification_info_get_subscriber_origin ( notification ); const void * userPayload ; if ( iox_sub_take_chunk ( subscriber , & userPayload )) { printf ( \"received: %u \\n \" , (( struct CounterTopic * ) userPayload ) -> counter ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); } } // dismiss the received data for the second group else if ( iox_notification_info_get_notification_id ( notification ) == SECOND_GROUP_ID ) { printf ( \"dismiss data \\n \" ); iox_sub_t subscriber = iox_notification_info_get_subscriber_origin ( notification ); // We need to release the samples to reset the event hasSamples // otherwise the WaitSet would notify us in `iox_ws_wait()` again // instantly. iox_sub_release_queued_chunks ( subscriber ); } } In the case of the SECOND_GROUP_ID we have to release all queued chunks otherwise the WaitSet would notify us right away since the SubscriberState_HAS_DATA still persists. The last thing we have to do is to cleanup all the acquired resources. for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { iox_sub_deinit ( subscriber [ i ]); } iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger ); Individual \ud83d\udd17 We also can handle every event individually, for instance when you would like to have a different reaction for every subscriber which has received a sample. One way would be to assign every subscriber a different callback, here we look at a different approach. We check if the event originated from a specific subscriber and then perform the calls on that subscriber directly. We start as usual by creating a WaitSet and attach the shutdownTrigger to it. iox_runtime_init ( \"iox-c-waitset-individual\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0U , NULL ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); Now we create two subscribers, subscribe them to our topic and attach them to the waitset without a callback and with the same trigger id. // array where the subscriber are stored iox_sub_storage_t subscriberStorage [ NUMBER_OF_SUBSCRIBERS ]; iox_sub_t subscriber [ NUMBER_OF_SUBSCRIBERS ]; // create two subscribers, subscribe to the service and attach them to the waitset iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 1U ; options . queueCapacity = 256U ; options . nodeName = \"iox-c-waitset-individual-node1\" ; subscriber [ 0 ] = iox_sub_init ( & ( subscriberStorage [ 0 ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); options . nodeName = \"iox-c-waitset-individual-node2\" ; subscriber [ 1 ] = iox_sub_init ( & ( subscriberStorage [ 1 ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); iox_ws_attach_subscriber_state ( waitSet , subscriber [ 0U ], SubscriberState_HAS_DATA , 0U , NULL ); iox_ws_attach_subscriber_state ( waitSet , subscriber [ 1U ], SubscriberState_HAS_DATA , 0U , NULL ); We are ready to start the event loop. We begin by acquiring the array of all the triggered triggers. uint64_t missedElements = 0U ; uint64_t numberOfNotifications = 0U ; // array where all notification infos from iox_ws_wait will be stored iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; bool keepRunning = true ; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } The shutdownTrigger is handled as usual and we use iox_notification_info_does_originate_from_subscriber to identify the event that originated from a specific subscriber. If it originated from the first subscriber we print the received data to the console, if it originated from the second subscriber we discard the data. for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } // process sample received by subscriber1 else if ( iox_notification_info_does_originate_from_subscriber ( notification , subscriber [ 0U ])) { const void * userPayload ; if ( iox_sub_take_chunk ( subscriber [ 0U ], & userPayload )) { printf ( \"subscriber 1 received: %u \\n \" , (( struct CounterTopic * ) userPayload ) -> counter ); fflush ( stdout ); iox_sub_release_chunk ( subscriber [ 0U ], userPayload ); } } // dismiss sample received by subscriber2 else if ( iox_notification_info_does_originate_from_subscriber ( notification , subscriber [ 1 ])) { // We need to release the samples to reset the event hasSamples // otherwise the WaitSet would notify us in `iox_ws_wait()` again // instantly. iox_sub_release_queued_chunks ( subscriber [ 1U ]); printf ( \"subscriber 2 received something - dont care \\n \" ); fflush ( stdout ); } } We conclude the example as always, by cleaning up the resources. for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { iox_sub_deinit ( subscriber [ i ]); } iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger ); Timer Driven Execution \ud83d\udd17 In this example, we demonstrate how you can use the WaitSet to trigger a cyclic call every second. We use a user trigger which will be triggered in a separate thread every second to signal the WaitSet that it's time for the next run. Additionally, we attach a callback ( cyclicRun ) to this user trigger so that the event can directly call the cyclic call. Note This example does not run on Windows due to direct usage of the pthread API. We begin by creating the WaitSet and attach the shutdownTrigger . iox_runtime_init ( \"iox-c-waitset-timer-driven-execution\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0 , NULL ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); Now we create our cyclic trigger and attach it to our waitset with an eventId of 0 and the callback cyclicRun . cyclicTrigger = iox_user_trigger_init ( & cyclicTriggerStorage ); iox_ws_attach_user_trigger_event ( waitSet , cyclicTrigger , 0 , cyclicRun ); The thread which will trigger the cyclicTrigger every second is started in the next lines. pthread_t cyclicTriggerThread ; if ( createThread ( & cyclicTriggerThread , cyclicTriggerCallback )) { printf ( \"failed to create thread \\n \" ); return -1 ; } Everything is prepared and we enter the event loop. We start by gathering all notifications in an array. uint64_t missedElements = 0U ; uint64_t numberOfNotifications = 0U ; // array where all notifications from iox_ws_wait will be stored iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } The shutdownTrigger is handled as usual and the cyclicTrigger is handled by just calling the attached callback with iox_notification_info_call(notification) . for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } else { // call myCyclicRun iox_notification_info_call ( notification ); } } The last thing we have to do is to cleanup all the used resources. joinThread ( cyclicTriggerThread ); iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger ); Check out waitset_in_c on GitHub","title":"Waiting for events like arrival of data using C"},{"location":"examples/waitset_in_c/#waitset-in-c","text":"","title":"WaitSet in C"},{"location":"examples/waitset_in_c/#thread-safety","text":"The WaitSet is not thread-safe! It is not allowed to attach or detach Triggerable classes with iox_ws_attach_** or iox_ws_detach_** when another thread is currently waiting for notifications with iox_ws_wait or iox_ws_timed_wait . Do not call any of the iox_ws_ functions concurrently. The TriggerHandle on the other hand, is thread-safe! Therefore you are allowed to attach/detach a TriggerHandle to a Triggerable while another thread may trigger the TriggerHandle .","title":"Thread Safety"},{"location":"examples/waitset_in_c/#introduction","text":"A detailed introduction into the WaitSet nomenclature and topic can be found in the waitset C++ example . Here we will only introduce the C API and not the WaitSet in general. For this, we will take a look at the same use case as the waitset C++ example . The examples are structured in the same way as the C++ ones.","title":"Introduction"},{"location":"examples/waitset_in_c/#expected-output","text":"","title":"Expected Output"},{"location":"examples/waitset_in_c/#code-walkthrough","text":"Warning Please be aware of the thread-safety restrictions of the WaitSet and read the Thread Safety chapter carefully. To run an example you need a running iox-roudi and the waitset publisher iox-c-waitset-publisher . They are identical to the ones introduced in the icedelivery C example .","title":"Code Walkthrough"},{"location":"examples/waitset_in_c/#gateway","text":"Let's say we would like to write a gateway and would like to forward every incoming message from a subscriber with the same callback. For instance we could perform a memcopy of the received data into a specific struct. Additionally, we would like to count all processed samples. Therefore we provide an extra void pointer argument called contextData which is a pointer to an uint64_t . This could be performed by a function that we attach to an event as a callback. In our case, we have the function subscriberCallback that prints out the subscriber pointer and the content of the received sample. void subscriberCallback ( iox_sub_t const subscriber , void * const contextData ) { if ( contextData == NULL ) { fprintf ( stderr , \"aborting subscriberCallback since contextData is a null pointer \\n \" ); return ; } uint64_t * sumOfAllSamples = ( uint64_t * ) contextData ; const void * userPayload = NULL ; while ( iox_sub_take_chunk ( subscriber , & userPayload ) == ChunkReceiveResult_SUCCESS ) { printf ( \"subscriber: %p received %u \\n \" , ( void * ) subscriber , (( struct CounterTopic * ) userPayload ) -> counter ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); ++ ( * sumOfAllSamples ); } } The shutdownTrigger gets a simplified callback where it just states that the program will be terminated. For this we do not need any context data. void shutdownCallback ( iox_user_trigger_t userTrigger ) { ( void ) userTrigger ; printf ( \"CTRL+C pressed - exiting now \\n \" ); fflush ( stdout ); } Since we attach the SubscriberEvent_DATA_RECEIVED event to the WaitSet that notifies us just once when data was received we have to gather and process all chunks. One will never miss chunks since the event notification is reset after a call to iox_ws_wait or iox_ws_timed_wait which we introduce below. After we registered our runtime we set up some waitSetStorage , initialize the WaitSet and attach a shutdownTrigger to handle CTRL+C . iox_runtime_init ( \"iox-c-waitset-gateway\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0U , shutdownCallback ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); In the next steps, we define sumOfAllSamples , create two subscribers with iox_sub_init , subscribe them to our topic and attach the event SubscriberEvent_DATA_RECEIVED to the WaitSet with the subscriberCallback , an event id 1U and a pointer to our user defined context data sumOfAllSamples which is then provided as argument for the callback. Attention The user has to ensure that the contextData ( sumOfAllSamples ) in iox_ws_attach_subscriber_event_with_context_data lives as long as the attachment, with its callback, is attached otherwise the callback context data pointer is dangling. uint64_t sumOfAllSamples = 0U ; // array where the subscriber are stored iox_sub_storage_t subscriberStorage [ NUMBER_OF_SUBSCRIBERS ]; iox_sub_t subscriber [ NUMBER_OF_SUBSCRIBERS ]; // create subscriber and subscribe them to our service iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 1U ; options . queueCapacity = 256U ; options . nodeName = \"iox-c-waitSet-gateway-node\" ; for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriber [ i ] = iox_sub_init ( & ( subscriberStorage [ i ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); iox_ws_attach_subscriber_event_with_context_data ( waitSet , subscriber [ i ], SubscriberEvent_DATA_RECEIVED , 1U , subscriberCallback , & sumOfAllSamples ); } Now that everything is set up we enter the event loop. It always starts with a call to iox_ws_wait , a blocking call which returns us the number of occurred notifications. uint64_t missedElements = 0U ; uint64_t numberOfNotifications = 0U ; // array where all notification infos from iox_ws_wait will be stored iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; bool keepRunning = true ; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } The events which have occurred are stored in the notificationArray . We iterate through it, if the shutdownTrigger was triggered we terminate the program otherwise we call the callback with iox_notification_info_call(notification) . for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } else { // call the callback which was assigned to the event iox_notification_info_call ( notification ); printf ( \"sum of all samples: %lu \\n \" , ( unsigned long ) sumOfAllSamples ); fflush ( stdout ); } } Before we can close the program, we cleanup all resources. for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { // not mandatory since iox_sub_deinit will detach the subscriber automatically // only added to present the full API iox_ws_detach_subscriber_event ( waitSet , subscriber [ i ], SubscriberEvent_DATA_RECEIVED ); iox_sub_deinit ( subscriber [ i ]); } iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger );","title":"Gateway"},{"location":"examples/waitset_in_c/#grouping","text":"In this scenario, we have two groups of subscribers. We are interested in the data of the first group and would like to print them onto the console and the data of the second group should be discarded. We start like in every example with creating the WaitSet and attaching the shutdownTrigger . iox_runtime_init ( \"iox-c-waitset-grouping\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0U , NULL ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); After that we can create a list of subscribers and subscribe them to our topic. // array where the subscribers are stored iox_sub_storage_t subscriberStorage [ NUMBER_OF_SUBSCRIBERS ]; iox_sub_t subscriber [ NUMBER_OF_SUBSCRIBERS ]; // create subscriber and subscribe them to our service iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 1U ; options . queueCapacity = 256U ; options . nodeName = \"iox-c-waitset-grouping-node\" ; for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { subscriber [ i ] = iox_sub_init ( & ( subscriberStorage [ i ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); } To distinct our two groups we set the eventId of the first group to 123 and of the second group to 456 . The first two subscribers are attached with the SubscriberState_HAS_DATA state and the event id of the first group to our waitset. The third and forth subscriber are attached to the same waitset under the second group id. const uint64_t FIRST_GROUP_ID = 123U ; const uint64_t SECOND_GROUP_ID = 456U ; // attach the first two subscribers to the waitset with a triggerid of FIRST_GROUP_ID for ( uint64_t i = 0U ; i < 2U ; ++ i ) { iox_ws_attach_subscriber_state ( waitSet , subscriber [ i ], SubscriberState_HAS_DATA , FIRST_GROUP_ID , NULL ); } // attach the remaining subscribers to the waitset with a triggerid of SECOND_GROUP_ID for ( uint64_t i = 2U ; i < 4U ; ++ i ) { iox_ws_attach_subscriber_state ( waitSet , subscriber [ i ], SubscriberState_HAS_DATA , SECOND_GROUP_ID , NULL ); } We are again ready for our event loop. We start as usual by setting the array of notifications by calling iox_ws_wait . bool keepRunning = true ; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } When we iterate through the array we handle the shutdownTrigger first. We check if an event is from the first group by calling iox_notification_info_get_event_id and compare the result with FIRST_GROUP_ID . If that is the case we acquire the subscriber handle with iox_notification_info_get_subscriber_origin . This allows us to receive the new sample and to print the result to the console. The second group is handled in the same way. But we do not print the new samples to screen, we just discard them. for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } // we print the received data for the first group else if ( iox_notification_info_get_notification_id ( notification ) == FIRST_GROUP_ID ) { iox_sub_t subscriber = iox_notification_info_get_subscriber_origin ( notification ); const void * userPayload ; if ( iox_sub_take_chunk ( subscriber , & userPayload )) { printf ( \"received: %u \\n \" , (( struct CounterTopic * ) userPayload ) -> counter ); fflush ( stdout ); iox_sub_release_chunk ( subscriber , userPayload ); } } // dismiss the received data for the second group else if ( iox_notification_info_get_notification_id ( notification ) == SECOND_GROUP_ID ) { printf ( \"dismiss data \\n \" ); iox_sub_t subscriber = iox_notification_info_get_subscriber_origin ( notification ); // We need to release the samples to reset the event hasSamples // otherwise the WaitSet would notify us in `iox_ws_wait()` again // instantly. iox_sub_release_queued_chunks ( subscriber ); } } In the case of the SECOND_GROUP_ID we have to release all queued chunks otherwise the WaitSet would notify us right away since the SubscriberState_HAS_DATA still persists. The last thing we have to do is to cleanup all the acquired resources. for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { iox_sub_deinit ( subscriber [ i ]); } iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger );","title":"Grouping"},{"location":"examples/waitset_in_c/#individual","text":"We also can handle every event individually, for instance when you would like to have a different reaction for every subscriber which has received a sample. One way would be to assign every subscriber a different callback, here we look at a different approach. We check if the event originated from a specific subscriber and then perform the calls on that subscriber directly. We start as usual by creating a WaitSet and attach the shutdownTrigger to it. iox_runtime_init ( \"iox-c-waitset-individual\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0U , NULL ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); Now we create two subscribers, subscribe them to our topic and attach them to the waitset without a callback and with the same trigger id. // array where the subscriber are stored iox_sub_storage_t subscriberStorage [ NUMBER_OF_SUBSCRIBERS ]; iox_sub_t subscriber [ NUMBER_OF_SUBSCRIBERS ]; // create two subscribers, subscribe to the service and attach them to the waitset iox_sub_options_t options ; iox_sub_options_init ( & options ); options . historyRequest = 1U ; options . queueCapacity = 256U ; options . nodeName = \"iox-c-waitset-individual-node1\" ; subscriber [ 0 ] = iox_sub_init ( & ( subscriberStorage [ 0 ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); options . nodeName = \"iox-c-waitset-individual-node2\" ; subscriber [ 1 ] = iox_sub_init ( & ( subscriberStorage [ 1 ]), \"Radar\" , \"FrontLeft\" , \"Counter\" , & options ); iox_ws_attach_subscriber_state ( waitSet , subscriber [ 0U ], SubscriberState_HAS_DATA , 0U , NULL ); iox_ws_attach_subscriber_state ( waitSet , subscriber [ 1U ], SubscriberState_HAS_DATA , 0U , NULL ); We are ready to start the event loop. We begin by acquiring the array of all the triggered triggers. uint64_t missedElements = 0U ; uint64_t numberOfNotifications = 0U ; // array where all notification infos from iox_ws_wait will be stored iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; bool keepRunning = true ; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } The shutdownTrigger is handled as usual and we use iox_notification_info_does_originate_from_subscriber to identify the event that originated from a specific subscriber. If it originated from the first subscriber we print the received data to the console, if it originated from the second subscriber we discard the data. for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } // process sample received by subscriber1 else if ( iox_notification_info_does_originate_from_subscriber ( notification , subscriber [ 0U ])) { const void * userPayload ; if ( iox_sub_take_chunk ( subscriber [ 0U ], & userPayload )) { printf ( \"subscriber 1 received: %u \\n \" , (( struct CounterTopic * ) userPayload ) -> counter ); fflush ( stdout ); iox_sub_release_chunk ( subscriber [ 0U ], userPayload ); } } // dismiss sample received by subscriber2 else if ( iox_notification_info_does_originate_from_subscriber ( notification , subscriber [ 1 ])) { // We need to release the samples to reset the event hasSamples // otherwise the WaitSet would notify us in `iox_ws_wait()` again // instantly. iox_sub_release_queued_chunks ( subscriber [ 1U ]); printf ( \"subscriber 2 received something - dont care \\n \" ); fflush ( stdout ); } } We conclude the example as always, by cleaning up the resources. for ( uint64_t i = 0U ; i < NUMBER_OF_SUBSCRIBERS ; ++ i ) { iox_sub_deinit ( subscriber [ i ]); } iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger );","title":"Individual"},{"location":"examples/waitset_in_c/#timer-driven-execution","text":"In this example, we demonstrate how you can use the WaitSet to trigger a cyclic call every second. We use a user trigger which will be triggered in a separate thread every second to signal the WaitSet that it's time for the next run. Additionally, we attach a callback ( cyclicRun ) to this user trigger so that the event can directly call the cyclic call. Note This example does not run on Windows due to direct usage of the pthread API. We begin by creating the WaitSet and attach the shutdownTrigger . iox_runtime_init ( \"iox-c-waitset-timer-driven-execution\" ); iox_ws_storage_t waitSetStorage ; iox_ws_t waitSet = iox_ws_init ( & waitSetStorage ); shutdownTrigger = iox_user_trigger_init ( & shutdownTriggerStorage ); // attach shutdownTrigger with no callback to handle CTRL+C iox_ws_attach_user_trigger_event ( waitSet , shutdownTrigger , 0 , NULL ); // register signal after shutdownTrigger since we are using it in the handler signal ( SIGINT , sigHandler ); signal ( SIGTERM , sigHandler ); Now we create our cyclic trigger and attach it to our waitset with an eventId of 0 and the callback cyclicRun . cyclicTrigger = iox_user_trigger_init ( & cyclicTriggerStorage ); iox_ws_attach_user_trigger_event ( waitSet , cyclicTrigger , 0 , cyclicRun ); The thread which will trigger the cyclicTrigger every second is started in the next lines. pthread_t cyclicTriggerThread ; if ( createThread ( & cyclicTriggerThread , cyclicTriggerCallback )) { printf ( \"failed to create thread \\n \" ); return -1 ; } Everything is prepared and we enter the event loop. We start by gathering all notifications in an array. uint64_t missedElements = 0U ; uint64_t numberOfNotifications = 0U ; // array where all notifications from iox_ws_wait will be stored iox_notification_info_t notificationArray [ NUMBER_OF_NOTIFICATIONS ]; while ( keepRunning ) { numberOfNotifications = iox_ws_wait ( waitSet , notificationArray , NUMBER_OF_NOTIFICATIONS , & missedElements ); // ... } The shutdownTrigger is handled as usual and the cyclicTrigger is handled by just calling the attached callback with iox_notification_info_call(notification) . for ( uint64_t i = 0U ; i < numberOfNotifications ; ++ i ) { iox_notification_info_t notification = notificationArray [ i ]; if ( iox_notification_info_does_originate_from_user_trigger ( notification , shutdownTrigger )) { // CTRL+C was pressed -> exit keepRunning = false ; } else { // call myCyclicRun iox_notification_info_call ( notification ); } } The last thing we have to do is to cleanup all the used resources. joinThread ( cyclicTriggerThread ); iox_ws_deinit ( waitSet ); iox_user_trigger_deinit ( shutdownTrigger ); Check out waitset_in_c on GitHub","title":"Timer Driven Execution"},{"location":"getting-started/installation/","text":"Installation \ud83d\udd17 All iceoryx libraries are deployed as independent CMake packages. Posh is using functions from hoofs and is depending on it. You are able to build posh and hoofs and integrate them into existing CMake projects. Prerequisites \ud83d\udd17 Dependencies \ud83d\udd17 64-bit hardware (e.g. x86_64 or aarch64; 32-bit hardware might work, but is not supported) CMake , 3.16 or later One of the following compilers: GCC , 8.3 or later (5.4 currently supported too) Clang , 9.0 or later MSVC , part of Visual Studio 2019 or later libacl , 2.2 or later. Only for Linux & QNX. optional, ncurses , 6.2 or later. Required by introspection tool (only for Linux, QNX and MacOS). Optional, Cyclone DDS Gateway \ud83d\udd17 The Cyclone DDS gateway depends currently on Cyclone DDS . When building it with the CMake option -DDDS_GATEWAY=ON it will be automatically installed as a dependency. Furthermore, you have to install: GNU Bison , 3.0.4 or later Mac OS \ud83d\udd17 Before installing iceoryx you need to install XCode and git. Optionally, ncurses library is required for the introspection client. To install ncurses locally into your build folder follow these steps cd iceoryx ICEORYX_DIR = $PWD mkdir -p build cd build git clone https://github.com/mirror/ncurses.git cd ncurses git checkout v6.2 ./configure --prefix = $ICEORYX_DIR /build/dependencies/ --exec-prefix = $ICEORYX_DIR /build/dependencies/ --with-termlib make -j12 make install Linux \ud83d\udd17 Although we strive to be fully POSIX-compliant, we recommend using Ubuntu 18.04 and at least GCC 7.5.0 for development. You will need to install the following packages: sudo apt install gcc g++ cmake libacl1-dev libncurses5-dev pkg-config Additionally, there is an optional dependency to the cpptoml library, which is used to parse the RouDi config file containing mempool configuration. QNX \ud83d\udd17 QNX SDP 7.0 and 7.1 are supported (shipping with gcc 5.4 and gcc 8.3 respectively). The easiest way to build iceoryx on QNX is by using the build script and providing a toolchain file. We provide generic QNX SDP 7.0 toolchain files for ARM_64 and X86_64 in ./tools/toolchains/qnx ( Direct Link ). ARM_64: ./tools/iceoryx_build_test.sh -t /home/user/toolchains/qnx/qnx_sdp70_aarch64le.cmake X86_64: ./tools/iceoryx_build_test.sh -t /home/user/toolchains/qnx/qnx_sdp70_x86_64.cmake Attention Please ensure that the folder /var/lock exist and the filesystem supports file locking. Windows \ud83d\udd17 In case you do not have a Windows installation, Microsoft provides free developer images from here . Additionally, CMake and git are required. The option to add CMake to the system PATH for all users should be set when it is installed. If the developer image from Microsoft is used, Visual Studio Community 2019 is already installed, else it can be found here . To be able to compile iceoryx, the Desktop development with C++ Workload must be installed. This is done by running VisualStudioInstaller and selecting the Modify button on Visual Studio Community 2019 . Either VS Code or Developer Command Prompt can be used to build iceoryx with CMake. Maybe one or two restarts are required to let CMake find the compiler. Alternatively, C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat can be executed in any shell to setup all the paths for compilation. Build with CMake \ud83d\udd17 Note Building with CMake is the preferred way, for more complex actions like a coverage scan is a script available (see chapter below). The CMakeLists.txt from iceoryx_meta can be used to easily develop iceoryx with an IDE. Clone the repository git clone https://github.com/eclipse-iceoryx/iceoryx.git Generate the necessary build files cd iceoryx cmake -Bbuild -Hiceoryx_meta # when you have installed external dependencies like ncurses you have to add them # to your prefix path cmake -Bbuild -Hiceoryx_meta -DCMAKE_PREFIX_PATH = $( PWD ) /build/dependencies/ Tip To build all iceoryx components add -DBUILD_ALL=ON to the CMake command. For Windows it is currently recommended to use the cmake -Bbuild -Hiceoryx_meta -DBUILD_TEST=ON -DINTROSPECTION=OFF -DBINDING_C=ON -DEXAMPLES=ON instead Compile the source code cmake --build build Tip You can speed up the build by appending -j 4 where 4 stands for the number of parallel build processes. You can choose more or less depending on your available CPU cores on your machine. Install to system Mac: cmake --build build --target install Linux: sudo cmake --build build --target install Tip The installation directory is usually left at its default, which is /usr/local Note iceoryx is built in release mode as static library with -O3 optimization by default. If you want to enable debug symbols please set CMAKE_BUILD_TYPE=Deb . Build options \ud83d\udd17 Please take a look at the CMake file build_options.cmake to get an overview of the available build options for enabling additional features. Build with script \ud83d\udd17 As an alternative, we provide a build-test script which we use to integrate iceoryx into our infrastructure. The intention of the script goes beyond building iceoryx, it is also used for the code coverage scan or the address-sanitizer runs on the CI. The script currently works for Linux and QNX only, it is planned to offer a multi-platform solution. Clone the repository git clone https://github.com/eclipse-iceoryx/iceoryx.git Build everything cd iceoryx ./tools/iceoryx_build_test.sh build-all Note The build script is installing the header files and binaries into build/install/prefix . You can use the help argument for getting an overview of the available options: ./tools/iceoryx_build_test.sh help Tip The examples can be built with -DEXAMPLES=ON with iceoryx_meta or by providing the examples argument to the build script. Build with colcon \ud83d\udd17 Alternatively, iceoryx can be built with colcon to provide a smooth integration for ROS 2 developers. To build the iceoryx_integrationtest package one requires a minimal ROS 2 installation . Install required ROS 2 packages: sudo apt install ros-foxy-ros-testing ros-foxy-ros-base source /opt/ros/foxy/setup.bash build with colcon: mkdir -p iceoryx_ws/src cd $_ git clone https://github.com/eclipse-iceoryx/iceoryx.git cd .. colcon build Note If you don't want to install ROS 2, you can skip the iceoryx_integrationtest package by calling: colcon build --packages-skip iceoryx_integrationtest This build method makes the most sense in combination with rmw_iceoryx","title":"Installation"},{"location":"getting-started/installation/#installation","text":"All iceoryx libraries are deployed as independent CMake packages. Posh is using functions from hoofs and is depending on it. You are able to build posh and hoofs and integrate them into existing CMake projects.","title":"Installation"},{"location":"getting-started/installation/#prerequisites","text":"","title":"Prerequisites"},{"location":"getting-started/installation/#dependencies","text":"64-bit hardware (e.g. x86_64 or aarch64; 32-bit hardware might work, but is not supported) CMake , 3.16 or later One of the following compilers: GCC , 8.3 or later (5.4 currently supported too) Clang , 9.0 or later MSVC , part of Visual Studio 2019 or later libacl , 2.2 or later. Only for Linux & QNX. optional, ncurses , 6.2 or later. Required by introspection tool (only for Linux, QNX and MacOS).","title":" Dependencies"},{"location":"getting-started/installation/#optional-cyclone-dds-gateway","text":"The Cyclone DDS gateway depends currently on Cyclone DDS . When building it with the CMake option -DDDS_GATEWAY=ON it will be automatically installed as a dependency. Furthermore, you have to install: GNU Bison , 3.0.4 or later","title":"Optional, Cyclone DDS Gateway"},{"location":"getting-started/installation/#mac-os","text":"Before installing iceoryx you need to install XCode and git. Optionally, ncurses library is required for the introspection client. To install ncurses locally into your build folder follow these steps cd iceoryx ICEORYX_DIR = $PWD mkdir -p build cd build git clone https://github.com/mirror/ncurses.git cd ncurses git checkout v6.2 ./configure --prefix = $ICEORYX_DIR /build/dependencies/ --exec-prefix = $ICEORYX_DIR /build/dependencies/ --with-termlib make -j12 make install","title":" Mac OS"},{"location":"getting-started/installation/#linux","text":"Although we strive to be fully POSIX-compliant, we recommend using Ubuntu 18.04 and at least GCC 7.5.0 for development. You will need to install the following packages: sudo apt install gcc g++ cmake libacl1-dev libncurses5-dev pkg-config Additionally, there is an optional dependency to the cpptoml library, which is used to parse the RouDi config file containing mempool configuration.","title":" Linux"},{"location":"getting-started/installation/#qnx","text":"QNX SDP 7.0 and 7.1 are supported (shipping with gcc 5.4 and gcc 8.3 respectively). The easiest way to build iceoryx on QNX is by using the build script and providing a toolchain file. We provide generic QNX SDP 7.0 toolchain files for ARM_64 and X86_64 in ./tools/toolchains/qnx ( Direct Link ). ARM_64: ./tools/iceoryx_build_test.sh -t /home/user/toolchains/qnx/qnx_sdp70_aarch64le.cmake X86_64: ./tools/iceoryx_build_test.sh -t /home/user/toolchains/qnx/qnx_sdp70_x86_64.cmake Attention Please ensure that the folder /var/lock exist and the filesystem supports file locking.","title":" QNX"},{"location":"getting-started/installation/#windows","text":"In case you do not have a Windows installation, Microsoft provides free developer images from here . Additionally, CMake and git are required. The option to add CMake to the system PATH for all users should be set when it is installed. If the developer image from Microsoft is used, Visual Studio Community 2019 is already installed, else it can be found here . To be able to compile iceoryx, the Desktop development with C++ Workload must be installed. This is done by running VisualStudioInstaller and selecting the Modify button on Visual Studio Community 2019 . Either VS Code or Developer Command Prompt can be used to build iceoryx with CMake. Maybe one or two restarts are required to let CMake find the compiler. Alternatively, C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat can be executed in any shell to setup all the paths for compilation.","title":" Windows"},{"location":"getting-started/installation/#build-with-cmake","text":"Note Building with CMake is the preferred way, for more complex actions like a coverage scan is a script available (see chapter below). The CMakeLists.txt from iceoryx_meta can be used to easily develop iceoryx with an IDE. Clone the repository git clone https://github.com/eclipse-iceoryx/iceoryx.git Generate the necessary build files cd iceoryx cmake -Bbuild -Hiceoryx_meta # when you have installed external dependencies like ncurses you have to add them # to your prefix path cmake -Bbuild -Hiceoryx_meta -DCMAKE_PREFIX_PATH = $( PWD ) /build/dependencies/ Tip To build all iceoryx components add -DBUILD_ALL=ON to the CMake command. For Windows it is currently recommended to use the cmake -Bbuild -Hiceoryx_meta -DBUILD_TEST=ON -DINTROSPECTION=OFF -DBINDING_C=ON -DEXAMPLES=ON instead Compile the source code cmake --build build Tip You can speed up the build by appending -j 4 where 4 stands for the number of parallel build processes. You can choose more or less depending on your available CPU cores on your machine. Install to system Mac: cmake --build build --target install Linux: sudo cmake --build build --target install Tip The installation directory is usually left at its default, which is /usr/local Note iceoryx is built in release mode as static library with -O3 optimization by default. If you want to enable debug symbols please set CMAKE_BUILD_TYPE=Deb .","title":" Build with CMake"},{"location":"getting-started/installation/#build-options","text":"Please take a look at the CMake file build_options.cmake to get an overview of the available build options for enabling additional features.","title":"Build options"},{"location":"getting-started/installation/#build-with-script","text":"As an alternative, we provide a build-test script which we use to integrate iceoryx into our infrastructure. The intention of the script goes beyond building iceoryx, it is also used for the code coverage scan or the address-sanitizer runs on the CI. The script currently works for Linux and QNX only, it is planned to offer a multi-platform solution. Clone the repository git clone https://github.com/eclipse-iceoryx/iceoryx.git Build everything cd iceoryx ./tools/iceoryx_build_test.sh build-all Note The build script is installing the header files and binaries into build/install/prefix . You can use the help argument for getting an overview of the available options: ./tools/iceoryx_build_test.sh help Tip The examples can be built with -DEXAMPLES=ON with iceoryx_meta or by providing the examples argument to the build script.","title":" Build with script"},{"location":"getting-started/installation/#build-with-colcon","text":"Alternatively, iceoryx can be built with colcon to provide a smooth integration for ROS 2 developers. To build the iceoryx_integrationtest package one requires a minimal ROS 2 installation . Install required ROS 2 packages: sudo apt install ros-foxy-ros-testing ros-foxy-ros-base source /opt/ros/foxy/setup.bash build with colcon: mkdir -p iceoryx_ws/src cd $_ git clone https://github.com/eclipse-iceoryx/iceoryx.git cd .. colcon build Note If you don't want to install ROS 2, you can skip the iceoryx_integrationtest package by calling: colcon build --packages-skip iceoryx_integrationtest This build method makes the most sense in combination with rmw_iceoryx","title":" Build with colcon"},{"location":"getting-started/overview/","text":"Overview \ud83d\udd17 This document covers the core functionality of Eclipse iceoryx and is intended to provide a quick introduction to setting up iceoryx applications. General \ud83d\udd17 To set up a collection of applications using iceoryx (an iceoryx system ), the applications need to initialize a runtime and create communication participants like publishers and subscribers or clients and servers . Publishers send data of a specific topic which can be received by subscribers of the same topic. Servers wait on a topic for requests from clients and respond to these requests. To enable the operation of these participants, the middleware daemon, called RouDi , must be running. But before we get into more details, let's start with a simple publish-subscribe example. A first example \ud83d\udd17 We need to create a runtime with a unique name along all applications for each application to enable communication with RouDi. iox :: runtime :: PoshRuntime :: initRuntime ( \"some_unique_name\" ); Now this application is ready to communicate with RouDi and we can define the data type we want to send. struct CounterTopic { uint32_t counter ; }; Then we create a publisher that offers our CounterTopic. iox :: popo :: Publisher < CounterTopic > publisher ({ \"Group\" , \"Instance\" , \"CounterTopic\" }); Now we can use the publisher to send the data. auto result = publisher . loan (); if ( ! result . has_error ()) { auto & sample = result . value (); sample -> counter = 30 ; sample . publish (); } else { // handle the error } Here result is an expected and hence we may get an error. This can happen if we try to loan too many samples and exhaust memory. We have to handle this potential error since the expected class has the nodiscard keyword attached. This means we get a warning (or an error when build in strict mode) when we don't handle it. We could also explicitly discard it with IOX_DISCARD_RESULT which is discouraged. If you want to know more about expected , take a look at How optional and error values are returned in iceoryx . Let's create a corresponding subscriber. iox :: popo :: Subscriber < CounterTopic > subscriber ({ \"Group\" , \"Instance\" , \"CounterTopic\" }); Now we can use the subscriber to receive data. For simplicity, we assume that we periodically check for new data. It is also possible to explicitly wait for data using the WaitSet or the Listener . The code to receive the data is the same, the only difference is the way we wake up before checking for data. while ( keepRunning ) { // wait for new data (either sleep and wake up periodically or by notification from the waitset) auto result = subscriber . take (); if ( ! result . has_error ()) { auto & sample = result . value (); uint32_t counter = sample -> counter ; //process the data } else { //handle the error } std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } By calling take we get an expected and hence we have to handle the potential error. And that's it. We have created our first simple iceoryx example. Here you can find further examples which demonstrate how iceoryx can be used and describe our API in more detail. Now that we have applications capable of sending and receiving data, we can run the complete iceoryx system. Note RouDi and all Apps have to be built with the same compiler and the same compiler flags. First we need to start RouDi. # If installed and available in PATH environment variable iox-roudi # If build from scratch with script in tools $ICEORYX_ROOT /build/iox-roudi Afterwards, we can start the applications which immediately connect to the RouDi via their runtime. When the application terminates, the runtime cleans up all resources needed for communication with RouDi. This includes all memory chunks used for the data transmission which may still be held by the application. Before going into the details in the next sections, the following animation depicts the course of events. We now briefly define the main entities of an iceoryx system which were partially already used in the example above. RouDi \ud83d\udd17 RouDi is an abbreviation for Rou ting and Di scovery. RouDi takes care of the communication setup but does not actually participate in the communication between the publisher and the subscriber or the client and the server. RouDi can be thought of as the switchboard operator of iceoryx. One of its other major tasks is the setup of the shared memory, which the applications use for exchanging payload data. Sometimes referred to as daemon, RouDi manages the shared memory and is responsible for the service discovery, i.e. enabling subscribers/clients to find topics offered by publishers/servers. It also keeps track of all applications which have initialized a runtime and are hence able to create publishers, subscribers, servers or clients. It provides facilities for applications to query this information. When an application crashes, RouDi cleans up all resources. Due to our mostly lock-free inter-process mechanisms (only one last lock; we are working to remove it), iceoryx-based communication is much more reliable compared to traditional mechanism using locking. To view the available command line options for RouDi call $ICEORYX_ROOT/build/iox-roudi --help . Shared memory \ud83d\udd17 To enable zero-copy inter-process communication, iceoryx uses the shared memory approach, i.e. publishers and subscribers or clients and servers can communicate via shared memory resulting in zero-copy communication. Shared memory is physical memory that is made accessible to multiple processes via a mapping to a memory area in their virtual address spaces. For further information have a look at our shared memory concept article . Runtime \ud83d\udd17 Each application that wants to use iceoryx has to instantiate its runtime, which essentially enables communication with RouDi. To do so, the following lines of code are required iox :: runtime :: PoshRuntime :: initRuntime ( \"some_unique_application_name\" ); The runtime is an object inside the user application that maps the shared memory into the user application's address space. Note Only one runtime object per user application is allowed. Creating service descriptions for topics \ud83d\udd17 A ServiceDescription in iceoryx represents a topic under which publishers and subscribers or clients and servers can exchange data and is uniquely identified by three string identifiers. Group name Instance name Topic name A triple consisting of such strings is called a ServiceDescription . Two ServiceDescription s are considered matching if all these three strings are element-wise equal, i.e. group, instance and topic names are the same for both of them. This means the group and instance identifier can be ignored to create different ServiceDescription s. They will be needed for advanced filtering functionality in the future. The service model of iceoryx is derived from AUTOSAR and is still used in the API with these names ( Service , Instance , Event ). The so called canonical protocol is implemented in the namespace capro . The following table gives an overview of the different terminologies and the current mapping: Group Instance Topic rmw_iceoryx Type Namespace/Topic - AUTOSAR Service Instance Event DDS Gateway - - /Group/Instance/Topic Cyclone DDS - Type Name Topic Name Service is related to instance like classes are related to objects in C++. A service describes an abstract topic and an instance is one instantiation of that abstraction, like an object is an instantiated class. Events are in this context like members of a class. Example: class MyRadarService { public : bool hasObstacleDetected ; float distanceToObstacle ; }; MyRadarService frontLeftRadarInstance ; std :: cout << frontLeftRadarInstance . hasObstacleDetected << std :: endl ; In the iceoryx world, we would for instance subscribe to the service (\"MyRadarService\", \"frontLeftRadarInstance\", \"hasObstacleDetected\") and would receive a sample whenever an obstacle was detected. Or we would subscribe to distanceToObstacle and would receive a constant stream of data which presents the distance to the obstacle. Restrictions \ud83d\udd17 The data type of the transmitted data can be any C++ class, struct or plain old data type as long as it satisfies the following conditions: no heap is used the data structure is entirely contained in the shared memory - no pointers to process local memory, no references to process local constructs, no dynamic allocators the data structure has to be relocatable and therefore must not internally use pointers/references no virtual member functions Note Most of the STL types cannot be used, but we reimplemented some of them so that they meet the conditions above. You can find an overview here . Publisher \ud83d\udd17 A publisher is tied to a topic and needs a service description to be constructed. If it is typed, one needs to additionally specify the data type as a template parameter. Otherwise, the publisher is only aware of raw memory and the user has to ensure that it is interpreted correctly. Once it has offered its topic, it is able to publish (send) data of the specific type. Note that the default is to have multiple publishers for the same topic (n:m communication). A compile-time option to restrict iceoryx to 1:n communication is available. Should 1:n communication be used, RouDi checks for multiple publishers on the same topics and raises an error if there is more than one publisher for a topic. Subscriber \ud83d\udd17 Symmetrically a subscriber also corresponds to a topic and thus needs a service description to be constructed. As for publishers we distinguish between typed and untyped subscribers. Once a subscriber is subscribed to some topic, it is able to receive data of the type tied to this topic. In the untyped case this is raw memory and the user must take care that it is interpreted in a way that is compatible to the data that was actually sent. When multiple publishers have offered the same topic the subscriber will receive the data of all of them (but in indeterminate order between different publishers). Note that the subscriber will not receive data from servers or clients, even when they use the same topic. Client \ud83d\udd17 Similar to publishers and subscribers, clients are tied to a topic and need a service description to be constructed. If the client is typed, one needs to specify the request and response data types as template parameters. In the untyped case, the client is only aware of raw memory and the user has to take care of its correct interpretation. Once a client is connected to a server, it can send requests to and receive responses from the server. A sequence ID is used to match a response to a specific request. It must be set on request and checked on response by the user. Server \ud83d\udd17 Like a client, a server needs a service description to be constructed and can be typed or untyped. In the typed case, the user has to provide the request and the response data types as template parameters. Otherwise, the server handles raw memory and the user has to ensure that it is interpreted correctly. Once connected, the server can receive requests from clients and send the corresponding responses. Avoid polling \ud83d\udd17 The easiest way to receive data is to periodically poll whether data is available as depicted on the left side of the picture below for the publish-subscribe messaging pattern. This is sufficient for simple use cases but inefficient in general, as it often leads to unnecessary latency and wake-ups without data. An alternative approach to receive data is to wait for user-defined events to occur. This is provided by our WaitSet and Listener which are introduced in the following sections. WaitSet \ud83d\udd17 The WaitSet can be used to relinquish control by putting the thread to sleep with a non-busy wait and wait for user-defined events to occur. Usually, these events correspond to the availability of data at specific subscribers or clients. This way we can immediately wake up when data is available and avoid unnecessary wake-ups if no data is available. One typical use case is to create a WaitSet, attach multiple subscribers and/or clients and user triggers and then wait until one or many of the attached objects signal an event. If this happens one receives a list of all occured events called notificationVector . This makes it possible to collect data directly from the subscriber or client when it signals the WaitSet that new data or a new response is available. The WaitSet uses the reactor pattern and is informed with a push strategy that one of the attached events occured at which it informs the user. For more information on how to use the WaitSet see our WaitSet examples . Listener \ud83d\udd17 The Listener can be used to connect custom callbacks to user-defined events. Unlike the WaitSet, it reacts to those events by executing the connected custom callbacks in a background thread, that will be created by the Listener. As with the WaitSet the background thread waits non-busy on the reception of new data. Note The Listener is completely thread-safe but please be aware that most of the objects which can be attached to the Listener are not thread-safe! This means either the object is handled solely by the Listener, which should be the most common use case, or the user has to ensure the thread safety with other means like encapsulating the object in a thread-safe class. One use case could be that one creates a Listener and attaches multiple subscribers. Every time new data is available, the corresponding connected callback will be executed, e.g. print something to the console or calculate an algorithm. Another use case could be that a server is attached to the Listener and every time a request is received, the connected callback that creates and sends a response, is executed. Like the WaitSet, the Listener uses the reactor pattern. For more information about the Listener see our callbacks examples . API \ud83d\udd17 The API is offered in two languages, C++ and C. Detailed information can be found in the C++ example and C example . Many parts of the C++ API follow a functional programming approach which is less error-prone. This requires using the monadic types cxx::expected and cxx::optional which are introduced here . With the C++ API, we distinguish between the typed API and the untyped API . In the typed API, the underlying data type is made apparent by typed pointers or references to some data type T (often a template parameter). This allows working with the data in a C++ idiomatic and type-safe way and should be preferred whenever possible. The typed API is mainly used when iceoryx is used stand-alone, i.e. not integrated into a third party framework. The untyped API provides opaque (i.e. void) pointers to data, which is flexible and efficient but also requires that the user takes care to interpret received data correctly, i.e. as a type compatible to what was actually sent. This is required for interaction with other lower level APIs and integration into third party frameworks such as ROS . For further information see the respective header files.","title":"Overview"},{"location":"getting-started/overview/#overview","text":"This document covers the core functionality of Eclipse iceoryx and is intended to provide a quick introduction to setting up iceoryx applications.","title":"Overview"},{"location":"getting-started/overview/#general","text":"To set up a collection of applications using iceoryx (an iceoryx system ), the applications need to initialize a runtime and create communication participants like publishers and subscribers or clients and servers . Publishers send data of a specific topic which can be received by subscribers of the same topic. Servers wait on a topic for requests from clients and respond to these requests. To enable the operation of these participants, the middleware daemon, called RouDi , must be running. But before we get into more details, let's start with a simple publish-subscribe example.","title":"General"},{"location":"getting-started/overview/#a-first-example","text":"We need to create a runtime with a unique name along all applications for each application to enable communication with RouDi. iox :: runtime :: PoshRuntime :: initRuntime ( \"some_unique_name\" ); Now this application is ready to communicate with RouDi and we can define the data type we want to send. struct CounterTopic { uint32_t counter ; }; Then we create a publisher that offers our CounterTopic. iox :: popo :: Publisher < CounterTopic > publisher ({ \"Group\" , \"Instance\" , \"CounterTopic\" }); Now we can use the publisher to send the data. auto result = publisher . loan (); if ( ! result . has_error ()) { auto & sample = result . value (); sample -> counter = 30 ; sample . publish (); } else { // handle the error } Here result is an expected and hence we may get an error. This can happen if we try to loan too many samples and exhaust memory. We have to handle this potential error since the expected class has the nodiscard keyword attached. This means we get a warning (or an error when build in strict mode) when we don't handle it. We could also explicitly discard it with IOX_DISCARD_RESULT which is discouraged. If you want to know more about expected , take a look at How optional and error values are returned in iceoryx . Let's create a corresponding subscriber. iox :: popo :: Subscriber < CounterTopic > subscriber ({ \"Group\" , \"Instance\" , \"CounterTopic\" }); Now we can use the subscriber to receive data. For simplicity, we assume that we periodically check for new data. It is also possible to explicitly wait for data using the WaitSet or the Listener . The code to receive the data is the same, the only difference is the way we wake up before checking for data. while ( keepRunning ) { // wait for new data (either sleep and wake up periodically or by notification from the waitset) auto result = subscriber . take (); if ( ! result . has_error ()) { auto & sample = result . value (); uint32_t counter = sample -> counter ; //process the data } else { //handle the error } std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } By calling take we get an expected and hence we have to handle the potential error. And that's it. We have created our first simple iceoryx example. Here you can find further examples which demonstrate how iceoryx can be used and describe our API in more detail. Now that we have applications capable of sending and receiving data, we can run the complete iceoryx system. Note RouDi and all Apps have to be built with the same compiler and the same compiler flags. First we need to start RouDi. # If installed and available in PATH environment variable iox-roudi # If build from scratch with script in tools $ICEORYX_ROOT /build/iox-roudi Afterwards, we can start the applications which immediately connect to the RouDi via their runtime. When the application terminates, the runtime cleans up all resources needed for communication with RouDi. This includes all memory chunks used for the data transmission which may still be held by the application. Before going into the details in the next sections, the following animation depicts the course of events. We now briefly define the main entities of an iceoryx system which were partially already used in the example above.","title":"A first example"},{"location":"getting-started/overview/#roudi","text":"RouDi is an abbreviation for Rou ting and Di scovery. RouDi takes care of the communication setup but does not actually participate in the communication between the publisher and the subscriber or the client and the server. RouDi can be thought of as the switchboard operator of iceoryx. One of its other major tasks is the setup of the shared memory, which the applications use for exchanging payload data. Sometimes referred to as daemon, RouDi manages the shared memory and is responsible for the service discovery, i.e. enabling subscribers/clients to find topics offered by publishers/servers. It also keeps track of all applications which have initialized a runtime and are hence able to create publishers, subscribers, servers or clients. It provides facilities for applications to query this information. When an application crashes, RouDi cleans up all resources. Due to our mostly lock-free inter-process mechanisms (only one last lock; we are working to remove it), iceoryx-based communication is much more reliable compared to traditional mechanism using locking. To view the available command line options for RouDi call $ICEORYX_ROOT/build/iox-roudi --help .","title":"RouDi"},{"location":"getting-started/overview/#shared-memory","text":"To enable zero-copy inter-process communication, iceoryx uses the shared memory approach, i.e. publishers and subscribers or clients and servers can communicate via shared memory resulting in zero-copy communication. Shared memory is physical memory that is made accessible to multiple processes via a mapping to a memory area in their virtual address spaces. For further information have a look at our shared memory concept article .","title":"Shared memory"},{"location":"getting-started/overview/#runtime","text":"Each application that wants to use iceoryx has to instantiate its runtime, which essentially enables communication with RouDi. To do so, the following lines of code are required iox :: runtime :: PoshRuntime :: initRuntime ( \"some_unique_application_name\" ); The runtime is an object inside the user application that maps the shared memory into the user application's address space. Note Only one runtime object per user application is allowed.","title":"Runtime"},{"location":"getting-started/overview/#creating-service-descriptions-for-topics","text":"A ServiceDescription in iceoryx represents a topic under which publishers and subscribers or clients and servers can exchange data and is uniquely identified by three string identifiers. Group name Instance name Topic name A triple consisting of such strings is called a ServiceDescription . Two ServiceDescription s are considered matching if all these three strings are element-wise equal, i.e. group, instance and topic names are the same for both of them. This means the group and instance identifier can be ignored to create different ServiceDescription s. They will be needed for advanced filtering functionality in the future. The service model of iceoryx is derived from AUTOSAR and is still used in the API with these names ( Service , Instance , Event ). The so called canonical protocol is implemented in the namespace capro . The following table gives an overview of the different terminologies and the current mapping: Group Instance Topic rmw_iceoryx Type Namespace/Topic - AUTOSAR Service Instance Event DDS Gateway - - /Group/Instance/Topic Cyclone DDS - Type Name Topic Name Service is related to instance like classes are related to objects in C++. A service describes an abstract topic and an instance is one instantiation of that abstraction, like an object is an instantiated class. Events are in this context like members of a class. Example: class MyRadarService { public : bool hasObstacleDetected ; float distanceToObstacle ; }; MyRadarService frontLeftRadarInstance ; std :: cout << frontLeftRadarInstance . hasObstacleDetected << std :: endl ; In the iceoryx world, we would for instance subscribe to the service (\"MyRadarService\", \"frontLeftRadarInstance\", \"hasObstacleDetected\") and would receive a sample whenever an obstacle was detected. Or we would subscribe to distanceToObstacle and would receive a constant stream of data which presents the distance to the obstacle.","title":"Creating service descriptions for topics"},{"location":"getting-started/overview/#restrictions","text":"The data type of the transmitted data can be any C++ class, struct or plain old data type as long as it satisfies the following conditions: no heap is used the data structure is entirely contained in the shared memory - no pointers to process local memory, no references to process local constructs, no dynamic allocators the data structure has to be relocatable and therefore must not internally use pointers/references no virtual member functions Note Most of the STL types cannot be used, but we reimplemented some of them so that they meet the conditions above. You can find an overview here .","title":"Restrictions"},{"location":"getting-started/overview/#publisher","text":"A publisher is tied to a topic and needs a service description to be constructed. If it is typed, one needs to additionally specify the data type as a template parameter. Otherwise, the publisher is only aware of raw memory and the user has to ensure that it is interpreted correctly. Once it has offered its topic, it is able to publish (send) data of the specific type. Note that the default is to have multiple publishers for the same topic (n:m communication). A compile-time option to restrict iceoryx to 1:n communication is available. Should 1:n communication be used, RouDi checks for multiple publishers on the same topics and raises an error if there is more than one publisher for a topic.","title":"Publisher"},{"location":"getting-started/overview/#subscriber","text":"Symmetrically a subscriber also corresponds to a topic and thus needs a service description to be constructed. As for publishers we distinguish between typed and untyped subscribers. Once a subscriber is subscribed to some topic, it is able to receive data of the type tied to this topic. In the untyped case this is raw memory and the user must take care that it is interpreted in a way that is compatible to the data that was actually sent. When multiple publishers have offered the same topic the subscriber will receive the data of all of them (but in indeterminate order between different publishers). Note that the subscriber will not receive data from servers or clients, even when they use the same topic.","title":"Subscriber"},{"location":"getting-started/overview/#client","text":"Similar to publishers and subscribers, clients are tied to a topic and need a service description to be constructed. If the client is typed, one needs to specify the request and response data types as template parameters. In the untyped case, the client is only aware of raw memory and the user has to take care of its correct interpretation. Once a client is connected to a server, it can send requests to and receive responses from the server. A sequence ID is used to match a response to a specific request. It must be set on request and checked on response by the user.","title":"Client"},{"location":"getting-started/overview/#server","text":"Like a client, a server needs a service description to be constructed and can be typed or untyped. In the typed case, the user has to provide the request and the response data types as template parameters. Otherwise, the server handles raw memory and the user has to ensure that it is interpreted correctly. Once connected, the server can receive requests from clients and send the corresponding responses.","title":"Server"},{"location":"getting-started/overview/#avoid-polling","text":"The easiest way to receive data is to periodically poll whether data is available as depicted on the left side of the picture below for the publish-subscribe messaging pattern. This is sufficient for simple use cases but inefficient in general, as it often leads to unnecessary latency and wake-ups without data. An alternative approach to receive data is to wait for user-defined events to occur. This is provided by our WaitSet and Listener which are introduced in the following sections.","title":"Avoid polling"},{"location":"getting-started/overview/#waitset","text":"The WaitSet can be used to relinquish control by putting the thread to sleep with a non-busy wait and wait for user-defined events to occur. Usually, these events correspond to the availability of data at specific subscribers or clients. This way we can immediately wake up when data is available and avoid unnecessary wake-ups if no data is available. One typical use case is to create a WaitSet, attach multiple subscribers and/or clients and user triggers and then wait until one or many of the attached objects signal an event. If this happens one receives a list of all occured events called notificationVector . This makes it possible to collect data directly from the subscriber or client when it signals the WaitSet that new data or a new response is available. The WaitSet uses the reactor pattern and is informed with a push strategy that one of the attached events occured at which it informs the user. For more information on how to use the WaitSet see our WaitSet examples .","title":"WaitSet"},{"location":"getting-started/overview/#listener","text":"The Listener can be used to connect custom callbacks to user-defined events. Unlike the WaitSet, it reacts to those events by executing the connected custom callbacks in a background thread, that will be created by the Listener. As with the WaitSet the background thread waits non-busy on the reception of new data. Note The Listener is completely thread-safe but please be aware that most of the objects which can be attached to the Listener are not thread-safe! This means either the object is handled solely by the Listener, which should be the most common use case, or the user has to ensure the thread safety with other means like encapsulating the object in a thread-safe class. One use case could be that one creates a Listener and attaches multiple subscribers. Every time new data is available, the corresponding connected callback will be executed, e.g. print something to the console or calculate an algorithm. Another use case could be that a server is attached to the Listener and every time a request is received, the connected callback that creates and sends a response, is executed. Like the WaitSet, the Listener uses the reactor pattern. For more information about the Listener see our callbacks examples .","title":"Listener"},{"location":"getting-started/overview/#api","text":"The API is offered in two languages, C++ and C. Detailed information can be found in the C++ example and C example . Many parts of the C++ API follow a functional programming approach which is less error-prone. This requires using the monadic types cxx::expected and cxx::optional which are introduced here . With the C++ API, we distinguish between the typed API and the untyped API . In the typed API, the underlying data type is made apparent by typed pointers or references to some data type T (often a template parameter). This allows working with the data in a C++ idiomatic and type-safe way and should be preferred whenever possible. The typed API is mainly used when iceoryx is used stand-alone, i.e. not integrated into a third party framework. The untyped API provides opaque (i.e. void) pointers to data, which is flexible and efficient but also requires that the user takes care to interpret received data correctly, i.e. as a type compatible to what was actually sent. This is required for interaction with other lower level APIs and integration into third party frameworks such as ROS . For further information see the respective header files.","title":"API"},{"location":"getting-started/what-is-iceoryx/","text":"What is Eclipse iceoryx? \ud83d\udd17 The technology behind Eclipse iceoryx originated in the automotive domain. With the introduction of video-based driver assistance, the amount of data to be exchanged between different threads of execution increased to GBytes/sec. The resources on these embedded systems were constrained and a solution was needed to use precious runtime for functional computations, not for shifting around bytes in memory. The simple answer was to avoid copying of messages inside the middleware that manages the data communication between the different software nodes. This can be done by using shared memory that can be accessed by the producers and consumers of messages. On its own, this is not a new innovation as the approach has been used since the 1970s. However, iceoryx takes the approach further, ending up in an inter-process-communication technology with a publish/subscribe and request/response architecture that is fast, flexible and dependable. Fast \ud83d\udd17 With the iceoryx API, a publisher can write the message directly into a chunk of memory that was previously requested from the middleware. When the message is delivered, subscribers receive reference counted pointers to these memory chunks, which are stored in queues with configurable capacities. The same principle applies to clients and servers. With this iceoryx achieves what we refer to as true zero-copy \u2014 an end-to-end approach from producers to consumers without creating a single copy. Avoiding the copies on API level is crucial when GBytes of sensor data have to be processed per second on robotics and autonomous driving systems. Therefore the iceoryx team contributed to the standardization of true zero-copy capable APIs in ROS 2 and AUTOSAR Adaptive . On modern processors iceoryx has a latency of less than 1 \u00b5s for transferring a message. And the best message is that this latency is constant as size doesn't matter. Want to give it a try? Then have a look at our iceperf example after having made the first steps. Flexible \ud83d\udd17 iceoryx already supports Linux, QNX and MacOS as operating systems as well as C and C++ as user APIs. Windows and Rust are the next ones on the list. The typed C++ API is the most comfortable when you want to directly use the iceoryx API on the user side. The untyped C++ API and the C API provide a data agnostic interface that is often preferred when integrating iceoryx as shared memory backbone into a bigger framework. The APIs support polling access and event-driven interactions with the WaitSet and Listener . Applications can be started and stopped flexibly as there is a service discovery behind the scenes that dynamically connects matching communication entities. That iceoryx has the right set of features can be seen from the already existing integrations in middleware and frameworks such as Eclipse Cyclone DDS , eCAL from Continental , RTA-VRTE from ETAS and Apex.Middleware from Apex.AI . Dependable \ud83d\udd17 The predecessor of iceoryx is running in millions of vehicles worldwide. All iceoryx maintainers hail from the safety critical automotive domain. Hence, they know the necessary requirements and have these in mind for the design and implementation of features. The usage of heap, exceptions and any undefined behavior are to be avoided to increase the predictability. Instead a custom memory allocation is being used, based on static memory pools. Additionally, the handling of return values and error cases was inspired by upcoming C++ features and other languages like Rust (details can be found here ). As different processes are operating on shared data structures, avoiding deadlocks is becoming all the more important. iceoryx uses lock-free data structures like the multi-producer multi-consumer (MPMC) queue that was written portably thanks to modern C++. The tools available for automotive-compliant software development are always one or two releases behind the latest C++ standard. This fact, combined with our already mentioned constraints, led to a bunch of STL like C++ classes that have the goal to combine modern C++ with the reliability needed for the domains iceoryx is used in. They can be found in the iceoryx hoofs which are introduced here .","title":"What is Eclipse iceoryx?"},{"location":"getting-started/what-is-iceoryx/#what-is-eclipse-iceoryx","text":"The technology behind Eclipse iceoryx originated in the automotive domain. With the introduction of video-based driver assistance, the amount of data to be exchanged between different threads of execution increased to GBytes/sec. The resources on these embedded systems were constrained and a solution was needed to use precious runtime for functional computations, not for shifting around bytes in memory. The simple answer was to avoid copying of messages inside the middleware that manages the data communication between the different software nodes. This can be done by using shared memory that can be accessed by the producers and consumers of messages. On its own, this is not a new innovation as the approach has been used since the 1970s. However, iceoryx takes the approach further, ending up in an inter-process-communication technology with a publish/subscribe and request/response architecture that is fast, flexible and dependable.","title":"What is Eclipse iceoryx?"},{"location":"getting-started/what-is-iceoryx/#fast","text":"With the iceoryx API, a publisher can write the message directly into a chunk of memory that was previously requested from the middleware. When the message is delivered, subscribers receive reference counted pointers to these memory chunks, which are stored in queues with configurable capacities. The same principle applies to clients and servers. With this iceoryx achieves what we refer to as true zero-copy \u2014 an end-to-end approach from producers to consumers without creating a single copy. Avoiding the copies on API level is crucial when GBytes of sensor data have to be processed per second on robotics and autonomous driving systems. Therefore the iceoryx team contributed to the standardization of true zero-copy capable APIs in ROS 2 and AUTOSAR Adaptive . On modern processors iceoryx has a latency of less than 1 \u00b5s for transferring a message. And the best message is that this latency is constant as size doesn't matter. Want to give it a try? Then have a look at our iceperf example after having made the first steps.","title":"Fast"},{"location":"getting-started/what-is-iceoryx/#flexible","text":"iceoryx already supports Linux, QNX and MacOS as operating systems as well as C and C++ as user APIs. Windows and Rust are the next ones on the list. The typed C++ API is the most comfortable when you want to directly use the iceoryx API on the user side. The untyped C++ API and the C API provide a data agnostic interface that is often preferred when integrating iceoryx as shared memory backbone into a bigger framework. The APIs support polling access and event-driven interactions with the WaitSet and Listener . Applications can be started and stopped flexibly as there is a service discovery behind the scenes that dynamically connects matching communication entities. That iceoryx has the right set of features can be seen from the already existing integrations in middleware and frameworks such as Eclipse Cyclone DDS , eCAL from Continental , RTA-VRTE from ETAS and Apex.Middleware from Apex.AI .","title":"Flexible"},{"location":"getting-started/what-is-iceoryx/#dependable","text":"The predecessor of iceoryx is running in millions of vehicles worldwide. All iceoryx maintainers hail from the safety critical automotive domain. Hence, they know the necessary requirements and have these in mind for the design and implementation of features. The usage of heap, exceptions and any undefined behavior are to be avoided to increase the predictability. Instead a custom memory allocation is being used, based on static memory pools. Additionally, the handling of return values and error cases was inspired by upcoming C++ features and other languages like Rust (details can be found here ). As different processes are operating on shared data structures, avoiding deadlocks is becoming all the more important. iceoryx uses lock-free data structures like the multi-producer multi-consumer (MPMC) queue that was written portably thanks to modern C++. The tools available for automotive-compliant software development are always one or two releases behind the latest C++ standard. This fact, combined with our already mentioned constraints, led to a bunch of STL like C++ classes that have the goal to combine modern C++ with the reliability needed for the domains iceoryx is used in. They can be found in the iceoryx hoofs which are introduced here .","title":"Dependable"},{"location":"release-notes/iceoryx-unreleased/","text":"iceoryx vx.x.x \ud83d\udd17 vx.x.x (xxxx-xx-xx) \ud83d\udd17 Full Changelog Features: Bugfixes: Foo Bar #000 Refactoring: New API features: API Breaking Changes: Some API change. // before #include \"old/include.hpp\" // after #include \"new/include.hpp\"","title":"iceoryx vx.x.x"},{"location":"release-notes/iceoryx-unreleased/#iceoryx-vxxx","text":"","title":"iceoryx vx.x.x"},{"location":"release-notes/iceoryx-unreleased/#vxxx-xxxx-xx-xx","text":"Full Changelog Features: Bugfixes: Foo Bar #000 Refactoring: New API features: API Breaking Changes: Some API change. // before #include \"old/include.hpp\" // after #include \"new/include.hpp\"","title":"vx.x.x (xxxx-xx-xx)"},{"location":"release-notes/iceoryx-v1-0-0/","text":"iceoryx v1.0.0 \ud83d\udd17 v1.0.0 (2021-04-15) \ud83d\udd17 Full Changelog Description: This is the first major release for Eclipse iceoryx. That means it is the first release with long-term support and the adopters of iceoryx can rely on a stable API. The release called Almond allows for true zero-copy inter-process-communication on Linux, QNX and MacOS and provides C and modern C++ user APIs. This release is supported until 2022-04-01. Compared to the feature content of the initial contribution, the main new features are: Features: Introduction of a C API Refactoring of C++ API MacOS support Support for n:m communication Bridge to Eclipse Cyclone DDS See Eclipse iceoryx 1.0.0 (Almond) for more information. Reserved chunkinfo user payload header #14 New chunk available callback for the new C++ and C APIs #350 Add generic QNX toolchain files #609 Introduction of Runnables/Nodes for the new APIs #349 extend waitset and listener for member use case and waitset callback for user type #707 Refactoring: Added tests to iceoryx_posh and iceoryx_utils #496 , #484 , #454 , #240 Add [[nodiscard]] keyword to cxx::expected class #624 Refactor Relocatable Pointer #605 Integration test with RouDi and new API elements #378 Refactoring copyright headers #483 Integration of Unix Domain Sockets #381 Add how to install after build to guide #533 Add maven and openjdk-14-jdk-headless as build prerequisites #525 Refine modern pub/sub API #408 Replace introspection threads with PeriodicTask #489 Enable UndefinedBehaviorSanitizer #489 Move iceoryx from eclipse to iceoryx-eclipse organization #467 Fixed bugs: TOML parser exceptions will crash RouDi #622 fail build on ubuntu 16.04 with g++ 5.4.0 #495 Wrong handling of applications that are started multiple times in parallel #404 Expected and_then/or_else calling callable without checking #599 std::void_t used in code #591 Fix resource leak caused by move ctor/assignment #542 nanoseconds in units::Duration are truncated #190 popo/user_trigger.hpp:33:5: error: exception specification of explicitly defaulted default constructor does not match the calculated one #494 iceoryx libs should be build as static libs #509 Build with gcov is broken #497 v0.99.7 (2021-04-09) \ud83d\udd17 Full Changelog cleanup testing libraries; if used outside of iceoryx, include paths and link targets must be adjusted build iceoryx_utils, iceoryx_posh and iceoryx_binding_c as shared libraries in colcon v0.99.6 (2021-04-08) \ud83d\udd17 Full Changelog Add git to dependency list in iceoryx_posh for RHEL v0.99.5 (2021-04-08) \ud83d\udd17 Full Changelog Add libatomic to dependency list in iceoryx_utils for RHEL v0.99.4 (2021-04-06) \ud83d\udd17 Full Changelog Increase version number to trigger build again on ROS buildfarm v0.99.3 (2021-04-06) \ud83d\udd17 Full Changelog Increase version number to trigger build again on ROS buildfarm v0.99.2 (2021-04-03) \ud83d\udd17 Full Changelog Prepare package release for iceoryx 1.0 #670 v0.99.0 (2021-04-01) \ud83d\udd17 Full Changelog Intermediate Milestone before the final 1.0.0 release, see v.1.0.0 above for the changes. v0.90.0 (2020-12-22) \ud83d\udd17 Full Changelog Pre-Release for new and stable APIs and n:m pub/sub communication This is a pre-release for our first long-term-support release that is coming soon (will be iceoryx_1.0.0). We had a major refactoring of the iceoryx communication infrastructure which allows to do n:m communication now and provides a flexible history functionality for late joining subscribers. This new infrastructure is also made to support request/response communication as a next step (#27) . The C++ API has been completely reworked and a new C API has been added. We will give the API draft some weeks for finalizing the features and to incorporate feedback from the community. There's an issue in which we collect and discuss the final modifications (#408) . Features: Complete refactoring of publishers and subscribers from shared memory data structures to user APIs, #252 First versions of new APIs for C++ and C #252 n:m publish/subscribe communication now possible #25 First version of a DDS gateway. Cyclone DDS already integrated, FastDDS on it's way #64 , #65 New github actions for Mac OS and colcon build #175 , #276 , #328 Adjustable capacity for the lockfree queue #216 Check the files have a copyright header #346 Refactoring: Refactoring of waitset #341 create multi publisher example #394 Full IceOryx Public API Cheat Sheet #283 Rework build and test steps in iceoryx #433 Extend iceperf example to C API #453 Remove default parameter from PoshRuntime::getInstance() #382 Enable Sanitizer in Debug Build and Unit Tests #141 Minor RouDi cleanups #91 C++14 #220 Replace occurence of std::list by cxx::list #221 Fixed bugs: SegFault in iox-roudi on startup #447 Mocks can cause segfaults/undefined behavior #427 Chunks are lost forever when having an overflow in a variant queue of type FIFO #456 RouDi does not free shared memory properly on x86 Linux #324 WaitSet behavior wrong in waitAndReturnFulfilledConditions #388 Incorrect usage of strncpy #374 Global Instantiation of Publisher/Subscriber created core dump #327 v0.17.0 (2020-08-27) \ud83d\udd17 Full Changelog \\ MacOS support and preparations for new API Packages: iceoryx_posh (Quality level 4) iceoryx_utils (Quality level 4) iceoryx_examples (Quality level 5) Features: MacOS support #32 Major RouDi refactorings #70 , #59 , #78 Preparations for new iceoryx API #25 iceoryx to cyclonedds gateway #64 Introduce cxx::function_ref #86 Fixed bugs: POSIX timer improvements #120 , #167 Memory Synchronisation Issue in FiFo #119 Roudi MessageQueue thread startup #171 Destructor fix MessageQueue and UnixDomainSocket #150 RouDi ressource clean-up #113 v0.17.0_RC6 (2020-07-29) \ud83d\udd17 Full Changelog \\ Release Candidate for 0.17.0 release Fixed bugs: Sporadic timing test failure #120 Improvement: Merge Mempool Introspection data into one sample #210 v0.17.0_RC5 (2020-07-29) \ud83d\udd17 Full Changelog \\ Release Candidate for 0.17.0 release Fixed bugs: Callable can outrun periodicity of POSIX timer #161 v0.17.0_RC4 (2020-07-29) \ud83d\udd17 Full Changelog \\ Release Candidate for 0.17.0 release Fixed bugs: The destroy method of MessageQueue and UnixDomainSocket does not fully invalidate the object #150 Roudi message queue thread startup #171 v0.17.0_RC3 (2020-07-27) \ud83d\udd17 Full Changelog \\ Release Candidate for 0.17.0 release Features: cmake options for deployment parameter #142 v0.17.0_RC2 (2020-07-27) \ud83d\udd17 Full Changelog \\ Release Candidate for 0.17.0 release Refactoring: Refactoring of logging #88 Remove const_cast wherever possible #76 Remove asynchronous service discovery feature #90 qacpp-4.5.0-2427 #93 Usage of github actions to build pull requests #89 Reduce default memory consumption with config and mempools #78 Fixed bugs: Sporadic timing test failure #120 Make SOFI real size equal to the specified one #105 increase padding in introspection #117 Increase the process waiting for RouDi timeout to 60 seconds #110 v0.17.0_RC1 (2020-03-24) \ud83d\udd17 Full Changelog \\ Release Candidate for 0.17.0 release Features: Memory abstraction, modularization of RouDi and fixes #59 Memory abstraction and RouDi modularization step 2, fixed string improvements and other fixes #70 Fixed bugs: Can't compile due to missing CPPTOML #67 v0.16.1 (2020-03-02) \ud83d\udd17 Full Changelog \\ Support for rmw_iceoryx with ROS2 python API Packages: POSH (POSIX Shared Memory) Utils Iceoryx examples Features: Capability to cleanup shared memory resources during process lifetime #51 Fixed bugs: compile error with clang #43 CMqInterface unit tests are failing caused by unneeded move operations #56 Known limitations: RouDi --version shows 0.16.0.1 instead of 0.16.1 v0.16.0 (2019-12-16) \ud83d\udd17 Introspection, performance test and flexible mapping of shared memory Packages: POSH (POSIX Shared Memory) Utils Iceoryx examples Features: Introspection client for live debugging of iceoryx #21 Flexible mapping of shared memory in virtual address spaces #19 Performance test to measure inter-process latency #17 Docker build #15 (Thanks to @Mr-Slippery ) Fixed bugs: Payload size not updated by allocateChunk #10 Failure in runnable creation #23 Command for generating git log for merge commits between two tags **git log --merges --first-parent master --pretty = format: \"%h %<(10,trunc)%aN %C(white)%<(15)%aD%Creset %C(red bold)%<(15)%D%Creset %s\" <TAG_BASE>...<TAG_TARGET> > diff_merge_commit.log**","title":"iceoryx v1.0.0"},{"location":"release-notes/iceoryx-v1-0-0/#iceoryx-v100","text":"","title":"iceoryx v1.0.0"},{"location":"release-notes/iceoryx-v1-0-0/#v100-2021-04-15","text":"Full Changelog Description: This is the first major release for Eclipse iceoryx. That means it is the first release with long-term support and the adopters of iceoryx can rely on a stable API. The release called Almond allows for true zero-copy inter-process-communication on Linux, QNX and MacOS and provides C and modern C++ user APIs. This release is supported until 2022-04-01. Compared to the feature content of the initial contribution, the main new features are: Features: Introduction of a C API Refactoring of C++ API MacOS support Support for n:m communication Bridge to Eclipse Cyclone DDS See Eclipse iceoryx 1.0.0 (Almond) for more information. Reserved chunkinfo user payload header #14 New chunk available callback for the new C++ and C APIs #350 Add generic QNX toolchain files #609 Introduction of Runnables/Nodes for the new APIs #349 extend waitset and listener for member use case and waitset callback for user type #707 Refactoring: Added tests to iceoryx_posh and iceoryx_utils #496 , #484 , #454 , #240 Add [[nodiscard]] keyword to cxx::expected class #624 Refactor Relocatable Pointer #605 Integration test with RouDi and new API elements #378 Refactoring copyright headers #483 Integration of Unix Domain Sockets #381 Add how to install after build to guide #533 Add maven and openjdk-14-jdk-headless as build prerequisites #525 Refine modern pub/sub API #408 Replace introspection threads with PeriodicTask #489 Enable UndefinedBehaviorSanitizer #489 Move iceoryx from eclipse to iceoryx-eclipse organization #467 Fixed bugs: TOML parser exceptions will crash RouDi #622 fail build on ubuntu 16.04 with g++ 5.4.0 #495 Wrong handling of applications that are started multiple times in parallel #404 Expected and_then/or_else calling callable without checking #599 std::void_t used in code #591 Fix resource leak caused by move ctor/assignment #542 nanoseconds in units::Duration are truncated #190 popo/user_trigger.hpp:33:5: error: exception specification of explicitly defaulted default constructor does not match the calculated one #494 iceoryx libs should be build as static libs #509 Build with gcov is broken #497","title":"v1.0.0 (2021-04-15)"},{"location":"release-notes/iceoryx-v1-0-0/#v0997-2021-04-09","text":"Full Changelog cleanup testing libraries; if used outside of iceoryx, include paths and link targets must be adjusted build iceoryx_utils, iceoryx_posh and iceoryx_binding_c as shared libraries in colcon","title":"v0.99.7 (2021-04-09)"},{"location":"release-notes/iceoryx-v1-0-0/#v0996-2021-04-08","text":"Full Changelog Add git to dependency list in iceoryx_posh for RHEL","title":"v0.99.6 (2021-04-08)"},{"location":"release-notes/iceoryx-v1-0-0/#v0995-2021-04-08","text":"Full Changelog Add libatomic to dependency list in iceoryx_utils for RHEL","title":"v0.99.5 (2021-04-08)"},{"location":"release-notes/iceoryx-v1-0-0/#v0994-2021-04-06","text":"Full Changelog Increase version number to trigger build again on ROS buildfarm","title":"v0.99.4 (2021-04-06)"},{"location":"release-notes/iceoryx-v1-0-0/#v0993-2021-04-06","text":"Full Changelog Increase version number to trigger build again on ROS buildfarm","title":"v0.99.3 (2021-04-06)"},{"location":"release-notes/iceoryx-v1-0-0/#v0992-2021-04-03","text":"Full Changelog Prepare package release for iceoryx 1.0 #670","title":"v0.99.2 (2021-04-03)"},{"location":"release-notes/iceoryx-v1-0-0/#v0990-2021-04-01","text":"Full Changelog Intermediate Milestone before the final 1.0.0 release, see v.1.0.0 above for the changes.","title":"v0.99.0 (2021-04-01)"},{"location":"release-notes/iceoryx-v1-0-0/#v0900-2020-12-22","text":"Full Changelog Pre-Release for new and stable APIs and n:m pub/sub communication This is a pre-release for our first long-term-support release that is coming soon (will be iceoryx_1.0.0). We had a major refactoring of the iceoryx communication infrastructure which allows to do n:m communication now and provides a flexible history functionality for late joining subscribers. This new infrastructure is also made to support request/response communication as a next step (#27) . The C++ API has been completely reworked and a new C API has been added. We will give the API draft some weeks for finalizing the features and to incorporate feedback from the community. There's an issue in which we collect and discuss the final modifications (#408) . Features: Complete refactoring of publishers and subscribers from shared memory data structures to user APIs, #252 First versions of new APIs for C++ and C #252 n:m publish/subscribe communication now possible #25 First version of a DDS gateway. Cyclone DDS already integrated, FastDDS on it's way #64 , #65 New github actions for Mac OS and colcon build #175 , #276 , #328 Adjustable capacity for the lockfree queue #216 Check the files have a copyright header #346 Refactoring: Refactoring of waitset #341 create multi publisher example #394 Full IceOryx Public API Cheat Sheet #283 Rework build and test steps in iceoryx #433 Extend iceperf example to C API #453 Remove default parameter from PoshRuntime::getInstance() #382 Enable Sanitizer in Debug Build and Unit Tests #141 Minor RouDi cleanups #91 C++14 #220 Replace occurence of std::list by cxx::list #221 Fixed bugs: SegFault in iox-roudi on startup #447 Mocks can cause segfaults/undefined behavior #427 Chunks are lost forever when having an overflow in a variant queue of type FIFO #456 RouDi does not free shared memory properly on x86 Linux #324 WaitSet behavior wrong in waitAndReturnFulfilledConditions #388 Incorrect usage of strncpy #374 Global Instantiation of Publisher/Subscriber created core dump #327","title":"v0.90.0 (2020-12-22)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170-2020-08-27","text":"Full Changelog \\ MacOS support and preparations for new API Packages: iceoryx_posh (Quality level 4) iceoryx_utils (Quality level 4) iceoryx_examples (Quality level 5) Features: MacOS support #32 Major RouDi refactorings #70 , #59 , #78 Preparations for new iceoryx API #25 iceoryx to cyclonedds gateway #64 Introduce cxx::function_ref #86 Fixed bugs: POSIX timer improvements #120 , #167 Memory Synchronisation Issue in FiFo #119 Roudi MessageQueue thread startup #171 Destructor fix MessageQueue and UnixDomainSocket #150 RouDi ressource clean-up #113","title":"v0.17.0 (2020-08-27)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc6-2020-07-29","text":"Full Changelog \\ Release Candidate for 0.17.0 release Fixed bugs: Sporadic timing test failure #120 Improvement: Merge Mempool Introspection data into one sample #210","title":"v0.17.0_RC6 (2020-07-29)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc5-2020-07-29","text":"Full Changelog \\ Release Candidate for 0.17.0 release Fixed bugs: Callable can outrun periodicity of POSIX timer #161","title":"v0.17.0_RC5 (2020-07-29)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc4-2020-07-29","text":"Full Changelog \\ Release Candidate for 0.17.0 release Fixed bugs: The destroy method of MessageQueue and UnixDomainSocket does not fully invalidate the object #150 Roudi message queue thread startup #171","title":"v0.17.0_RC4 (2020-07-29)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc3-2020-07-27","text":"Full Changelog \\ Release Candidate for 0.17.0 release Features: cmake options for deployment parameter #142","title":"v0.17.0_RC3 (2020-07-27)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc2-2020-07-27","text":"Full Changelog \\ Release Candidate for 0.17.0 release Refactoring: Refactoring of logging #88 Remove const_cast wherever possible #76 Remove asynchronous service discovery feature #90 qacpp-4.5.0-2427 #93 Usage of github actions to build pull requests #89 Reduce default memory consumption with config and mempools #78 Fixed bugs: Sporadic timing test failure #120 Make SOFI real size equal to the specified one #105 increase padding in introspection #117 Increase the process waiting for RouDi timeout to 60 seconds #110","title":"v0.17.0_RC2 (2020-07-27)"},{"location":"release-notes/iceoryx-v1-0-0/#v0170_rc1-2020-03-24","text":"Full Changelog \\ Release Candidate for 0.17.0 release Features: Memory abstraction, modularization of RouDi and fixes #59 Memory abstraction and RouDi modularization step 2, fixed string improvements and other fixes #70 Fixed bugs: Can't compile due to missing CPPTOML #67","title":"v0.17.0_RC1 (2020-03-24)"},{"location":"release-notes/iceoryx-v1-0-0/#v0161-2020-03-02","text":"Full Changelog \\ Support for rmw_iceoryx with ROS2 python API Packages: POSH (POSIX Shared Memory) Utils Iceoryx examples Features: Capability to cleanup shared memory resources during process lifetime #51 Fixed bugs: compile error with clang #43 CMqInterface unit tests are failing caused by unneeded move operations #56 Known limitations: RouDi --version shows 0.16.0.1 instead of 0.16.1","title":"v0.16.1 (2020-03-02)"},{"location":"release-notes/iceoryx-v1-0-0/#v0160-2019-12-16","text":"Introspection, performance test and flexible mapping of shared memory Packages: POSH (POSIX Shared Memory) Utils Iceoryx examples Features: Introspection client for live debugging of iceoryx #21 Flexible mapping of shared memory in virtual address spaces #19 Performance test to measure inter-process latency #17 Docker build #15 (Thanks to @Mr-Slippery ) Fixed bugs: Payload size not updated by allocateChunk #10 Failure in runnable creation #23 Command for generating git log for merge commits between two tags **git log --merges --first-parent master --pretty = format: \"%h %<(10,trunc)%aN %C(white)%<(15)%aD%Creset %C(red bold)%<(15)%D%Creset %s\" <TAG_BASE>...<TAG_TARGET> > diff_merge_commit.log**","title":"v0.16.0 (2019-12-16)"},{"location":"release-notes/iceoryx-v1-0-1/","text":"iceoryx v.1.0.1 \ud83d\udd17 v1.0.1 (2021-06-15) \ud83d\udd17 Full Changelog Description: This is the first bugfix release for Eclipse iceoryx 1.0.0. We made minor changes in the documentation and added several patches. Compared to the feature content of the release 1.0.0, the following bug tickets where resolved: Bugfixes: Github CI Integrationtests failing #825 Segmentation Fault in FileLock #808 cpptoml cannot be build due to failing examples #791 Missing template parameter for user-header in typed C++ API #768 Fix issues with generating website documentation #743 Starting an application after RouDi was terminated floods the cmd line with error messages #654","title":"iceoryx v.1.0.1"},{"location":"release-notes/iceoryx-v1-0-1/#iceoryx-v101","text":"","title":"iceoryx v.1.0.1"},{"location":"release-notes/iceoryx-v1-0-1/#v101-2021-06-15","text":"Full Changelog Description: This is the first bugfix release for Eclipse iceoryx 1.0.0. We made minor changes in the documentation and added several patches. Compared to the feature content of the release 1.0.0, the following bug tickets where resolved: Bugfixes: Github CI Integrationtests failing #825 Segmentation Fault in FileLock #808 cpptoml cannot be build due to failing examples #791 Missing template parameter for user-header in typed C++ API #768 Fix issues with generating website documentation #743 Starting an application after RouDi was terminated floods the cmd line with error messages #654","title":"v1.0.1 (2021-06-15)"},{"location":"release-notes/iceoryx-v1-0-2/","text":"iceoryx v.1.0.2 \ud83d\udd17 v1.0.2 (2022-02-18) \ud83d\udd17 Full Changelog Bugfixes: Backporting Bugfixes for GCC 11 #1092","title":"iceoryx v.1.0.2"},{"location":"release-notes/iceoryx-v1-0-2/#iceoryx-v102","text":"","title":"iceoryx v.1.0.2"},{"location":"release-notes/iceoryx-v1-0-2/#v102-2022-02-18","text":"Full Changelog Bugfixes: Backporting Bugfixes for GCC 11 #1092","title":"v1.0.2 (2022-02-18)"},{"location":"release-notes/iceoryx-v2-0-0/","text":"iceoryx v2.0.0 \ud83d\udd17 v2.0.0 (2022-03-14) \ud83d\udd17 Full Changelog Features: block publisher when subscriber queue full #615 extend chunk header for gateways and recompute #711 Basic Windows 10 support #33 Common puml file for common settings #865 Relocatable Pointers - Version 2.0 #926 Implement waitForTerminationRequest #973 Partial enable iceoryx building with msvc2015+clang #965 C binding for posh configuration #930 Enhance MacOS performance with timed{send,receive} functionality in unix domain socket #903 Multi-Publisher support for DDS gateway and generic gateway class #900 Replace iox-gw-iceoryx2dds and iox-gw-dds2iceoryx gateways with iox-dds-gateway #900 Enhance posixCall #805 Git Hooks on iceoryx #486 static memory alternative for std::function #391 Adding support for Helix QAC 2021.1 #755 thanks to @toniglandy1 Axivion analysis on CI #409 Cpptoml can be provided by an external source #951 Extend cxx::optional constructor for in place construction so that copy/move for values inside the optional even could be deleted #967 Add templated from / into free functions to formalize conversions from enums and other types #992 UniqueId class for unique IDs within a process #1010 Add requirePublisherHistorySupport option at subscriber side (if set to true requires historyCapacity > 0 to be eligible for connection) #1029 , #1278 Add /tools/scripts/ice_env.sh shell script to provide simple access to docker containers for CI debugging #1049 Introduce cxx::FunctionalInterface to enrich nullable classes with and_then , or_else , value_or , expect #996 Add C++17 std::perms as cxx::perms to iceoryx_hoofs/cxx/filesystem.hpp . #1059 Support FreeBSD as a representative for the UNIX platforms #1054 Add event parameter to findService method #415 Implement stream operator for ChunkReceiveResult and AllocationError to be able to use it with ostream and LogStream #1062 Replace IPC-channel-based findService with pub/sub-based on #415 Add findService method to ServiceDiscovery which applies a callable to all matching services #1105 Increase limits of ServiceRegistry to support the maximum number of publishers and servers that are configured in iceoryx_posh_types.hpp #1074 C binding for service discovery #1142 Introduce iox::popo::MessagingPattern to findService to allow separate searches for publishers ( MessagingPattern::PUB_SUB ) and servers ( iox::popo::MessagingPattern::REQ_RES ) #27 Request/Response communication with iceoryx #27 For more details how this feature can be used please have a look at the iceoryx_examples/request_response Limitations The port introspection is not aware of the new Client and Server #1128 The DDS gateway is not aware of the new Server #1145 Set MAX_NUMBER_OF_NOTIFIERS to 256 and prepare configuration via CMake #1144 Reorganize code in publisher.hpp/.inl and subscriber.hpp/inl #1173 Install headers to include/iceoryx/vX.Y.Z by default and add CMake option MAKE_UNIQUE_INCLUDEDIR to control the behavior #1194 Bugfixes: Analyse suppressed errors of AddressSanitizer, LeakSanitizer & UndefinedBehaviorSanitizer #423 CMake file duplicate option in build_options.cmake #709 thanks to @ZhenshengLee SharedChunk should internally store an absolute pointer #713 loanPreviousChunk is broken #729 Runtime Error in SubscriberImpl #714 Wrong Values of iox-cpp-subscriber and iox-cpp-publisher #781 CMake fails during googletest step with gcc 11.1.0 #798 NewType Copy-Assign raises compiler warning on GCC 8.4.0 #282 Apply noexcept all the things rule to posh, hoofs and binding_c #916 Doxygen shows wrong include paths #922 find_package(iceoryx_posh) fails #944 thanks to @ijnek iox-roudi report error when running in docker #946 compile error: duration.inl - duration literals are not found (Windows) #1078 cxx::string initialization with nullptr leads to segfault #1108 Fix support for libc++ on clang #905 Fix warnings for gcc-11.1 #838 Incremental builds with the build script are broken #821 Compile failed because of missing <limits> for GCC 11 #811 thanks to @homalozoa Unable to build cyclone dds idlpp-cxx #736 Fix format string issues with introspection client #960 thanks to @roehling Add support for Multi-Arch install destinations #961 thanks to @roehling Fix a few misspellings in log messages #962 thanks to @roehling Fix typos in goals/non-goals document #968 thanks to @ fb913bf0de288ba84fe98f7a23d35edfdb22381 Catch deserialization errors for enums in publisher and subscriber options #989 Fix linker error on QNX #1013 When posix mutex fails a correct error message is reported on the console #999 Only use std::result_of for C++14 to be able to use iceoryx in C++20 projects #1076 Set stack size for windows in singleprocess example and posh tests #1082 Roudi console timestamps are out of date #1130 Application can't create publisher repeatedly with previous one already destroyed #938 Prevent creation of popo::Publisher 's with internal ServiceDescription #1120 RelativePointer is now type safe, i.e. can only be constructed from pointers with a valid convertion to the raw pointer #1121 Clamping historyRequest to queueCapacity #1192 C binding storage sizes do not match for multiple OS's and architectures #1218 Update cyclone dds version used by gateway to support aarch64 #1223 The file lock posix wrapper unlocks and removes a file correctly #1216 Minor fixes for the examples #743 Fix race condition in Windows platform semaphore/mutex posix implementation #1271 Fix race condition in Windows platform HandleTranslator #1264 Fix race condition in Windows platform shared memory implementation #1269 Refactoring: implement Module-Tests for smart_lock #588 improve Helix QAC parsing coverage #759 thanks to @toniglandy1 Write \"ROS 2\" with a space between \"ROS\" and \"2\" #762 thanks to @christophebedard Enforce unix line endings #794 Rename utils to hoofs #790 Cleanup MemoryProvider and MemoryBlock #842 Remove #define private public from all tests #529 Write example on how to use iceoryx in a docker environment #924 Allow cpptoml to be provided externally and not vendored by CMake #950 thanks to @photex Reworked iceoryx examples #482 Handle nullptr callbacks in waitset and listener #932 Add CI job that checks formatting with clang-format #887 Add clang-tidy rules for iceoryx_hoofs #889 Consolidate CI jobs in one workflow #891 Move all tests into an anonymous namespace #563 Refactor smart_c to use contract by design and expected #418 PoshRuntime Mock #449 Clean-up Doxygen for dds #583 Rename utils to hoofs #790 plantuml in design documentation #787 Refine quality levels #425 Clean-up std::terminate usage #261 Add Quality Declaration Document #910 Make cxx::string::capacity a static method #979 Restructure iceoryx tools #471 Use cxx::expected for MemoryManager::getChunk #954 Upgrade GTest/GMock to v1.10 #841 Remove the requirement for INVALID_STATE for the cxx::expected #987 Add unique test identifers #988 Remove ApplicationPort and ApplicationPortData classes #415 Remove creation pattern from MemoryMap and replace it with MemoryMapBuilder #1036 Fix error handling of TypedUniqueId and refactor it to UniquePortId #861 Updating Codecov API and enforce CMake version 3.16 for building iceoryx #774 and #1031 Remove InvalidIdString and isValid() from ServiceDescription , replace Wildcard string with iox::cxx::nullopt #415 Remove creation pattern from SharedMemory and replace it with SharedMemoryBuilder #1036 Remove the leading slash requirement from the name of a shared memory in SharedMemory and SharedMemoryObject #439 New API features: Introduce iceoryx_hoofs/cxx/filesystem.hpp which implements std::perms as cxx::perms . #include \"iceoryx_hoofs/cxx/filesystem.hpp\" // ... cxx :: perms filePermissions ; filePermissions = cxx :: perms :: owner_read | cxx :: perms :: group_write ; std :: cout << filePermissions << std :: endl ; API Breaking Changes: The CMake files in iceoryx expect to have CMake version 3.16 or greater installed, otherwise the build fails. (Hint: Ubuntu 18 users can install cmake-mozilla from the universe repository provided by Canonical) Dependency for building the iceoryx_dds gateway changed from openjdk (Java) to bison Change include from iceoryx_hoofs/cxx/helplets.hpp to iceoryx_hoofs/cxx/requires.hpp when using cxx::Expects or cxx::Ensures // before #include \"iceoryx_hoofs/cxx/helplets.hpp\" iox :: cxx :: Expects ( someCondition ); iox :: cxx :: Ensures ( anotherCondition ); // after #include \"iceoryx_hoofs/cxx/requires.hpp\" iox :: cxx :: Expects ( someCondition ); iox :: cxx :: Ensures ( anotherCondition ); Replace Creation pattern from MemoryMap with MemoryMapBuilder . // before auto memoryMapResult = posix :: MemoryMap :: create ( baseAddress , length , fileDescriptor , accessMode , flags , offset ); // after auto memoryMapResult = posix :: MemoryMapBuilder (). baseAddressHint ( baseAddress ) . length ( length ). fileDescriptor ( fileDescriptor ) . accessMode ( accessMode ). flags ( flags ) . offset ( 0 ). create (); Rename utils to hoofs: In CMake you need now to find and link the package iceoryx_hoofs instead of iceoryx_utils # before find_package ( iceoryx_utils REQUIRED ) target_link_libraries ( ${ target } iceoryx_utils::iceoryx_utils ) # after find_package ( iceoryx_hoofs REQUIRED ) target_link_libraries ( ${ target } iceoryx_hoofs::iceoryx_hoofs ) The include paths for iceoryx_utils are now iceoryx_hoofs // before #include \"iceoryx_utils/cxx/string.hpp\" // after #include \"iceoryx_hoofs/cxx/string.hpp\" Refactoring SmartC: Renaming SmartC wrapper to posixCall. Removed getErrorString() from posixCall, please use getHumanReadableErrnum() instead. Enhanced posixCall to handle a common case were multiple errnos are ignored just to suppress error logging // before #include \"iceoryx_utils/cxx/smart_c.hpp\" auto unlinkCallPublisher = iox :: cxx :: makeSmartC ( unlink , iox :: cxx :: ReturnMode :: PRE_DEFINED_ERROR_CODE , { ERROR_CODE }, { ENOENT }, sockAddrPublisher . sun_path ); if ( unlinkCallPublisher . hasErrors ()) { std :: cout << \"unlink error\" << std :: endl ; exit ( 1 ); } // after #include \"iceoryx_utils/posix_wrapper/posix_call.hpp\" iox :: posix :: posixCall ( unlink )( sockAddrPublisher . sun_path ) . failureReturnValue ( ERROR_CODE ) . ignoreErrnos ( ENOENT , EBUSY ) // can be a comma-separated list of errnos . evaluate () . or_else ([]( auto & r ) { std :: cout << \"unlink error \" << r . getHumanReadableErrnum () << std :: endl ; exit ( 1 ); }); Refactoring of ServiceDescription A ServiceDescription is now only string-based and no more wildcards are allowed. A well-defined ServiceDescription consists of three non-empty strings. // before ServiceDescription myServiceDescription1 ( 1U , 2U , 3U ); ServiceDescription myServiceDescription3 ( \"First\" , \"Second\" ); ServiceDescription myServiceDescription3 ( iox :: capro :: AnyServiceString , iox :: capro :: AnyInstanceString , iox :: capro :: AnyEventString ); // after ServiceDescription myServiceDescription1 ( \"Foo\" , \"Bar\" , \"Baz\" ); ServiceDescription myServiceDescription2 ( \"First\" , \"Second\" , \"DontCare\" ); ServiceDescription myServiceDescription3 ( \"Foo\" , \"Bar\" , \"Baz\" ); Instead of using a constructor a ServiceDescription is now deserialized via a static method with error handling: // before iox :: cxx :: Serialization serializedObj ; iox :: capro :: ServiceDescription service ( serializedObj ); // after iox :: cxx :: Serialization serialisedObj ; capro :: ServiceDescription :: deserialize ( serialisedObj ) . and_then ([]( auto & value ){ // Do something with the deserialized object }) . or_else ([]( auto & error ){ // Handle the error }); The InvalidIdString was removed from ServiceDescription and the Wildcard string was replaced with a iox::cxx::nullopt . With this, every string is allowed within the ServiceDescription . The default ServiceDescription consists of empty strings. The service-related methods have been moved from PoshRuntime to ServiceDiscovery . The offerService and stopOfferService methods have been removed and findService has now an additional event parameter. Furthermore it requires a function to be provided which is applied to each ServiceDescription in the search result (and can be used to collect them in a container etc.). The iox::popo::MessagingPattern parameter allows to search publishers ( PUB_SUB ) or servers ( REQ_RES ). ```cpp // before #include \"iceoryx_posh/runtime/posh_runtime.hpp\" poshRuntime.offerService(myServiceDescription); poshRuntime.stopOfferService(myServiceDescription); poshRuntime.findService({\"ServiceA\", iox::capro::AnyInstanceString}); // after #include \"iceoryx_posh/runtime/service_discovery.hpp\" void printSearchResult(const iox::capro::ServiceDescription& service) { std::cout << \"- \" << service << std::endl; } serviceDiscovery.findService(\"ServiceA\", Wildcard, Wildcard, printSearchResult, iox::popo::MessagingPattern::PUB_SUB); ``` The following classes have now an constructor marked as explicit : explicit DeadlineTimer ( const iox :: units :: Duration timeToWait ); explicit GenericRAII ( const std :: function < void () >& cleanupFunction ); explicit mutex ( const bool f_isRecursive ); explicit PosixUser ( const uid_t f_id ); explicit PosixUser ( const string_t & f_name ); Renaming in FileReader class and logging of iceoryx_hoofs // before iox :: cxx :: FileReader reader ( \"filename\" ); std :: string str ; if ( reader . IsOpen ()) { reader . ReadLine ( str ); } static auto & logger = CreateLogger ( \"\" , \"\" , iox :: log :: LogManager :: GetLogManager (). DefaultLogLevel ()); // after iox :: cxx :: FileReader reader ( \"filename\" ); std :: string str ; if ( reader . isOpen ()) { reader . readLine ( str ); } static auto & logger = createLogger ( \"\" , \"\" , iox :: log :: LogManager :: GetLogManager (). DefaultLogLevel ()); The iox::cxx::expected has dropped the requirement for INVALID_STATE . With this, the ErrorTypeAdapter which was necessary for non enum types was also removed. The specialization of ErrorTypeAdapter for custom types must therefore also be removed in the user code. The queue port policy enums are adjusted to use them with Client and Server . The QueueFullPolicy::BLOCK_PUBLISHER is replaced with the more generic QueueFullPolicy::BLOCK_PRODUCER . // old iox :: popo :: SubscriberOptions options ; options . queueFullPolicy = iox :: popo :: QueueFullPolicy :: BLOCK_PUBLISHER ; // new iox :: popo :: SubscriberOptions options ; options . queueFullPolicy = iox :: popo :: QueueFullPolicy :: BLOCK_PRODUCER ; Similar, for binding_c it is QueueFullPolicy_BLOCK_PRODUCER instead of QueueFullPolicy_BLOCK_PUBLISHER // old iox_sub_options_t options ; iox_sub_options_init ( & options ); options . queueFullPolicy = QueueFullPolicy_BLOCK_PUBLISHER ; // new iox_sub_options_t options ; iox_sub_options_init ( & options ); options . queueFullPolicy = QueueFullPolicy_BLOCK_PRODUCER ; The SubscriberTooSlowPolicy is replaced with the more generic ConsumerTooSlowPolicy and SubscriberTooSlowPolicy::WAIT_FOR_SUBSCRIBER became ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER . // old iox :: popo :: PublisherOptions options ; options . subscriberTooSlowPolicy = iox :: popo :: SubscriberTooSlowPolicy :: WAIT_FOR_SUBSCRIBER ; // new iox :: popo :: PublisherOptions options ; options . subscriberTooSlowPolicy = iox :: popo :: ConsumerTooSlowPolicy :: WAIT_FOR_CONSUMER ; And with the binding_c // old iox_pub_options_t options ; iox_pub_options_init ( & options ); options . subscriberTooSlowPolicy = SubscriberTooSlowPolicy_WAIT_FOR_SUBSCRIBER ; // new iox_pub_options_t options ; iox_pub_options_init ( & options ); options . subscriberTooSlowPolicy = ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER ; The CaproMessageSubType enum is renamed to CaproServiceType and the values are renamed from NOSUBTYPE , SERVICE , EVENT and FIELD to NONE , PUBLISHER and SERVER . This change only affects InterfacePorts which used this enum to communicate whether the CaproMessage was from a SERVICE , EVENT or FIELD . This was quite ara::com specific and with the introduction of the ServerPort changes were needed. The distinction between a FIELD and an EVENT can be made by checking CaproMessage::m_historyCapacity . // old caproMessage . m_subType = CaproMessageSubType :: EVENT ; // new caproMessage . m_serviceType = CaproServiceType :: PUBLISHER ;","title":"iceoryx v2.0.0"},{"location":"release-notes/iceoryx-v2-0-0/#iceoryx-v200","text":"","title":"iceoryx v2.0.0"},{"location":"release-notes/iceoryx-v2-0-0/#v200-2022-03-14","text":"Full Changelog Features: block publisher when subscriber queue full #615 extend chunk header for gateways and recompute #711 Basic Windows 10 support #33 Common puml file for common settings #865 Relocatable Pointers - Version 2.0 #926 Implement waitForTerminationRequest #973 Partial enable iceoryx building with msvc2015+clang #965 C binding for posh configuration #930 Enhance MacOS performance with timed{send,receive} functionality in unix domain socket #903 Multi-Publisher support for DDS gateway and generic gateway class #900 Replace iox-gw-iceoryx2dds and iox-gw-dds2iceoryx gateways with iox-dds-gateway #900 Enhance posixCall #805 Git Hooks on iceoryx #486 static memory alternative for std::function #391 Adding support for Helix QAC 2021.1 #755 thanks to @toniglandy1 Axivion analysis on CI #409 Cpptoml can be provided by an external source #951 Extend cxx::optional constructor for in place construction so that copy/move for values inside the optional even could be deleted #967 Add templated from / into free functions to formalize conversions from enums and other types #992 UniqueId class for unique IDs within a process #1010 Add requirePublisherHistorySupport option at subscriber side (if set to true requires historyCapacity > 0 to be eligible for connection) #1029 , #1278 Add /tools/scripts/ice_env.sh shell script to provide simple access to docker containers for CI debugging #1049 Introduce cxx::FunctionalInterface to enrich nullable classes with and_then , or_else , value_or , expect #996 Add C++17 std::perms as cxx::perms to iceoryx_hoofs/cxx/filesystem.hpp . #1059 Support FreeBSD as a representative for the UNIX platforms #1054 Add event parameter to findService method #415 Implement stream operator for ChunkReceiveResult and AllocationError to be able to use it with ostream and LogStream #1062 Replace IPC-channel-based findService with pub/sub-based on #415 Add findService method to ServiceDiscovery which applies a callable to all matching services #1105 Increase limits of ServiceRegistry to support the maximum number of publishers and servers that are configured in iceoryx_posh_types.hpp #1074 C binding for service discovery #1142 Introduce iox::popo::MessagingPattern to findService to allow separate searches for publishers ( MessagingPattern::PUB_SUB ) and servers ( iox::popo::MessagingPattern::REQ_RES ) #27 Request/Response communication with iceoryx #27 For more details how this feature can be used please have a look at the iceoryx_examples/request_response Limitations The port introspection is not aware of the new Client and Server #1128 The DDS gateway is not aware of the new Server #1145 Set MAX_NUMBER_OF_NOTIFIERS to 256 and prepare configuration via CMake #1144 Reorganize code in publisher.hpp/.inl and subscriber.hpp/inl #1173 Install headers to include/iceoryx/vX.Y.Z by default and add CMake option MAKE_UNIQUE_INCLUDEDIR to control the behavior #1194 Bugfixes: Analyse suppressed errors of AddressSanitizer, LeakSanitizer & UndefinedBehaviorSanitizer #423 CMake file duplicate option in build_options.cmake #709 thanks to @ZhenshengLee SharedChunk should internally store an absolute pointer #713 loanPreviousChunk is broken #729 Runtime Error in SubscriberImpl #714 Wrong Values of iox-cpp-subscriber and iox-cpp-publisher #781 CMake fails during googletest step with gcc 11.1.0 #798 NewType Copy-Assign raises compiler warning on GCC 8.4.0 #282 Apply noexcept all the things rule to posh, hoofs and binding_c #916 Doxygen shows wrong include paths #922 find_package(iceoryx_posh) fails #944 thanks to @ijnek iox-roudi report error when running in docker #946 compile error: duration.inl - duration literals are not found (Windows) #1078 cxx::string initialization with nullptr leads to segfault #1108 Fix support for libc++ on clang #905 Fix warnings for gcc-11.1 #838 Incremental builds with the build script are broken #821 Compile failed because of missing <limits> for GCC 11 #811 thanks to @homalozoa Unable to build cyclone dds idlpp-cxx #736 Fix format string issues with introspection client #960 thanks to @roehling Add support for Multi-Arch install destinations #961 thanks to @roehling Fix a few misspellings in log messages #962 thanks to @roehling Fix typos in goals/non-goals document #968 thanks to @ fb913bf0de288ba84fe98f7a23d35edfdb22381 Catch deserialization errors for enums in publisher and subscriber options #989 Fix linker error on QNX #1013 When posix mutex fails a correct error message is reported on the console #999 Only use std::result_of for C++14 to be able to use iceoryx in C++20 projects #1076 Set stack size for windows in singleprocess example and posh tests #1082 Roudi console timestamps are out of date #1130 Application can't create publisher repeatedly with previous one already destroyed #938 Prevent creation of popo::Publisher 's with internal ServiceDescription #1120 RelativePointer is now type safe, i.e. can only be constructed from pointers with a valid convertion to the raw pointer #1121 Clamping historyRequest to queueCapacity #1192 C binding storage sizes do not match for multiple OS's and architectures #1218 Update cyclone dds version used by gateway to support aarch64 #1223 The file lock posix wrapper unlocks and removes a file correctly #1216 Minor fixes for the examples #743 Fix race condition in Windows platform semaphore/mutex posix implementation #1271 Fix race condition in Windows platform HandleTranslator #1264 Fix race condition in Windows platform shared memory implementation #1269 Refactoring: implement Module-Tests for smart_lock #588 improve Helix QAC parsing coverage #759 thanks to @toniglandy1 Write \"ROS 2\" with a space between \"ROS\" and \"2\" #762 thanks to @christophebedard Enforce unix line endings #794 Rename utils to hoofs #790 Cleanup MemoryProvider and MemoryBlock #842 Remove #define private public from all tests #529 Write example on how to use iceoryx in a docker environment #924 Allow cpptoml to be provided externally and not vendored by CMake #950 thanks to @photex Reworked iceoryx examples #482 Handle nullptr callbacks in waitset and listener #932 Add CI job that checks formatting with clang-format #887 Add clang-tidy rules for iceoryx_hoofs #889 Consolidate CI jobs in one workflow #891 Move all tests into an anonymous namespace #563 Refactor smart_c to use contract by design and expected #418 PoshRuntime Mock #449 Clean-up Doxygen for dds #583 Rename utils to hoofs #790 plantuml in design documentation #787 Refine quality levels #425 Clean-up std::terminate usage #261 Add Quality Declaration Document #910 Make cxx::string::capacity a static method #979 Restructure iceoryx tools #471 Use cxx::expected for MemoryManager::getChunk #954 Upgrade GTest/GMock to v1.10 #841 Remove the requirement for INVALID_STATE for the cxx::expected #987 Add unique test identifers #988 Remove ApplicationPort and ApplicationPortData classes #415 Remove creation pattern from MemoryMap and replace it with MemoryMapBuilder #1036 Fix error handling of TypedUniqueId and refactor it to UniquePortId #861 Updating Codecov API and enforce CMake version 3.16 for building iceoryx #774 and #1031 Remove InvalidIdString and isValid() from ServiceDescription , replace Wildcard string with iox::cxx::nullopt #415 Remove creation pattern from SharedMemory and replace it with SharedMemoryBuilder #1036 Remove the leading slash requirement from the name of a shared memory in SharedMemory and SharedMemoryObject #439 New API features: Introduce iceoryx_hoofs/cxx/filesystem.hpp which implements std::perms as cxx::perms . #include \"iceoryx_hoofs/cxx/filesystem.hpp\" // ... cxx :: perms filePermissions ; filePermissions = cxx :: perms :: owner_read | cxx :: perms :: group_write ; std :: cout << filePermissions << std :: endl ; API Breaking Changes: The CMake files in iceoryx expect to have CMake version 3.16 or greater installed, otherwise the build fails. (Hint: Ubuntu 18 users can install cmake-mozilla from the universe repository provided by Canonical) Dependency for building the iceoryx_dds gateway changed from openjdk (Java) to bison Change include from iceoryx_hoofs/cxx/helplets.hpp to iceoryx_hoofs/cxx/requires.hpp when using cxx::Expects or cxx::Ensures // before #include \"iceoryx_hoofs/cxx/helplets.hpp\" iox :: cxx :: Expects ( someCondition ); iox :: cxx :: Ensures ( anotherCondition ); // after #include \"iceoryx_hoofs/cxx/requires.hpp\" iox :: cxx :: Expects ( someCondition ); iox :: cxx :: Ensures ( anotherCondition ); Replace Creation pattern from MemoryMap with MemoryMapBuilder . // before auto memoryMapResult = posix :: MemoryMap :: create ( baseAddress , length , fileDescriptor , accessMode , flags , offset ); // after auto memoryMapResult = posix :: MemoryMapBuilder (). baseAddressHint ( baseAddress ) . length ( length ). fileDescriptor ( fileDescriptor ) . accessMode ( accessMode ). flags ( flags ) . offset ( 0 ). create (); Rename utils to hoofs: In CMake you need now to find and link the package iceoryx_hoofs instead of iceoryx_utils # before find_package ( iceoryx_utils REQUIRED ) target_link_libraries ( ${ target } iceoryx_utils::iceoryx_utils ) # after find_package ( iceoryx_hoofs REQUIRED ) target_link_libraries ( ${ target } iceoryx_hoofs::iceoryx_hoofs ) The include paths for iceoryx_utils are now iceoryx_hoofs // before #include \"iceoryx_utils/cxx/string.hpp\" // after #include \"iceoryx_hoofs/cxx/string.hpp\" Refactoring SmartC: Renaming SmartC wrapper to posixCall. Removed getErrorString() from posixCall, please use getHumanReadableErrnum() instead. Enhanced posixCall to handle a common case were multiple errnos are ignored just to suppress error logging // before #include \"iceoryx_utils/cxx/smart_c.hpp\" auto unlinkCallPublisher = iox :: cxx :: makeSmartC ( unlink , iox :: cxx :: ReturnMode :: PRE_DEFINED_ERROR_CODE , { ERROR_CODE }, { ENOENT }, sockAddrPublisher . sun_path ); if ( unlinkCallPublisher . hasErrors ()) { std :: cout << \"unlink error\" << std :: endl ; exit ( 1 ); } // after #include \"iceoryx_utils/posix_wrapper/posix_call.hpp\" iox :: posix :: posixCall ( unlink )( sockAddrPublisher . sun_path ) . failureReturnValue ( ERROR_CODE ) . ignoreErrnos ( ENOENT , EBUSY ) // can be a comma-separated list of errnos . evaluate () . or_else ([]( auto & r ) { std :: cout << \"unlink error \" << r . getHumanReadableErrnum () << std :: endl ; exit ( 1 ); }); Refactoring of ServiceDescription A ServiceDescription is now only string-based and no more wildcards are allowed. A well-defined ServiceDescription consists of three non-empty strings. // before ServiceDescription myServiceDescription1 ( 1U , 2U , 3U ); ServiceDescription myServiceDescription3 ( \"First\" , \"Second\" ); ServiceDescription myServiceDescription3 ( iox :: capro :: AnyServiceString , iox :: capro :: AnyInstanceString , iox :: capro :: AnyEventString ); // after ServiceDescription myServiceDescription1 ( \"Foo\" , \"Bar\" , \"Baz\" ); ServiceDescription myServiceDescription2 ( \"First\" , \"Second\" , \"DontCare\" ); ServiceDescription myServiceDescription3 ( \"Foo\" , \"Bar\" , \"Baz\" ); Instead of using a constructor a ServiceDescription is now deserialized via a static method with error handling: // before iox :: cxx :: Serialization serializedObj ; iox :: capro :: ServiceDescription service ( serializedObj ); // after iox :: cxx :: Serialization serialisedObj ; capro :: ServiceDescription :: deserialize ( serialisedObj ) . and_then ([]( auto & value ){ // Do something with the deserialized object }) . or_else ([]( auto & error ){ // Handle the error }); The InvalidIdString was removed from ServiceDescription and the Wildcard string was replaced with a iox::cxx::nullopt . With this, every string is allowed within the ServiceDescription . The default ServiceDescription consists of empty strings. The service-related methods have been moved from PoshRuntime to ServiceDiscovery . The offerService and stopOfferService methods have been removed and findService has now an additional event parameter. Furthermore it requires a function to be provided which is applied to each ServiceDescription in the search result (and can be used to collect them in a container etc.). The iox::popo::MessagingPattern parameter allows to search publishers ( PUB_SUB ) or servers ( REQ_RES ). ```cpp // before #include \"iceoryx_posh/runtime/posh_runtime.hpp\" poshRuntime.offerService(myServiceDescription); poshRuntime.stopOfferService(myServiceDescription); poshRuntime.findService({\"ServiceA\", iox::capro::AnyInstanceString}); // after #include \"iceoryx_posh/runtime/service_discovery.hpp\" void printSearchResult(const iox::capro::ServiceDescription& service) { std::cout << \"- \" << service << std::endl; } serviceDiscovery.findService(\"ServiceA\", Wildcard, Wildcard, printSearchResult, iox::popo::MessagingPattern::PUB_SUB); ``` The following classes have now an constructor marked as explicit : explicit DeadlineTimer ( const iox :: units :: Duration timeToWait ); explicit GenericRAII ( const std :: function < void () >& cleanupFunction ); explicit mutex ( const bool f_isRecursive ); explicit PosixUser ( const uid_t f_id ); explicit PosixUser ( const string_t & f_name ); Renaming in FileReader class and logging of iceoryx_hoofs // before iox :: cxx :: FileReader reader ( \"filename\" ); std :: string str ; if ( reader . IsOpen ()) { reader . ReadLine ( str ); } static auto & logger = CreateLogger ( \"\" , \"\" , iox :: log :: LogManager :: GetLogManager (). DefaultLogLevel ()); // after iox :: cxx :: FileReader reader ( \"filename\" ); std :: string str ; if ( reader . isOpen ()) { reader . readLine ( str ); } static auto & logger = createLogger ( \"\" , \"\" , iox :: log :: LogManager :: GetLogManager (). DefaultLogLevel ()); The iox::cxx::expected has dropped the requirement for INVALID_STATE . With this, the ErrorTypeAdapter which was necessary for non enum types was also removed. The specialization of ErrorTypeAdapter for custom types must therefore also be removed in the user code. The queue port policy enums are adjusted to use them with Client and Server . The QueueFullPolicy::BLOCK_PUBLISHER is replaced with the more generic QueueFullPolicy::BLOCK_PRODUCER . // old iox :: popo :: SubscriberOptions options ; options . queueFullPolicy = iox :: popo :: QueueFullPolicy :: BLOCK_PUBLISHER ; // new iox :: popo :: SubscriberOptions options ; options . queueFullPolicy = iox :: popo :: QueueFullPolicy :: BLOCK_PRODUCER ; Similar, for binding_c it is QueueFullPolicy_BLOCK_PRODUCER instead of QueueFullPolicy_BLOCK_PUBLISHER // old iox_sub_options_t options ; iox_sub_options_init ( & options ); options . queueFullPolicy = QueueFullPolicy_BLOCK_PUBLISHER ; // new iox_sub_options_t options ; iox_sub_options_init ( & options ); options . queueFullPolicy = QueueFullPolicy_BLOCK_PRODUCER ; The SubscriberTooSlowPolicy is replaced with the more generic ConsumerTooSlowPolicy and SubscriberTooSlowPolicy::WAIT_FOR_SUBSCRIBER became ConsumerTooSlowPolicy::WAIT_FOR_CONSUMER . // old iox :: popo :: PublisherOptions options ; options . subscriberTooSlowPolicy = iox :: popo :: SubscriberTooSlowPolicy :: WAIT_FOR_SUBSCRIBER ; // new iox :: popo :: PublisherOptions options ; options . subscriberTooSlowPolicy = iox :: popo :: ConsumerTooSlowPolicy :: WAIT_FOR_CONSUMER ; And with the binding_c // old iox_pub_options_t options ; iox_pub_options_init ( & options ); options . subscriberTooSlowPolicy = SubscriberTooSlowPolicy_WAIT_FOR_SUBSCRIBER ; // new iox_pub_options_t options ; iox_pub_options_init ( & options ); options . subscriberTooSlowPolicy = ConsumerTooSlowPolicy_WAIT_FOR_CONSUMER ; The CaproMessageSubType enum is renamed to CaproServiceType and the values are renamed from NOSUBTYPE , SERVICE , EVENT and FIELD to NONE , PUBLISHER and SERVER . This change only affects InterfacePorts which used this enum to communicate whether the CaproMessage was from a SERVICE , EVENT or FIELD . This was quite ara::com specific and with the introduction of the ServerPort changes were needed. The distinction between a FIELD and an EVENT can be made by checking CaproMessage::m_historyCapacity . // old caproMessage . m_subType = CaproMessageSubType :: EVENT ; // new caproMessage . m_serviceType = CaproServiceType :: PUBLISHER ;","title":"v2.0.0 (2022-03-14)"},{"location":"release-notes/iceoryx-v2-0-1/","text":"iceoryx v2.0.1 \ud83d\udd17 v2.0.1 (2022-04-01) \ud83d\udd17 Full Changelog Bugfixes: CMake warning: empty command-line option #1311 thanks to @clalancette iox-#743 Fixes to make docs exportable #1289 Don't exclude implementations of public classes in Doxygen #1293","title":"iceoryx v2.0.1"},{"location":"release-notes/iceoryx-v2-0-1/#iceoryx-v201","text":"","title":"iceoryx v2.0.1"},{"location":"release-notes/iceoryx-v2-0-1/#v201-2022-04-01","text":"Full Changelog Bugfixes: CMake warning: empty command-line option #1311 thanks to @clalancette iox-#743 Fixes to make docs exportable #1289 Don't exclude implementations of public classes in Doxygen #1293","title":"v2.0.1 (2022-04-01)"},{"location":"release-notes/iceoryx-v2-0-2/","text":"iceoryx v2.0.2 \ud83d\udd17 v2.0.2 (2022-04-08) \ud83d\udd17 Full Changelog Bugfixes: Double build issue in ROS2 build farm #1323","title":"iceoryx v2.0.2"},{"location":"release-notes/iceoryx-v2-0-2/#iceoryx-v202","text":"","title":"iceoryx v2.0.2"},{"location":"release-notes/iceoryx-v2-0-2/#v202-2022-04-08","text":"Full Changelog Bugfixes: Double build issue in ROS2 build farm #1323","title":"v2.0.2 (2022-04-08)"},{"location":"release-notes/iceoryx-v2-0-3/","text":"iceoryx v2.0.3 \ud83d\udd17 v2.0.3 (2023-02-02) \ud83d\udd17 Full Changelog Bugfixes: Build error on certain versions of Windows/Visual Studio #1476 Fix FileLock leak when lock failed #1440 Fix INTERFACE_INCLUDE_DIRECTORIES in CMake #1481 m_originId in mepoo::ChunkHeader sometimes not set #1668 WaitSet::wait returns if data was send before WaitSet::attachState(.., State::HAS_{DATA, REQUEST, RESPONSE}) #1855","title":"iceoryx v2.0.3"},{"location":"release-notes/iceoryx-v2-0-3/#iceoryx-v203","text":"","title":"iceoryx v2.0.3"},{"location":"release-notes/iceoryx-v2-0-3/#v203-2023-02-02","text":"Full Changelog Bugfixes: Build error on certain versions of Windows/Visual Studio #1476 Fix FileLock leak when lock failed #1440 Fix INTERFACE_INCLUDE_DIRECTORIES in CMake #1481 m_originId in mepoo::ChunkHeader sometimes not set #1668 WaitSet::wait returns if data was send before WaitSet::attachState(.., State::HAS_{DATA, REQUEST, RESPONSE}) #1855","title":"v2.0.3 (2023-02-02)"},{"location":"release-notes/iceoryx-v2-0-4/","text":"iceoryx v2.0.4 \ud83d\udd17 v2.0.4 (2023-11-27) \ud83d\udd17 Full Changelog Features: Add the introspection to the ROS release #2099","title":"iceoryx v2.0.4"},{"location":"release-notes/iceoryx-v2-0-4/#iceoryx-v204","text":"","title":"iceoryx v2.0.4"},{"location":"release-notes/iceoryx-v2-0-4/#v204-2023-11-27","text":"Full Changelog Features: Add the introspection to the ROS release #2099","title":"v2.0.4 (2023-11-27)"},{"location":"release-notes/iceoryx-v2-0-5/","text":"iceoryx v2.0.5 \ud83d\udd17 v2.0.5 (2023-11-30) \ud83d\udd17 Full Changelog Bugfixes: Fix ROS 2 RHEL build #2099","title":"iceoryx v2.0.5"},{"location":"release-notes/iceoryx-v2-0-5/#iceoryx-v205","text":"","title":"iceoryx v2.0.5"},{"location":"release-notes/iceoryx-v2-0-5/#v205-2023-11-30","text":"Full Changelog Bugfixes: Fix ROS 2 RHEL build #2099","title":"v2.0.5 (2023-11-30)"}]}